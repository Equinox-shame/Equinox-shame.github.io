
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CSAPP - Data Lab - Autumnal</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="Data Lab前言看到网上对这个实验讲解的不是很详细，个人将其中的一些部分进行了细化方便大家理解与学习，如有不对处还请多多指正。
第一题用&amp;amp;和~在 14 个字符以内实现异或 
123456,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="Autumnal" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Autumnal</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">CSAPP - Data Lab</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">CSAPP - Data Lab</h1>
        <div class="stuff">
            <span>三月 13, 2022</span>
            

        </div>
        <div class="content markdown">
            <h1 id="Data-Lab"><a href="#Data-Lab" class="headerlink" title="Data Lab"></a>Data Lab</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看到网上对这个实验讲解的不是很详细，个人将其中的一些部分进行了细化方便大家理解与学习，如有不对处还请多多指正。</p>
<h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>用<code>&amp;</code>和<code>~</code>在 14 个字符以内实现异或 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求解方式有如下 3 种方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a^b=</span><br><span class="line">= (a|b)&amp;(~a|~b)</span><br><span class="line">= ~(~a&amp;~b)&amp;~(a&amp;b)</span><br><span class="line">= (a&amp;~b)|(~a&amp;b)</span><br></pre></td></tr></table></figure>

<p>可以用这三种方式表示异或操作，具体的推导可以自行Google。答案如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ~(~a&amp;~b)&amp;~(a&amp;b);</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/03/13/BHZ16iuoNpKgkO4.png"></p>
<h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>题目要求返回最小二进制补码整数，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们已知最小的二进制补码数是<code>-2147483648</code>其对应的二进制位是<code>1000000...</code>，所以我们直接将 1 进行左移即可得到。答案如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br></pre></td></tr></table></figure>

<h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>题目要求如果是补码的最大数返回 1 ，否则返回 0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道<code>011111.....</code>表示的是补码的最大二进制位，如果我们对其加 1 可以得到<code>10000000....</code>再取一次反便可以得到原来的最大补码。同时由于一个数异或本身为 0 ，我们便可以利用个性质来代替等号的判断，于是我们有对应的如下思路：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~ ( a + <span class="number">1</span> ) ^ a == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>题目中并没有允许<code>?:</code>的使用，于是我们可以换一种方式来实现这个过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ! ( ~ ( a + <span class="number">1</span> ) ^ a );</span><br></pre></td></tr></table></figure>

<p>上述的结果并不完全正确，如果我们输入的数字是<code>1111111...</code>那么再经过上述操作过后，会再次变回该数字，因此我们要判断这个特例</p>
<blockquote>
<p>1111… + 1 = 0000…<br>~ 0000… = 1111… </p>
</blockquote>
<p>我们这里引入一个概念规格化数据：<code>!! x</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们对一个数进行两次取反，如果一个数是不为 0 的数，两次取反后返回值是 1 ，如果该数是 0 ，则返回的仍为 0</span></span><br><span class="line">!! <span class="number">123</span> = <span class="number">1</span></span><br><span class="line">!! <span class="number">-1</span> = <span class="number">1</span></span><br><span class="line">!! <span class="number">0</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>同时我们利用<code>&amp;</code>运算符的特性，一个数与 0 进行与运算的结果都是 0 ，来判断特殊数据<code>1111...</code>，我们构造如下式子来进行判断特殊数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!! (( x + <span class="number">1</span> ) ^ <span class="number">0x0</span> )</span><br></pre></td></tr></table></figure>

<p>如果输入值是<code>1111...</code>那么其值是 0 ，其他情况下返回值为 1</p>
<p>于是我们可以写出对应解：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ! ( ~ ( a + <span class="number">1</span> ) ^ a ) &amp; !! (( x + <span class="number">1</span> ) ^ <span class="number">0x0</span> );</span><br></pre></td></tr></table></figure>

<h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2><p>题目要求判断所有二进制偶数位是否都为 1 ，如果是返回 1 否则返回 0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们从题目中了解到最大长度的二进制位长 32 ，我们注意到：一个特殊的数据<code>101010....</code>与一个数进行<code>&amp;</code>运算得到的结果如果与<code>101010....</code>本身异或等于 0 时则证明了该数的二进制偶数位上全是 1 。</p>
<p>对此我们需要<code>101010....</code>来帮助我们进行判断，但是题目中不允许我们直接定义，于是我们将<code>A ( 1010 ) </code>进行变换得到<code>0xAAAAAAAA</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A = <span class="number">0xA</span>			<span class="comment">//4</span></span><br><span class="line"><span class="keyword">int</span> AA = A | A &lt;&lt; <span class="number">4</span>		<span class="comment">//8</span></span><br><span class="line"><span class="keyword">int</span> AAA = AA | AA &lt;&lt; <span class="number">8</span>		<span class="comment">//16</span></span><br><span class="line"><span class="keyword">int</span> AAAA = AAA | AAA &lt;&lt; <span class="number">16</span>		<span class="comment">//32</span></span><br></pre></td></tr></table></figure>

<p>通过上述方式我们构造出来了<code>0xAAAAAAAA</code>，于是我们可以进行相应的运算了，答案如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A = <span class="number">0xA</span>			<span class="comment">//4</span></span><br><span class="line"><span class="keyword">int</span> AA = A | A &lt;&lt; <span class="number">4</span>		<span class="comment">//8</span></span><br><span class="line"><span class="keyword">int</span> AAA = AA | AA &lt;&lt; <span class="number">8</span>		<span class="comment">//16</span></span><br><span class="line"><span class="keyword">int</span> AAAA = AAA | AAA &lt;&lt; <span class="number">16</span>		<span class="comment">//32</span></span><br><span class="line"><span class="keyword">return</span> !((AAAA&amp;x) ^ AAAA)</span><br></pre></td></tr></table></figure>

<h2 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h2><p>题目要求返回输入数据的负数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个数<code>x</code>，<code>-x</code>为其补码，所以我们对<code>x</code>取反码后加一，得到的便是其所对应的负数</p>
<blockquote>
<p><code>A + ~A = -1</code> 和 <code>A + neg A =0</code> 利用这两个式子我们可以得到 <code>neg A = ~A + 1</code></p>
</blockquote>
<p>所以答案为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ~ x + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h2><p>题目要求如果输入的<code>ASCII</code>在字符<code>0 - 9</code>之间就返回 1 否则返回 0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先把<code>0x30</code>和<code>0x39</code>转为二进制可以得到：<code>110000</code>和<code>111001</code></p>
<p>我们试想一下如果我们输入的二进制位数是大于 6 位时那必定在右移六位后是不为 0 的，如果是小于或者等于 6 位时，那么得到的结果便是 0 ，我们引出第一个判断条件，来进行判断其二进制位数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> check_1 = x &gt;&gt; <span class="number">6</span>;		    <span class="comment">//判断返回结果是否为 0 ，来判断二进制位长</span></span><br><span class="line"><span class="keyword">int</span> condition_1 = ! check_1; 	<span class="comment">//如果返回的是 0 便有可能是我们所需要的数字</span></span><br></pre></td></tr></table></figure>

<p>接下来我们观察在这个 6 位的二进制位中两个数的开头均为<code>0x11XXXX</code>，于是我们再将输入的数据进行右移 4 位来与<code>000011 ( 0x3 ) </code>进行异或来判断是否相等，得到第二个判断条件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> check_2 = x &gt;&gt; <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> condition_2 = ! ( check_2 ^ <span class="number">0x3</span> )		<span class="comment">//如果两数相等返回的是 0 ，再取非得到 1 </span></span><br></pre></td></tr></table></figure>

<p>接下来我们需要判断的便是后 4 位的二进制位，我们如何得到后 4位的二进制数呢？我们利用<code>&amp;</code>同为 1 下结果才为 1 的性质与<code>0xf ( 1111 )</code>来进行运算，得到的便是后 4 位二进制位。得到后 4 位的二进制位后我们需要的便是比较大小范围了，<code>0x30</code>与<code>0x39</code>取完后 4 位二进制位后分别为<code> 0000</code>和<code>1001</code>，题目中可使用符号并没有给出减号，需要我们自己构造一下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> check_3 = x &amp; <span class="number">0xF</span></span><br></pre></td></tr></table></figure>

<p>我们试想一下我们的二进制最大为<code>1001 ( 9 )</code>如果我们减去一个<code>1010 ( 10 ) </code>是小于 0 的那么是不是我们所需要的数据范围？那么我们便可以写出最后一个判断表达式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> condition_3 = check_3 + ( ~ <span class="number">0xA</span> + <span class="number">1</span> )		<span class="comment">//用 ~ A + 1 代替减号</span></span><br></pre></td></tr></table></figure>

<p>如果减出来的值是一个负数那么得到的便是<code>1111...</code>，我们需要再次处理，将其右移 31 位<code>( 因为输入最大二进制位为 32 )</code>得到其符号位 1 ，如果减出来的数大于等于 0 其符号位为 0 ，因此我们利用符号位来判断计算结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition_3 = !! ( condition_3 &gt;&gt; <span class="number">31</span> )			<span class="comment">//得到符号位后进行规格化，让其返回一个二进制位</span></span><br></pre></td></tr></table></figure>

<p>于是我们将上面 3 个条件组合进行判断便可以得到对应的答案了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> check_1 = x &gt;&gt; <span class="number">6</span>;		    <span class="comment">//判断返回结果是否为 0 ，来判断二进制位长</span></span><br><span class="line"><span class="keyword">int</span> condition_1 = ! check_1; 	<span class="comment">//如果返回的是 0 便有可能是我们所需要的数字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> check_2 = x &gt;&gt; <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> condition_2 = ! ( check_2 ^ <span class="number">0x3</span> )		<span class="comment">//如果两数相等返回的是 0 ，再取非得到 1 </span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> check_3 = x &amp; <span class="number">0xF</span></span><br><span class="line"><span class="keyword">int</span> condition_3 = check_3 + ( ~ <span class="number">0xA</span> + <span class="number">1</span> )		<span class="comment">//用 ~ A + 1 代替减号</span></span><br><span class="line">condition_3 = !! ( condition_3 &gt;&gt; <span class="number">31</span> )			<span class="comment">//得到符号位后进行规格化，让其返回一个二进制位</span></span><br><span class="line"><span class="keyword">return</span> condition_1 &amp; condition_2 &amp; condition_3 ; <span class="comment">//三个条件均为一个二进制位，相互 &amp; 运算即相当于 &amp;&amp; 运算</span></span><br></pre></td></tr></table></figure>

<h2 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h2><p>题目要求我们实现一个三目运算符<code>? :</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三目运算<code>?:</code>中我们需要判断的便是<code>x</code>的值是否为 0 ，为 0 时取<code>z</code>的值，反之取<code>y</code>的值。那么有没有一种方式让我们取值时根据<code>x</code>的值进行返回<code>1111...</code>或<code>0</code>，让我们直接利用<code>&amp;</code>运算直接取到<code>z</code>或<code>y</code>？</p>
<p>事实上是有的，之前我们介绍过了<code>!!</code>规格化一个数，如果这个数是一个 0 返回的便是 0 ，在其他情况下返回值是 1 。由于在程序中<code>singed ( 有符号数 )</code>执行的是算术右移 ( 填补符号位 )，而输入的最大的二进制位长 32 ，我们可以利用上述性质来进行转换出一个根据<code>x</code>变化而变化的数据而分别取到<code>y</code>或<code>z</code>的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> change = !! x;		<span class="comment">//规格化 x</span></span><br><span class="line"><span class="keyword">int</span> num = ( x &lt;&lt; <span class="number">31</span> ) &gt;&gt; <span class="number">31</span>;		<span class="comment">//将 x 转化为符号位，如果 change 为 0 执行后为 0 ，如果 change 为 1 执行后返回 1111...</span></span><br><span class="line"><span class="keyword">return</span> ( num &amp; y ) | (( ~ num ) &amp; z );</span><br></pre></td></tr></table></figure>

<h2 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h2><p>题目要求我们返回<code>x</code>和<code>y</code>的大小关系，如果<code>x&lt;=y</code>返回 1 否则返回 0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个题目中如果我们直接采用<code>x-y</code>的方式来编写的话，可能会造成溢出现象，我们需要考虑的是<code>x</code>和<code>y</code>两者的符号，分多种情况进行讨论。</p>
<p>我们先看<code>x==y</code>的情况，在这个情况下我们返回的是 1 ，我们可以用异或实现这个判断，如果是 0 则两数相等：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> condition_1 = ! ( x ^ y ) <span class="comment">//让其相等时返回 1</span></span><br></pre></td></tr></table></figure>

<p>第二个情况我们考虑<code>x</code>为<code>+</code>，<code>y</code>为<code>-</code>，此时我们的返回值一定是不成立的，那么要怎么判断呢？我们利用<code>x</code>和<code>y</code>的符号位来进行判断数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> signX = x &gt;&gt; <span class="number">31</span> &amp; <span class="number">1</span>;		<span class="comment">//正数的符号位为 0 </span></span><br><span class="line"><span class="keyword">int</span> signY = y &gt;&gt; <span class="number">31</span> &amp; <span class="number">1</span>;		<span class="comment">//负数的符号位为 1</span></span><br><span class="line"><span class="keyword">int</span> condition_2 = !(( ! signX ) &amp; signY );</span><br></pre></td></tr></table></figure>

<p>同理当<code>x</code>为<code>-</code>，<code>y</code>为<code>+</code>时：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> condition_3 = signX &amp; ( ! signY )</span><br></pre></td></tr></table></figure>

<p>第三个情况是两个同号时：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> condition_4 = ( x + ~ y + <span class="number">1</span> ) &gt;&gt; <span class="number">31</span> &amp; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>我们把上面的情况合并在一起可以得到答案：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> condition_1 = ! ( x ^ y ) 	 <span class="comment">//让其相等时返回 1</span></span><br><span class="line"><span class="keyword">int</span> signX = ( x &gt;&gt; <span class="number">31</span> ) &amp; <span class="number">1</span>;		<span class="comment">//正数的符号位为 0 </span></span><br><span class="line"><span class="keyword">int</span> signY = ( y &gt;&gt; <span class="number">31</span> ) &amp; <span class="number">1</span>;		<span class="comment">//负数的符号位为 1</span></span><br><span class="line"><span class="keyword">int</span> condition_2 = !(( ! signX ) &amp; signY );</span><br><span class="line"><span class="keyword">int</span> condition_3 = signX &amp; ( ! signY )</span><br><span class="line"><span class="keyword">int</span> condition_4 = ( x + (~ y + <span class="number">1</span> )) &gt;&gt; <span class="number">31</span> &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> condition_1 | ( !condition_2 &amp; ( condition_3 | condition_4));</span><br></pre></td></tr></table></figure>

<h2 id="第九题"><a href="#第九题" class="headerlink" title="第九题"></a>第九题</h2><p>题目要求我们实现<code>!</code>运算</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这个题目我们需要想到的是 0 的符号位在取反前后都是 0 ，而对于一个其他不为 0 的数，在取反前后的符号位是不一样的，我们便利用这个特性来实现<code>!</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> negX = ~ x + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sign = ( x | negX ) &gt;&gt; <span class="number">31</span>;		<span class="comment">//x 取负后与原来的 x 的符号位进行或运算时，如果 x 为 0 返回结果则是 0 ，如果是非 0 是返回的结果是 1111... ( 执行了算术右移 )</span></span><br><span class="line"><span class="keyword">return</span> sign + <span class="number">1</span>;<span class="comment">// 1111... + 1 = 0000... 利用其溢出后值为 0 的特性来进行判断  </span></span><br></pre></td></tr></table></figure>

<h2 id="第十题"><a href="#第十题" class="headerlink" title="第十题"></a>第十题</h2><p>题目要我们求一个数的补码最小需要的位数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据题目要求我们先来判断以下这些数的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11111111</span> -&gt; <span class="number">-1</span></span><br><span class="line"><span class="number">1111111</span>	 -&gt; <span class="number">-1</span></span><br><span class="line"><span class="number">111111</span>	 -&gt; <span class="number">-1</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="number">1</span>		-&gt; <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>可以看到表示一个负数时我们需要去除前面的多个 1 ，来确定表示这个数所需要的对应位数多少。同时如果输入的数据是 0 时，我们需要一个判断，来检测输入的数据是否为 0 ，如果是 0 那就可以直接返回 0 .</p>
<p>我们先对 0 的判断进行实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> isZero = ! x;<span class="comment">//对 x 进行取反，如果 x 为 0 那么返回值为 1  </span></span><br></pre></td></tr></table></figure>

<p>而对于负数的符号位的个数进行判断我们需要去取其符号位，输入的二进制位最大为 32 位，所以我们将输入的数字进行左移 31 位，得到的便是其符号位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flag = x &gt;&gt; <span class="number">31</span>; <span class="comment">//取其符号位</span></span><br></pre></td></tr></table></figure>

<p>此时我们已经拥有了输入数据的符号位，我们还需要拿到输入 x 的高位，在一般其情况下我们输入的是一个正数时只需要去取出其最高位后加上一个符号位 0 ，而对于一个负数，我们需要去除前面的一连串 1 ，得到一个值的最高位为 0 ( 即其除去多余 1 后的数据 )，再加上一个符号位便是表示所需要的位数。有如下实现：</p>
<blockquote>
<p>111110111 对于这个负数我们去除多余的 1 直到遇到 0 时，在加上 1 ( 代表其符号位 )</p>
<p>0111  ——&gt;   4 + 1 = 5</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = ((~ flag ) &amp; x ) | ( flag &amp; ( ~ x ))	<span class="comment">//取其最高位</span></span><br></pre></td></tr></table></figure>

<p>我们假设一下，上面输入的一个数<code>x</code>是一个正数，那么有<code>flag = 0</code>，对于上式我们可以发现得到的新<code>x</code>是原来的<code>x</code>值即没有改变<code>x</code>，我们如果输入的是一个负数，那么有<code>flag = 1</code>而<code>x</code>在取反后前面多余的 1 恰好变成了 0 ，而 0 变成了 1，方便我们判断对应第一个 0 的位置。</p>
<p>我们已经得到了这个数的最高位，接下来需要的便是计算对应表示其二进制位个数的多少。</p>
<p>我们输入的数据最大的二进制位长度为 32 ，我们将其不断二分来进行判断是否需要对应长度的二进制数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bit_16 = !!( x &gt;&gt; <span class="number">16</span> ) &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="comment">//截取前 16 位，如右移后的数据为 0 ，在规格化后仍为 0 ，也就不需要再左移 4 位了(乘以16，表示需要16个二进制位)</span></span><br><span class="line"><span class="comment">//相似的如果右移后的数据不为 0 则规格化后是 1 ，便会进行左移</span></span><br><span class="line">x &gt;&gt;= bit_16;</span><br><span class="line"><span class="comment">//同理类推于截取 8、4、2、1、0 位</span></span><br><span class="line"><span class="keyword">int</span> bit_8 = !!( x &gt;&gt; <span class="number">8</span> ) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">x &gt;&gt;= bit_8;</span><br><span class="line"><span class="keyword">int</span> bit_4 = !!( x &gt;&gt; <span class="number">4</span> ) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">x &gt;&gt;= bit_4;</span><br><span class="line"><span class="keyword">int</span> bit_2 = !!( x &gt;&gt; <span class="number">2</span> ) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">x &gt;&gt;= bit_2;</span><br><span class="line"><span class="keyword">int</span> bit_1 = !!( x &gt;&gt; <span class="number">1</span> );</span><br><span class="line">x &gt;&gt;= bit_1;</span><br><span class="line">bit_0 = x;</span><br><span class="line"><span class="keyword">int</span> result = bit_16 + bit_8 + bit_4 + bit_2 + bit_1 + bit_0 + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>此时我们已经拥有了输入值为 0 时的需要的二进制位和非 0 时的二进制位的个数，那么我们怎么把他们合并呢？</p>
<p>我们此时还是根据输入的符号位来进行处理，我们试想输入一个 0 ，那么其符号位恒为 0 ，不论在左移还是右移过程中都是不变的，而当输入一个非 0 数时，在右移过程中会有算术右移的出现，我们通过移动符号位来得到一个全为 1 ( 长 32 位 )的二级制数。那么我们在返回值时可以采用生成的全为 1 的这个数来保留我们的<code>isZero</code>，同时确保我们的<code>result</code>不会覆盖掉得到的答案，我们有如下定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mask = (( !!x ) &lt;&lt; <span class="number">31</span> ) &gt;&gt; <span class="number">31</span> ;<span class="comment">//输入 0 时 mask 为 0</span></span><br><span class="line"><span class="keyword">return</span> isZero | ( mask &amp; result );<span class="comment">//确保了输入为 0 的时候后半截的数据为 0</span></span><br></pre></td></tr></table></figure>

<p>把上述综合一下便是所需答案：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> isZero = ! x;<span class="comment">//对 x 进行取反，如果 x 为 0 那么返回值为 1  </span></span><br><span class="line"><span class="keyword">int</span> flag = x &gt;&gt; <span class="number">31</span>; <span class="comment">//取其符号位</span></span><br><span class="line"><span class="keyword">int</span> mask = (( !!x ) &lt;&lt; <span class="number">31</span> ) &gt;&gt; <span class="number">31</span> ;<span class="comment">//输入 0 时 mask 为 0</span></span><br><span class="line"><span class="keyword">int</span> bit_16 , bit_8 , bit_4 , bit_2 , bit_1 , bit_0 ;</span><br><span class="line"></span><br><span class="line">x = ((~ flag ) &amp; x ) | ( flag &amp; ( ~ x ))	<span class="comment">//取其最高位</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> bit_16 = !!( x &gt;&gt; <span class="number">16</span> ) &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="comment">//截取前 16 位，如右移后的数据为 0 ，在规格化后仍为 0 ，也就不需要再左移 4 位了(乘以16，表示需要16个二进制位)</span></span><br><span class="line"><span class="comment">//相似的如果右移后的数据不为 0 则规格化后是 1 ，便会进行左移</span></span><br><span class="line">x &gt;&gt;= bit_16;</span><br><span class="line"><span class="comment">//同理类推于截取 8、4、2、1、0 位</span></span><br><span class="line"><span class="keyword">int</span> bit_8 = !!( x &gt;&gt; <span class="number">8</span> ) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">x &gt;&gt;= bit_8;</span><br><span class="line"><span class="keyword">int</span> bit_4 = !!( x &gt;&gt; <span class="number">4</span> ) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">x &gt;&gt;= bit_4;</span><br><span class="line"><span class="keyword">int</span> bit_2 = !!( x &gt;&gt; <span class="number">2</span> ) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">x &gt;&gt;= bit_2;</span><br><span class="line"><span class="keyword">int</span> bit_1 = !!( x &gt;&gt; <span class="number">1</span> );</span><br><span class="line">x &gt;&gt;= bit_1;</span><br><span class="line">bit_0 = x;</span><br><span class="line"><span class="keyword">int</span> result = bit_16 + bit_8 + bit_4 + bit_2 + bit_1 + bit_0 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> isZero | ( mask &amp; result );<span class="comment">//确保了输入为 0 的时候后半截的数据为 0</span></span><br></pre></td></tr></table></figure>

<h2 id="第十一题"><a href="#第十一题" class="headerlink" title="第十一题"></a>第十一题</h2><p>题目要求返回表达式 <code>2*f</code> 的位级等效值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//float</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatScale2</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开始前先插入一些关于浮点数的概念：</p>
<blockquote>
<p>浮点数的相关二进制位的权重如图：</p>
<img src="https://s2.loli.net/2022/02/28/sOjnrlWpBq6dube.png" style="zoom: 50%;" />

<p>但是这个方式无法表示较大的数据，在<code>IEEE</code>中我们引入一个新的方式来进行表示：</p>
<img src="https://s2.loli.net/2022/02/28/t4fYHoyVlLkAJO6.png" style="zoom:50%;" />

<blockquote>
<p><code>s</code> ：符号位    |    <code>exp</code>： 阶码    |    <code>frac</code>：小数字段</p>
</blockquote>
<p>其中数值大致可以分为三类：</p>
<img src="https://s2.loli.net/2022/02/28/plk7hLO1X5exV9f.png" style="zoom:50%;" />

<ul>
<li><p>规格化的值</p>
<p>当阶码的二进制位不全为 0 ，且不全为 1 时，此时表示的是规格化的值。</p>
<img src="https://s2.loli.net/2022/02/28/tEnSAKZu4LGHNzk.png" style="zoom:50%;" />

<p>对于图中<code>E</code>的值并不是解码所对应的值，而是需要其减去一个偏置，对于<code>float</code>和<code>double</code>的偏置是不相同的，则以<code>float</code>为例，其最小最大 E 值如下：$E_{min}=-126\ \ \ \  |  \ \ \ \  E_{max}=127$</p>
</li>
</ul>
<p>在小数字段上，尾数 M 被定义为 <code>1+f</code>，尾数的二进制表示如图：</p>
<p><img src="https://s2.loli.net/2022/02/28/lzF9vXcJm8hjQRY.png"></p>
<p>  因为我们可以调整 E 的取指，使得尾数 M 的取值范围大于等于 1 ，小于 2 ，既然第一位总是一，那么就没有必要显示的表示出来，这也就是为什么尾数 M 的值需要加一。</p>
<ul>
<li><p>非规格化的值</p>
<p>当阶码的二进制位全为 0 时，此时表示的是非规格化的值。其大概有两个用途，其一是表示 0 ，其二是表示非常接近 0 的数。</p>
<img src="https://s2.loli.net/2022/02/28/gA1EdFz4KphNwbJ.png" style="zoom:67%;" />

<p>若表示非常接近 0 的数，则阶码字段全为 0 ，阶码 E 的值等于<code>E = 1 - bias</code>, 尾数 M 的值是 f <code>( M = f )</code>。</p>
<blockquote>
<p>+0.0 和 -0.0 在某些方面认为时不同的，而在其他方面是相同的。</p>
</blockquote>
</li>
<li><p>特殊值</p>
<p>当阶码的二进制位全为 1 时，表示的数值是特殊值。特殊值分为两类，一类表示无穷大或者无穷小，另外一类表示不是一个数。</p>
<img src="https://s2.loli.net/2022/02/28/hl7m28MvbydHGow.png" style="zoom: 50%;" /></li>
</ul>
<p>​    如我们输出下列数据，得到的返回值便是 <code>NaN (不是一个数)</code>，如：$\sqrt{-1}\ \ \ \ | \ \ \ \ \infty-\infty$  </p>
</blockquote>
<p>了解完后题目中所给出的数据是<code>float</code>类型，那么我们分别去取出其<code>s</code>、<code>exp</code>、<code>frac</code>，便有如下计算过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> s = uf &gt;&gt; <span class="number">31</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="built_in">exp</span> = (uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line"><span class="keyword">unsigned</span> frac = (uf &amp; <span class="number">0x7FFFFF</span>);</span><br><span class="line"><span class="comment">//输入为 0</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">exp</span> == <span class="number">0</span> &amp;&amp; frac ==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入为无穷或者不是一个数</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">exp</span> == <span class="number">0XFF</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入为非规格化的数</span></span><br><span class="line"><span class="keyword">if</span>(expr == <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="comment">// E = exp -127 = -127</span></span><br><span class="line">    frac &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ( s &lt;&lt; <span class="number">31</span> ) | frac ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入为规格化的数</span></span><br><span class="line"><span class="built_in">exp</span> ++;</span><br><span class="line"><span class="comment">// E = exp - 127</span></span><br><span class="line"><span class="keyword">return</span> ( s &lt;&lt; <span class="number">31</span> ) | ( <span class="built_in">exp</span> &lt;&lt; <span class="number">23</span> ) | frac ;</span><br></pre></td></tr></table></figure>

<h2 id="第十二题"><a href="#第十二题" class="headerlink" title="第十二题"></a>第十二题</h2><p>题目要求将浮点数转换为整数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与上面一个题相似，我们分别去取出其<code>s</code>、<code>exp</code>、<code>frac</code>，便有如下计算过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> s = uf &gt;&gt; <span class="number">31</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="built_in">exp</span> = (uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line"><span class="keyword">unsigned</span> frac = (uf &amp; <span class="number">0x7FFFFF</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入为0 </span></span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">exp</span> == <span class="number">0</span> &amp;&amp; frac ==<span class="number">0</span> )&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入为无穷或者不是一个数</span></span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">exp</span> == <span class="number">0xFF</span> )&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入为非规格化的数</span></span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">exp</span> == <span class="number">0</span> )&#123;</span><br><span class="line">	<span class="comment">//E = 1 - 127 = -126</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入为规格化的数</span></span><br><span class="line"><span class="keyword">int</span> E = <span class="built_in">exp</span> - <span class="number">127</span>;</span><br><span class="line">frac = frac  | ( <span class="number">1</span> &lt;&lt; <span class="number">23</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( E &gt; <span class="number">31</span> )&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> ( E &lt; <span class="number">0</span> )&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//M * 2^E</span></span><br><span class="line"><span class="keyword">if</span>( E &gt;= <span class="number">23</span> )&#123;</span><br><span class="line">    frac &lt;&lt;= ( E - <span class="number">23</span>); </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	frac &gt;&gt;= ( <span class="number">23</span> - E );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s)&#123;</span><br><span class="line">	<span class="keyword">return</span> ~ frac + <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> frac;</span><br></pre></td></tr></table></figure>

<h2 id="第十三题"><a href="#第十三题" class="headerlink" title="第十三题"></a>第十三题</h2><p>题目要求返回对应数等于 2 的<code>x</code>次阶乘</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatPower2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这个题目我们需要先找到对应的范围来进行判断</p>
<p>对于非规格化的数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lowerbound: 2^ -149</span><br><span class="line">upperbound: 2^ -126 ( 2^ -1 + 2^ -2 + ... + 2^ -23 )</span><br></pre></td></tr></table></figure>

<p>对于规格化的数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lowerbound: 2^ -126</span><br><span class="line">upperbound: 2^ 127 </span><br></pre></td></tr></table></figure>

<p>对此我们可以写出如下操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( x &lt; <span class="number">-149</span> )&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>( x &lt; <span class="number">-126</span> )&#123;</span><br><span class="line">	<span class="comment">//E = x</span></span><br><span class="line">	<span class="comment">//E = 1 - 127 = -126 </span></span><br><span class="line">    <span class="keyword">int</span> shift = <span class="number">23</span> + ( x + <span class="number">126</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; shift;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>( x &lt;= <span class="number">127</span> )&#123;</span><br><span class="line">	<span class="comment">//x= exp -bias</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">exp</span> = x + <span class="number">127</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">exp</span> &lt;&lt;<span class="number">23</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ( <span class="number">0XFF</span> ) &lt;&lt; <span class="number">23</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='true'
        data-ae='true'
        data-ci='01ed89abee289d37f2f8'
        data-cs='51741e819059e2ea7ab6c6f3d0fa0ac631d1d975'
        data-r='MyBlogComments'
        data-o='Equinox-shame'
        data-a='Equinox-shame'
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
