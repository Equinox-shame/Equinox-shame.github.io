
<!DOCTYPE html>
<html lang="zh" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Base 64	个人理解笔记 - Autumnal</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="Base 64 加密标准码表
Base64加密过程原理我们将字符串中的字符每3个一分割，再将3个字符转换为每个8位数长的2进制数据。

如输入：ABC，则转换的二进制是：A : 01000001、B,"> 
    <meta name="author" content="梓曰"> 
    <link rel="alternative" href="atom.xml" title="Autumnal" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Autumnal</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://equinox-shame.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">Base 64	个人理解笔记</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">Base 64	个人理解笔记</h1>
        <div class="stuff">
            <span>三月 14, 2022</span>
            

        </div>
        <div class="content markdown">
            <h2 id="Base-64-加密标准码表"><a href="#Base-64-加密标准码表" class="headerlink" title="Base 64 加密标准码表"></a>Base 64 加密标准码表</h2><p><img src="https://static01.imgkr.com/temp/cbd8c3ab2e43414eb5d5f3785a75ec09.png"></p>
<h2 id="Base64加密过程"><a href="#Base64加密过程" class="headerlink" title="Base64加密过程"></a>Base64加密过程</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>我们将字符串中的字符每3个一分割，再将3个字符转换为每个8位数长的2进制数据。</p>
<blockquote>
<p>如输入：ABC，则转换的二进制是：A : 01000001、B : 01000010、C : 01000011</p>
</blockquote>
<p>我们将这3个二进制的数据拼在一起得到一个全新的二进制数据</p>
<blockquote>
<p><code>010000010100001001000011</code></p>
</blockquote>
<p>我们再对其每六个一分组，并在最高位补上00</p>
<blockquote>
<p>分组出来为  <code>010000  010100  001001  000011</code>，补上00后为 <code> 00010000   00010100   00001001   00000011</code></p>
</blockquote>
<p>之后我们对其转化为10进制</p>
<blockquote>
<p>可以得到    16    20    19    3</p>
</blockquote>
<p>再对应开头的标准码表进行 ” 翻译 “ 得到新的字符，再将他们拼在一起就是我们想要得到的加密后的数据了。</p>
<blockquote>
<p>可以得到    Q    U    J    D</p>
</blockquote>
<h4 id="可是如果我们的字符不是3的倍数怎么办呢？"><a href="#可是如果我们的字符不是3的倍数怎么办呢？" class="headerlink" title="可是如果我们的字符不是3的倍数怎么办呢？"></a>可是如果我们的字符不是3的倍数怎么办呢？</h4><p>我们以    <code>Basic</code>    来进行类推，<code>Basic</code>一共是5个字符我们按照相同的步骤来进行</p>
<blockquote>
<p>B：01000010        a：01100001        s：01110011        i：01101001        c：01100011</p>
<p>进行拼接得到    <code>0100001001100001011100110110100101100011</code></p>
<p>再进行每六个一组得到    <code>010000    100110    000101    110011    011010    010110    0011</code></p>
</blockquote>
<p>这个时候我们就会发现最后面怎么只有4个数字呢？</p>
<p>我们可以发现一个规律（ 3 * 8 = 4 * 6 ）二进制数是长度为 8 ，而我们是按照每 6 个数字一组，所以我们每 3 个字符一起就可以转换成 4组数据。但是我们按照之前的最高位加上 00 后最后一个也才是 000011 不是 8位长度，这个时候我们就要再末尾补上 0 让其变为 8 位的二进制数，我们也就得到了 00001100</p>
<blockquote>
<p>这个时候我们便可以按照之前的法则进行转换，我们可以得到 ： <code>00010000001001100000010100110011000110100001011000001100</code></p>
<p>我们把上面的数据分一下组：</p>
<p><code>00010000    00100110    00000101    00110011    00011010    00010110    00001100</code></p>
<p>转换为 10 进制可以得到：16    38    5    51    26    22    12</p>
<p>对照码表我们得到了：<code>QmFzaWM</code></p>
</blockquote>
<h4 id="这个时候如果你去在线的网站上转换的话你会发现后面多出来一个-，这又是为什么呢？"><a href="#这个时候如果你去在线的网站上转换的话你会发现后面多出来一个-，这又是为什么呢？" class="headerlink" title="这个时候如果你去在线的网站上转换的话你会发现后面多出来一个 = ，这又是为什么呢？"></a>这个时候如果你去在线的网站上转换的话你会发现后面多出来一个 = ，这又是为什么呢？</h4><blockquote>
<p><img src="https://static01.imgkr.com/temp/e05bf3f95f8d481eaaaaf44e68cda5a7.png"></p>
</blockquote>
<p>一般而言我们在进行编码加密的时候会遇到余下两个或者一个字符，这个时候我们就会在末尾补上对应个数的 0 使之成为 8 位的二进制数，因为我们在输入之前便已经得到了字符串<code>Basic</code>的长度为 5 ，那么我们便可以判断出会有几个字符串剩余，每有一个字符串剩余我们就会在最后的密文里面加入对应数量的 = </p>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>Base64在对输入的数据进行加密时是以每三个字符为一组，进行对应的位运算，如果字符剩余两个则在对这两个数据进行位运算加密后的密文补上一个<code>=</code>，如果剩余一个字符在同样的位运算加密后的密文补上两个<code>=</code>。</p>
<h4 id="我们同样以ABC为例子-用位运算实现上面的一般原理"><a href="#我们同样以ABC为例子-用位运算实现上面的一般原理" class="headerlink" title="我们同样以ABC为例子,用位运算实现上面的一般原理"></a>我们同样以ABC为例子,用位运算实现上面的一般原理</h4><blockquote>
<h5 id="A：A-gt-Q"><a href="#A：A-gt-Q" class="headerlink" title="A：A -&gt; Q"></a>A：<code>A -&gt; Q</code></h5><p>那么这个要怎么实现呢？我们先观察两者的二进制数</p>
<p>A 的二进制数是：01000001    Q的二进制数是：00010000</p>
<p>不难看出 <code>A</code>在右移两位后便得到了<code>Q</code></p>
<h5 id="B：B-gt-U-J"><a href="#B：B-gt-U-J" class="headerlink" title="B：B -&gt; U J"></a>B：<code>B -&gt; U J</code></h5><p>B 的二进制数是：<code>01000010</code>，可是我们是将A的二进制数的最后两位与B的二进制数的开头四位组成的一个新的二进制数在在最高位补上 00 得到<code>00010100</code> （ U ）再把 B 的最后两位二进制数与 C 的前四位二进制数组成<code>00001001</code> ( J )</p>
<h6 id="这个要怎么实现呢？"><a href="#这个要怎么实现呢？" class="headerlink" title="这个要怎么实现呢？"></a>这个要怎么实现呢？</h6><h6 id="U"><a href="#U" class="headerlink" title="U :"></a>U :</h6><p>我们借用与运算<code>（&amp;）</code>的规则，两个操作对象同一位都为 1 则结果对应位为 1 ，否则对应结果为 0，我们要取最后的两位那么我们可以借用 <code>0x3</code> (3)</p>
<p>0x3的二进制数是：<code>00000011</code> 在和A的二进制进行与运算后可以得到：<code>00000001</code>，我们要在最高位加上00，并且第3、4位是A的最后两位二进制数，而现在的二进制数是：<code>00000001</code>，那么我们再次移位向左移 4 位得到：<code>00010000</code></p>
<p>接下来我们还要取<code>B</code>的二进制数的前4位<code>0100</code>,同样的我们将<code>B</code>右移4位便可以得到：<code>00000100</code>，但是我们要把<code>A</code>的后两位二进制与<code>B</code>的前4位二进制拼在一起，这个时候又该怎么办呢？</p>
<p>我们借助或运算<code>( | )</code>，若两个操作对象同一位都为 0，则结果对应位为 0，否则对应位为 1 。</p>
<p>我们把<code>00010000</code>和<code>00000100</code>进行或运算便得到了：<code>00010100</code> 转化成 10进制为 20，对应码表为 <code>U</code></p>
<h6 id="J"><a href="#J" class="headerlink" title="J :"></a>J :</h6><p>按照上述步骤我们将 B 与 0xf （<code>00001111</code>) 进行与运算得到 B 的二进制数最后 4 位在左移 2 位，C 则右移 6 位得到其最后两位二进制数，将两个数进行或运算即可得到：<code>00001001</code>转化成 10进制为 9，对应码表为 <code>J</code></p>
<h5 id="C-C-gt-J-D"><a href="#C-C-gt-J-D" class="headerlink" title="C : C -&gt; J D"></a>C : <code>C -&gt; J D</code></h5><h6 id="D"><a href="#D" class="headerlink" title="D :"></a>D :</h6><p>对于 D 而言我们仅需要去取二进制数的后 6 位就可以了，那么我们将 C 和 <code>0x3f</code>进行与运算便可以得到<code>00000011</code>转化成 10进制为 3，对应码表为 <code>D</code></p>
</blockquote>
<h4 id="此时我们便完成了对应数据的加密过程，那么在代码上是如何实现的呢？"><a href="#此时我们便完成了对应数据的加密过程，那么在代码上是如何实现的呢？" class="headerlink" title="此时我们便完成了对应数据的加密过程，那么在代码上是如何实现的呢？"></a>此时我们便完成了对应数据的加密过程，那么在代码上是如何实现的呢？</h4><h5 id="代码如下-："><a href="#代码如下-：" class="headerlink" title="代码如下 ："></a>代码如下 ：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *<span class="hljs-title">base64_encode</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *str)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">long</span> len;  <br>    <span class="hljs-keyword">long</span> str_len;  <br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *res;  <br>    <span class="hljs-keyword">int</span> i,j;  <br><span class="hljs-comment">//定义base64编码表  </span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *base64_table=<span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;  <br>  <br><span class="hljs-comment">//计算经过base64编码后的字符串长度  </span><br>    str_len=<span class="hljs-built_in">strlen</span>(str);  <br>    <span class="hljs-keyword">if</span>(str_len % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>)  <br>        len=str_len/<span class="hljs-number">3</span>*<span class="hljs-number">4</span>;  <br>    <span class="hljs-keyword">else</span>  <br>        len=(str_len/<span class="hljs-number">3</span>+<span class="hljs-number">1</span>)*<span class="hljs-number">4</span>;  <br>  <br>    res=<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)*len+<span class="hljs-number">1</span>);  <br>    res[len]=<span class="hljs-string">&#x27;\0&#x27;</span>;  <br>  <br><span class="hljs-comment">//以3个8位字符为一组进行编码  </span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;len<span class="hljs-number">-2</span>;j+=<span class="hljs-number">3</span>,i+=<span class="hljs-number">4</span>)  <br>    &#123;  <br>        <br>        res[i]=base64_table[str[j]&gt;&gt;<span class="hljs-number">2</span>]; <span class="hljs-comment">//取出第一个字符的前6位并找出对应的结果字符  </span><br>        <br>        res[i+<span class="hljs-number">1</span>]=base64_table[(str[j]&amp;<span class="hljs-number">0x3</span>)&lt;&lt;<span class="hljs-number">4</span> | (str[j+<span class="hljs-number">1</span>]&gt;&gt;<span class="hljs-number">4</span>)]; <span class="hljs-comment">//将第一个字符的后位与第二个字符的前4位进行组合并找到对应的结果字符 </span><br>        <br>        res[i+<span class="hljs-number">2</span>]=base64_table[(str[j+<span class="hljs-number">1</span>]&amp;<span class="hljs-number">0xf</span>)&lt;&lt;<span class="hljs-number">2</span> | (str[j+<span class="hljs-number">2</span>]&gt;&gt;<span class="hljs-number">6</span>)]; <span class="hljs-comment">//将第二个字符的后4位与第三个字符的前2位组合并找出对应的结果字符  </span><br>        <br>        res[i+<span class="hljs-number">3</span>]=base64_table[str[j+<span class="hljs-number">2</span>]&amp;<span class="hljs-number">0x3f</span>]; <span class="hljs-comment">//取出第三个字符的后6位并找出结果字符  </span><br>        <br>    &#125;  <br>  <br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>(str_len % <span class="hljs-number">3</span>)  <br>    &#123;  <br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:  <br>            res[i<span class="hljs-number">-2</span>]=<span class="hljs-string">&#x27;=&#x27;</span>;  <br>            res[i<span class="hljs-number">-1</span>]=<span class="hljs-string">&#x27;=&#x27;</span>;  <br>            <span class="hljs-keyword">break</span>;  <br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:  <br>            res[i<span class="hljs-number">-1</span>]=<span class="hljs-string">&#x27;=&#x27;</span>;  <br>            <span class="hljs-keyword">break</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">return</span> res;  <br>&#125;  <br><br></code></pre></td></tr></table></figure>



<p>我们加密一般是采用每 3 个一加密 ，而对于这 3 个字符来说，进行的操作都是同质化的，可以按照上面的模板进行加密，因而可以快速完成加密。</p>
<h2 id="解密过程-："><a href="#解密过程-：" class="headerlink" title="解密过程 ："></a>解密过程 ：</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>在加密过程中我们了解到了（ 3 * 8 = 4 * 6 ）的规律，那么我们再次利用这个规律将其还原回去，不过这次便是以 4 位为一组，来进行解密，因为 = 的加入，所以都能按照 4 个一组进行分配。按照上面的码表进行查找其对应的 10 进制数据，我们再将 10 进制数据转换为8 位长度的二进制数据之后去除最高位的 00 进行拼接，得到一串新的二进制数据。我们对这串数据按每 8 个一组分割，便可以得到对应明文中字符对应的二进制数据，最后进行转换和拼接，便是明文。</p>
<p>其中在解密过程中我们将 = 对应的二进制为<code>00000000</code>，不过一般在解密过程中我们会忽略 = ，将字符串进行解密。（python 中如果密文数据不为 4 的倍数会报错）</p>
<blockquote>
<p>我们仍以 ABC 为例子，ABC转换出的数据是 QUJD</p>
<p>我们逆向查找码表可以得到对应的数据分别为：16    20    19    3</p>
<p>我们依次转换为二进制并去除最高位的 00 得到：<code>010000  010100  001001  000011</code></p>
<p>我们可以看到现在的数据就是 6 位二进制数据了我们按照加密过程的逆向进行操作将上述数据拼接，每 8 个数字一组可以得到：<code>01000001    01000010    01000011</code>，我们将这些数据还原成字符便可以得到明文 ABC</p>
</blockquote>
<h3 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a>实现方法</h3><p>因为最终的密文中，如果 6 位二进制数据的分组不满 4 组，会有 <code>=</code> 作为填充物，所以一个 Base64 完后的密文总是能够被 4 整除。所以，在解密中，我们每次需要处理 4 个字符，将这 4 个字符编码之后转换成十进制，再转换成二进制，不足 6 位的高位补0，然后将 6 个位一组的二进制数按原顺序重新分成每 8 个位一组，也就是一个字节一组。然后将其转换成十六进制，再转换成对应的字符。</p>
<blockquote>
<p>我们以 Basic 为例子进行翻译明文，我们知道密文是 QmFzaWM=<br>我们分一下组 QmFz    aWM=</p>
<h6 id="B"><a href="#B" class="headerlink" title="B :"></a>B :</h6><p>我们观察 Q 的二进制：00010000，Q是由 B 的前六位二进制数转换而来的，而 B 的二进制数是：01000010<br>我们将 Q 的二进制数进行左移 2 位可以得到 01000000，我们发现与 B 的二进制数据还是有区别，此时我们再观察下一位 m 的二进制数据：00100110 ，这个时候我们如果将 m 右移4位那么不就可以得到我们想要的 00000010，再将其与01000000 进行或运算那不就得到第一个字符 B 了吗。</p>
<h6 id="a"><a href="#a" class="headerlink" title="a :"></a>a :</h6><p>我们还是一样的观察 m 的二进制：00100110，m 是由 B 的后 2 位二进制数加上 a 的前 4 位组成的，我们观察 a 的二进制数：01100001 和 F 的二进制数：00000101 可以看到我们将 m 的二进制数左移 4 位可以得到 01100000，此时我们再将 F右移两位可以得到：00000001，这个时候我们将这两个数进行或运算便可以得到我们想要的 a 的二进制数了。</p>
<h6 id="s："><a href="#s：" class="headerlink" title="s："></a>s：</h6><p>s是 3 个为一组的字符里面的最后一个，s将组成 F 、z，那么我们解密 Fz 之前，我们还是先来观察一下 z 的二进制：00110011， s 的二进制：01110011，F 的二进制数：00000101，如果你仔细观察，那么你会发现我们将 F 左移 6 位后在与 z 进行与运算便是 s 的二进制了。</p>
<h6 id="a、W、M、-："><a href="#a、W、M、-：" class="headerlink" title="a、W、M、=："></a>a、W、M、=：</h6><p>解密类似于 <code>QmFz</code> 就不再过多叙述了，最后我们会遇到 = ，此时我们不需要管 = ，将我们所有解密后的字符组合成一个字符串那么我们便得到了明文。</p>
</blockquote>
<h4 id="此时我们便完成了对应数据的解密过程，那么在代码上是如何实现的呢？"><a href="#此时我们便完成了对应数据的解密过程，那么在代码上是如何实现的呢？" class="headerlink" title="此时我们便完成了对应数据的解密过程，那么在代码上是如何实现的呢？"></a>此时我们便完成了对应数据的解密过程，那么在代码上是如何实现的呢？</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *<span class="hljs-title">base64_decode</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *code)</span>  </span><br><span class="hljs-function"></span>&#123;  <br><span class="hljs-comment">//根据base64表，以字符找到对应的十进制数据  </span><br>    <span class="hljs-keyword">int</span> table[]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<br>    		 <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<br>    		 <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<br>    		 <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">62</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<br>    		 <span class="hljs-number">63</span>,<span class="hljs-number">52</span>,<span class="hljs-number">53</span>,<span class="hljs-number">54</span>,<span class="hljs-number">55</span>,<span class="hljs-number">56</span>,<span class="hljs-number">57</span>,<span class="hljs-number">58</span>,<br>    		 <span class="hljs-number">59</span>,<span class="hljs-number">60</span>,<span class="hljs-number">61</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<br>    		 <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<br>    		 <span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>,<span class="hljs-number">18</span>,<span class="hljs-number">19</span>,<span class="hljs-number">20</span>,<span class="hljs-number">21</span>,<br>    		 <span class="hljs-number">22</span>,<span class="hljs-number">23</span>,<span class="hljs-number">24</span>,<span class="hljs-number">25</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">26</span>,<br>    		 <span class="hljs-number">27</span>,<span class="hljs-number">28</span>,<span class="hljs-number">29</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">32</span>,<span class="hljs-number">33</span>,<span class="hljs-number">34</span>,<span class="hljs-number">35</span>,<br>    		 <span class="hljs-number">36</span>,<span class="hljs-number">37</span>,<span class="hljs-number">38</span>,<span class="hljs-number">39</span>,<span class="hljs-number">40</span>,<span class="hljs-number">41</span>,<span class="hljs-number">42</span>,<span class="hljs-number">43</span>,<span class="hljs-number">44</span>,<br>    		 <span class="hljs-number">45</span>,<span class="hljs-number">46</span>,<span class="hljs-number">47</span>,<span class="hljs-number">48</span>,<span class="hljs-number">49</span>,<span class="hljs-number">50</span>,<span class="hljs-number">51</span><br>    	       &#125;;  <br>    <span class="hljs-keyword">long</span> len;  <br>    <span class="hljs-keyword">long</span> str_len;  <br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *res;  <br>    <span class="hljs-keyword">int</span> i,j;  <br>  <br><span class="hljs-comment">//计算解码后的字符串长度  </span><br>    len=<span class="hljs-built_in">strlen</span>(code);  <br><span class="hljs-comment">//判断编码后的字符串后是否有=  </span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strstr</span>(code,<span class="hljs-string">&quot;==&quot;</span>))  <br>        str_len=len/<span class="hljs-number">4</span>*<span class="hljs-number">3</span><span class="hljs-number">-2</span>;  <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strstr</span>(code,<span class="hljs-string">&quot;=&quot;</span>))  <br>        str_len=len/<span class="hljs-number">4</span>*<span class="hljs-number">3</span><span class="hljs-number">-1</span>;  <br>    <span class="hljs-keyword">else</span>  <br>        str_len=len/<span class="hljs-number">4</span>*<span class="hljs-number">3</span>;  <br>  <br>    res=<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)*str_len+<span class="hljs-number">1</span>);  <br>    res[str_len]=<span class="hljs-string">&#x27;\0&#x27;</span>;  <br>  <br><span class="hljs-comment">//以4个字符为一位进行解码  </span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i &lt; len<span class="hljs-number">-2</span>;j+=<span class="hljs-number">3</span>,i+=<span class="hljs-number">4</span>)  <br>    &#123;  <br>        res[j]=((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)table[code[i]])&lt;&lt;<span class="hljs-number">2</span> | (((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)table[code[i+<span class="hljs-number">1</span>]])&gt;&gt;<span class="hljs-number">4</span>); <span class="hljs-comment">//取出第一个字符对应base64表的十进制数的前6位与第二个字符对应base64表的十进制数的后2位进行组合  </span><br>        res[j+<span class="hljs-number">1</span>]=(((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)table[code[i+<span class="hljs-number">1</span>]])&lt;&lt;<span class="hljs-number">4</span>) | (((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)table[code[i+<span class="hljs-number">2</span>]])&gt;&gt;<span class="hljs-number">2</span>); <span class="hljs-comment">//取出第二个字符对应base64表的十进制数的后4位与第三个字符对应bas464表的十进制数的后4位进行组合  </span><br>        res[j+<span class="hljs-number">2</span>]=(((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)table[code[i+<span class="hljs-number">2</span>]])&lt;&lt;<span class="hljs-number">6</span>) | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)table[code[i+<span class="hljs-number">3</span>]]); <span class="hljs-comment">//取出第三个字符对应base64表的十进制数的后2位与第4个字符进行组合  </span><br>    &#125;  <br>  <br>    <span class="hljs-keyword">return</span> res;  <br>  <br>&#125;  <br> <br></code></pre></td></tr></table></figure>





<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>C语言实现Base64编码/解码_开挂的熊猫-CSDN博客(<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26093511/article/details/78836087">https://blog.csdn.net/qq_26093511/article/details/78836087</a>)</p>
<p>Base64编码 - 简书 (<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e95278ed98b4">https://www.jianshu.com/p/e95278ed98b4</a>)</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        

    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci='01ed89abee289d37f2f8'
        data-cs='51741e819059e2ea7ab6c6f3d0fa0ac631d1d975'
        data-r='equinox-shame.github.io'
        data-o='Equinox-shame'
        data-a='Equinox-shame'
        data-d='false'
    >查看评论</div>


        
    </div>
    
</div>


    </div>
</div>



</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
