
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Linux 手册 - Autumnal</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="系统简介学习路线
重要快捷键Tab : 可以进行命令补全，补全目录，补全命令参数
ctrl+c : 强行终止当前程序
ctrl+d : 键盘输入结束或者退出终端
ctrl+s : 暂停当前程序，暂停,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="Autumnal" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Autumnal</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">Linux 手册</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">Linux 手册</h1>
        <div class="stuff">
            <span>三月 14, 2022</span>
            

        </div>
        <div class="content markdown">
            <h2 id="系统简介"><a href="#系统简介" class="headerlink" title="系统简介"></a>系统简介</h2><h3 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h3><p><img src="https://doc.shiyanlou.com/linux_base/1-8.png"></p>
<h2 id="重要快捷键"><a href="#重要快捷键" class="headerlink" title="重要快捷键"></a>重要快捷键</h2><p><code>Tab</code> : 可以进行命令补全，补全目录，补全命令参数</p>
<p><code>ctrl+c</code> : 强行终止当前程序</p>
<p><code>ctrl+d</code> : 键盘输入结束或者退出终端</p>
<p><code>ctrl+s</code> : 暂停当前程序，暂停后按下任意键恢复运行</p>
<p><code>ctrl+z</code> : 将当前程序放在后台运行，恢复到前台命令<code>fg</code></p>
<p><code>ctrl+a</code> : 将光标移至输入行头，相当于<code>Home</code>键</p>
<p><code>ctrl+e</code> : 将光标移至输入行末，相当于<code>End</code>键</p>
<p><code>ctrl+k</code> : 删除光标所在位置到行末</p>
<p><code>alt+backspace</code> : 向前删除一个单词</p>
<p><code>shift+pageup</code> : 将终端显示向上滚动</p>
<p><code>shift+pagedown</code> : 将终端显示向下滚动</p>
<p><code>方向上键</code> : 恢复之前输入过的命令</p>
<h2 id="Shell-常用通配符"><a href="#Shell-常用通配符" class="headerlink" title="Shell 常用通配符"></a>Shell 常用通配符</h2><table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>匹配 0 或多个字符</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配任意一个字符</td>
</tr>
<tr>
<td><code>[list]</code></td>
<td>匹配 list 中的任意单一字符</td>
</tr>
<tr>
<td><code>[^list]</code></td>
<td>匹配 除 list 中的任意单一字符以外的字符</td>
</tr>
<tr>
<td><code>[c1-c2]</code></td>
<td>匹配 c1-c2 中的任意单一字符 如：[0-9][a-z]</td>
</tr>
<tr>
<td><code>&#123;string1,string2,...&#125;</code></td>
<td>匹配 string1 或 string2 (或更多)其一字符串</td>
</tr>
<tr>
<td><code>&#123;c1..c2&#125;</code></td>
<td>匹配 c1-c2 中全部字符 如{1..10}</td>
</tr>
</tbody></table>
<h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><h3 id="获取命令帮助"><a href="#获取命令帮助" class="headerlink" title="获取命令帮助"></a>获取命令帮助</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man &lt;命令名字&gt;</span><br></pre></td></tr></table></figure>

<p>获得更详细的帮助，你还可以使用<code>info</code>命令，不过通常使用<code>man</code>就足够了。如果你知道某个命令的作用，只是想快速查看一些它的某个具体参数的作用，那么你可以使用<code>--help</code>参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;命令名称&gt; --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<h3 id="切换目录"><a href="#切换目录" class="headerlink" title="切换目录"></a>切换目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> [路径]</span><br></pre></td></tr></table></figure>

<h3 id="查看当前目录"><a href="#查看当前目录" class="headerlink" title="查看当前目录"></a>查看当前目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure>
<h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [文件名]</span><br></pre></td></tr></table></figure>

<h2 id="用户系统操作"><a href="#用户系统操作" class="headerlink" title="用户系统操作"></a>用户系统操作</h2><h3 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser [用户名]</span><br></pre></td></tr></table></figure>

<p><code>useradd</code> 只创建用户，不会创建用户密码和工作目录，创建完了需要使用 <code>passwd &lt;username&gt;</code> 去设置新用户的密码。<code>adduser</code> 在创建用户的同时，会创建工作目录和密码（提示你设置），做这一系列的操作。其实 <code>useradd</code>、<code>userdel</code> 这类操作更像是一种命令，执行完了就返回。而 <code>adduser</code> 更像是一种程序，需要你输入、确定等一系列操作。</p>
<h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su -l [用户名]</span><br></pre></td></tr></table></figure>

<h3 id="退出当前用户"><a href="#退出当前用户" class="headerlink" title="退出当前用户"></a>退出当前用户</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>也可以使用快捷键<code>Ctrl+D</code></p>
<h3 id="查看用户组"><a href="#查看用户组" class="headerlink" title="查看用户组"></a>查看用户组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groups [用户名]</span><br></pre></td></tr></table></figure>

<p>在回显中冒号之前表示用户，后面表示该用户所属的用户组。</p>
<h3 id="将其他用户加入-sudo-用户组"><a href="#将其他用户加入-sudo-用户组" class="headerlink" title="将其他用户加入  sudo 用户组"></a>将其他用户加入  sudo 用户组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -G sudo [用户名]</span><br></pre></td></tr></table></figure>

<h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo deluser [用户名] --remove-home</span><br></pre></td></tr></table></figure>

<p>使用 <code>--remove-home</code> 参数在删除用户时候会一并将该用户的工作目录一并删除。如果不使用那么系统会自动在 /home 目录为该用户保留工作目录。</p>
<h2 id="文件系统操作"><a href="#文件系统操作" class="headerlink" title="文件系统操作"></a>文件系统操作</h2><h3 id="文件创建"><a href="#文件创建" class="headerlink" title="文件创建"></a>文件创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch [文件名]</span><br></pre></td></tr></table></figure>

<h3 id="目录创建"><a href="#目录创建" class="headerlink" title="目录创建"></a>目录创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [目录名]</span><br></pre></td></tr></table></figure>

<p>使用 <code>-p</code> 参数，同时创建父目录（如果不存在该父目录），如下我们同时创建一个多级目录（这在安装软件、配置安装路径时非常有用）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p father/son/grandson</span><br></pre></td></tr></table></figure>

<h3 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [文件名] [保存路径]</span><br></pre></td></tr></table></figure>

<p>如果需要复制一个目录则需要加上一个 <code>-r</code> 或者 <code>-R</code> 参数，表示递归复制</p>
<h3 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h3><h4 id="文件删除-1"><a href="#文件删除-1" class="headerlink" title="文件删除"></a>文件删除</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [文件名]</span><br></pre></td></tr></table></figure>

<p>可以加入<code>-f</code>参数来强行删除文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm  -f [文件名]</span><br></pre></td></tr></table></figure>

<h4 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h4><p>跟复制目录一样，要删除一个目录，也需要加上 <code>-r</code> 或 <code>-R</code> 参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r [目录名]</span><br></pre></td></tr></table></figure>

<p>遇到权限不足删除不了的目录也可以和删除文件一样加上 <code>-f</code> 参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf [目录名]</span><br></pre></td></tr></table></figure>

<h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [文件名] [目标目录]</span><br></pre></td></tr></table></figure>

<h3 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [文件名] [新文件名]</span><br></pre></td></tr></table></figure>

<p>如果是要批量重命名可以使用<code>rename</code>，需要自行安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install rename</span><br></pre></td></tr></table></figure>

<h3 id="查看文件-1"><a href="#查看文件-1" class="headerlink" title="查看文件"></a>查看文件</h3><h4 id="cat-命令的使用"><a href="#cat-命令的使用" class="headerlink" title="cat 命令的使用"></a>cat 命令的使用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [文件名]</span><br></pre></td></tr></table></figure>

<p>可以加上<code>-n</code>参数显示行数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n [文件名]</span><br></pre></td></tr></table></figure>

<h4 id="nl-命令的使用"><a href="#nl-命令的使用" class="headerlink" title="nl 命令的使用"></a>nl 命令的使用</h4><h5 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-b : 指定添加行号的方式，主要有两种：</span><br><span class="line">    -b a:表示无论是否为空行，同样列出行号(&quot;cat -n&quot;就是这种方式)</span><br><span class="line">    -b t:只列出非空行的编号并列出（默认为这种方式）</span><br><span class="line">-n : 设置行号的样式，主要有三种：</span><br><span class="line">    -n ln:在行号字段最左端显示</span><br><span class="line">    -n rn:在行号字段最右边显示，且不加 0</span><br><span class="line">    -n rz:在行号字段最右边显示，且加 0</span><br><span class="line">-w : 行号字段占用的位数(默认为 6 位)</span><br></pre></td></tr></table></figure>

<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl -b a [文件名]</span><br></pre></td></tr></table></figure>

<h4 id="more-和-less-命令的使用"><a href="#more-和-less-命令的使用" class="headerlink" title="more 和 less 命令的使用"></a>more 和 less 命令的使用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more/less [文件名]</span><br></pre></td></tr></table></figure>

<p>打开后默认只显示一屏内容，终端底部显示当前阅读的进度。可以使用 <code>Enter</code> 键向下滚动一行，使用 <code>Space</code> 键向下滚动一屏，按下 <code>h</code> 显示帮助，<code>q</code> 退出。</p>
<h4 id="head-和-tail-命令的使用"><a href="#head-和-tail-命令的使用" class="headerlink" title="head 和 tail 命令的使用"></a>head 和 tail 命令的使用</h4><p>一个是只查看文件的头几行（默认为 10 行，不足 10 行则显示全部）<code>[head]</code>和尾几行<code>[tail]</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head/tail [文件、路径名]</span><br></pre></td></tr></table></figure>

<p>也可以加入<code>-n</code>参数来查看指定行数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head/tail -n [行数] [文件、路径名]</span><br></pre></td></tr></table></figure>

<p>关于 <code>tail</code> 命令，不得不提的还有它一个很牛的参数 <code>-f</code>，这个参数可以实现不停地读取某个文件的内容并显示。这可以让我们动态查看日志，达到实时监视的目的。可以自行去了解。</p>
<h4 id="查看所有文件（包括隐藏文件）"><a href="#查看所有文件（包括隐藏文件）" class="headerlink" title="查看所有文件（包括隐藏文件）"></a>查看所有文件（包括隐藏文件）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure>

<h4 id="查看某一个目录的完整属性，而不是显示目录里面的文件属性："><a href="#查看某一个目录的完整属性，而不是显示目录里面的文件属性：" class="headerlink" title="查看某一个目录的完整属性，而不是显示目录里面的文件属性："></a>查看某一个目录的完整属性，而不是显示目录里面的文件属性：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -dl &lt;目录名&gt;</span><br></pre></td></tr></table></figure>

<h4 id="显示所有文件大小，并以普通人类能看懂的方式呈现："><a href="#显示所有文件大小，并以普通人类能看懂的方式呈现：" class="headerlink" title="显示所有文件大小，并以普通人类能看懂的方式呈现："></a>显示所有文件大小，并以普通人类能看懂的方式呈现：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -asSh</span><br></pre></td></tr></table></figure>

<p>其中小 s 为显示文件大小，大 S 为按文件大小排序</p>
<h4 id="查看文件类型"><a href="#查看文件类型" class="headerlink" title="查看文件类型"></a>查看文件类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file [文件名]</span><br></pre></td></tr></table></figure>

<p>与 Windows 不同的是，如果你新建了一个 shiyanlou.txt 文件，Windows 会自动把它识别为文本文件，而 <code>file</code> 命令会识别为一个空文件。在 Linux 中文件的类型不是根据文件后缀来判断的。当你在文件里输入内容后才会显示文件类型。</p>
<h4 id="以较长格式列出文件"><a href="#以较长格式列出文件" class="headerlink" title="以较长格式列出文件"></a>以较长格式列出文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br></pre></td></tr></table></figure>

<h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p><img src="https://doc.shiyanlou.com/linux_base/3-9.png"></p>
<p><img src="https://doc.shiyanlou.com/linux_base/3-10.png"></p>
<ul>
<li>文件类型</li>
</ul>
<p>关于文件类型，这里有一点你必需时刻牢记 <strong>Linux 里面一切皆文件</strong>，正因为这一点才有了设备文件（ <code>/dev</code> 目录下有各种设备文件，大都跟具体的硬件设备相关）这一说。 <code>socket</code>：网络套接字，具体是什么，感兴趣的用户可以去学习实验楼的后续相关课程。<code>pipe</code> 管道，这个东西很重要，我们以后将会讨论到，这里你先知道有它的存在即可。<code>软链接文件</code>：链接文件是分为两种的，另一种当然是“硬链接”（硬链接不常用，具体内容不作为本课程讨论重点，而软链接等同于 Windows 上的快捷方式，你记住这一点就够了）。</p>
<ul>
<li>文件权限</li>
</ul>
<p>读权限，表示你可以使用 <code>cat &lt;file name&gt;</code> 之类的命令来读取某个文件的内容；写权限，表示你可以编辑和修改某个文件的内容；</p>
<p>执行权限，通常指可以运行的二进制程序文件或者脚本文件，如同 Windows 上的 <code>exe</code> 后缀的文件，不过 Linux 上不是通过文件后缀名来区分文件的类型。你需要注意的一点是，<strong>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件</strong>，这是因为目录文件实际保存着该目录里面的文件的列表等信息。</p>
<p>所有者权限，这一点相信你应该明白了，至于所属用户组权限，是指你所在的用户组中的所有其它用户对于该文件的权限，比如，你有一个 iPad，那么这个用户组权限就决定了你的兄弟姐妹有没有权限使用它破坏它和占有它。</p>
<ul>
<li>链接数</li>
</ul>
<blockquote>
<p>链接到该文件所在的 inode 结点的文件名数目（关于这个概念涉及到 Linux 文件系统的相关概念知识，不在本课程的讨论范围，感兴趣的用户可以查看 <a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html#major2">硬链接和软链接的联系与区别</a>）。</p>
</blockquote>
<ul>
<li>文件大小</li>
</ul>
<blockquote>
<p>以 inode 结点大小为单位来表示的文件大小，你可以给 ls 加上 <code>-lh</code> 参数来更直观的查看文件的大小。</p>
</blockquote>
<p>明白了文件权限的一些概念，我们顺带补充一下关于 <code>ls</code> 命令的一些其它常用的用法：</p>
<ul>
<li>显示除了 <code>.</code>（当前目录）和 <code>..</code>（上一级目录）之外的所有文件，包括隐藏文件（Linux 下以 <code>.</code> 开头的文件为隐藏文件）。</li>
</ul>
<h4 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h4><h4 id="更改方式"><a href="#更改方式" class="headerlink" title="更改方式"></a>更改方式</h4><h5 id="方式一：二进制数字"><a href="#方式一：二进制数字" class="headerlink" title="方式一：二进制数字"></a>方式一：二进制数字</h5><p><img src="https://doc.shiyanlou.com/linux_base/3-14.png"></p>
<p>每个文件有三组固定的权限，分别对应拥有者，所属用户组，其他用户，<strong>记住这个顺序是固定的</strong>。文件的读写执行对应字母 <code>rwx</code>，以二进制表示就是 <code>111</code>，用十进制表示就是 <code>7</code>，对进制转换不熟悉的同学可以看看 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/3117222">进制转换</a>。例如我们刚刚新建的文件 test 的权限是 <code>rw-rw-rw-</code>，换成对应的十进制表示就是 666，这就表示这个文件的拥有者，所属用户组和其他用户具有读写权限，不具有执行权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 [文件名]</span><br></pre></td></tr></table></figure>

<h5 id="方式二：加减赋值操作"><a href="#方式二：加减赋值操作" class="headerlink" title="方式二：加减赋值操作"></a>方式二：加减赋值操作</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod go-rw test</span><br></pre></td></tr></table></figure>

<p><code>g</code>、<code>o</code> 还有 <code>u</code> 分别表示 group（用户组）、others（其他用户） 和 user（用户），<code>+</code> 和 <code>-</code> 分别表示增加和去掉相应的权限。</p>
<h4 id="变更文件所有权"><a href="#变更文件所有权" class="headerlink" title="变更文件所有权"></a>变更文件所有权</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown [用户名] [文件名]</span><br></pre></td></tr></table></figure>

<h3 id="文件打包-ZIP"><a href="#文件打包-ZIP" class="headerlink" title="文件打包 (ZIP)"></a>文件打包 (ZIP)</h3><h4 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r -q -o -[1-9] -e [输出压缩包名字] [打包文件/路径]</span><br></pre></td></tr></table></figure>

<p><code>-r</code> 参数表示递归打包包含子目录的全部内容，<code>-q</code> 参数表示为安静模式，即不向屏幕输出信息，<code>-o</code>表示输出文件，需在其后紧跟打包输出文件名，<code>-e</code>表示创建加密压缩包。</p>
<p>其中也可以设置压缩级别，添加一个参数用于设置压缩级别 <code>-[1-9]</code>即可，其中1 表示最快压缩但体积大，9 表示体积最小但耗时最久。也可以增加 <code>-x</code> ，用于排除某些文件，如排除该目录下的<code>zip</code>文件<code>-x ~/*.zip</code><strong>注意：这里只能使用绝对路径，否则不起作用</strong>。</p>
<p>与此同时我们也可以使用<code>du</code>指令来查看默认压缩级别、最低、最高压缩级别及未压缩的文件的大小</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h -d 0 *.zip ~ | sort</span><br></pre></td></tr></table></figure>

<p>其中<code>-h</code>指<code>human-readable</code>，便于阅读。而<code>-d</code>指所查看文件的深度</p>
<p><strong>注意：</strong> 关于 <code>zip</code> 命令，因为 Windows 系统与 Linux/Unix 在文本文件格式上的一些兼容问题，比如换行符（为不可见字符），在 Windows 为 CR+LF（Carriage-Return+Line-Feed：回车加换行），而在 Linux/Unix 上为 LF（换行），所以如果在不加处理的情况下，在 Linux 上编辑的文本，在 Windows 系统上打开可能看起来是没有换行的。如果想让在 Linux 创建的 zip 压缩文件在 Windows 上解压后没有任何问题，那么还需要对命令做一些修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r -l -o shiyanlou.zip /home/shiyanlou/Desktop</span><br></pre></td></tr></table></figure>

<p>需要加上 <code>-l</code> 参数将 <code>LF</code> 转换为 <code>CR+LF</code> 来达到以上目的。</p>
<h4 id="文件解压"><a href="#文件解压" class="headerlink" title="文件解压"></a>文件解压</h4><p>解压文件到当前目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip [文件名]</span><br></pre></td></tr></table></figure>

<p>使用安静模式则可以加上指令<code>-q</code>，如果需要解压到指定位置则在命令末尾加上<code>-d [解压到的地址]</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -q file.zip -d /home/<span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>如果解压到的目录不存在的时候将会自动创建。如果只想查看压缩包内容则可以使用<code>-l</code>命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -l [文件名]</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 使用 unzip 解压文件时我们同样应该注意兼容问题，不过这里我们关心的不再是上面的问题，而是中文编码的问题，通常 Windows 系统上面创建的压缩文件，如果有有包含中文的文档或以中文作为文件名的文件时默认会采用 GBK 或其它编码，而 Linux 上面默认使用的是 UTF-8 编码，如果不加任何处理，直接解压的话可能会出现中文乱码的问题（有时候它会自动帮你处理），为了解决这个问题，我们可以在解压时指定编码类型。</p>
<p>使用 <code>-O</code>（英文字母，大写 o）参数指定编码类型：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -O GBK 中文压缩文件.zip</span><br></pre></td></tr></table></figure>

<h3 id="文件打包-TAR"><a href="#文件打包-TAR" class="headerlink" title="文件打包 (TAR)"></a>文件打包 (TAR)</h3><h4 id="文件压缩-1"><a href="#文件压缩-1" class="headerlink" title="文件压缩"></a>文件压缩</h4><p>只能实现对文件或目录（单独压缩目录中的文件）的压缩，没有实现对文件的打包压缩</p>
<p>创建一个<code>tar</code>包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -P -cf [输出压缩包名] [打包文件/路径]</span><br></pre></td></tr></table></figure>

<p><code>-P</code> 保留绝对路径符，<code>-c</code> 表示创建一个 tar 包文件，<code>-f</code> 用于指定创建的文件名，注意文件名必须紧跟在 <code>-f</code> 参数之后，比如不能写成 <code>tar -fc xxx.tar</code>，可以写成 <code>tar -f xxx.tar -c ~</code>。还可以加上 <code>-v</code> 参数以可视的的方式输出打包的文件。</p>
<h4 id="文件解压-1"><a href="#文件解压-1" class="headerlink" title="文件解压"></a>文件解压</h4><p>解包一个文件（<code>-x</code> 参数）到指定路径的<strong>已存在</strong>目录（<code>-C</code> 参数）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf [文件名] -C [文件保存路径]</span><br></pre></td></tr></table></figure>

<p>如果仅查看压缩包内容则使用<code>-t</code>参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tf [文件名]</span><br></pre></td></tr></table></figure>

<p>保留文件属性和跟随链接（符号链接或软链接），有时候我们使用 tar 备份文件当你在其他主机还原时希望保留文件的属性（<code>-p</code> 参数）和备份链接指向的源文件而不是链接本身（<code>-h</code> 参数）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cphf [文件名] [保存路径]</span><br></pre></td></tr></table></figure>

<p>如果需要创建/解压其他格式的压缩包只需要在对应位置上加上对应的参数即可</p>
<table>
<thead>
<tr>
<th>压缩文件格式</th>
<th>参数</th>
</tr>
</thead>
<tbody><tr>
<td><code>*.tar.gz</code></td>
<td><code>-z</code></td>
</tr>
<tr>
<td><code>*.tar.xz</code></td>
<td><code>-J</code></td>
</tr>
<tr>
<td><code>*tar.bz2</code></td>
<td><code>-j</code></td>
</tr>
</tbody></table>
<h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><ul>
<li><code>whereis</code> 简单快速</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whereis who</span><br><span class="line">whereis find</span><br></pre></td></tr></table></figure>

<p><code>whereis</code> 只能搜索二进制文件（<code>-b</code>），man 帮助文件（<code>-m</code>）和源代码文件（<code>-s</code>）。如果想要获得更全面的搜索结果可以使用 <code>locate</code> 命令。</p>
<ul>
<li><code>locate</code> 快而全</li>
</ul>
<p>使用 <code>locate</code> 命令查找文件也不会遍历硬盘，它通过查询 <code>/var/lib/mlocate/mlocate.db</code> 数据库来检索信息。不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行 <code>updatedb</code> 命令来更新数据库。所以有时候你刚添加的文件，它可能会找不到，需要手动执行一次 <code>updatedb</code> 命令（在我们的环境中必须先执行一次该命令）。注意这个命令也不是内置的命令，在部分环境中需要手动安装，然后执行更新。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install locate</span><br><span class="line">sudo updatedb</span><br></pre></td></tr></table></figure>

<p>它可以用来查找指定目录下的不同文件类型，如查找 <code>/etc</code> 下所有以 sh 开头的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate /etc/sh</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，它不只是在 /etc 目录下查找，还会自动递归子目录进行查找。</p>
</blockquote>
<p>如果想只统计数目可以加上 <code>-c</code> 参数，<code>-i</code> 参数可以忽略大小写进行查找，<code>whereis</code> 的 <code>-b</code>、<code>-m</code>、<code>-s</code> 同样可以使用。</p>
<ul>
<li><code>which</code> 小而精</li>
</ul>
<p><code>which</code> 本身是 Shell 内建的一个命令，我们通常使用 <code>which</code> 来确定是否安装了某个指定的程序，因为它只从 <code>PATH</code> 环境变量指定的路径中去搜索命令并且返回第一个搜索到的结果。也就是说，我们可以看到某个系统命令是否存在以及执行的到底是哪一个地方的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> man</span><br><span class="line"><span class="built_in">which</span> nginx</span><br><span class="line"><span class="built_in">which</span> ping</span><br></pre></td></tr></table></figure>

<ul>
<li><code>find</code> 精而细</li>
</ul>
<p><code>find</code> 应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [路径] -name [文件名]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意 find 命令的路径是作为第一个参数的， 基本命令格式为 find [path][option] [action] 。</strong></p>
</blockquote>
<p>与时间相关的命令参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-atime</code></td>
<td>最后访问时间</td>
</tr>
<tr>
<td><code>-ctime</code></td>
<td>最后修改文件内容的时间</td>
</tr>
<tr>
<td><code>-mtime</code></td>
<td>最后修改文件属性的时间</td>
</tr>
</tbody></table>
<p>下面以 <code>-mtime</code> 参数举例：</p>
<ul>
<li><code>-mtime n</code>：n 为数字，表示为在 n 天之前的“一天之内”修改过的文件</li>
<li><code>-mtime +n</code>：列出在 n 天之前（不包含 n 天本身）被修改过的文件</li>
<li><code>-mtime -n</code>：列出在 n 天之内（包含 n 天本身）被修改过的文件</li>
<li><code>-newer file</code>：file 为一个已存在的文件，列出比 file 还要新的文件名</li>
</ul>
<p><img src="https://doc.shiyanlou.com/linux_base/5-8.png" alt="1"></p>
<p>列出 home 目录中，当天（24 小时之内）有改动的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~ -mtime 0</span><br></pre></td></tr></table></figure>

<p>列出用户家目录下比 /etc 目录新的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~ -newer /etc</span><br></pre></td></tr></table></figure>

<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="查看磁盘容量"><a href="#查看磁盘容量" class="headerlink" title="查看磁盘容量"></a>查看磁盘容量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df</span><br></pre></td></tr></table></figure>

<p>物理主机上的 <code>/dev/sda2</code> 是对应着主机硬盘的分区，后面的数字表示分区号，数字前面的字母 a 表示第几块硬盘（也可能是可移动磁盘），你如果主机上有多块硬盘则可能还会出现 <code>/dev/sdb</code>，<code>/dev/sdc</code> 这些磁盘设备都会在 <code>/dev</code> 目录下以文件的存在形式。</p>
<p>接着你还会看到”1k-块”这个陌生的东西，它表示以磁盘块大小的方式显示容量，后面为相应的以块大小表示的已用和可用容量，可以通过加上<code>-h</code>参数更易于阅读。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>

<h3 id="查看目录容量"><a href="#查看目录容量" class="headerlink" title="查看目录容量"></a>查看目录容量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认同样以块的大小展示</span></span><br><span class="line">du</span><br><span class="line"><span class="comment"># 加上 `-h` 参数，以更易读的方式展示</span></span><br><span class="line">du -h</span><br></pre></td></tr></table></figure>

<p><code>-d</code> 参数指定查看目录的深度</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只查看 1 级目录的信息</span></span><br><span class="line">du -h -d 0 ~</span><br><span class="line"><span class="comment"># 查看 2 级</span></span><br><span class="line">du -h -d 1 ~</span><br></pre></td></tr></table></figure>

<p>常用参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">du -h <span class="comment"># 同 --human-readable 以 K，M，G 为单位，提高信息的可读性。</span></span><br><span class="line">du -a <span class="comment"># 同 --all 显示目录中所有文件的大小。</span></span><br><span class="line">du -s <span class="comment"># 同 --summarize 仅显示总计，只列出最后加总的值。</span></span><br></pre></td></tr></table></figure>

<h3 id="虚拟磁盘创建"><a href="#虚拟磁盘创建" class="headerlink" title="虚拟磁盘创建"></a>虚拟磁盘创建</h3><h4 id="dd-命令基本使用"><a href="#dd-命令基本使用" class="headerlink" title="dd 命令基本使用"></a>dd 命令基本使用</h4><p><code>dd</code> 命令用于转换和复制文件，不过它的复制不同于 <code>cp</code>。之前提到过关于 Linux 的很重要的一点，<strong>一切即文件</strong>，在 Linux 上，硬件的设备驱动（如硬盘）和特殊设备文件（如 <code>/dev/zero</code> 和 <code>/dev/random</code>）都像普通文件一样，只是在各自的驱动程序中实现了对应的功能，<code>dd</code> 也可以读取文件或写入这些文件。这样，<code>dd</code> 也可以用在备份硬件的引导扇区、获取一定数量的随机数据或者空数据等任务中。<code>dd</code> 程序也可以在复制时处理数据，例如转换字节序、或在 ASCII 与 EBCDIC 编码间互换。</p>
<p><code>dd</code> 的命令行语句与其他的 Linux 程序不同，因为它的命令行选项格式为 <strong>选项=值</strong>，而不是更标准的 <strong>–选项 值</strong> 或 <strong>-选项=值</strong>。<code>dd</code> 默认从标准输入中读取，并写入到标准输出中，但可以用选项 <code>if</code>（input file，输入文件）和 <code>of</code>（output file，输出文件）改变。</p>
<p>我们先来试试用 <code>dd</code> 命令从标准输入读入用户的输入到标准输出或者一个文件中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出到文件</span></span><br><span class="line">dd of=<span class="built_in">test</span> bs=10 count=1 <span class="comment"># 或者 dd if=/dev/stdin of=test bs=10 count=1</span></span><br><span class="line"><span class="comment"># 输出到标准输出</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/stdin of=/dev/stdout bs=10 count=1</span><br><span class="line"><span class="comment"># 在打完了这个命令后，继续在终端打字，作为你的输入</span></span><br></pre></td></tr></table></figure>

<p>上述命令从标准输入设备读入用户输入（缺省值，所以可省略）然后输出到 test 文件，<code>bs</code>（block size）用于指定块大小（缺省单位为 Byte，也可为其指定如 <code>K</code>，<code>M</code>，<code>G</code> 等单位），<code>count</code> 用于指定块数量。如上图所示，我指定只读取总共 10 个字节的数据，当我输入了 <code>hello shiyanlou</code> 之后加上空格回车总共 16 个字节（一个英文字符占一个字节）内容，显然超过了设定大小。使用 <code>du</code> 和 <code>cat</code> 10 个字节（那个黑底百分号表示这里没有换行符），而其他的多余输入将被截取并保留在标准输入。</p>
<p>前面说到 <code>dd</code> 在拷贝的同时还可以实现数据转换，那下面就举一个简单的例子：将输出的英文字符转换为大写再写入文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/stdin of=<span class="built_in">test</span> bs=10 count=1 conv=ucase</span><br></pre></td></tr></table></figure>

<h4 id="使用-dd-命令创建虚拟镜像文件"><a href="#使用-dd-命令创建虚拟镜像文件" class="headerlink" title="使用 dd 命令创建虚拟镜像文件"></a>使用 dd 命令创建虚拟镜像文件</h4><p>通过上面一小节，你应该掌握了 <code>dd</code> 的基本使用，下面就来使用 <code>dd</code> 命令来完成创建虚拟磁盘的第一步。</p>
<p>从 <code>/dev/zero</code> 设备创建一个容量为 256M 的空文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=virtual.img bs=1M count=256</span><br><span class="line">du -h virtual.img</span><br></pre></td></tr></table></figure>

<p>然后我们要将这个文件格式化（写入文件系统），这里我们要学到一个（准确的说是一组）新的命令来完成这个需求。</p>
<h4 id="使用-mkfs-命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）"><a href="#使用-mkfs-命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）" class="headerlink" title="使用 mkfs 命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）"></a>使用 mkfs 命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）</h4><p>你可以在命令行输入 <code>sudo mkfs</code> 然后按下 <code>&lt;Tab&gt;</code> 键，你可以看到很多个以 mkfs 为前缀的命令，这些不同的后缀其实就是表示着不同的文件系统，可以用 mkfs 格式化成的文件系统。</p>
<p>我们可以简单的使用下面的命令来将我们的虚拟磁盘镜像格式化为 <code>ext4</code> 文件系统：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkfs.ext4 virtual.img</span><br></pre></td></tr></table></figure>

<p>可以看到实际 <code>mkfs.ext4</code> 是使用 <code>mke2fs</code> 来完成格式化工作的。<code>mke2fs</code> 的参数很多，不过我们也不会经常格式化磁盘来玩，所以就掌握这基本用法吧，等你有特殊需求时，再查看 man 文档解决。</p>
<p>更多关于文件系统的知识，请查看 wiki： <a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F#Linux_.E6.94.AF.E6.8F.B4.E7.9A.84.E6.AA.94.E6.A1.88.E7.B3.BB.E7.B5.B1">文件系统</a> <a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/Ext3">ext3</a>，<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/Ext4">ext4</a></p>
<p>如果你想知道 Linux 支持哪些文件系统你可以输入 <code>ls -l /lib/modules/$(uname -r)/kernel/fs</code> 查看。</p>
<h4 id="使用-mount-命令挂载磁盘到目录树"><a href="#使用-mount-命令挂载磁盘到目录树" class="headerlink" title="使用 mount 命令挂载磁盘到目录树"></a>使用 mount 命令挂载磁盘到目录树</h4><p>用户在 Linux/UNIX 的机器上打开一个文件以前，包含该文件的文件系统必须先进行挂载的动作，此时用户要对该文件系统执行 <code>mount</code> 的指令以进行挂载。该指令通常是使用在 USB 或其他可移除存储设备上，而根目录则需要始终保持挂载的状态。又因为 Linux/UNIX 文件系统可以对应一个文件而不一定要是硬件设备，所以可以挂载一个包含文件系统的文件到目录树。</p>
<p>Linux/UNIX 命令行的 <code>mount</code> 指令是告诉操作系统，对应的文件系统已经准备好，可以使用了，而该文件系统会对应到一个特定的点（称为挂载点）。挂载好的文件、目录、设备以及特殊文件即可提供用户使用。</p>
<p>我们先来使用 <code>mount</code> 来查看下主机已经挂载的文件系统：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount</span><br></pre></td></tr></table></figure>

<p>输出的结果中每一行表示一个设备或虚拟设备，每一行最前面是设备名，然后是 on 后面是挂载点，type 后面表示文件系统类型，再后面是挂载选项（比如可以在挂载时设定以只读方式挂载等等）。</p>
<p>那么我们如何挂载真正的磁盘到目录树呢，<code>mount</code> 命令的一般格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [options] [<span class="built_in">source</span>] [directory]</span><br></pre></td></tr></table></figure>

<p>一些常用操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [-o [操作选项]] [-t 文件系统类型] [-w|--rw|--ro] [文件系统源] [挂载点]</span><br></pre></td></tr></table></figure>

<p>现在直接来挂载我们创建的虚拟磁盘镜像到 <code>/mnt</code> 目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mount -o loop -t ext4 virtual.img /mnt</span><br><span class="line"><span class="comment"># 也可以省略挂载类型，很多时候 mount 会自动识别</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以只读方式挂载</span></span><br><span class="line">mount -o loop --ro virtual.img /mnt</span><br><span class="line"><span class="comment"># 或者 mount -o loop,ro virtual.img /mnt</span></span><br></pre></td></tr></table></figure>

<h4 id="使用-umount-命令卸载已挂载磁盘"><a href="#使用-umount-命令卸载已挂载磁盘" class="headerlink" title="使用 umount 命令卸载已挂载磁盘"></a>使用 umount 命令卸载已挂载磁盘</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#命令格式 sudo umount 已挂载设备名或者挂载点，如：</span></span><br><span class="line">sudo umount /mnt</span><br></pre></td></tr></table></figure>

<h4 id="使用-fdisk-为磁盘分区"><a href="#使用-fdisk-为磁盘分区" class="headerlink" title="使用 fdisk 为磁盘分区"></a>使用 fdisk 为磁盘分区</h4><p>（关于分区的一些概念不清楚的用户请参看 <a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95">主引导记录</a>）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看硬盘分区表信息</span></span><br><span class="line">sudo fdisk -l</span><br></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/linux_base/7-12.png"></p>
<p>输出结果中开头显示了我主机上的磁盘的一些信息，包括容量扇区数，扇区大小，I/O 大小等信息。</p>
<p>我们重点看一下中间的分区信息，<code>/dev/sda1</code>，<code>/dev/sda2</code> 为主分区分别安装了 Windows 和 Linux 操作系统，<code>/dev/sda3</code> 为交换分区（可以理解为虚拟内存），<code>/dev/sda4</code> 为扩展分区其中包含 <code>/dev/sda5</code>，<code>/dev/sda6</code>，<code>/dev/sda7</code>，<code>/dev/sda8</code> 四个逻辑分区，因为主机上有几个分区之间有空隙，没有对齐边界扇区，所以分区之间不是完全连续的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入磁盘分区模式</span></span><br><span class="line">sudo fdisk virtual.img</span><br></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/linux_base/7-13.png" alt="1"></p>
<p>在进行操作前我们首先应先规划好我们的分区方案，这里我将在使用 128M（可用 127M 左右）的虚拟磁盘镜像创建一个 30M 的主分区剩余部分为扩展分区包含 2 个大约 45M 的逻辑分区。</p>
<p>操作完成后输入 <code>p</code> 查看结果如下:</p>
<p><img src="https://doc.shiyanlou.com/linux_base/7-14.png" alt="1"></p>
<p>最后不要忘记输入 <code>w</code> 写入分区表。</p>
<h4 id="使用-losetup-命令建立镜像与回环设备的关联"><a href="#使用-losetup-命令建立镜像与回环设备的关联" class="headerlink" title="使用 losetup 命令建立镜像与回环设备的关联"></a>使用 losetup 命令建立镜像与回环设备的关联</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo losetup /dev/loop0 virtual.img</span><br><span class="line"><span class="comment"># 如果提示设备忙你也可以使用其它的回环设备，&quot;ls /dev/loop*&quot;参看所有回环设备</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解除设备关联</span></span><br><span class="line">sudo losetup -d /dev/loop0</span><br></pre></td></tr></table></figure>

<p>然后再使用 <code>mkfs</code> 格式化各分区（前面我们是格式化整个虚拟磁盘镜像文件或磁盘），不过格式化之前，我们还要为各分区建立虚拟设备的映射，用到 <code>kpartx</code> 工具，需要先安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install kpartx</span><br><span class="line">sudo kpartx -av /dev/loop0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消映射</span></span><br><span class="line">sudo kpartx -dv /dev/loop0</span><br></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/linux_base/7-15.png" alt="pic"></p>
<p>接着再是格式化，我们将其全部格式化为 ext4：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkfs.ext4 -q /dev/mapper/loop0p1</span><br><span class="line">sudo mkfs.ext4 -q /dev/mapper/loop0p5</span><br><span class="line">sudo mkfs.ext4 -q /dev/mapper/loop0p6</span><br></pre></td></tr></table></figure>

<p>格式化完成后在 <code>/media</code> 目录下新建四个空目录用于挂载虚拟磁盘：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /media/virtualdisk_&#123;1..3&#125;</span><br><span class="line"><span class="comment"># 挂载磁盘分区</span></span><br><span class="line">sudo mount /dev/mapper/loop0p1 /media/virtualdisk_1</span><br><span class="line">sudo mount /dev/mapper/loop0p5 /media/virtualdisk_2</span><br><span class="line">sudo mount /dev/mapper/loop0p6 /media/virtualdisk_3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载磁盘分区</span></span><br><span class="line">sudo umount /dev/mapper/loop0p1</span><br><span class="line">sudo umount /dev/mapper/loop0p5</span><br><span class="line">sudo umount /dev/mapper/loop0p6</span><br></pre></td></tr></table></figure>

<p>然后：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/linux_base/7-16.png" alt="pic"></p>
<h2 id="Linux-下帮助命令"><a href="#Linux-下帮助命令" class="headerlink" title="Linux 下帮助命令"></a>Linux 下帮助命令</h2><h3 id="内建命令与外部命令"><a href="#内建命令与外部命令" class="headerlink" title="内建命令与外部命令"></a>内建命令与外部命令</h3><p>什么是内建命令，什么是外部命令呢？这和帮助命令又有什么关系呢？</p>
<p>因为有一些查看帮助的工具在内建命令与外建命令上是有区别对待的。</p>
<blockquote>
<p><strong>内建命令</strong>实际上是 shell 程序的一部分，其中包含的是一些比较简单的 Linux 系统命令，这些命令是写在 bash 源码的 builtins 里面的，由 shell 程序识别并在 shell 程序内部完成运行，通常在 Linux 系统加载运行时 shell 就被加载并驻留在系统内存中。而且解析内部命令 shell 不需要创建子进程，因此其执行速度比外部命令快。比如：history、cd、exit 等等。</p>
</blockquote>
<blockquote>
<p><strong>外部命令</strong>是 Linux 系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调入内存。虽然其不包含在 shell 中，但是其命令执行过程是由 shell 程序控制的。外部命令是在 Bash 之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin 等等。比如：ls、vi 等。</p>
</blockquote>
<p>简单来说就是：一个是天生自带的天赋技能，一个是后天得来的附加技能。我们可以使用 type 命令来区分命令是内建的还是外部的。例如这两个得出的结果是不同的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> vim</span><br></pre></td></tr></table></figure>

<p>得到的是两种结果，若是对 ls 你还能得到第三种结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到这样的结果说明是内建命令，正如上文所说内建命令都是在 bash 源码中的 builtins 的.def中</span></span><br><span class="line">xxx is a shell <span class="built_in">builtin</span></span><br><span class="line"><span class="comment"># 得到这样的结果说明是外部命令，正如上文所说，外部命令在/usr/bin or /usr/sbin等等中</span></span><br><span class="line">xxx is /usr/bin/xxx</span><br><span class="line"><span class="comment"># 若是得到alias的结果，说明该指令为命令别名所设定的名称；</span></span><br><span class="line">xxx is an <span class="built_in">alias</span> <span class="keyword">for</span> xx --xxx</span><br></pre></td></tr></table></figure>

<h3 id="help-命令"><a href="#help-命令" class="headerlink" title="help 命令"></a>help 命令</h3><p><code>help</code> 命令是用于显示 <code>shell</code> 内建命令的简要帮助信息。帮助信息中显示有该命令的简要说明以及一些参数的使用以及说明，一定记住 <code>help</code> 命令只能用于显示内建命令的帮助信息，如果是外部命令则可以在命令后加上<code>--help</code>参数。</p>
<h3 id="man-命令"><a href="#man-命令" class="headerlink" title="man 命令"></a>man 命令</h3><p><code>man</code>得到的内容比用 <code>help</code> 更多更详细，而且 <code>man</code> 没有内建与外部命令的区分，因为 man 工具是显示系统手册页中的内容，也就是一本电子版的字典，这些内容大多数都是对命令的解释信息，还有一些相关的描述。通过查看系统文档中的 <code>man</code> 也可以得到程序的更多相关信息和 <code>Linux</code> 的更多特性。</p>
<p>在尝试上面这个命令时我们会发现最左上角显示“ LS （1）”，在这里，“ LS ”表示手册名称，而“（1）”表示该手册位于第一章节。这个章节又是什么？在 man 手册中一共有这么几个章节</p>
<table>
<thead>
<tr>
<th>章节数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>1</code></td>
<td>Standard commands （标准命令）</td>
</tr>
<tr>
<td><code>2</code></td>
<td>System calls （系统调用）</td>
</tr>
<tr>
<td><code>3</code></td>
<td>Library functions （库函数）</td>
</tr>
<tr>
<td><code>4</code></td>
<td>Special devices （设备说明）</td>
</tr>
<tr>
<td><code>5</code></td>
<td>File formats （文件格式）</td>
</tr>
<tr>
<td><code>6</code></td>
<td>Games and toys （游戏和娱乐）</td>
</tr>
<tr>
<td><code>7</code></td>
<td>Miscellaneous （杂项）</td>
</tr>
<tr>
<td><code>8</code></td>
<td>Administrative Commands （管理员命令）</td>
</tr>
<tr>
<td><code>9</code></td>
<td>其他（Linux 特定的）， 用来存放内核例行程序的文档。</td>
</tr>
</tbody></table>
<p>打开手册之后我们可以通过 pgup 与 pgdn 或者上下键来上下翻看，可以按 q 退出当前页面</p>
<h3 id="info-命令"><a href="#info-命令" class="headerlink" title="info 命令"></a>info 命令</h3><p>使用<code>info</code>命令需要手动安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">安装和操作步骤如下：</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 info</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install info</span><br><span class="line"><span class="comment"># 查看 ls 命令的 info</span></span><br><span class="line">info ls</span><br></pre></td></tr></table></figure>

<p>得到的信息比 man 还要多，与此同时，man 和 info 就像两个集合，它们有一个交集部分，但与 man 相比，info 工具可显示更完整的 GNU 工具信息。若 man 页包含的某个工具的概要信息在 info 中也有介绍，那么 man 页中会有“请参考 info 页更详细内容”的字样。</p>
<h2 id="Linux-任务计划-crontab"><a href="#Linux-任务计划-crontab" class="headerlink" title="Linux 任务计划 crontab"></a>Linux 任务计划 crontab</h2><h3 id="crontab-简介"><a href="#crontab-简介" class="headerlink" title="crontab 简介"></a>crontab 简介</h3><p>crontab 命令从输入设备读取指令，并将其存放于 crontab 文件中，以供之后读取和执行。通常，crontab 储存的指令被守护进程激活，crond 为其守护进程，crond 常常在后台运行，每一分钟会检查一次是否有预定的作业需要执行。</p>
<p>通过 crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell 脚本。时间间隔的单位可以是分钟、小时、日、月、周的任意组合。</p>
<p>这里我们看一看 crontab 的格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  * user-name command to be executed</span></span><br></pre></td></tr></table></figure>

<p>我们通过下面一个命令来添加一个计划任务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>

<p>第一次启动会出现这样一个画面，这是让我们选择编辑的工具，选择第二个基本的 vim 就可以了。</p>
<p><img src="https://doc.shiyanlou.com/document-uid600404labid6124timestamp1523941985569.png" alt="此处输入图片的描述"></p>
<p>而选择后我们会进入这样一个画面，这就是添加计划的地方了，与一般的配置文档相同，以#号开头的都是注释，通过文档的最后一排我们可以猜猜 crontab 的格式是什么样的呢？</p>
<p><img src="https://dn-simplecloud.shiyanlou.com/1135081468202029108" alt="实验楼"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man crontab</span><br></pre></td></tr></table></figure>

<p>在了解命令格式之后，我们通过这样的一个例子来完成一个任务的添加，在文档的最后一排加上这样一排命令，该任务是每分钟我们会在/home/shiyanlou 目录下创建一个以当前的年月日时分秒为名字的空白文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/1 * * * * touch /home/shiyanlou/$(date +\%Y\%m\%d\%H\%M\%S)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<blockquote>
<p>“ % ” 在 crontab 文件中，有结束命令行、换行、重定向的作用，前面加 ” \ ” 符号转义，否则，“ % ” 符号将执行其结束命令行或者换行的作用，并且其后的内容会被做为标准输入发送给前面的命令。</p>
</blockquote>
<p>添加成功后我们会得到最后一排 installing new crontab 的一个提示：</p>
<p><img src="https://dn-simplecloud.shiyanlou.com/1135081468203483143" alt="实验楼"></p>
<p>当然我们也可以通过这样的一个指令来查看我们添加了哪些任务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure>

<p>通过图中的显示，我们也可以看出，我们正确的保存并且添加成功了该任务的：</p>
<p><img src="https://dn-simplecloud.shiyanlou.com/1135081468204230683" alt="实验楼"></p>
<p>虽然我们添加了任务，但是如果 <code>cron</code> 的守护进程并没有启动，它根本都不会监测到有任务，当然也就不会帮我们执行，我们可以通过以下 2 种方式来确定我们的 <code>cron</code> 是否成功的在后台启动，默默的帮我们做事，若是没有就得执行上文准备中的第二步了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep cron</span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"></span><br><span class="line">pgrep cron</span><br></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid600404labid6124timestamp1523942683532.png" alt="此处输入图片的描述"></p>
<p>通过下图可以看到任务在创建之后，执行了几次，生成了一些文件，且每分钟生成一个：</p>
<p><img src="https://doc.shiyanlou.com/document-uid600404labid6124timestamp1523943532369.png" alt="此处输入图片的描述"></p>
<p>我们通过这样一个命令可以查看到执行任务命令之后在日志中的信息反馈：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tail -f /var/<span class="built_in">log</span>/syslog</span><br></pre></td></tr></table></figure>

<p>从图中我们可以看到分别在 13 点 28、29、30 分的 01 秒为我们在 shiyanlou 用户的家目录下创建了文件。</p>
<p><img src="https://doc.shiyanlou.com/document-uid600404labid6124timestamp1523943327065.png" alt="此处输入图片的描述"></p>
<p>当我们并不需要这个任务的时候我们可以使用这么一个命令去删除任务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -r</span><br></pre></td></tr></table></figure>

<p>通过图中我们可以看出我们删除之后再查看任务列表，系统已经显示该用户并没有任务哦。</p>
<p><img src="https://doc.shiyanlou.com/document-uid600404labid6124timestamp1523943647348.png" alt="此处输入图片的描述"></p>
<h3 id="crontab-的深入"><a href="#crontab-的深入" class="headerlink" title="crontab 的深入"></a>crontab 的深入</h3><p>每个用户使用 <code>crontab -e</code> 添加计划任务，都会在 <code>/var/spool/cron/crontabs</code> 中添加一个该用户自己的任务文档，这样目的是为了隔离。</p>
<p><img src="https://dn-simplecloud.shiyanlou.com/1135081468206283987" alt="实验楼"></p>
<p>如果是系统级别的定时任务，需要 root 权限执行的任务应该怎么处理？</p>
<p>只需要使用 <code>sudo</code> 编辑 <code>/etc/crontab</code> 文件就可以。</p>
<p><code>cron</code> 服务监测时间最小单位是分钟，所以 <code>cron</code> 会每分钟去读取一次 <code>/etc/crontab</code> 与 <code>/var/spool/cron/crontabs</code> 里面的內容。</p>
<p>在 <code>/etc</code> 目录下，<code>cron</code> 相关的目录有下面几个：</p>
<p><img src="https://dn-simplecloud.shiyanlou.com/1135081468206856712" alt="实验楼"></p>
<p>每个目录的作用：</p>
<ol>
<li><code>/etc/cron.daily</code>，目录下的脚本会每天执行一次，在每天的 6 点 25 分时运行；</li>
<li><code>/etc/cron.hourly</code>，目录下的脚本会每个小时执行一次，在每小时的 17 分钟时运行；</li>
<li><code>/etc/cron.monthly</code>，目录下的脚本会每月执行一次，在每月 1 号的 6 点 52 分时运行；</li>
<li><code>/etc/cron.weekly</code>，目录下的脚本会每周执行一次，在每周第七天的 6 点 47 分时运行；</li>
</ol>
<p>系统默认执行时间可以根据需求进行修改。</p>
<h2 id="命令执行顺序控制与管道"><a href="#命令执行顺序控制与管道" class="headerlink" title="命令执行顺序控制与管道"></a>命令执行顺序控制与管道</h2><h3 id="命令执行顺序"><a href="#命令执行顺序" class="headerlink" title="命令执行顺序"></a>命令执行顺序</h3><p>在终端中简单的顺序执行你可以使用 <code>;</code> 来完成，比如你可以：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update;sudo apt-get install some-tool;some-tool <span class="comment"># 让它自己运行</span></span><br></pre></td></tr></table></figure>

<p>如果我们在让它自动顺序执行命令时，前面的命令执行不成功，而后面的命令又依赖于上一条命令的结果，那么就会造成花了时间，最终却得到一个错误的结果，而且有时候直观的看你还无法判断结果是否正确。那么我们需要能够有选择性的来执行命令，比如上一条命令执行成功才继续下一条，或者不成功又该做出其它什么处理，比如我们使用 <code>which</code> 来查找是否安装某个命令，如果找到就执行该命令，否则什么也不做，虽然这个操作没有什么实际意义，但可帮你更好的理解一些概念：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> cowsay&gt;/dev/null &amp;&amp; cowsay -f head-in ohch~</span><br></pre></td></tr></table></figure>

<p>你如果没有安装 <code>cowsay</code>，你可以先执行一次上述命令，你会发现什么也没发生，你再安装好之后你再执行一次上述命令，你也会发现一些惊喜。</p>
<p>上面的 <code>&amp;&amp;</code> 就是用来实现选择性执行的，它表示如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）返回 0 则执行后面的，否则不执行，你可以从 <code>$?</code> 环境变量获取上一次命令的返回结果。</p>
<p>学习过 C 语言的应该知道在 C 语言里面 <code>&amp;&amp;</code> 表示逻辑与，而且还有一个 <code>||</code> 表示逻辑或，同样 Shell 也有一个 <code>||</code>，它们的区别就在于，shell 中的这两个符号除了也可用于表示逻辑与和或之外，就是可以实现这里的命令执行顺序的简单控制。<code>||</code> 在这里就是与 <code>&amp;&amp;</code> 相反的控制效果，当上一条命令执行结果为 <code>≠0(\$?≠0)</code> 时则执行它后面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> cowsay&gt;/dev/null || <span class="built_in">echo</span> <span class="string">&quot;cowsay has not been install, please run &#x27;sudo apt-get install cowsay&#x27; to install&quot;</span></span><br></pre></td></tr></table></figure>

<p>除了上述基本的使用之外，我们还可以结合着 <code>&amp;&amp;</code> 和 <code>||</code> 来实现一些操作，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> cowsay&gt;/dev/null &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;exist&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;not exist&quot;</span></span><br></pre></td></tr></table></figure>

<p>用流程图可以理解为：</p>
<p><img src="https://doc.shiyanlou.com/linux_base/8-3.png"></p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>比如查看 <code>/etc</code> 目录下有哪些文件和目录，使用 <code>ls</code> 命令来查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al /etc</span><br></pre></td></tr></table></figure>

<p>有太多内容，屏幕不能完全显示，这时候可以使用滚动条或快捷键滚动窗口来查看。不过这时候可以使用管道：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al /etc | less</span><br></pre></td></tr></table></figure>

<p>通过管道将前一个命令(<code>ls</code>)的输出作为下一个命令(<code>less</code>)的输入，然后就可以一行一行地看。</p>
<h3 id="cut-命令"><a href="#cut-命令" class="headerlink" title="cut 命令"></a>cut 命令</h3><p>打印 <code>/etc/passwd</code> 文件中以 <code>:</code> 为分隔符的第 1 个字段和第 6 个字段分别表示用户名和其家目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut /etc/passwd -d &#x27;:&#x27; -f 1,6</span><br></pre></td></tr></table></figure>

<p>打印 <code>/etc/passwd</code> 文件中每一行的前 N 个字符：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前五个（包含第五个）</span></span><br><span class="line">cut /etc/passwd -c -5</span><br><span class="line"><span class="comment"># 前五个之后的（包含第五个）</span></span><br><span class="line">cut /etc/passwd -c 5-</span><br><span class="line"><span class="comment"># 第五个</span></span><br><span class="line">cut /etc/passwd -c 5</span><br><span class="line"><span class="comment"># 2 到 5 之间的（包含第五个）</span></span><br><span class="line">cut /etc/passwd -c 2-5</span><br></pre></td></tr></table></figure>

<h3 id="grep-命令"><a href="#grep-命令" class="headerlink" title="grep 命令"></a>grep 命令</h3><p><code>grep</code> 命令是很强大的，也是相当常用的一个命令，它结合正则表达式可以实现很复杂却很高效的匹配和查找，不过在学习正则表达式之前，这里介绍它简单的使用，而关于正则表达式后面将会有单独一小节介绍到时会再继续学习 <code>grep</code> 命令和其他一些命令。</p>
<p><code>grep</code> 命令的一般形式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [命令选项]... 用于匹配的表达式 [文件]...</span><br></pre></td></tr></table></figure>

<p>还是先体验一下，我们搜索<code>/home/shiyanlou</code>目录下所有包含”shiyanlou”的文本文件，并显示出现在文本中的行号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -rnI <span class="string">&quot;shiyanlou&quot;</span> ~</span><br></pre></td></tr></table></figure>

<p><code>-r</code> 参数表示递归搜索子目录中的文件，<code>-n</code> 表示打印匹配项行号，<code>-I</code> 表示忽略二进制文件。这个操作实际没有多大意义，但可以感受到 <code>grep</code> 命令的强大与实用。</p>
<p>当然也可以在匹配字段中使用正则表达式，下面简单的演示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看环境变量中以 &quot;yanlou&quot; 结尾的字符串</span></span><br><span class="line"><span class="built_in">export</span> | grep <span class="string">&quot;.*yanlou$&quot;</span></span><br></pre></td></tr></table></figure>

<p>其中<code>$</code>表示一行的末尾</p>
<h3 id="wc-命令"><a href="#wc-命令" class="headerlink" title="wc 命令"></a>wc 命令</h3><p>wc 命令用于统计并输出一个文件中行、单词和字节的数目，比如输出 <code>/etc/passwd</code> 文件的统计信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc /etc/passwd</span><br></pre></td></tr></table></figure>

<p>分别只输出行数、单词数、字节数、字符数和输入文本中最长一行的字节数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 行数</span></span><br><span class="line">wc -l /etc/passwd</span><br><span class="line"><span class="comment"># 单词数</span></span><br><span class="line">wc -w /etc/passwd</span><br><span class="line"><span class="comment"># 字节数</span></span><br><span class="line">wc -c /etc/passwd</span><br><span class="line"><span class="comment"># 字符数</span></span><br><span class="line">wc -m /etc/passwd</span><br><span class="line"><span class="comment"># 最长行字节数</span></span><br><span class="line">wc -L /etc/passwd</span><br></pre></td></tr></table></figure>

<p><strong>注意：对于西文字符来说，一个字符就是一个字节，但对于中文字符一个汉字是大于 2 个字节的，具体数目是由字符编码决定的。</strong></p>
<p>再来结合管道来操作一下，下面统计 /etc 下面所有目录数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -dl /etc/*/ | wc -l</span><br></pre></td></tr></table></figure>

<h3 id="sort-命令"><a href="#sort-命令" class="headerlink" title="sort 命令"></a>sort 命令</h3><p>功能很简单就是将输入按照一定方式排序，然后再输出，它支持的排序有按字典排序，数字排序，按月份排序，随机排序，反转排序，指定特定字段进行排序等等。</p>
<p>默认为字典排序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | sort</span><br></pre></td></tr></table></figure>

<p>反转排序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | sort -r</span><br></pre></td></tr></table></figure>

<p>按特定字段排序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | sort -t<span class="string">&#x27;:&#x27;</span> -k 3</span><br></pre></td></tr></table></figure>

<p>上面的<code>-t</code>参数用于指定字段的分隔符，这里是以”:”作为分隔符；<code>-k 字段号</code>用于指定对哪一个字段进行排序。这里<code>/etc/passwd</code>文件的第三个字段为数字，默认情况下是以字典序排序的，如果要按照数字排序就要加上<code>-n</code>参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | sort -t<span class="string">&#x27;:&#x27;</span> -k 3 -n</span><br></pre></td></tr></table></figure>

<p>注意观察第二个冒号后的数字：</p>
<p><img src="https://doc.shiyanlou.com/document-uid735639labid63timestamp1532414849333.png"></p>
<h3 id="uniq-命令"><a href="#uniq-命令" class="headerlink" title="uniq 命令"></a>uniq 命令</h3><p><code>uniq</code> 命令可以用于过滤或者输出重复行。</p>
<ul>
<li>过滤重复行</li>
</ul>
<p>我们可以使用 <code>history</code> 命令查看最近执行过的命令（实际为读取 <code>$&#123;SHELL&#125;_history</code> 文件，如环境中的 <code>.zsh_history</code> 文件），不过你可能只想查看使用了哪个命令而不需要知道具体干了什么，那么你可能就会要想去掉命令后面的参数然后去掉重复的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | cut -c 8- | cut -d <span class="string">&#x27; &#x27;</span> -f 1 | uniq</span><br></pre></td></tr></table></figure>

<p>然后经过层层过滤，你会发现确是只输出了执行的命令那一列，不过去重效果好像不明显，仔细看你会发现它确实去重了，只是不那么明显，之所以不明显是因为 <code>uniq</code> 命令只能去连续重复的行，不是全文去重，所以要达到预期效果，我们先排序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | cut -c 8- | cut -d <span class="string">&#x27; &#x27;</span> -f 1 | sort | uniq</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="built_in">history</span> | cut -c 8- | cut -d <span class="string">&#x27; &#x27;</span> -f 1 | sort -u</span><br></pre></td></tr></table></figure>

<p>这就是 Linux/UNIX 哲学吸引人的地方，大繁至简，一个命令只干一件事却能干到最好。</p>
<ul>
<li>输出重复行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出重复过的行（重复的只输出一个）及重复次数</span></span><br><span class="line"><span class="built_in">history</span> | cut -c 8- | cut -d <span class="string">&#x27; &#x27;</span> -f 1 | sort | uniq -dc</span><br><span class="line"><span class="comment"># 输出所有重复的行</span></span><br><span class="line"><span class="built_in">history</span> | cut -c 8- | cut -d <span class="string">&#x27; &#x27;</span> -f 1 | sort | uniq -D</span><br></pre></td></tr></table></figure>

<p>文本处理命令还有很多，下一节将继续介绍一些常用的文本处理的命令。</p>
<h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><h3 id="tr-命令"><a href="#tr-命令" class="headerlink" title="tr 命令"></a>tr 命令</h3><p>tr 命令可以用来删除一段文本信息中的某些文字。或者将其进行转换。</p>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr [option]...SET1 [SET2]</span><br></pre></td></tr></table></figure>

<h4 id="常用的选项有"><a href="#常用的选项有" class="headerlink" title="常用的选项有"></a>常用的选项有</h4><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-d</code></td>
<td>删除和 set1 匹配的字符，注意不是全词匹配也不是按字符顺序匹配</td>
</tr>
<tr>
<td><code>-s</code></td>
<td>去除 set1 指定的在输入文本中连续并重复的字符</td>
</tr>
</tbody></table>
<h4 id="操作举例"><a href="#操作举例" class="headerlink" title="操作举例"></a>操作举例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 &quot;hello shiyanlou&quot; 中所有的&#x27;o&#x27;，&#x27;l&#x27;，&#x27;h&#x27;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;hello shiyanlou&#x27;</span> | tr -d <span class="string">&#x27;olh&#x27;</span></span><br><span class="line"><span class="comment"># 将&quot;hello&quot; 中的ll，去重为一个l</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;hello&#x27;</span> | tr -s <span class="string">&#x27;l&#x27;</span></span><br><span class="line"><span class="comment"># 将输入文本，全部转换为大写或小写输出</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;input some text here&#x27;</span> | tr <span class="string">&#x27;[:lower:]&#x27;</span> <span class="string">&#x27;[:upper:]&#x27;</span></span><br><span class="line"><span class="comment"># 上面的&#x27;[:lower:]&#x27; &#x27;[:upper:]&#x27;你也可以简单的写作&#x27;[a-z]&#x27; &#x27;[A-Z]&#x27;，当然反过来将大写变小写也是可以的</span></span><br></pre></td></tr></table></figure>

<p>与此同时<code>tr</code>命令也可以用于替换，比如需要把<code>$</code>替换为<code>^M</code>，则可以写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr <span class="string">&#x27;$&#x27;</span> <span class="string">&#x27;^M&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="col-命令"><a href="#col-命令" class="headerlink" title="col 命令"></a>col 命令</h3><p>col 命令可以将<code>Tab</code>换成对等数量的空格键，或反转这个操作。</p>
<h4 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">col [option]</span><br></pre></td></tr></table></figure>

<h4 id="常用的选项有-1"><a href="#常用的选项有-1" class="headerlink" title="常用的选项有"></a>常用的选项有</h4><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-x</code></td>
<td>将<code>Tab</code>转换为空格</td>
</tr>
<tr>
<td><code>-h</code></td>
<td>将空格转换为<code>Tab</code>（默认选项）</td>
</tr>
</tbody></table>
<h4 id="操作举例-1"><a href="#操作举例-1" class="headerlink" title="操作举例"></a>操作举例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 /etc/protocols 中的不可见字符，可以看到很多 ^I ，这其实就是 Tab 转义成可见字符的符号</span></span><br><span class="line">cat -A /etc/protocols</span><br><span class="line"><span class="comment"># 使用 col -x 将 /etc/protocols 中的 Tab 转换为空格，然后再使用 cat 查看，你发现 ^I 不见了</span></span><br><span class="line">cat /etc/protocols | col -x | cat -A</span><br></pre></td></tr></table></figure>

<h3 id="join-命令"><a href="#join-命令" class="headerlink" title="join 命令"></a>join 命令</h3><p>学过数据库的用户对这个应该不会陌生，这个命令就是用于将两个文件中包含相同内容的那一行合并在一起。</p>
<h4 id="使用方式-2"><a href="#使用方式-2" class="headerlink" title="使用方式"></a>使用方式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">join [option]... file1 file2</span><br></pre></td></tr></table></figure>

<h4 id="常用的选项有-2"><a href="#常用的选项有-2" class="headerlink" title="常用的选项有"></a>常用的选项有</h4><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-t</code></td>
<td>指定分隔符，默认为空格</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>忽略大小写的差异</td>
</tr>
<tr>
<td><code>-1</code></td>
<td>指明第一个文件要用哪个字段来对比，默认对比第一个字段</td>
</tr>
<tr>
<td><code>-2</code></td>
<td>指明第二个文件要用哪个字段来对比，默认对比第一个字段</td>
</tr>
</tbody></table>
<h4 id="操作举例-2"><a href="#操作举例-2" class="headerlink" title="操作举例"></a>操作举例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/shiyanlou</span><br><span class="line"><span class="comment"># 创建两个文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1 hello&#x27;</span> &gt; file1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1 shiyanlou&#x27;</span> &gt; file2</span><br><span class="line">join file1 file2</span><br><span class="line"><span class="comment"># 将 /etc/passwd 与 /etc/shadow 两个文件合并，指定以&#x27;:&#x27;作为分隔符</span></span><br><span class="line">sudo join -t<span class="string">&#x27;:&#x27;</span> /etc/passwd /etc/shadow</span><br><span class="line"><span class="comment"># 将 /etc/passwd 与 /etc/group 两个文件合并，指定以&#x27;:&#x27;作为分隔符，分别比对第4和第3个字段</span></span><br><span class="line">sudo join -t<span class="string">&#x27;:&#x27;</span> -1 4 /etc/passwd -2 3 /etc/group</span><br></pre></td></tr></table></figure>

<h3 id="paste-命令"><a href="#paste-命令" class="headerlink" title="paste 命令"></a>paste 命令</h3><p><code>paste</code>这个命令与<code>join</code> 命令类似，它是在不对比数据的情况下，简单地将多个文件合并一起，以<code>Tab</code>隔开。</p>
<h4 id="使用方式-3"><a href="#使用方式-3" class="headerlink" title="使用方式"></a>使用方式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste [option] file...</span><br></pre></td></tr></table></figure>

<h4 id="常用的选项有-3"><a href="#常用的选项有-3" class="headerlink" title="常用的选项有"></a>常用的选项有</h4><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-d</code></td>
<td>指定合并的分隔符，默认为 Tab</td>
</tr>
<tr>
<td><code>-s</code></td>
<td>不合并到一行，每个文件为一行</td>
</tr>
</tbody></table>
<h4 id="操作举例-3"><a href="#操作举例-3" class="headerlink" title="操作举例"></a>操作举例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello &gt; file1</span><br><span class="line"><span class="built_in">echo</span> shiyanlou &gt; file2</span><br><span class="line"><span class="built_in">echo</span> www.shiyanlou.com &gt; file3</span><br><span class="line">paste -d <span class="string">&#x27;:&#x27;</span> file1 file2 file3</span><br><span class="line">paste -s file1 file2 file3</span><br></pre></td></tr></table></figure>

<h2 id="数据流重定向"><a href="#数据流重定向" class="headerlink" title="数据流重定向"></a>数据流重定向</h2><h3 id="简单重定向"><a href="#简单重定向" class="headerlink" title="简单重定向"></a>简单重定向</h3><p>在更多了解 Linux 的重定向之前，我们需要先知道一些基本的东西，前面我们已经提到过 Linux 默认提供了三个特殊设备，用于终端的显示和输出，分别为 <code>stdin</code>（标准输入，对应于你在终端的输入），<code>stdout</code>（标准输出，对应于终端的输出），<code>stderr</code>（标准错误输出，对应于终端的输出）。</p>
<table>
<thead>
<tr>
<th>文件描述符</th>
<th>设备文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>0</code></td>
<td><code>/dev/stdin</code></td>
<td>标准输入</td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>/dev/stdout</code></td>
<td>标准输出</td>
</tr>
<tr>
<td><code>2</code></td>
<td><code>/dev/stderr</code></td>
<td>标准错误</td>
</tr>
</tbody></table>
<blockquote>
<p>文件描述符：文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。</p>
</blockquote>
<p>我们可以这样使用这些文件描述符。例如默认使用终端的标准输入作为命令的输入和标准输出作为命令的输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="comment"># 按 Ctrl+C 退出</span></span><br></pre></td></tr></table></figure>

<p>将 cat 的连续输出（heredoc 方式）重定向到一个文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mkdir Documents</span><br><span class="line">cat &gt; Documents/test.c &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    printf(&quot;hello world\n&quot;);</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>将一个文件作为命令的输入，标准输出作为命令的输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat Documents/test.c</span><br></pre></td></tr></table></figure>

<p>将 echo 命令通过管道传过来的数据作为 cat 命令的输入，将标准输出作为命令的输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hi&#x27;</span> | cat</span><br></pre></td></tr></table></figure>

<p>将 echo 命令的输出从默认的标准输出重定向到一个普通文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello shiyanlou&#x27;</span> &gt; redirect</span><br><span class="line">cat redirect</span><br></pre></td></tr></table></figure>

<p>初学者这里要注意不要将管道和重定向混淆，<strong>管道默认是连接前一个命令的输出到下一个命令的输入</strong>，而重定向通常是需要一个文件来建立两个命令的连接，你可以仔细体会一下上述第三个操作和最后两个操作的异同点。</p>
<h3 id="标准错误重定向"><a href="#标准错误重定向" class="headerlink" title="标准错误重定向"></a>标准错误重定向</h3><p>重定向标准输出到文件，这是一个很实用的操作，另一个很实用的操作是将标准错误重定向，标准输出和标准错误都被指向伪终端的屏幕显示，所以我们经常看到的一个命令的输出通常是同时包含了标准输出和标准错误的结果的。比如下面的操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用cat 命令同时读取两个文件，其中一个存在，另一个不存在</span></span><br><span class="line">cat Documents/test.c hello.c</span><br><span class="line"><span class="comment"># 你可以看到除了正确输出了前一个文件的内容，还在末尾出现了一条错误信息</span></span><br><span class="line"><span class="comment"># 下面我们将输出重定向到一个文件</span></span><br><span class="line">cat Documents/test.c hello.c &gt; somefile</span><br></pre></td></tr></table></figure>

<p>遗憾的是，这里依然出现了那条错误信息，这正是因为如我上面说的那样，标准输出和标准错误虽然都指向终端屏幕，实际它们并不一样。那有的时候我们就是要隐藏某些错误或者警告，那又该怎么做呢。这就需要用到我们前面讲的文件描述符了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将标准错误重定向到标准输出，再将标准输出重定向到文件，注意要将重定向到文件写到前面</span></span><br><span class="line">cat Documents/test.c hello.c &gt;somefile  2&gt;&amp;1</span><br><span class="line"><span class="comment"># 或者只用bash提供的特殊的重定向符号&quot;&amp;&quot;将标准错误和标准输出同时重定向到文件</span></span><br><span class="line">cat Documents/test.c hello.c &amp;&gt;somefilehell</span><br></pre></td></tr></table></figure>

<p><strong>注意你应该在输出重定向文件描述符前加上<code>&amp;</code>，否则 shell 会当做重定向到一个文件名为 1 的文件中</strong></p>
<h3 id="使用-tee-命令同时重定向到多个文件"><a href="#使用-tee-命令同时重定向到多个文件" class="headerlink" title="使用 tee 命令同时重定向到多个文件"></a>使用 tee 命令同时重定向到多个文件</h3><p>除了需要将输出重定向到文件，也需要将信息打印在终端。那么你可以使用 <code>tee</code> 命令来实现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello shiyanlou&#x27;</span> | tee hello</span><br></pre></td></tr></table></figure>

<h3 id="永久重定向"><a href="#永久重定向" class="headerlink" title="永久重定向"></a>永久重定向</h3><p>你应该可以看出我们前面的重定向操作都只是临时性的，即只对当前命令有效，那如何做到永久有效呢，比如在一个脚本中，你需要某一部分的命令的输出全部进行重定向，难道要让你在每个命令上面加上临时重定向的操作嘛？</p>
<p>当然不需要，我们可以使用 <code>exec</code> 命令实现永久重定向。<code>exec</code> 命令的作用是使用指定的命令替换当前的 Shell，即使用一个进程替换当前进程，或者指定新的重定向：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先开启一个子 Shell</span></span><br><span class="line">zsh</span><br><span class="line"><span class="comment"># 使用exec替换当前进程的重定向，将标准输出重定向到一个文件</span></span><br><span class="line"><span class="built_in">exec</span> 1&gt;somefile</span><br><span class="line"><span class="comment"># 后面你执行的命令的输出都将被重定向到文件中，直到你退出当前子shell，或取消exec的重定向（后面将告诉你怎么做）</span></span><br><span class="line">ls</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">cat somefile</span><br></pre></td></tr></table></figure>

<h3 id="创建输出文件描述符"><a href="#创建输出文件描述符" class="headerlink" title="创建输出文件描述符"></a>创建输出文件描述符</h3><p>在 Shell 中有 9 个文件描述符。上面我们使用了也是它默认提供的 0，1，2 号文件描述符。另外我们还可以使用 3-8 的文件描述符，只是它们默认没有打开而已。你可以使用下面命令查看当前 Shell 进程中打开的文件描述符：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /dev/fd/;ls -Al</span><br></pre></td></tr></table></figure>

<p>同样使用 <code>exec</code> 命令可以创建新的文件描述符：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">zsh</span><br><span class="line"><span class="built_in">exec</span> 3&gt;somefile</span><br><span class="line"><span class="comment"># 先进入目录，再查看，否则你可能不能得到正确的结果，然后再回到上一次的目录</span></span><br><span class="line"><span class="built_in">cd</span> /dev/fd/;ls -Al;<span class="built_in">cd</span> -</span><br><span class="line"><span class="comment"># 注意下面的命令&gt;与&amp;之间不应该有空格，如果有空格则会出错</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;this is test&quot;</span> &gt;&amp;3</span><br><span class="line">cat somefile</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<h3 id="关闭文件描述符"><a href="#关闭文件描述符" class="headerlink" title="关闭文件描述符"></a>关闭文件描述符</h3><p>如上面我们打开的 3 号文件描述符，可以使用如下操作将它关闭：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 3&gt;&amp;-</span><br><span class="line"><span class="built_in">cd</span> /dev/fd;ls -Al;<span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure>

<h3 id="完全屏蔽命令的输出"><a href="#完全屏蔽命令的输出" class="headerlink" title="完全屏蔽命令的输出"></a>完全屏蔽命令的输出</h3><p>在 Linux 中有一个被称为黑洞的设备文件，所有导入它的数据都将被吞噬。</p>
<blockquote>
<p>在类 UNIX 系统中，/dev/null，或称空设备，是一个特殊的设备文件，它通常被用于丢弃不需要的输出流，或作为用于输入流的空文件，这些操作通常由重定向完成。读取它则会立即得到一个 EOF。</p>
</blockquote>
<p>我们可以利用 <code>/dev/null</code> 屏蔽命令的输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat Documents/test.c 1&gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>上面这样的操作将使你得不到任何输出结果。</p>
<h3 id="使用-xargs-分割参数列表"><a href="#使用-xargs-分割参数列表" class="headerlink" title="使用 xargs 分割参数列表"></a>使用 xargs 分割参数列表</h3><blockquote>
<p>xargs 是一条 UNIX 和类 UNIX 操作系统的常用命令。它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。</p>
</blockquote>
<p>这个命令在有些时候十分有用，特别是当用来处理产生大量输出结果的命令如 <code>find</code>，<code>locate</code> 和 <code>grep</code> 的结果，详细用法请参看 man 文档。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -d: -f1 &lt; /etc/passwd | sort | xargs <span class="built_in">echo</span></span><br></pre></td></tr></table></figure>

<p>上面这个命令用于将 <code>/etc/passwd</code> 文件按 <code>:</code> 分割取第一个字段排序后，使用 <code>echo</code> 命令生成一个列表。</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>一个正则表达式通常被称为一个模式（<strong>pattern</strong>），为用来描述或者匹配一系列符合某个句法规则的字符串。</p>
<h4 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h4><p><code>|</code> 竖直分隔符表示选择，例如 <code>boy|girl</code> 可以匹配 <code>boy</code> 或者 <code>girl</code>。</p>
<h4 id="数量限定"><a href="#数量限定" class="headerlink" title="数量限定"></a>数量限定</h4><p>数量限定除了我们举例用的 <code>*</code> 还有 <code>+</code> 加号 <code>?</code> 问号，如果在一个模式中不加数量限定符则表示出现一次且仅出现一次：</p>
<ul>
<li><code>+</code> 表示前面的字符必须出现至少一次(1 次或多次)，例如 <code>goo+gle</code> 可以匹配 <code>gooogle</code>，<code>goooogle</code> 等；</li>
<li><code>?</code> 表示前面的字符最多出现一次（0 次或 1 次），例如，<code>colou?r</code>，可以匹配 <code>color</code> 或者 <code>colour</code>;</li>
<li><code>*</code> 星号代表前面的字符可以不出现，也可以出现一次或者多次（0 次、或 1 次、或多次），例如，<code>0*42</code> 可以匹配 42、042、0042、00042 等。</li>
</ul>
<h4 id="范围和优先级"><a href="#范围和优先级" class="headerlink" title="范围和优先级"></a>范围和优先级</h4><p><code>()</code> 圆括号可以用来定义模式字符串的范围和优先级，这可以简单的理解为是否将括号内的模式串作为一个整体。例如，<code>gr(a|e)y</code> 等价于 <code>gray|grey</code>，（这里体现了优先级，竖直分隔符用于选择 <code>a</code> 或者 <code>e</code> 而不是 <code>gra</code> 和 <code>ey</code>），<code>(grand)?father</code> 匹配 <code>father</code> 和 <code>grandfather</code>（这里体现了范围，<code>?</code> 将圆括号内容作为一个整体匹配）。</p>
<h4 id="语法（部分）"><a href="#语法（部分）" class="headerlink" title="语法（部分）"></a>语法（部分）</h4><p>正则表达式有多种不同的风格，下面列举一些常用的作为 PCRE 子集的适用于 <code>perl</code> 和 <code>python</code> 编程语言及 <code>grep</code> 或 <code>egrep</code> 的正则表达式匹配规则：</p>
<blockquote>
<p>PCRE（Perl Compatible Regular Expressions 中文含义：perl 语言兼容正则表达式）是一个用 C 语言编写的正则表达式函数库，由菲利普.海泽(Philip Hazel)编写。PCRE 是一个轻量级的函数库，比 Boost 之类的正则表达式库小得多。PCRE 十分易用，同时功能也很强大，性能超过了 POSIX 正则表达式库和一些经典的正则表达式库。</p>
</blockquote>
<p><strong>(由于 markdown 表格解析的问题，下面的竖直分隔符 <code>|</code> 用全角字符代替，实际使用时请换回半角字符。</strong></p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>\</code></td>
<td><strong>将下一个字符标记为一个特殊字符、或一个原义字符。</strong> 例如 <code>n</code> 匹配字符 <code>n</code>。<code>\n</code> 匹配一个换行符。序列 <code>\\</code> 匹配 <code>\</code> 而 <code>\(</code> 则匹配 <code>(</code>。</td>
</tr>
<tr>
<td><code>^</code></td>
<td><strong>匹配输入字符串的开始位置。</strong></td>
</tr>
<tr>
<td><code>$</code></td>
<td><strong>匹配输入字符串的结束位置。</strong></td>
</tr>
<tr>
<td><code>&#123;n&#125;</code></td>
<td>n 是一个非负整数。<strong>匹配确定的 n 次</strong>。例如 <code>o&#123;2&#125;</code> 不能匹配 <code>Bob</code> 中的 <code>o</code>，但是能匹配 <code>food</code> 中的两个 <code>o</code>。</td>
</tr>
<tr>
<td><code>&#123;n,&#125;</code></td>
<td>n 是一个非负整数。<strong>至少匹配 n 次</strong>。例如 <code>o&#123;2,&#125;</code> 不能匹配 <code>Bob</code> 中的 <code>o</code>，但能匹配 <code>foooood</code> 中的所有 <code>o</code>。<code>o&#123;1,&#125;</code> 等价于 <code>o+</code>。<code>o&#123;0,&#125;</code> 则等价于 <code>o*</code>。</td>
</tr>
<tr>
<td><code>&#123;n,m&#125;</code></td>
<td>m 和 n 均为非负整数，其中 <code>n&lt;=m</code>。<strong>最少匹配 n 次且最多匹配 m 次</strong>。例如，<code>o&#123;1,3&#125;</code> 将匹配 <code>fooooood</code> 中的前三个 <code>o</code>。<code>o&#123;0,1&#125;</code> 等价于 <code>o?</code>。请注意在逗号和两个数之间不能有空格。</td>
</tr>
<tr>
<td><code>*</code></td>
<td><strong>匹配前面的子表达式零次或多次</strong>。例如，<code>zo*</code> 能匹配 <code>z</code>、<code>zo</code> 以及 <code>zoo</code>。<code>*</code> 等价于 <code>&#123;0,&#125;</code>。</td>
</tr>
<tr>
<td><code>+</code></td>
<td><strong>匹配前面的子表达式一次或多次</strong>。例如，<code>zo+</code> 能匹配 <code>zo</code> 以及 <code>zoo</code>，但不能匹配 <code>z</code>。<code>+</code> 等价于 <code>&#123;1,&#125;</code>。</td>
</tr>
<tr>
<td><code>?</code></td>
<td><strong>匹配前面的子表达式零次或一次</strong>。例如，<code>do(es)?</code> 可以匹配 <code>do</code> 或 <code>does</code> 中的 <code>do</code>。<code>?</code> 等价于 <code>&#123;0,1&#125;</code>。</td>
</tr>
<tr>
<td><code>?</code></td>
<td>当该字符紧跟在任何一个其他限制符（<code>*</code>，<code>+</code>，<code>?</code>，<code>&#123;n&#125;</code>，<code>&#123;n,&#125;</code>，<code>&#123;n,m&#125;</code>）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 <code>oooo</code>，<code>o+?</code> 将匹配单个 <code>o</code>，而 <code>o+</code> 将匹配所有 <code>o</code>。</td>
</tr>
<tr>
<td><code>.</code></td>
<td><strong>匹配除 <code>\n</code> 之外的任何单个字符</strong>。要匹配包括 <code>\n</code> 在内的任何字符，请使用类似 <code>(.｜\n)</code> 的模式。</td>
</tr>
<tr>
<td><code>(pattern)</code></td>
<td><strong>匹配 pattern 并获取这一匹配的子字符串</strong>。该子字符串用于向后引用。要匹配圆括号字符，请使用 <code>\(</code> 和 <code>\)</code>。</td>
</tr>
<tr>
<td>x ｜ y</td>
<td><strong>匹配 x 或 y</strong>。例如，“z ｜ food”能匹配 <code>z</code> 或 <code>food</code>。“(z ｜ f)ood”则匹配 <code>zood</code> 或 <code>food</code>。</td>
</tr>
<tr>
<td><code>[xyz]</code></td>
<td>字符集合（character class）。<strong>匹配所包含的任意一个字符</strong>。例如，<code>[abc]</code> 可以匹配 <code>plain</code> 中的 <code>a</code>。其中特殊字符仅有反斜线 <code>\</code> 保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符^如果出现在首位则表示负值字符集合；如果出现在字符串中间就仅作为普通字符。<strong>连字符 <code>-</code> 如果出现在字符串中间表示字符范围描述；如果出现在首位则仅作为普通字符。</strong></td>
</tr>
<tr>
<td><code>[^xyz]</code></td>
<td>排除型（negate）字符集合。<strong>匹配未列出的任意字符。</strong>例如，<code>[^abc]</code> 可以匹配 <code>plain</code> 中的 <code>plin</code>。</td>
</tr>
<tr>
<td><code>[a-z]</code></td>
<td>字符范围。<strong>匹配指定范围内的任意字符。</strong>例如，<code>[a-z]</code> 可以匹配 <code>a</code> 到 <code>z</code> 范围内的任意小写字母字符。</td>
</tr>
<tr>
<td><code>[^a-z]</code></td>
<td>排除型的字符范围。<strong>匹配任何不在指定范围内的任意字符</strong>。例如，<code>[^a-z]</code> 可以匹配任何不在 <code>a</code> 到 <code>z</code> 范围内的任意字符。</td>
</tr>
</tbody></table>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>优先级为从上到下从左到右，依次降低：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>\</code></td>
<td>转义符</td>
</tr>
<tr>
<td><code>()</code>，<code>(?:)</code>，<code>(?=)</code>，<code>[]</code></td>
<td>括号和中括号</td>
</tr>
<tr>
<td><code>*</code>，<code>+</code>，<code>?</code>，<code>&#123;n&#125;</code>，<code>&#123;n,&#125;</code>，<code>&#123;n,m&#125;</code></td>
<td>限定符</td>
</tr>
<tr>
<td><code>^</code>，<code>$</code>，<code>\</code> 任何元字符</td>
<td>定位点和序列</td>
</tr>
<tr>
<td>｜</td>
<td>选择</td>
</tr>
</tbody></table>
<p>更多正则表达式的内容可以参考以下链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式 wiki</a></li>
<li><a target="_blank" rel="noopener" href="http://www.greenend.org.uk/rjk/tech/regexp.html">几种正则表达式引擎的语法差异</a></li>
<li><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines">各语言各平台对正则表达式的支持</a></li>
</ul>
<p>regex 的思导图：</p>
<p><img src="https://doc.shiyanlou.com/linux_base/RegularExpression.png" alt="pic"></p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><code>grep</code> 命令用于打印输出文本中匹配的模式串，它使用正则表达式作为模式匹配的条件。<code>grep</code> 支持三种正则表达式引擎，分别用三个参数指定：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-E</code></td>
<td>POSIX 扩展正则表达式，ERE</td>
</tr>
<tr>
<td><code>-G</code></td>
<td>POSIX 基本正则表达式，BRE</td>
</tr>
<tr>
<td><code>-P</code></td>
<td>Perl 正则表达式，PCRE</td>
</tr>
</tbody></table>
<p>不过在你没学过 perl 语言的大多数情况下你将只会使用到 <code>ERE</code> 和 <code>BRE</code>，所以我们接下来的内容都不会讨论到 PCRE 中特有的一些正则表达式语法（它们之间大部分内容是存在交集的，所以你不用担心会遗漏多少重要内容）。</p>
<p>在通过<code>grep</code>命令使用正则表达式之前，先介绍一下它的常用参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-b</code></td>
<td>将二进制文件作为文本来进行匹配</td>
</tr>
<tr>
<td><code>-c</code></td>
<td>统计以模式匹配的数目，可以用于统计文本中某个字符串出现的次数</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>忽略大小写</td>
</tr>
<tr>
<td><code>-n</code></td>
<td>显示匹配文本所在行的行号</td>
</tr>
<tr>
<td><code>-v</code></td>
<td>反选，输出不匹配行的内容</td>
</tr>
<tr>
<td><code>-r</code></td>
<td>递归匹配查找</td>
</tr>
<tr>
<td><code>-A n</code></td>
<td>n 为正整数，表示 after 的意思，除了列出匹配行之外，还列出后面的 n 行</td>
</tr>
<tr>
<td><code>-B n</code></td>
<td>n 为正整数，表示 before 的意思，除了列出匹配行之外，还列出前面的 n 行</td>
</tr>
<tr>
<td><code>--color=auto</code></td>
<td>将输出中的匹配项设置为自动颜色显示</td>
</tr>
</tbody></table>
<blockquote>
<p>注：在大多数发行版中是默认设置了 grep 的颜色的，你可以通过参数指定或修改<code>GREP_COLOR</code>环境变量。</p>
</blockquote>
<h3 id="基本正则表达式的使用-BRE"><a href="#基本正则表达式的使用-BRE" class="headerlink" title="基本正则表达式的使用 (BRE)"></a>基本正则表达式的使用 (BRE)</h3><h4 id="查找位置"><a href="#查找位置" class="headerlink" title="查找位置"></a>查找位置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [查找内容] [查找目标、路径]</span><br></pre></td></tr></table></figure>

<h4 id="查找数量"><a href="#查找数量" class="headerlink" title="查找数量"></a>查找数量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将匹配以&#x27;z&#x27;开头以&#x27;o&#x27;结尾的所有字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;zero\nzo\nzoo&#x27;</span> | grep <span class="string">&#x27;z.*o&#x27;</span></span><br><span class="line"><span class="comment"># 将匹配以&#x27;z&#x27;开头以&#x27;o&#x27;结尾，中间包含一个任意字符的字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;zero\nzo\nzoo&#x27;</span> | grep <span class="string">&#x27;z.o&#x27;</span></span><br><span class="line"><span class="comment"># 将匹配以&#x27;z&#x27;开头，以任意多个&#x27;o&#x27;结尾的字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;zero\nzo\nzoo&#x27;</span> | grep <span class="string">&#x27;zo*&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注意：其中 <code>\n</code> 为换行符</p>
<h3 id="进行选择"><a href="#进行选择" class="headerlink" title="进行选择"></a>进行选择</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep默认是区分大小写的，这里将匹配所有的小写字母</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | grep <span class="string">&#x27;[a-z]&#x27;</span></span><br><span class="line"><span class="comment"># 将匹配所有的数字</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | grep <span class="string">&#x27;[0-9]&#x27;</span></span><br><span class="line"><span class="comment"># 将匹配所有的数字</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | grep <span class="string">&#x27;[[:digit:]]&#x27;</span></span><br><span class="line"><span class="comment"># 将匹配所有的小写字母</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | grep <span class="string">&#x27;[[:lower:]]&#x27;</span></span><br><span class="line"><span class="comment"># 将匹配所有的大写字母</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | grep <span class="string">&#x27;[[:upper:]]&#x27;</span></span><br><span class="line"><span class="comment"># 将匹配所有的字母和数字，包括0-9，a-z，A-Z</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | grep <span class="string">&#x27;[[:alnum:]]&#x27;</span></span><br><span class="line"><span class="comment"># 将匹配所有的字母</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | grep <span class="string">&#x27;[[:alpha:]]&#x27;</span></span><br></pre></td></tr></table></figure>

<p>下面包含完整的特殊符号及说明：</p>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>[:alnum:]</code></td>
<td>代表英文大小写字母及数字，亦即 0-9，A-Z，a-z</td>
</tr>
<tr>
<td><code>[:alpha:]</code></td>
<td>代表任何英文大小写字母，亦即 A-Z，a-z</td>
</tr>
<tr>
<td><code>[:blank:]</code></td>
<td>代表空白键与 <code>[Tab]</code> 按键两者</td>
</tr>
<tr>
<td><code>[:cntrl:]</code></td>
<td>代表键盘上面的控制按键，亦即包括 CR，LF，Tab，Del…</td>
</tr>
<tr>
<td><code>[:digit:]</code></td>
<td>代表数字而已，亦即 0-9</td>
</tr>
<tr>
<td><code>[:graph:]</code></td>
<td>除了空白字节（空白键与 [Tab] 按键）外的其他所有按键</td>
</tr>
<tr>
<td><code>[:lower:]</code></td>
<td>代表小写字母，亦即 a-z</td>
</tr>
<tr>
<td><code>[:print:]</code></td>
<td>代表任何可以被列印出来的字符</td>
</tr>
<tr>
<td><code>[:punct:]</code></td>
<td>代表标点符号（punctuation symbol），即：<code>&quot;</code>，<code>&#39;</code>，<code>?</code>，<code>!</code>，<code>;</code>，<code>:</code>，<code>#</code>，<code>$</code>…</td>
</tr>
<tr>
<td><code>[:upper:]</code></td>
<td>代表大写字母，亦即 A-Z</td>
</tr>
<tr>
<td><code>[:space:]</code></td>
<td>任何会产生空白的字符，包括空格键，<code>[Tab]</code>，CR 等等</td>
</tr>
<tr>
<td><code>[:xdigit:]</code></td>
<td>代表 16 进位的数字类型，因此包括： 0-9，A-F，a-f 的数字与字节</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意</strong>：之所以要使用特殊符号，是因为上面的 <code>[a-z]</code> 不是在所有情况下都管用，这还与主机当前的语系有关，即设置在 <code>LANG</code> 环境变量的值，<code>zh_CN.UTF-8</code> 的话 <code>[a-z]</code>，即为所有小写字母，其它语系可能是大小写交替的如，”a A b B…z Z”，<code>[a-z]</code> 中就可能包含大写字母。所以在使用 <code>[a-z]</code> 时请确保当前语系的影响，使用 <code>[:lower:]</code> 则不会有这个问题。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 排除字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;geek\ngood&#x27;</span> | grep <span class="string">&#x27;[^o]&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当 <code>^</code> 放到中括号内为排除字符，否则表示行首。</p>
</blockquote>
<h3 id="扩展正则表达式的使用-ERE"><a href="#扩展正则表达式的使用-ERE" class="headerlink" title="扩展正则表达式的使用 (ERE)"></a>扩展正则表达式的使用 (ERE)</h3><p>要通过 <code>grep</code> 使用扩展正则表达式需要加上 <code>-E</code> 参数，或使用 <code>egrep</code>。</p>
<ul>
<li>数量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只匹配&quot;zo&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;zero\nzo\nzoo&#x27;</span> | grep -E <span class="string">&#x27;zo&#123;1&#125;&#x27;</span></span><br><span class="line"><span class="comment"># 匹配以&quot;zo&quot;开头的所有单词</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;zero\nzo\nzoo&#x27;</span> | grep -E <span class="string">&#x27;zo&#123;1,&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>推荐掌握 <code>&#123;n,m&#125;</code> 即可 <code>+</code>，<code>?</code>，<code>*</code> 这几个不太直观，且容易弄混淆。</p>
</blockquote>
<ul>
<li>选择</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配&quot;www.shiyanlou.com&quot;和&quot;www.google.com&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;www.shiyanlou.com\nwww.baidu.com\nwww.google.com&#x27;</span> | grep -E <span class="string">&#x27;www\.(shiyanlou|google)\.com&#x27;</span></span><br><span class="line"><span class="comment"># 或者匹配不包含&quot;baidu&quot;的内容</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;www.shiyanlou.com\nwww.baidu.com\nwww.google.com&#x27;</span> | grep -Ev <span class="string">&#x27;www\.baidu\.com&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为 <code>.</code> 号有特殊含义，所以需要转义。</p>
</blockquote>
<h2 id="sed-编辑器"><a href="#sed-编辑器" class="headerlink" title="sed 编辑器"></a>sed 编辑器</h2><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><p>sed 命令基本格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed [参数]... [执行命令] [输入文件]...</span><br><span class="line"><span class="comment"># 形如：</span></span><br><span class="line">$ sed -i <span class="string">&#x27;s/sad/happy/&#x27;</span> <span class="built_in">test</span> <span class="comment"># 表示将test文件中的&quot;sad&quot;替换为&quot;happy&quot;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-n</code></td>
<td>安静模式，只打印受影响的行，默认打印输入数据的全部内容</td>
</tr>
<tr>
<td><code>-e</code></td>
<td>用于在脚本中添加多个执行命令一次执行，在命令行中执行多个命令通常不需要加该参数</td>
</tr>
<tr>
<td><code>-f filename</code></td>
<td>指定执行 filename 文件中的命令</td>
</tr>
<tr>
<td><code>-r</code></td>
<td>使用扩展正则表达式，默认为标准正则表达式</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>将直接修改输入文件内容，而不是打印到标准输出设备</td>
</tr>
</tbody></table>
<h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>sed 执行命令格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[n1][,n2]<span class="built_in">command</span></span><br><span class="line">[n1][~step]<span class="built_in">command</span></span><br></pre></td></tr></table></figure>

<p>其中一些命令可以在后面加上作用范围，形如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/sad/happy/g&#x27;</span> <span class="built_in">test</span> <span class="comment"># g 表示全局范围</span></span><br><span class="line">sed -i <span class="string">&#x27;s/sad/happy/4&#x27;</span> <span class="built_in">test</span> <span class="comment"># 4 表示指定行中的第四个匹配字符串</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>n1,n2</code> 表示输入内容的行号，它们之间为 <code>,</code> 逗号则表示从 n1 到 n2 行，如果为 <code>~</code> 波浪号则表示从 n1 开始以 step 为步进的所有行；command 为执行动作，下面为一些常用动作指令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>s</code></td>
<td>行内替换</td>
</tr>
<tr>
<td><code>c</code></td>
<td>整行替换</td>
</tr>
<tr>
<td><code>a</code></td>
<td>插入到指定行的后面</td>
</tr>
<tr>
<td><code>i</code></td>
<td>插入到指定行的前面</td>
</tr>
<tr>
<td><code>p</code></td>
<td>打印指定行，通常与 <code>-n</code> 参数配合使用</td>
</tr>
<tr>
<td><code>d</code></td>
<td>删除指定行</td>
</tr>
</tbody></table>
<h3 id="操作举例-4"><a href="#操作举例-4" class="headerlink" title="操作举例"></a>操作举例</h3><h4 id="打印指定行"><a href="#打印指定行" class="headerlink" title="打印指定行"></a>打印指定行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印2-5行</span></span><br><span class="line">nl passwd | sed -n <span class="string">&#x27;2,5p&#x27;</span></span><br><span class="line"><span class="comment"># 打印奇数行</span></span><br><span class="line">nl passwd | sed -n <span class="string">&#x27;1~2p&#x27;</span></span><br><span class="line"><span class="comment">#&#x27;1~2p&#x27;表示从第一行开始,每次往下读取两行</span></span><br></pre></td></tr></table></figure>

<h4 id="行内替换"><a href="#行内替换" class="headerlink" title="行内替换"></a>行内替换</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将输入文本中&quot;shiyanlou&quot; 全局替换为&quot;hehe&quot;，并只打印替换的那一行，注意这里不能省略最后的&quot;p&quot;命令</span></span><br><span class="line">sed -n <span class="string">&#x27;s/shiyanlou/hehe/gp&#x27;</span> passwd</span><br></pre></td></tr></table></figure>

<blockquote>
<p>行内替换可以结合正则表达式使用。</p>
</blockquote>
<h4 id="删除某行"><a href="#删除某行" class="headerlink" title="删除某行"></a>删除某行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nl passwd | grep <span class="string">&quot;shiyanlou&quot;</span></span><br><span class="line"><span class="comment"># 删除第30行</span></span><br><span class="line">sed -i <span class="string">&#x27;30d&#x27;</span> passwd</span><br></pre></td></tr></table></figure>

<p>更多 sed 的高级用法，你可以参看如下链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://coolshell.cn/articles/9104.html">sed 简明教程</a></li>
<li><a target="_blank" rel="noopener" href="http://sed.sourceforge.net/sed1line_zh-CN.html">sed 单行脚本快速参考</a></li>
<li><a target="_blank" rel="noopener" href="http://www.gnu.org/software/sed/manual/sed.html">sed 完全手册</a></li>
</ul>
<h2 id="awk-文本处理语言"><a href="#awk-文本处理语言" class="headerlink" title="awk 文本处理语言"></a>awk 文本处理语言</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>awk 所有的操作都是基于 pattern(模式)—action(动作)对来完成的，如下面的形式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern &#123;action&#125;</span><br></pre></td></tr></table></figure>

<p>你可以看到就如同很多编程语言一样，它将所有的动作操作用一对 <code>&#123;&#125;</code> 花括号包围起来。其中 pattern 通常是表示用于匹配输入的文本的“关系式”或“正则表达式”，action 则是表示匹配后将执行的动作。在一个完整 awk 操作中，这两者可以只有其中一个，如果没有 pattern 则默认匹配输入的全部文本，如果没有 action 则默认为打印匹配内容到屏幕。</p>
<p><code>awk</code> 处理文本的方式，是将文本分割成一些“字段”，然后再对这些字段进行处理，默认情况下，awk 以空格作为一个字段的分割符，不过这不是固定的，你可以任意指定分隔符。</p>
<h3 id="基本命令格式"><a href="#基本命令格式" class="headerlink" title="基本命令格式"></a>基本命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk [-F fs] [-v var=value] [-f prog-file | <span class="string">&#x27;program text&#x27;</span>] [file...]</span><br></pre></td></tr></table></figure>

<p>其中 <code>-F</code> 参数用于预先指定前面提到的字段分隔符（还有其他指定字段的方式），<code>-v</code> 用于预先为 <code>awk</code> 程序指定变量，<code>-f</code> 参数用于指定 <code>awk</code> 命令要执行的程序文件，或者在不加 <code>-f</code> 参数的情况下直接将程序语句放在这里，最后为 <code>awk</code> 需要处理的文本输入，且可以同时输入多个文本文件。</p>
<h3 id="文本输出"><a href="#文本输出" class="headerlink" title="文本输出"></a>文本输出</h3><p>使用 awk 将文本内容打印到终端：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &quot;quote&gt;&quot; 不用输入</span></span><br><span class="line">awk <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">quote&gt; print</span></span><br><span class="line"><span class="string">quote&gt; &#125;&#x27;</span> <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 或者写到一行</span></span><br><span class="line">awk <span class="string">&#x27;&#123;print&#125;&#x27;</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>在这个操作中是省略了 <code>pattern</code>，所以 <code>awk</code> 会默认匹配输入文本的全部内容，然后在 <code>&#123;&#125;</code> 花括号中执行动作，即 <code>print</code> 打印所有匹配项，这里是全部文本内容。</p>
<h3 id="字段替换"><a href="#字段替换" class="headerlink" title="字段替换"></a>字段替换</h3><ul>
<li>将第一行的每个字段单独显示为一行：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">&gt; if(NR==1)&#123;</span></span><br><span class="line"><span class="string">&gt; print $1 &quot;\n&quot; $2 &quot;\n&quot; $3</span></span><br><span class="line"><span class="string">&gt; &#125; else &#123;</span></span><br><span class="line"><span class="string">&gt; print&#125;</span></span><br><span class="line"><span class="string">&gt; &#125;&#x27;</span> <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ awk <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">&gt; if(NR==1)&#123;</span></span><br><span class="line"><span class="string">&gt; OFS=&quot;\n&quot;</span></span><br><span class="line"><span class="string">&gt; print $1, $2, $3</span></span><br><span class="line"><span class="string">&gt; &#125; else &#123;</span></span><br><span class="line"><span class="string">&gt; print&#125;</span></span><br><span class="line"><span class="string">&gt; &#125;&#x27;</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>说明:你首先应该注意的是，这里我使用了 <code>awk</code> 语言的分支选择语句<code>if</code>，它的使用和很多高级语言如 <code>C/C++</code> 语言基本一致，如果你有这些语言的基础，这里将很好理解。另一个你需要注意的是 <code>NR</code> 与 <code>OFS</code>，这两个是 <code>awk</code> 内建的变量，<code>NR</code> 表示当前读入的记录数，你可以简单的理解为当前处理的行数，<code>OFS</code> 表示输出时的字段分隔符，默认为” “空格，如上图所见，我们将字段分隔符设置为 <code>\n</code> 换行符，所以第一行原本以空格为字段分隔的内容就分别输出到单独一行了。然后是 <code>$N</code> 其中 N 为相应的字段号，这也是 <code>awk</code> 的内建变量，它表示引用相应的字段，因为我们这里第一行只有三个字段，所以只引用到了 <code>$3</code>。除此之外另一个这里没有出现的 <code>$0</code>，它表示引用当前记录（当前行）的全部内容。</p>
<ul>
<li>将第二行的以点为分段的字段换成以空格为分隔：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">awk -F<span class="string">&#x27;.&#x27;</span> <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">&gt; if(NR==2)&#123;</span></span><br><span class="line"><span class="string">&gt; print $1 &quot;\t&quot; $2 &quot;\t&quot; $3</span></span><br><span class="line"><span class="string">&gt; &#125;&#125;&#x27;</span> <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">awk <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&gt; BEGIN&#123;</span></span><br><span class="line"><span class="string">&gt; FS=&quot;.&quot;</span></span><br><span class="line"><span class="string">&gt; OFS=&quot;\t&quot;  # 如果写为一行，两个动作语句之间应该以&quot;;&quot;号分开</span></span><br><span class="line"><span class="string">&gt; &#125;&#123;</span></span><br><span class="line"><span class="string">&gt; if(NR==2)&#123;</span></span><br><span class="line"><span class="string">&gt; print $1, $2, $3</span></span><br><span class="line"><span class="string">&gt; &#125;&#125;&#x27;</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>说明：这里的 <code>-F</code> 参数，前面已经介绍过，它是用来预先指定待处理记录的字段分隔符。我们需要注意的是除了指定 <code>OFS</code> 我们还可以在 <code>print</code> 语句中直接打印特殊符号如这里的 <code>\t</code>，<strong>print 打印的非变量内容都需要用””一对引号包围起来</strong>。上面另一个版本，展示了实现预先指定变量分隔符的另一种方式，即使用 <code>BEGIN</code>，就这个表达式指示了，其后的动作将在所有动作之前执行，这里是 <code>FS</code> 赋值了新的 <code>.</code> 点号代替默认的空格。</p>
<p><strong>注意</strong>:首先说明一点，我们在学习和使用 awk 的时候应该尽可能将其作为一门程序语言来理解，这样将会使你学习起来更容易，所以初学阶段在练习 <code>awk</code> 时应该尽量按照我那样的方式分多行按照一般程序语言的换行和缩进来输入，而不是全部写到一行（当然这在你熟练了之后是没有任何问题的）。</p>
<h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h3><table>
<thead>
<tr>
<th>变量名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>FILENAME</code></td>
<td>当前输入文件名，若有多个文件，则只表示第一个。如果输入是来自标准输入，则为空字符串</td>
</tr>
<tr>
<td><code>$0</code></td>
<td>当前记录的内容</td>
</tr>
<tr>
<td><code>$N</code></td>
<td>N 表示字段号，最大值为<code>NF</code>变量的值</td>
</tr>
<tr>
<td><code>FS</code></td>
<td>字段分隔符，由正则表达式表示，默认为空格</td>
</tr>
<tr>
<td><code>RS</code></td>
<td>输入记录分隔符，默认为 <code>\n</code>，即一行为一个记录</td>
</tr>
<tr>
<td><code>NF</code></td>
<td>当前记录字段数</td>
</tr>
<tr>
<td><code>NR</code></td>
<td>已经读入的记录数</td>
</tr>
<tr>
<td><code>FNR</code></td>
<td>当前输入文件的记录数，请注意它与 NR 的区别</td>
</tr>
<tr>
<td><code>OFS</code></td>
<td>输出字段分隔符，默认为空格</td>
</tr>
<tr>
<td><code>ORS</code></td>
<td>输出记录分隔符，默认为 <code>\n</code></td>
</tr>
</tbody></table>
<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><h3 id="apt-包管理介绍"><a href="#apt-包管理介绍" class="headerlink" title="apt 包管理介绍"></a>apt 包管理介绍</h3><p>当你在执行安装操作时，首先 <code>apt-get</code> 工具会在<strong>本地</strong>的一个数据库中搜索关于 <code>xxx</code> 软件的相关信息，并根据这些信息在相关的服务器上下载软件安装，这里大家可能会一个疑问：既然是在线安装软件，为啥会在本地的数据库中搜索？要解释这个问题就得提到几个名词了：</p>
<ul>
<li><strong>软件源镜像服务器</strong></li>
<li><strong>软件源</strong></li>
</ul>
<p>我们需要定期从服务器上下载一个软件包列表，使用 <code>sudo apt-get update</code> 命令来保持本地的软件包列表是最新的（有时你也需要手动执行这个操作，比如更换了软件源），而这个表里会有<strong>软件依赖</strong>信息的记录，对于软件依赖，我举个例子：我们安装 <code>xxx</code> 软件的时候，而这个软件需要 <code>libgc1c2</code> 这个软件包才能正常工作，这个时候 <code>apt-get</code> 在安装软件的时候会一并替我们安装了，以保证 <code>xxx</code> 能正常的工作。</p>
<h3 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h3><p><code>apt-get</code> 是用于处理 <code>apt</code>包的公用程序集，我们可以用它来在线安装、卸载和升级软件包等，下面列出一些 <code>apt-get</code> 包含的常用的一些工具：</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>install</code></td>
<td>其后加上软件包名，用于安装一个软件包</td>
</tr>
<tr>
<td><code>update</code></td>
<td>从软件源镜像服务器上下载/更新用于更新本地软件源的软件包列表</td>
</tr>
<tr>
<td><code>upgrade</code></td>
<td>升级本地可更新的全部软件包，但存在依赖问题时将不会升级，通常会在更新之前执行一次 <code>update</code></td>
</tr>
<tr>
<td><code>dist-upgrade</code></td>
<td>解决依赖关系并升级（存在一定危险性）</td>
</tr>
<tr>
<td><code>remove</code></td>
<td>移除已安装的软件包，包括与被移除软件包有依赖关系的软件包，但不包含软件包的配置文件</td>
</tr>
<tr>
<td><code>autoremove</code></td>
<td>移除之前被其他软件包依赖，但现在不再被使用的软件包</td>
</tr>
<tr>
<td><code>purge</code></td>
<td>与 remove 相同，但会完全移除软件包，包含其配置文件</td>
</tr>
<tr>
<td><code>clean</code></td>
<td>移除下载到本地的已经安装的软件包，默认保存在 <code>/var/cache/apt/archives/</code></td>
</tr>
<tr>
<td><code>autoclean</code></td>
<td>移除已安装的软件的旧版本软件包</td>
</tr>
</tbody></table>
<p>下面是一些<code>apt-get</code>常用的参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-y</code></td>
<td>自动回应是否安装软件包的选项，在一些自动化安装脚本中使用这个参数将十分有用</td>
</tr>
<tr>
<td><code>-s</code></td>
<td>模拟安装</td>
</tr>
<tr>
<td><code>-q</code></td>
<td>静默安装方式，指定多个 <code>q</code> 或者 <code>-q=#</code>，<code>#</code> 表示数字，用于设定静默级别，这在你不想要在安装软件包时屏幕输出过多时很有用</td>
</tr>
<tr>
<td><code>-f</code></td>
<td>修复损坏的依赖关系</td>
</tr>
<tr>
<td><code>-d</code></td>
<td>只下载不安装</td>
</tr>
<tr>
<td><code>--reinstall</code></td>
<td>重新安装已经安装但可能存在问题的软件包</td>
</tr>
<tr>
<td><code>--install-suggests</code></td>
<td>同时安装 APT 给出的建议安装的软件包</td>
</tr>
</tbody></table>
<h3 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h3><p>关于安装，如前面演示的一样你只需要执行 <code>apt-get install &lt;packagename&gt;</code> 即可，除了这一点，你还应该掌握的是如何重新安装软件包。</p>
<p>很多时候我们需要重新安装一个软件包，比如你的系统被破坏，或者一些错误的配置导致软件无法正常工作。你可以使用如下方式重新安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get --reinstall install &lt;packagename&gt;</span><br></pre></td></tr></table></figure>

<p>在不知道软件包完整名的时候进行安装，通常我们使用 <code>Tab</code> 键补全软件包名。同时也可以利用正则表达式匹配软件包名进行批量安装。</p>
<h3 id="软件升级"><a href="#软件升级" class="headerlink" title="软件升级"></a>软件升级</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新软件源</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级没有依赖问题的软件包</span></span><br><span class="line">sudo apt-get upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级并解决依赖关系</span></span><br><span class="line">sudo apt-get dist-upgrade</span><br></pre></td></tr></table></figure>

<h3 id="软件卸载"><a href="#软件卸载" class="headerlink" title="软件卸载"></a>软件卸载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove [软件包名]</span><br></pre></td></tr></table></figure>

<p>或者，你可以执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不保留配置文件的移除</span></span><br><span class="line">sudo apt-get purge [软件包名]</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">sudo apt-get --purge remove [软件包名]</span><br><span class="line"><span class="comment"># 移除不再需要的被依赖的软件包</span></span><br><span class="line">sudo apt-get autoremove</span><br></pre></td></tr></table></figure>

<h3 id="软件搜索"><a href="#软件搜索" class="headerlink" title="软件搜索"></a>软件搜索</h3><p>当自己刚知道了一个软件，想下载使用，需要确认软件仓库里面有没有，就需要用到搜索功能了，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-cache search softname1 softname2 softname3……</span><br></pre></td></tr></table></figure>

<p><code>apt-cache</code> 命令则是针对本地数据进行相关操作的工具，<code>search</code> 顾名思义在本地的数据库中寻找有关 <code>softname1</code>，<code>softname2</code> 相关软件的信息。</p>
<h2 id="dpkg-使用"><a href="#dpkg-使用" class="headerlink" title="dpkg 使用"></a>dpkg 使用</h2><h3 id="dpkg-介绍"><a href="#dpkg-介绍" class="headerlink" title="dpkg 介绍"></a>dpkg 介绍</h3><p>在网络上见到以<code>deb</code>形式打包的软件包，就需要使用<code>dpkg</code>命令来安装。</p>
<p><code>dpkg</code>常用参数介绍：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-i</code></td>
<td>安装指定 deb 包</td>
</tr>
<tr>
<td><code>-R</code></td>
<td>后面加上目录名，用于安装该目录下的所有 deb 安装包</td>
</tr>
<tr>
<td><code>-r</code></td>
<td>remove，移除某个已安装的软件包</td>
</tr>
<tr>
<td><code>-I</code></td>
<td>显示 <code>deb</code> 包文件的信息</td>
</tr>
<tr>
<td><code>-s</code></td>
<td>显示已安装软件的信息</td>
</tr>
<tr>
<td><code>-S</code></td>
<td>搜索已安装的软件包</td>
</tr>
<tr>
<td><code>-L</code></td>
<td>显示已安装软件包的目录信息</td>
</tr>
</tbody></table>
<h3 id="软件安装-1"><a href="#软件安装-1" class="headerlink" title="软件安装"></a>软件安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用dpkg安装</span></span><br><span class="line">sudo dpkg -I xxx.deb</span><br></pre></td></tr></table></figure>

<p>如果这个包还额外依赖了一些软件包，这意味着，如果主机目前没有这些被依赖的软件包，直接使用 dpkg 安装可能会存在一些问题，因为<code>dpkg</code>并不能为你解决依赖关系。</p>
<p>我们将如何解决这个错误呢？这就要用到<code>apt-get</code>了，使用它的<code>-f</code>参数了，修复依赖关系的安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -f install -y</span><br></pre></td></tr></table></figure>

<h3 id="查看已安装软件包的安装目录"><a href="#查看已安装软件包的安装目录" class="headerlink" title="查看已安装软件包的安装目录"></a>查看已安装软件包的安装目录</h3><p>如果你在纠结到底 linux 将软件安装到了什么地方，那么很幸运你将可以通过<code>dpkg</code>找到答案</p>
<p>使用<code>dpkg -L</code>查看<code>deb</code>包目录信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -L emacs24</span><br></pre></td></tr></table></figure>

<h2 id="二进制文件安装"><a href="#二进制文件安装" class="headerlink" title="二进制文件安装"></a>二进制文件安装</h2><p>对应文件下载下来后将对应的二进制包解压到合适目录，之后将包含可执行的主程序文件的目录添加进<code>PATH</code>环境变量即可。</p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>并且每个终端或者说 bash 只能管理当前终端中的 job，不能管理其他终端中的 job。比如我当前存在两个 bash 分别为 bash1、bash2，bash1 只能管理其自己里面的 job 并不能管理 bash2 里面的 job</p>
<p>我们都知道当一个进程在前台运作时我们可以用 <code>ctrl + c</code> 来终止它，但是若是在后台的话就不行了。</p>
<p>我们可以通过 <code>&amp;</code> 这个符号，让我们的命令在后台中运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &amp;</span><br></pre></td></tr></table></figure>

<img src="https://dn-simplecloud.shiyanlou.com/1135081469036077882" alt="实验楼" style="zoom:50%;" />

<p>图中所显示的 <code>[1] 236</code>分别是该 job 的 job number 与该进程的 PID，而最后一行的 Done 表示该命令已经在后台执行完毕。</p>
<p>我们还可以通过 <code>ctrl + z</code> 使我们的当前工作停止并丢到后台中去</p>
<img src="https://dn-simplecloud.shiyanlou.com/1135081469036715105" alt="实验楼" style="zoom:50%;" />

<p>被停止并放置在后台的工作我们可以使用这个命令来查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">jobs</span></span><br></pre></td></tr></table></figure>

<img src="https://dn-simplecloud.shiyanlou.com/1135081469037134869" alt="实验楼" style="zoom:50%;" />

<p>其中第一列显示的为被放置后台 job 的编号，而第二列的 <code>＋</code> 表示最近(刚刚、最后)被放置后台的 job，同时也表示预设的工作，也就是若是有什么针对后台 job 的操作，首先对预设的 job，<code>-</code> 表示倒数第二（也就是在预设之前的一个）被放置后台的工作，倒数第三个（再之前的）以后都不会有这样的符号修饰，第三列表示它们的状态，而最后一列表示该进程执行的命令。</p>
<p>我们可以通过这样的一个命令将后台的工作拿到前台来：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 后面不加参数提取预设工作，加参数提取指定工作的编号</span></span><br><span class="line"><span class="comment"># ubuntu 在 zsh 中需要 %，在 bash 中不需要 %</span></span><br><span class="line"><span class="built_in">fg</span> [%jobnumber]</span><br></pre></td></tr></table></figure>

<img src="https://dn-simplecloud.shiyanlou.com/1135081469037555070" alt="实验楼" style="zoom:50%;" />

<img src="https://dn-simplecloud.shiyanlou.com/1135081469037666320" alt="实验楼" style="zoom:50%;" />

<p>之前我们通过 <code>ctrl + z</code> 使得工作停止放置在后台，若是我们想让其在后台运作我们就使用这样一个命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#与fg类似，加参则指定，不加参则取预设</span></span><br><span class="line"><span class="built_in">bg</span> [%jobnumber]</span><br></pre></td></tr></table></figure>

<img src="https://dn-simplecloud.shiyanlou.com/1135081469037983282" alt="实验楼" style="zoom:50%;" />

<p>既然有方法将被放置在后台的工作提至前台或者让它从停止变成继续运行在后台，当然也有方法删除一个工作，或者重启等等。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kill的使用格式如下</span></span><br><span class="line"><span class="built_in">kill</span> -signal %jobnumber</span><br><span class="line"></span><br><span class="line"><span class="comment"># signal从1-64个信号值可以选择，可以这样查看</span></span><br><span class="line"><span class="built_in">kill</span> －l</span><br></pre></td></tr></table></figure>

<p>其中常用的有这些信号值</p>
<table>
<thead>
<tr>
<th>信号值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-1</td>
<td>重新读取参数运行，类似与 restart</td>
</tr>
<tr>
<td>-2</td>
<td>如同 ctrl+c 的操作退出</td>
</tr>
<tr>
<td>-9</td>
<td>强制终止该任务</td>
</tr>
<tr>
<td>-15</td>
<td>正常的方式终止该任务</td>
</tr>
</tbody></table>
<img src="https://dn-simplecloud.shiyanlou.com/1135081469038840624" alt="实验楼" style="zoom:50%;" />

<blockquote>
<p>若是在使用 kill ＋信号值然后直接加 pid，你将会对 pid 对应的进程进行操作。<br>若是在使用 kill+信号值然后 <code>％jobnumber</code>，这时所操作的对象是 job，这个数字就是就当前 bash 中后台的运行的 job 的 ID。</p>
</blockquote>
<h3 id="进程的查看"><a href="#进程的查看" class="headerlink" title="进程的查看"></a>进程的查看</h3><p>Linux下可以使用<code>top</code>来实时的查看进程状态，以及一些系统信息，于此也可以通过<code>ps</code>静态查看当前的进程信息，同时我们还可以使用 <code>pstree</code> 来查看当前活跃进程的树形结构。</p>
<p>top 是一个在前台执行的程序，所以执行后便进入到这样的一个交互界面，正是因为交互界面我们才可以实时的获取到系统与进程的信息。在交互界面中我们可以通过一些指令来操作和筛选。在此之前我们先来了解显示了哪些信息。</p>
<p>我们看到 top 显示的第一排，</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>top</td>
<td>表示当前程序的名称</td>
</tr>
<tr>
<td>11:05:18</td>
<td>表示当前的系统的时间</td>
</tr>
<tr>
<td>up 8 days,17:12</td>
<td>表示该机器已经启动了多长时间</td>
</tr>
<tr>
<td>1 user</td>
<td>表示当前系统中只有一个用户</td>
</tr>
<tr>
<td>load average: 0.29,0.20,0.25</td>
<td>分别对应 1、5、15 分钟内 cpu 的平均负载</td>
</tr>
</tbody></table>
<p>load average 在 wikipedia 中的解释是 the system load is a measure of the amount of work that a computer system is doing 也就是对当前 CPU 工作量的度量，具体来说也就是指运行队列的平均长度，也就是等待 CPU 的平均进程数相关的一个计算值。</p>
<p>我们该如何看待这个 load average 数据呢？</p>
<p>假设我们的系统是单 CPU、单内核的，把它比喻成是一条单向的桥，把 CPU 任务比作汽车。</p>
<ul>
<li>load = 0 的时候意味着这个桥上并没有车，cpu 没有任何任务；</li>
<li>load &lt; 1 的时候意味着桥上的车并不多，一切都还是很流畅的，cpu 的任务并不多，资源还很充足；</li>
<li>load = 1 的时候就意味着桥已经被车给占满了，没有一点空隙，cpu 已经在全力工作了，所有的资源都被用完了，当然还好，这还在能力范围之内，只是有点慢而已；</li>
<li>load &gt; 1 的时候就意味着不仅仅是桥上已经被车占满了，就连桥外都被占满了，cpu 已经在全力工作，系统资源的用完了，但是还是有大量的进程在请求，在等待。若是这个值大于 2 表示进程请求超过 CPU 工作能力的 2 倍。而若是这个值大于 5 说明系统已经在超负荷运作了。</li>
</ul>
<p>这是单个 CPU 单核的情况，而实际生活中我们需要将得到的这个值除以我们的核数来看。我们可以通过以下的命令来查看 CPU 的个数与核心数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看物理 CPU 的个数</span></span><br><span class="line">cat /proc/cpuinfo | grep <span class="string">&quot;physical id&quot;</span> | sort | uniq |wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment">#每个 cpu 的核心数</span></span><br><span class="line">cat /proc/cpuinfo | grep <span class="string">&quot;physical id&quot;</span> | grep <span class="string">&quot;0&quot;</span> | wc -l</span><br></pre></td></tr></table></figure>

<p>通过上面的指数我们可以得知 load 的临界值为 1 ，但是在实际生活中，比较有经验的运维或者系统管理员会将临界值定为 0.7。这里的指数都是除以核心数以后的值，不要混淆了</p>
<ul>
<li>若是 load &lt; 0.7 并不会去关注他；</li>
<li>若是 0.7&lt; load &lt; 1 的时候我们就需要稍微关注一下了，虽然还可以应付但是这个值已经离临界不远了；</li>
<li>若是 load = 1 的时候我们就需要警惕了，因为这个时候已经没有更多的资源的了，已经在全力以赴了；</li>
<li>若是 load &gt; 5 的时候系统已经快不行了，这个时候你需要加班解决问题了</li>
</ul>
<p>通常我们都会先看 15 分钟的值来看这个大体的趋势，然后再看 5 分钟的值对比来看是否有下降的趋势。</p>
<p>查看 busybox 的代码可以知道，数据是每 5 秒钟就检查一次活跃的进程数，然后计算出该值，然后 load 从 <code>/proc/loadavg</code> 中读取的。而这个 load 的值是如何计算的呢，这是 load 的计算的源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSHIFT      11          <span class="comment">/* nr of bits of precision */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIXED_1     (1&lt;&lt;FSHIFT) <span class="comment">/* 1.0 as fixed-point(定点) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOAD_FREQ   (5*HZ)      <span class="comment">/* 5 sec intervals，每隔5秒计算一次平均负载值 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALC_LOAD(load, exp, n)     \</span></span><br><span class="line"><span class="meta">         load *= exp;               \</span></span><br><span class="line"><span class="meta">         load += n*(FIXED_1 - exp); \</span></span><br><span class="line"><span class="meta">         load &gt;&gt;= FSHIFT;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> avenrun[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(avenrun);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* calc_load - given tick count, update the avenrun load estimates.</span></span><br><span class="line"><span class="comment">* This is called while holding a write_lock on xtime_lock.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc_load</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> ticks)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> active_tasks; <span class="comment">/* fixed-point */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> count = LOAD_FREQ;</span><br><span class="line">        count -= ticks;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                count += LOAD_FREQ;</span><br><span class="line">                active_tasks = count_active_tasks();</span><br><span class="line">                CALC_LOAD(avenrun[<span class="number">0</span>], EXP_1, active_tasks);</span><br><span class="line">                CALC_LOAD(avenrun[<span class="number">1</span>], EXP_5, active_tasks);</span><br><span class="line">                CALC_LOAD(avenrun[<span class="number">2</span>], EXP_15, active_tasks);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有兴趣的朋友可以研究一下，是如何计算的。代码中的后面这部分相当于它的计算公式。</p>
</blockquote>
<p>我们回归正题，来看 top 的第二行数据，基本上第二行是进程的一个情况统计：</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Tasks: 26 total</td>
<td>进程总数</td>
</tr>
<tr>
<td>1 running</td>
<td>1 个正在运行的进程数</td>
</tr>
<tr>
<td>25 sleeping</td>
<td>25 个睡眠的进程数</td>
</tr>
<tr>
<td>0 stopped</td>
<td>没有停止的进程数</td>
</tr>
<tr>
<td>0 zombie</td>
<td>没有僵尸进程数</td>
</tr>
</tbody></table>
<p>来看 top 的第三行数据，这一行基本上是 CPU 的一个使用情况的统计了：</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>Cpu(s): 1.0%us</code></td>
<td>用户空间进程占用 CPU 百分比</td>
</tr>
<tr>
<td><code>1.0% sy</code></td>
<td>内核空间运行占用 CPU 百分比</td>
</tr>
<tr>
<td><code>0.0%ni</code></td>
<td>用户进程空间内改变过优先级的进程占用 CPU 百分比</td>
</tr>
<tr>
<td><code>97.9%id</code></td>
<td>空闲 CPU 百分比</td>
</tr>
<tr>
<td><code>0.0%wa</code></td>
<td>等待输入输出的 CPU 时间百分比</td>
</tr>
<tr>
<td><code>0.1%hi</code></td>
<td>硬中断(Hardware IRQ)占用 CPU 的百分比</td>
</tr>
<tr>
<td><code>0.0%si</code></td>
<td>软中断(Software IRQ)占用 CPU 的百分比</td>
</tr>
<tr>
<td><code>0.0%st</code></td>
<td>(Steal time) 是 hypervisor 等虚拟服务中，虚拟 CPU 等待实际 CPU 的时间的百分比</td>
</tr>
</tbody></table>
<p>CPU 利用率是对一个时间段内 CPU 使用状况的统计，通过这个指标可以看出在某一个时间段内 CPU 被占用的情况，而 Load Average 是 CPU 的 Load，它所包含的信息不是 CPU 的使用率状况，而是在一段时间内 CPU 正在处理以及等待 CPU 处理的进程数情况统计信息，这两个指标并不一样。</p>
<p>来看 top 的第四行数据，这一行基本上是内存的一个使用情况的统计了：</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>8176740 total</td>
<td>物理内存总量</td>
</tr>
<tr>
<td>8032104 used</td>
<td>使用的物理内存总量</td>
</tr>
<tr>
<td>144636 free</td>
<td>空闲内存总量</td>
</tr>
<tr>
<td>313088 buffers</td>
<td>用作内核缓存的内存量</td>
</tr>
</tbody></table>
<p><strong>注意：</strong></p>
<blockquote>
<p>系统中可用的物理内存最大值并不是 free 这个单一的值，而是 free + buffers + swap 中的 cached 的和。</p>
</blockquote>
<p>来看 top 的第五行数据，这一行基本上是交换区的一个使用情况的统计了：</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>total</td>
<td>交换区总量</td>
</tr>
<tr>
<td>used</td>
<td>使用的交换区总量</td>
</tr>
<tr>
<td>free</td>
<td>空闲交换区总量</td>
</tr>
<tr>
<td>cached</td>
<td>缓冲的交换区总量，内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖</td>
</tr>
</tbody></table>
<p>再下面就是进程的一个情况了</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>PID</td>
<td>进程 id</td>
</tr>
<tr>
<td>USER</td>
<td>该进程的所属用户</td>
</tr>
<tr>
<td>PR</td>
<td>该进程执行的优先级 priority 值</td>
</tr>
<tr>
<td>NI</td>
<td>该进程的 nice 值</td>
</tr>
<tr>
<td>VIRT</td>
<td>该进程任务所使用的虚拟内存的总数</td>
</tr>
<tr>
<td>RES</td>
<td>该进程所使用的物理内存数，也称之为驻留内存数</td>
</tr>
<tr>
<td>SHR</td>
<td>该进程共享内存的大小</td>
</tr>
<tr>
<td>S</td>
<td>该进程进程的状态: S=sleep R=running Z=zombie</td>
</tr>
<tr>
<td>%CPU</td>
<td>该进程 CPU 的利用率</td>
</tr>
<tr>
<td>%MEM</td>
<td>该进程内存的利用率</td>
</tr>
<tr>
<td>TIME+</td>
<td>该进程活跃的总时间</td>
</tr>
<tr>
<td>COMMAND</td>
<td>该进程运行的名字</td>
</tr>
</tbody></table>
<p><strong>注意:</strong></p>
<p><strong>NICE 值</strong>叫做静态优先级，是用户空间的一个优先级值，其取值范围是 -20 至 19。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。nice 值中的 -20 到 19，中 -20 优先级最高， 0 是默认的值，而 19 优先级最低。</p>
<p><strong>PR 值</strong>表示 Priority 值叫动态优先级，是进程在内核中实际的优先级值，进程优先级的取值范围是通过一个宏定义的，这个宏的名称是 <code>MAX_PRIO</code>，它的值为 140。Linux 实际上实现了 140 个优先级范围，取值范围是从 <code>0-139</code>，这个值越小，优先级越高。而这其中的 <code>0-99</code> 是实时进程的值，而 <code>100-139</code> 是给用户的。</p>
<p>其中 PR 中的 <code>100 to 139</code> 值部分有这么一个对应 <code>PR = 20 + (-20 to +19)</code>，这里的 <code>-20 to +19</code> 便是 nice 值，所以说两个虽然都是优先级，而且有千丝万缕的关系，但是他们的值，他们的作用范围并不相同。</p>
<p><strong>VIRT</strong> 任务所使用的虚拟内存的总数，其中包含所有的代码，数据，共享库和被换出 swap 空间的页面等所占据空间的总数。</p>
<p>在上文我们曾经说过 top 是一个前台程序，所以是一个可以交互的：</p>
<table>
<thead>
<tr>
<th align="center">常用交互命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">q</td>
<td>退出程序</td>
</tr>
<tr>
<td align="center">I</td>
<td>切换显示平均负载和启动时间的信息</td>
</tr>
<tr>
<td align="center">P</td>
<td>根据 CPU 使用百分比大小进行排序</td>
</tr>
<tr>
<td align="center">M</td>
<td>根据驻留内存大小进行排序</td>
</tr>
<tr>
<td align="center">i</td>
<td>忽略闲置和僵死的进程，这是一个开关式命令</td>
</tr>
<tr>
<td align="center">k</td>
<td>终止一个进程，系统提示输入 PID 及发送的信号值。一般终止进程用 15 信号，不能正常结束则使用 9 信号。安全模式下该命令被屏蔽。</td>
</tr>
</tbody></table>
<p>好好的利用 top 能够很有效的帮助我们观察到系统的瓶颈所在，或者是系统的问题所在。</p>
<h3 id="ps的使用"><a href="#ps的使用" class="headerlink" title="ps的使用"></a>ps的使用</h3><p>我们来总体了解下会出现哪些信息给我们，这些信息又代表着什么（更多的 keywords 大家可以通过 <code>man ps</code> 了解）。</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>F</code></td>
<td>进程的标志（process flags），当 flags 值为 1 则表示此子程序只是 fork 但没有执行 exec，为 4 表示此程序使用超级管理员 root 权限</td>
</tr>
<tr>
<td><code>USER</code></td>
<td>进程的拥有用户</td>
</tr>
<tr>
<td><code>PID</code></td>
<td>进程的 ID</td>
</tr>
<tr>
<td><code>PPID</code></td>
<td>其父进程的 PID</td>
</tr>
<tr>
<td><code>SID</code></td>
<td>session 的 ID</td>
</tr>
<tr>
<td><code>TPGID</code></td>
<td>前台进程组的 ID</td>
</tr>
<tr>
<td><code>%CPU</code></td>
<td>进程占用的 CPU 百分比</td>
</tr>
<tr>
<td><code>%MEM</code></td>
<td>占用内存的百分比</td>
</tr>
<tr>
<td><code>NI</code></td>
<td>进程的 NICE 值</td>
</tr>
<tr>
<td><code>VSZ</code></td>
<td>进程使用虚拟内存大小</td>
</tr>
<tr>
<td><code>RSS</code></td>
<td>驻留内存中页的大小</td>
</tr>
<tr>
<td><code>TTY</code></td>
<td>终端 ID</td>
</tr>
<tr>
<td><code>S or STAT</code></td>
<td>进程状态</td>
</tr>
<tr>
<td><code>WCHAN</code></td>
<td>正在等待的进程资源</td>
</tr>
<tr>
<td><code>START</code></td>
<td>启动进程的时间</td>
</tr>
<tr>
<td><code>TIME</code></td>
<td>进程消耗 CPU 的时间</td>
</tr>
<tr>
<td><code>COMMAND</code></td>
<td>命令的名称和参数</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>TPGID</strong>栏写着-1 的都是没有控制终端的进程，也就是守护进程</p>
</blockquote>
<blockquote>
<p><strong>STAT</strong>表示进程的状态，而进程的状态有很多，如下表所示</p>
</blockquote>
<table>
<thead>
<tr>
<th>状态</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>R</code></td>
<td>Running.运行中</td>
</tr>
<tr>
<td><code>S</code></td>
<td>Interruptible Sleep.等待调用</td>
</tr>
<tr>
<td><code>D</code></td>
<td>Uninterruptible Sleep.不可中断睡眠</td>
</tr>
<tr>
<td><code>T</code></td>
<td>Stoped.暂停或者跟踪状态</td>
</tr>
<tr>
<td><code>X</code></td>
<td>Dead.即将被撤销</td>
</tr>
<tr>
<td><code>Z</code></td>
<td>Zombie.僵尸进程</td>
</tr>
<tr>
<td><code>W</code></td>
<td>Paging.内存交换</td>
</tr>
<tr>
<td><code>N</code></td>
<td>优先级低的进程</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>优先级高的进程</td>
</tr>
<tr>
<td><code>s</code></td>
<td>进程的领导者</td>
</tr>
<tr>
<td><code>L</code></td>
<td>锁定状态</td>
</tr>
<tr>
<td><code>l</code></td>
<td>多线程状态</td>
</tr>
<tr>
<td><code>+</code></td>
<td>前台进程</td>
</tr>
</tbody></table>
<blockquote>
<p>其中的 D 是不能被中断睡眠的状态，处在这种状态的进程不接受外来的任何 signal，所以无法使用 kill 命令杀掉处于 D 状态的进程，无论是 <code>kill</code>，<code>kill -9</code> 还是 <code>kill -15</code>，一般处于这种状态可能是进程 I/O 的时候出问题了。</p>
</blockquote>
<p>ps 工具有许多的参数，下面给大家解释部分常用的参数。</p>
<p>使用 <code>-l</code> 参数可以显示自己这次登录的 bash 相关的进程信息罗列出来：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -l</span><br></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469088103140" alt="实验楼"></p>
<p>相对来说我们更加常用下面这个命令，他将会罗列出所有的进程信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux</span><br></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469089342412" alt="实验楼"></p>
<p>若是查找其中的某个进程的话，我们还可以配合着 <code>grep</code> 和正则表达式一起使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep zsh</span><br></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469089837027" alt="实验楼"></p>
<p>此外我们还可以查看时，将连同部分的进程呈树状显示出来：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps axjf</span><br></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469090040956" alt="实验楼"></p>
<p>当然如果你觉得使用这样的此时没有把你想要的信息放在一起，我们也可以是用这样的命令，来自定义我们所需要的参数显示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -afxo user,ppid,pid,pgid,<span class="built_in">command</span></span><br></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469004994601" alt="实验楼"></p>
<p>这是一个简单而又实用的工具，想要更灵活的使用，想要知道更多的参数我们可以使用 man 来获取更多相关的信息。</p>
<h3 id="pstree的使用"><a href="#pstree的使用" class="headerlink" title="pstree的使用"></a>pstree的使用</h3><p>通过 <code>pstree</code> 可以很直接的看到相同的进程数量，最主要的还是我们可以看到所有进程之间的相关性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree</span><br></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469090893467" alt="实验楼"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree -up</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数选择</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>-A</td>
<td>程序树之间以 ASCII 字符连接</td>
</tr>
<tr>
<td>-p</td>
<td>同时列出每个 process 的 PID</td>
</tr>
<tr>
<td>-u</td>
<td>同时列出每个 process 的所属账户名称</td>
</tr>
</tbody></table>
<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469091089249" alt="实验楼"></p>
<h3 id="kill指令的使用"><a href="#kill指令的使用" class="headerlink" title="kill指令的使用"></a>kill指令的使用</h3><p>我们来回顾一下，当一个进程结束的时候或者要异常结束的时候，会向其父进程返回一个或者接收一个 SIGHUP 信号而做出的结束进程或者其他的操作，这个 SIGHUP 信号不仅可以由系统发送，我们可以使用 <code>kill</code> 来发送这个信号来操作进程的结束或者重启等等。</p>
<p>上节课程我们使用 <code>kill</code> 命令来管理我们的一些 job，这节课我们将尝试用 <code>kill</code> 来操作下一些不属于 job 范畴的进程，直接对 pid 下手。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先我们使用图形界面打开了 gedit、gvim，用 ps 可以查看到</span></span><br><span class="line">ps aux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 9 这个信号强制结束 gedit 进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 1608</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们再查找这个进程的时候就找不到了</span></span><br><span class="line">ps aux | grep gedit</span><br></pre></td></tr></table></figure>

<h3 id="进程执行顺序"><a href="#进程执行顺序" class="headerlink" title="进程执行顺序"></a>进程执行顺序</h3><p>我们在使用 ps 命令的时候可以看到大部分的进程都是处于休眠的状态，如果这些进程都被唤醒，那么该谁最先享受 CPU 的服务，后面的进程又该是一个什么样的顺序呢？进程调度的队列又该如何去排列呢？</p>
<p>当然就是靠该进程的优先级值来判定进程调度的优先级，而优先级的值就是上文所提到的 PR 与 nice 来控制与体现了</p>
<p>而 nice 的值我们是可以通过 nice 命令来修改的，而需要注意的是 nice 值可以调整的范围是 <code>-20 ~ 19</code>，其中 root 有着至高无上的权力，既可以调整自己的进程也可以调整其他用户的程序，并且是所有的值都可以用，而普通用户只可以调制属于自己的进程，并且其使用的范围只能是 <code>0 ~ 19</code>，因为系统为了避免一般用户抢占系统资源而设置的一个限制</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个实验在环境中无法做，因为权限不够，可以自己在本地尝试</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开一个程序放在后台，或者用图形界面打开</span></span><br><span class="line">nice -n -5 vim &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用 ps 查看其优先级</span></span><br><span class="line">ps -afxo user,ppid,pid,<span class="built_in">stat</span>,pri,ni,time,<span class="built_in">command</span> | grep vim</span><br></pre></td></tr></table></figure>

<p>我们还可以用 renice 来修改已经存在的进程的优先级，同样因为权限的原因在实验环境中无法尝试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renice -5 pid</span><br></pre></td></tr></table></figure>

<h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><p>日志是一个系统管理员，一个运维人员，甚至是开发人员不可或缺的东西，系统用久了偶尔也会出现一些错误，我们需要日志来给系统排错，在一些网络应用服务不能正常工作的时候，我们需要用日志来做问题定位，日志还是过往时间的记录本，我们可以通过它知道我们是否被不明用户登录过等等。</p>
<p>在 Linux 中大部分的发行版都内置使用 syslog 系统日志，那么通过前期的课程我们了解到常见的日志一般存放在 <code>/var/log</code> 中，我们来看看其中有哪些日志</p>
<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469406921904" alt="实验楼"></p>
<p>根据图中所显示的日志，我们可以根据服务对象粗略的将日志分为两类</p>
<ul>
<li>系统日志</li>
<li>应用日志</li>
</ul>
<p>系统日志主要是存放系统内置程序或系统内核之类的日志信息如 <code>alternatives.log</code> 、<code>btmp</code> 等等，应用日志主要是我们装的第三方应用所产生的日志如 <code>tomcat7</code> 、<code>apache2</code> 等等。</p>
<p>接下来我们来看看常见的系统日志有哪些，他们都记录了怎样的信息</p>
<table>
<thead>
<tr>
<th>日志名称</th>
<th>记录信息</th>
</tr>
</thead>
<tbody><tr>
<td>alternatives.log</td>
<td>系统的一些更新替代信息记录</td>
</tr>
<tr>
<td>apport.log</td>
<td>应用程序崩溃信息记录</td>
</tr>
<tr>
<td>apt/history.log</td>
<td>使用 apt-get 安装卸载软件的信息记录</td>
</tr>
<tr>
<td>apt/term.log</td>
<td>使用 apt-get 时的具体操作，如 package 的下载、打开等</td>
</tr>
<tr>
<td>auth.log</td>
<td>登录认证的信息记录</td>
</tr>
<tr>
<td>boot.log</td>
<td>系统启动时的程序服务的日志信息</td>
</tr>
<tr>
<td>btmp</td>
<td>错误的信息记录</td>
</tr>
<tr>
<td>Consolekit/history</td>
<td>控制台的信息记录</td>
</tr>
<tr>
<td>dist-upgrade</td>
<td>dist-upgrade 这种更新方式的信息记录</td>
</tr>
<tr>
<td>dmesg</td>
<td>启动时，显示屏幕上内核缓冲信息，与硬件有关的信息</td>
</tr>
<tr>
<td>dpkg.log</td>
<td>dpkg 命令管理包的日志。</td>
</tr>
<tr>
<td>faillog</td>
<td>用户登录失败详细信息记录</td>
</tr>
<tr>
<td>fontconfig.log</td>
<td>与字体配置有关的信息记录</td>
</tr>
<tr>
<td>kern.log</td>
<td>内核产生的信息记录，在自己修改内核时有很大帮助</td>
</tr>
<tr>
<td>lastlog</td>
<td>用户的最近信息记录</td>
</tr>
<tr>
<td>wtmp</td>
<td>登录信息的记录。wtmp 可以找出谁正在进入系统，谁使用命令显示这个文件或信息等</td>
</tr>
<tr>
<td>syslog</td>
<td>系统信息记录</td>
</tr>
</tbody></table>
<p>而在本实验环境中没有 apport.log 是因为 apport 这个应用程序需要读取一些内核的信息来收集判断其他应用程序的信息，从而记录应用程序的崩溃信息。而在本实验环境中我们没有这个权限，所以将 apport 从内置应用值剔除，自然而然就没有它的日志信息了。</p>
<p>只闻其名，不见其人，我们并不能明白这些日志记录的内容。首先我们来看 <code>alternatives.log</code> 中的信息，在本实验环境中没有任何日志输出是因为刚刚启动的系统中并没有任何的更新迭代。我可以看看从其他地方截取过来的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/x-www-browser x-www-browser /usr/bin/google-chrome-stable 200</span><br><span class="line">update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/gnome-www-browser gnome-www-browser /usr/bin/google-chrome-stable 200</span><br><span class="line">update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/google-chrome google-chrome /usr/bin/google-chrome-stable 200</span><br></pre></td></tr></table></figure>

<p>我们可以从中得到的信息有程序作用，日期，命令，成功与否的返回码。</p>
<p>我们用这样的命令来看看 <code>auth.log</code> 中的信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo less /var/<span class="built_in">log</span>/auth.log</span><br></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469409885670" alt="实验楼"></p>
<p>我们可以从中得到的信息有日期与 ip 地址的来源以及的用户与工具。</p>
<p>在 <code>/var/log/apt</code> 文件夹中有两个日志文件 <code>history.log</code> 与 <code>term.log</code>，两个日志文件的区别在于 <code>history.log</code> 主要记录了进行了哪个操作，相关的依赖有哪些，而 <code>term.log</code> 则是较为具体的一些操作，主要就是下载包，打开包，安装包等等的细节操作。</p>
<p>如果是刚刚开启的新系统，那么按理说这些日志应该都是空的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /var/<span class="built_in">log</span>/apt/history.log</span><br><span class="line">sudo cat /var/<span class="built_in">log</span>/apt/term.log</span><br></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/courses/1379/871732/7bc699b28ff48cefee31fa859af518d9-0" alt="图片描述"></p>
<p>但是在实验环境中因为是启动的我们定制后的环境，所以两个日志中还残留了配置镜像的记录。可以先删除这两个文件然后再执行新的安装命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /var/<span class="built_in">log</span>/apt/history.log</span><br><span class="line">sudo rm /var/<span class="built_in">log</span>/apt/term.log</span><br></pre></td></tr></table></figure>

<p>我们来安装 git 这个程序，因为实验环境里已经预装了 git，所以这里真正执行的操作是一个更新的操作，但这并不影响。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/courses/uid871732-20200807-1596779861997" alt="图片描述"></p>
<p>成功的执行之后我们再来查看两个日志的内容变化：</p>
<p><img src="https://doc.shiyanlou.com/courses/1379/871732/dc97b5ebc3c1054d4e5a6070fa36773b-0" alt="图片描述"></p>
<p>其他的日志格式也都类似于之前我们所查看的日志，主要便是时间，操作。而这其中有两个比较特殊的日志，其查看的方式比较与众不同，因为这两个日志并不是 ASCII 文件而是被编码成了二进制文件，所以我们并不能直接使用 less、cat、more 这样的工具来查看，这两个日志文件是 wtmp，lastlog</p>
<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469412303087" alt="实验楼"></p>
<p>我们查看的方法是使用 last 与 lastlog 工具来提取其中的信息</p>
<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469412472830" alt="实验楼"></p>
<p>关于这两个工具的更深入使用我们可以使用前面的学习过的 man 来查看</p>
<p>这些日志是如何产生的？通过上面的例子我们可以看出大部分的日志信息似乎格式都很类似，并且都出现在这个文件夹中。</p>
<p>这样的实现可以通过两种方式：</p>
<ul>
<li>一种是由软件开发商自己来自定义日志格式然后指定输出日志位置；</li>
<li>一种方式就是 Linux 提供的日志服务程序，而我们这里系统日志是通过 syslog 来实现，提供日志管理服务。</li>
</ul>
<p>syslog 是一个系统日志记录程序，在早期的大部分 Linux 发行版都是内置 syslog，让其作为系统的默认日志收集工具，虽然随着时代的进步与发展，syslog 已经年老体衰跟不上时代的需求，所以他被 rsyslog 所代替了，较新的 Ubuntu、Fedora 等等都是默认使用 rsyslog 作为系统的日志收集工具</p>
<p>rsyslog 的全称是 rocket-fast system for log，它提供了高性能，高安全功能和模块化设计。rsyslog 能够接受各种各样的来源，将其输入，输出的结果到不同的目的地。rsyslog 可以提供超过每秒一百万条消息给目标文件。</p>
<p>这样能实时收集日志信息的程序是有其守护进程的，如 rsyslog 的守护进程便是 rsyslogd</p>
<p>因为一些原因本实验环境中默认并没有打开这个服务，我们可以手动开启这项服务，然后来查看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y rsyslog</span><br><span class="line">sudo service rsyslog start</span><br><span class="line">ps aux | grep syslog</span><br></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469414492628" alt="实验楼"></p>
<p>既然它是一个服务，那么它便是可以配置，为我们提供一些我们自定义的服务</p>
<p>首先我们来看 rsyslog 的配置文件是什么样子的，而 rsyslog 的配置文件有两个，</p>
<ul>
<li>一个是 <code>/etc/rsyslog.conf</code></li>
<li>一个是 <code>/etc/rsyslog.d/50-default.conf</code>。</li>
</ul>
<p>第一个主要是配置的环境，也就是 rsyslog 加载什么模块，文件的所属者等；而第二个主要是配置的 Filter Conditions</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/rsyslog.conf</span><br><span class="line"></span><br><span class="line">vim /etc/rsyslog.d/50-default.conf</span><br></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469414801715" alt="实验楼"></p>
<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469433052645" alt="实验楼"></p>
<p>也不知道他在写什么，我们还是来看看 rsyslog 的结构框架，数据流的走向吧。</p>
<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469416361678" alt="实验楼"></p>
<p>通过这个简单的流程图我们可以知道 rsyslog 主要是由 Input、Output、Parser 这样三个模块构成的，并且了解到数据的简单走向，首先通过 Input module 来收集消息，然后将得到的消息传给 Parser module，通过分析模块的层层处理，将真正需要的消息传给 Output module，然后便输出至日志文件中。</p>
<p>上文提到过 rsyslog 号称可以提供超过每秒一百万条消息给目标文件，怎么只是这样简单的结构。我们可以通过下图来做更深入的了解</p>
<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469415269198" alt="实验楼"></p>
<p>（图片来源于<a target="_blank" rel="noopener" href="http://www.rsyslog.com/doc/queues_analogy.html%EF%BC%89">http://www.rsyslog.com/doc/queues_analogy.html）</a></p>
<p>Rsyslog 架构如图中所示，从图中我们可以很清楚的看见，rsyslog 还有一个核心的功能模块便是 Queue，也正是因为它才能做到如此高的并发。</p>
<p>第一个模块便是 Input，该模块的主要功能就是从各种各样的来源收集 messages，通过这些接口实现：</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>im3195</td>
<td>RFC3195 Input Module</td>
</tr>
<tr>
<td>imfile</td>
<td>Text File Input Module</td>
</tr>
<tr>
<td>imgssapi</td>
<td>GSSAPI Syslog Input Module</td>
</tr>
<tr>
<td>imjournal</td>
<td>Systemd Journal Input Module</td>
</tr>
<tr>
<td>imklog</td>
<td>Kernel Log Input Module</td>
</tr>
<tr>
<td>imkmsg</td>
<td>/dev/kmsg Log Input Module</td>
</tr>
<tr>
<td>impstats</td>
<td>Generate Periodic Statistics of Internal Counters</td>
</tr>
<tr>
<td>imptcp</td>
<td>Plain TCP Syslog</td>
</tr>
<tr>
<td>imrelp</td>
<td>RELP Input Module</td>
</tr>
<tr>
<td>imsolaris</td>
<td>Solaris Input Module</td>
</tr>
<tr>
<td>imtcp</td>
<td>TCP Syslog Input Module</td>
</tr>
<tr>
<td>imudp</td>
<td>UDP Syslog Input Module</td>
</tr>
<tr>
<td>imuxsock</td>
<td>Unix Socket Input</td>
</tr>
</tbody></table>
<p>而 Output 中也有许多可用的接口，可以通过 man 或者官方的文档查看</p>
<p>而这些模块接口的使用需要通过 $ModLoad 指令来加载，那么返回上文的图中，配置生效的头两行可以看懂了，默认加载了 imklog、imuxsock 这两个模块</p>
<p>在配置中 rsyslog 支持三种配置语法格式：</p>
<ul>
<li>sysklogd</li>
<li>legacy rsyslog</li>
<li>RainerScript</li>
</ul>
<p>sysklogd 是老的简单格式，一些新的语法特性不支持。而 legacy rsyslog 是以 dollar 符($)开头的语法，在 v6 及以上的版本还在支持，就如上文所说的 <code>$ModLoad</code> 还有一些插件和特性只在此语法下支持。而以 <code>$</code> 开头的指令是全局指令，全局指令是 rsyslogd 守护进程的配置指令，每行只能有一个指令。 RainnerScript 是最新的语法。在官网上 rsyslog 大多推荐这个语法格式来配置</p>
<p>老的语法格式（sysklogd &amp; legacy rsyslog）是以行为单位。新的语法格式（RainnerScript）可以分割多行。</p>
<p>注释有两种语法:</p>
<ul>
<li>井号 #</li>
<li>C-style <code>/* .. */</code></li>
</ul>
<p>执行顺序: 指令在 rsyslog.conf 文件中是从上到下的顺序执行的。</p>
<p>模板是 rsyslog 一个重要的属性，它可以控制日志的格式，支持类似 template() 语句的基于 string 或 plugin 的模板，通过它我们可以自定义日志格式。</p>
<p>legacy 格式使用 $template 的语法，不过这个在以后要移除，所以最好使用新格式 template():，以免未来突然不工作了也不知道为什么</p>
<p>模板定义的形式有四种，适用于不同的输出模块，一般简单的格式，可以使用 string 的形式，复杂的格式，建议使用 list 的形式，使用 list 的形式，可以使用一些额外的属性字段（property statement）</p>
<p>如果不指定输出模板，rsyslog 会默认使用 RSYSLOG_DEFAULT。若想更深入的学习可以查看<a target="_blank" rel="noopener" href="http://www.rsyslog.com/doc/v8-stable/configuration/index.html">官方文档</a></p>
<p>了解了 rsyslog 环境的配置文件之后，我们看向 <code>/etc/rsyslog.d/50-default.conf</code> 这个配置文件，这个文件中主要是配置的 Filter Conditions，也就是我们在流程图中所看见的 <code>Parser &amp; Filter Engine</code>，它的名字叫 Selectors 是过滤 syslog 的传统方法，他主要由两部分组成，<code>facility</code> 与 <code>priority</code>，其配置格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">facility.priority log_location</span><br></pre></td></tr></table></figure>

<p>其中一个 priority 可以指定多个 facility，多个 facility 之间使用逗号 <code>,</code> 分割开</p>
<p>rsyslog 通过 Facility 的概念来定义日志消息的来源，以便对日志进行分类，Facility 的种类有：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>kern</td>
<td>内核消息</td>
</tr>
<tr>
<td>user</td>
<td>用户信息</td>
</tr>
<tr>
<td>mail</td>
<td>邮件系统消息</td>
</tr>
<tr>
<td>daemon</td>
<td>系统服务消息</td>
</tr>
<tr>
<td>auth</td>
<td>认证系统</td>
</tr>
<tr>
<td>authpriv</td>
<td>权限系统</td>
</tr>
<tr>
<td>syslog</td>
<td>日志系统自身消息</td>
</tr>
<tr>
<td>cron</td>
<td>计划安排</td>
</tr>
<tr>
<td>news</td>
<td>新闻信息</td>
</tr>
<tr>
<td>local0~7</td>
<td>由自定义程序使用</td>
</tr>
</tbody></table>
<p>而另外一部分 priority 也称之为 serverity level，除了日志的来源以外，对统一源产生日志消息还需要进行优先级的划分，而优先级的类别有以下几种：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>emergency</td>
<td>系统已经无法使用了</td>
</tr>
<tr>
<td>alert</td>
<td>必须立即处理的问题</td>
</tr>
<tr>
<td>critical</td>
<td>很严重了</td>
</tr>
<tr>
<td>error</td>
<td>错误</td>
</tr>
<tr>
<td>warning</td>
<td>警告信息</td>
</tr>
<tr>
<td>notice</td>
<td>系统正常，但是比较重要</td>
</tr>
<tr>
<td>informational</td>
<td>正常</td>
</tr>
<tr>
<td>debug</td>
<td>debug 的调试信息</td>
</tr>
<tr>
<td>panic</td>
<td>很严重但是已淘汰不常用</td>
</tr>
<tr>
<td>none</td>
<td>没有优先级，不记录任何日志消息</td>
</tr>
</tbody></table>
<p>我们来看看系统中的配置</p>
<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469433052645" alt="实验楼"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth,authpriv.*       /var/<span class="built_in">log</span>/auth.log</span><br></pre></td></tr></table></figure>

<p>这里的意思是 auth 与 authpriv 的所有优先级的信息全都输出于 <code>/var/log/auth.log</code> 日志中</p>
<p>而其中有类似于这样的配置信息意思有细微的差别</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kern.*      -/var/<span class="built_in">log</span>/kern.log</span><br></pre></td></tr></table></figure>

<p><code>-</code> 代表异步写入，也就是日志写入时不需要等待系统缓存的同步，也就是日志还在内存中缓存也可以继续写入无需等待完全写入硬盘后再写入。通常用于写入数据比较大时使用。</p>
<p>到此我们对 rsyslog 的配置就有了一定的了解，若想更深入学习模板，队列的高级应用，大家可去查看<a target="_blank" rel="noopener" href="http://www.rsyslog.com/doc/v8-stable/index.html">官网的文档</a>，需要注意的是 rsyslog 每个版本之间差异化比较大，学习之前先查看自己所使用的版本，再去查看相关的文档</p>
<p>与日志相关的还有一个还有常用的命令 <code>logger</code>，<code>logger</code> 是一个 shell 命令接口，可以通过该接口使用 Syslog 的系统日志模块，还可以从命令行直接向系统日志文件写入信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#首先将syslog启动起来</span></span><br><span class="line">sudo service rsyslog start</span><br><span class="line"></span><br><span class="line"><span class="comment">#向 syslog 写入数据</span></span><br><span class="line">ping 127.0.0.1 | logger -it logger_test -p local3.notice &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看是否有数据写入</span></span><br><span class="line">sudo tail -f /var/<span class="built_in">log</span>/syslog</span><br></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469474419356" alt="实验楼"></p>
<p>从图中我们可以看到我们成功的将 ping 的信息写入了 syslog 中，格式也就是使用的 rsyslog 的默认模板</p>
<p>我们可以通过 man 来查看 logger 的其他用法，</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>-i</td>
<td>在每行都记录进程 ID</td>
</tr>
<tr>
<td>-t</td>
<td>添加 tag 标签</td>
</tr>
<tr>
<td>-p</td>
<td>设置日志的 facility 与 priority</td>
</tr>
</tbody></table>
<h3 id="日志转储"><a href="#日志转储" class="headerlink" title="日志转储"></a>日志转储</h3><p>在本地的机器中每天都有成百上千条日志被写入文件中，更别说是我们的服务器，每天都会有数十兆甚至更多的日志信息被写入文件中，如果是这样的话，每天看着我们的日志文件不断的膨胀，那岂不是要占用许多的空间，所以有个叫 logrotate 的东西诞生了。</p>
<p>logrotate 程序是一个日志文件管理工具。用来把旧的日志文件删除，并创建新的日志文件。我们可以根据日志文件的大小，也可以根据其天数来切割日志、管理日志，这个过程又叫做“转储”。</p>
<p>大多数 Linux 发行版使用 logrotate 或 newsyslog 对日志进行管理。logrotate 程序不但可以压缩日志文件，减少存储空间，还可以将日志发送到指定 E-mail，方便管理员及时查看日志。</p>
<p>显而易见，logrotate 是基于 CRON 来运行的，其脚本是 /etc/cron.daily/logrotate；同时我们可以在 <code>/etc/logrotate</code> 中找到其配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/logrotate.conf</span><br></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469476364695" alt="实验楼"></p>
<p>这其中的具体意思是什么呢？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># see &quot;man logrotate&quot; for details  //可以查看帮助文档</span></span><br><span class="line"><span class="comment"># rotate log files weekly</span></span><br><span class="line">weekly                             //设置每周转储一次(daily、weekly、monthly当然可以使用这些参数每天、星期，月 )</span><br><span class="line"><span class="comment"># keep 4 weeks worth of backlogs</span></span><br><span class="line">rotate 4                           //最多转储4次</span><br><span class="line"><span class="comment"># create new (empty) log files after rotating old ones</span></span><br><span class="line">create                             //当转储后文件不存在时创建它</span><br><span class="line"><span class="comment"># uncomment this if you want your log files compressed</span></span><br><span class="line">compress                          //通过gzip压缩方式转储（nocompress可以不压缩）</span><br><span class="line"><span class="comment"># RPM packages drop log rotation information into this directory</span></span><br><span class="line">include /etc/logrotate.d           //其他日志文件的转储方式配置文件，包含在该目录下</span><br><span class="line"><span class="comment"># no packages own wtmp -- we&#x27;ll rotate them here</span></span><br><span class="line">/var/<span class="built_in">log</span>/wtmp &#123;                    //设置/var/<span class="built_in">log</span>/wtmp日志文件的转储参数</span><br><span class="line">    monthly                        //每月转储</span><br><span class="line">    create 0664 root utmp          //转储后文件不存在时创建它，文件所有者为root，所属组为utmp，对应的权限为0664</span><br><span class="line">    rotate 1                       //最多转储一次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然在 /etc/logrotate.d/ 中有各项应用的 logrotate 配置，还有更多的配置参数，大家可以使用 man 查看，如按文件大小转储，按当前时间格式命名等等参数配置。</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='true'
        data-ae='true'
        data-ci='01ed89abee289d37f2f8'
        data-cs='51741e819059e2ea7ab6c6f3d0fa0ac631d1d975'
        data-r='MyBlogComments'
        data-o='Equinox-shame'
        data-a='Equinox-shame'
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
