
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Angr 学习笔记 - Autumnal</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="Angr 学习笔记安装安装的话angr支持了Python 3.x可以不用去折腾2.x的版本了，对于Windows似乎可以直接：
1pip install angr

就可以完成大部分需要库的安装，对,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="Autumnal" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Autumnal</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">Angr 学习笔记</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">Angr 学习笔记</h1>
        <div class="stuff">
            <span>三月 19, 2022</span>
            

        </div>
        <div class="content markdown">
            <h1 id="Angr-学习笔记"><a href="#Angr-学习笔记" class="headerlink" title="Angr 学习笔记"></a>Angr 学习笔记</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装的话<code>angr</code>支持了<code>Python 3.x</code>可以不用去折腾<code>2.x</code>的版本了，对于<code>Windows</code>似乎可以直接：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install angr</span><br></pre></td></tr></table></figure>

<p>就可以完成大部分需要库的安装，对于<code>Linux</code>可能会有一些复杂，这里给出一个链接给大家参考一下：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lxy8584099/p/13668749.html">https://www.cnblogs.com/lxy8584099/p/13668749.html</a></p>
<blockquote>
<p> 本人是在<code>Windows</code>下安装的，也没遇到网上出现的缺失文件的现象。出现问题了我也不清楚呀 ：(</p>
</blockquote>
<h2 id="部分使用教程"><a href="#部分使用教程" class="headerlink" title="部分使用教程"></a>部分使用教程</h2><h3 id="导入-angr-包"><a href="#导入-angr-包" class="headerlink" title="导入 angr 包"></a>导入 angr 包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br></pre></td></tr></table></figure>

<p>似乎这一部没有出差错就是说明安装成功了。</p>
<h3 id="新建一个-angr-工程"><a href="#新建一个-angr-工程" class="headerlink" title="新建一个 angr 工程"></a>新建一个 angr 工程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建angr项目</span></span><br><span class="line">p = angr.Project(<span class="string">&quot;&lt;需要拿来解题的文件&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>上述过程相当于完成了<code>angr</code>的加载。</p>
<h3 id="初始化-angr"><a href="#初始化-angr" class="headerlink" title="初始化 angr"></a>初始化 angr</h3><p><code>Unicorn</code>是 <code>angr</code>的依赖库，在<code>Unicorn</code>下可以执行任意一段二进制的代码，我们对此需要告诉其从哪里开始，因此我们需要对<code>angr</code>进行初始化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置项目起点，entry_state代表程序的入口点，即main函数</span></span><br><span class="line">init_state = p.factory.entry_state()</span><br></pre></td></tr></table></figure>

<h3 id="执行-angr"><a href="#执行-angr" class="headerlink" title="执行 angr"></a>执行 angr</h3><p>初始化后我们需要执行<code>angr</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置模拟器</span></span><br><span class="line">sm = p.factory.simulation_manager(init_state)</span><br></pre></td></tr></table></figure>

<p>上述过程中我们设置了一个模拟器，接下来我们需要告诉程序应该到哪里去，我们需要设置目标地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sm.explore(find = <span class="string">&quot;&lt;目标地址&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>此时如果我们找到了通向对应的目标地址的时候，将其打印出来其符号向量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果到达目标地址，打印此时的符号向量</span></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line"><span class="comment"># 否则抛出失败异常</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find solution&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="00-angr-find"><a href="#00-angr-find" class="headerlink" title="00_angr_find"></a>00_angr_find</h2><p><img src="https://s2.loli.net/2022/03/15/oYsr4MzlfXy8Lq3.png"></p>
<p>第一题拖进<code>IDA</code>分析可以看到是十分简单的，其关键部分便是中间的那个<code>complex_function</code>，我们尝试用<code>angr</code>来进行解题 ( 虽然爆破也可以直接执行 )。</p>
<p>我们找到对应目标 ( Good Job ) 的地址，将其导入进行求解</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">    <span class="comment"># 目标文件的路径</span></span><br><span class="line">    path_to_binary = <span class="string">&#x27;../program/00_angr_find&#x27;</span></span><br><span class="line">    <span class="comment"># 创建angr项目</span></span><br><span class="line">    project = angr.Project(path_to_binary)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置项目起点，entry_state代表程序的入口点，即main函数</span></span><br><span class="line">    initial_state = project.factory.entry_state()</span><br><span class="line">    <span class="comment"># 设置模拟器</span></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置目标地址</span></span><br><span class="line">    print_good_addr = <span class="number">0x0804867D</span></span><br><span class="line">    simulation.explore(find=print_good_addr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果到达目标地址，打印此时的符号向量</span></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">    <span class="comment"># 否者抛出失败异常</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find solution&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>值得注意的是在输出语句中<code>print(solution_state.posix.dumps(sys.stdin.fileno()))</code>，其中的<code>dumps</code>在<code>Python 3.x</code>下运行成功，但是在文档中看到有些写的是<code>dump</code>，不清楚其是否为<code>Python 2.x</code>运行的，上述脚本运行不成功时可以试试看各改一下输出的<code>dump</code></p>
</blockquote>
<p>通过上述脚本我们可以直接得到目标地址的值在解密后得到的目标答案。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b&#x27;FMKGABFY&#x27;</span><br></pre></td></tr></table></figure>

<p>本题中我们了解到了如何编写<code>angr</code>脚本，了解了如何创建项目，创建模拟器以及如何约束模拟器到对应的地址处和输出约束求解的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">angr.Project(file_path) <span class="comment">#创建项目</span></span><br><span class="line">project.factory.simgr(initial_state) <span class="comment">#创建模拟器</span></span><br><span class="line">simulation.explore(find=addr) <span class="comment">#约束模拟器到达find指定的地址</span></span><br><span class="line">solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno())) <span class="comment">#打印符号向量</span></span><br></pre></td></tr></table></figure>

<h2 id="01-angr-avoid"><a href="#01-angr-avoid" class="headerlink" title="01_angr_avoid"></a>01_angr_avoid</h2><p>将程序拖进<code>IDA</code>，反编译主函数程序显示函数过大，无法反编译，在这个题目中我们主要学习<code>angr</code>的<code>avoid</code>的使用，对此我们利用<code>avoid</code>来去除我们不想要到达的地址。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">    <span class="comment"># 目标文件的路径</span></span><br><span class="line">    path_to_binary = <span class="string">&#x27;../program/00_angr_find&#x27;</span></span><br><span class="line">    <span class="comment"># 创建angr项目</span></span><br><span class="line">    project = angr.Project(path_to_binary)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置项目起点，entry_state代表程序的入口点，即main函数</span></span><br><span class="line">    initial_state = project.factory.entry_state()</span><br><span class="line">    <span class="comment"># 设置模拟器</span></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置目标地址</span></span><br><span class="line">    print_good_addr = <span class="number">0x080485E0</span></span><br><span class="line">    try_again_addr = <span class="number">0x080485F2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># simulation.explore(find=print_good_addr)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在这里可以添加 avoid 来约束我们到达的目的地址 </span></span><br><span class="line">    simulation.explore(find=print_good_addr, avoid=try_again_addr)</span><br><span class="line">    <span class="comment"># 如果到达目标地址，打印此时的符号向量</span></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">    <span class="comment"># 否者抛出失败异常</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find solution&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是对应的<code>good</code>的地址不是这个字符串的地址，而是打印字符串时的汇编代码对应的地址。</p>
</blockquote>
<p>通过上述例子，我们学会了如何加入规避的地址来进行进一步的约束求解</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print_good_addr = XXXX	<span class="comment"># 目的地址</span></span><br><span class="line">try_again_addr = XXXX	<span class="comment"># 规避地址</span></span><br><span class="line">simulation.explore(find=print_good_addr, avoid=try_again_addr)</span><br></pre></td></tr></table></figure>

<h2 id="01-angr-condition"><a href="#01-angr-condition" class="headerlink" title="01_angr_condition"></a>01_angr_condition</h2><p>将程序拖入<code>IDA</code>可以看到主函数还是和上一题一样，函数过大而无法反编译，同时我们观察一下主函数里的数据可以看到有多个<code>Good Job</code>和多个<code>Try again</code>，此时的一个单一的约束并不能很好的起作用，此时用到了<code>angr</code>中的<code>condition</code>来对多个结果进行约束求解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simulation.explore(find=print_good_addr, avoid=try_again_addr)</span><br></pre></td></tr></table></figure>

<p>之前我们的约束条件都是上面的<code>explore</code>中加入<code>find</code>和<code>avoid</code>的函数地址，但是实际上<code>find</code>和<code>avoid</code>对应的参数可以是一个函数，我们将在这个函数里面进行一个条件的约束</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">good_job</span>(<span class="params">state</span>):</span></span><br><span class="line">      stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Good Job&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">try_again</span>(<span class="params">state</span>):</span> </span><br><span class="line">      stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Try again&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>stdout_output = state.posix.dumps(sys.stdout.fileno())</code>用来获取标准输出的字符</p>
</blockquote>
<p>我们利用获取的标准输出字符来进行创建函数，而进一步对我们的条件进行约束求解，那么我们传入的便不再是一个单一的地址，可以对输出的字符集合进行集体约束求解，得到我们想要的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 到达目标地址，打印此时的符号向量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">good_job</span>(<span class="params">state</span>):</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Good Job&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 否则抛出失败异常</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">try_again</span>(<span class="params">state</span>):</span> </span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Try again&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">    path_to_binary = <span class="string">&#x27;./02_angr_find_condition&#x27;</span></span><br><span class="line">    <span class="comment"># 创建angr项目</span></span><br><span class="line">    project = angr.Project(path_to_binary)</span><br><span class="line">    <span class="comment"># 设置项目起点，entry_state代表程序的入口点，即main函数</span></span><br><span class="line">    initial_state = project.factory.entry_state()</span><br><span class="line">    <span class="comment"># 设置模拟器</span></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line">    <span class="comment"># 设置目标地址</span></span><br><span class="line">    simulation.explore(find=good_job, avoid=try_again) </span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find solution&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br></pre></td></tr></table></figure>

<p>上述例子，我们学会了对输出条件来进行集体约束求解，明白了<code>simulation.explore</code>对应的参数值可以是一个函数，在函数中我们调用标准的输出库，来对输出字符进行约束求解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数的返回类型为布尔类型 (bool)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">good_job</span>(<span class="params">state</span>):</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">b&quot;XXX&quot;</span> <span class="keyword">in</span> solution_state.posix.dumps(<span class="number">0</span>) <span class="comment"># 0 是输出 1 是输入</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">try_again</span>(<span class="params">state</span>):</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">b&quot;XXX&quot;</span> <span class="keyword">in</span> solution_state.posix.dumps(<span class="number">0</span>)</span><br><span class="line">simulation.explore(find=good_job, avoid=try_again) <span class="comment"># 参数值为函数</span></span><br></pre></td></tr></table></figure>

<h2 id="03-angr-symbolic-registers"><a href="#03-angr-symbolic-registers" class="headerlink" title="03_angr_symbolic_registers"></a>03_angr_symbolic_registers</h2><p>打开题目一看，程序要求我们输入的是 3 个数据，通过三个复杂的函数进行运算，当三个数运算处理后的返回值均为 1 时，判断输入正确，反之判断错误。之前有一个学长去问过<code>angr_CTF</code>库的原作者问多个输入<code>angr</code>可以直接处理吗，原作者回答可以直接处理，但是为了学习目的我们不直接按照之前几个题目的方式来约束地址或者输出来进行运算。</p>
<p>我们还是给出之前的代码写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 到达目标地址，打印此时的符号向量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">good_job</span>(<span class="params">state</span>):</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Good Job&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 否则抛出失败异常</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">try_again</span>(<span class="params">state</span>):</span> </span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Try again&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">    path_to_binary = <span class="string">&#x27;./03_angr_symbolic_registers&#x27;</span></span><br><span class="line">    <span class="comment"># 创建angr项目</span></span><br><span class="line">    project = angr.Project(path_to_binary)</span><br><span class="line">    <span class="comment"># 设置项目起点，entry_state代表程序的入口点，即main函数</span></span><br><span class="line">    initial_state = project.factory.entry_state()</span><br><span class="line">    <span class="comment"># 设置模拟器</span></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line">    <span class="comment"># 设置目标地址</span></span><br><span class="line">    simulation.explore(find=good_job, avoid=try_again) </span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find solution&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br><span class="line">    <span class="comment"># cfcdef7a 968d69bd c66a3c12</span></span><br></pre></td></tr></table></figure>

<p>在题目名称中我们可以看到符号化寄存器的英文，那么什么是符号化寄存器？</p>
<blockquote>
<p>设置状态的寄存器值，符号化寄存器值含义就是将寄存器内存储的值设为自变量，而后类别列方程加入约束条件内</p>
</blockquote>
<p>似乎有点类似于<code>z3</code>设置多个未知数然后带入方程组进行约束求解。那么我们要怎么做呢？我们先观察一下程序的输入：</p>
<img src="https://s2.loli.net/2022/03/16/KfW3vZumG2gxEUS.png" style="zoom:80%;" />

<p>可以看出来我们的 3 个输入数据先后从<code>ecx</code>中转移到了<code>eax</code>、<code>ebx</code>、<code>edx</code>里，同时在后续复杂函数的处理部分中没有改变 3 个寄存器来进行其他处理，对此我们可以直接设置 3 个未知数来代替这三个寄存器，来参与下面函数的运算和执行。</p>
<p>要将寄存器符号化我们需要引入一个新的函数库：<code>import claripy</code>，由于我们不再是从主函数( main )直接执行我们的符号化向量，我们需要重新设置一个起始地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置项目开始地址</span></span><br><span class="line">start_addr = XXX</span><br><span class="line">initial_state = project.factory.blank_state(addr=start_addr)</span><br></pre></td></tr></table></figure>

<p>其中的<code>project.factory.blank_state</code>与之前的<code>project.factory.entry_state</code>不同了，<code>blank_state</code>相当于表示一个空的地址，需要我们把开始地址进行导入。</p>
<p>接下来便是将寄存器进行符号化，我们便利用到了之前引入的<code>claripy</code>库，下面给出示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将寄存器符号化</span></span><br><span class="line">bit_length = XX  <span class="comment"># 设置寄存器的长度 如 32 —&gt; int </span></span><br><span class="line">register = claripy.BVS(<span class="string">&#x27;&lt;符号向量取名&gt;&#x27;</span>, bit_length)</span><br><span class="line">initial_state.regs.eax = register <span class="comment"># 将 eax 寄存器符号化</span></span><br><span class="line"><span class="comment"># initial_state.regs.xxx = register # xxx 处换成其他寄存器名即可</span></span><br><span class="line"><span class="comment"># 设置模拟器</span></span><br><span class="line">simulation = project.factory.simgr(initial_state)</span><br></pre></td></tr></table></figure>

<p>那么我们想要输出对应找到后的寄存器值又该怎么处理呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">   solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 条件判断</span></span><br><span class="line">   solution = solution_state.se.<span class="built_in">eval</span>(register)</span><br><span class="line"><span class="comment"># 创建输出格式</span></span><br><span class="line">   solution = <span class="string">&#x27;%x&#x27;</span> % (solution)</span><br><span class="line">   <span class="built_in">print</span>(solution)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line"><span class="comment"># 如果有多个寄存器时</span></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">   solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 条件判断</span></span><br><span class="line">   solution1 = solution_state.se.<span class="built_in">eval</span>(register1)</span><br><span class="line">   solution2 = solution_state.se.<span class="built_in">eval</span>(register2)</span><br><span class="line"><span class="comment"># 创建输出格式</span></span><br><span class="line">   solution = <span class="string">&#x27;%x %x&#x27;</span> % (solution1,solution2)</span><br><span class="line">   <span class="built_in">print</span>(solution)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>此时新的脚本可以如下编写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;../program/03_angr_symbolic_registers&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line">	</span><br><span class="line">    <span class="comment"># 设置项目开始地址</span></span><br><span class="line">    start_addr = <span class="number">0x0804890E</span></span><br><span class="line">    initial_state = project.factory.blank_state(addr=start_addr)</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">   <span class="comment"># 将寄存器符号化</span></span><br><span class="line">    bit_length = <span class="number">32</span>	<span class="comment"># 此处的长度为 bit</span></span><br><span class="line">    psd0 = claripy.BVS(<span class="string">&#x27;psd0&#x27;</span>, bit_length)</span><br><span class="line">    psd1 = claripy.BVS(<span class="string">&#x27;psd1&#x27;</span>, bit_length)</span><br><span class="line">    psd2 = claripy.BVS(<span class="string">&#x27;psd2&#x27;</span>, bit_length)</span><br><span class="line">	<span class="comment"># 将符号化的寄存器对应到相应的寄存器</span></span><br><span class="line">    initial_state.regs.eax = psd0</span><br><span class="line">    initial_state.regs.ebx = psd1</span><br><span class="line">    initial_state.regs.edx = psd2</span><br><span class="line">	<span class="comment"># 设置模拟</span></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">good_job</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_content = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_content</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fail</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_content = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> stdout_content</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=good_job, avoid=fail)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">        solution0 = solution_state.se.<span class="built_in">eval</span>(psd0)</span><br><span class="line">        solution1 = solution_state.se.<span class="built_in">eval</span>(psd1)</span><br><span class="line">        solution2 = solution_state.se.<span class="built_in">eval</span>(psd2)</span><br><span class="line">		<span class="comment"># 创建输出格式</span></span><br><span class="line">        solution = <span class="string">&#x27;%x %x %x&#x27;</span> % (solution0, solution1, solution2)</span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>上述过程中我们学习了符号化寄存器，修改对应的输出格式，同时如何更改执行的起始地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置项目开始地址</span></span><br><span class="line">start_addr = XXX</span><br><span class="line">initial_state = project.factory.blank_state(addr=start_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将寄存器符号化</span></span><br><span class="line">bit_length = XX  <span class="comment"># 设置寄存器的长度 如 32 —&gt; int </span></span><br><span class="line">register = claripy.BVS(<span class="string">&#x27;&lt;符号向量取名&gt;&#x27;</span>, bit_length)</span><br><span class="line">initial_state.regs.eax = register <span class="comment"># 将 eax 寄存器符号化</span></span><br><span class="line"><span class="comment"># initial_state.regs.xxx = register # xxx 处换成其他寄存器名即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改输出格式</span></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">   solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 条件判断</span></span><br><span class="line">   solution = solution_state.se.<span class="built_in">eval</span>(register)</span><br><span class="line"><span class="comment"># solution2 = solution_state.se.eval(register2)</span></span><br><span class="line"><span class="comment"># 创建输出格式</span></span><br><span class="line">   solution = <span class="string">&#x27;%x&#x27;</span> % (solution)</span><br><span class="line"><span class="comment">#  solution = &#x27;%x %x&#x27; % (solution,solution2)</span></span><br><span class="line">   <span class="built_in">print</span>(solution)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="04-angr-symbolic-stack"><a href="#04-angr-symbolic-stack" class="headerlink" title="04_angr_symbolic_stack"></a>04_angr_symbolic_stack</h2><p>程序名字是符号化栈，对于这个题目我尝试了一下使用之前的<code>02_angr_find_condition</code>来进行约束输出求解，发现<code>angr</code>同样可以直接处理栈，岂不是直接一个输出条件的约束就可以吃遍逆向了？因为有些程序的分支结构十分大，<code>angr</code>会遍历所有可能的分支结构，简单的约束限制求解消耗的时间会十分巨大，所以我们需要进一步的学习来进行约束求解。</p>
<p><img src="https://s2.loli.net/2022/03/16/2xg7TbQYspFXZ6j.png"></p>
<p>在程序里我们的输入是处于栈上的，在<code>scanf</code>过后执行了一个<code>add esp, 10h</code>的操作来清理<code>scanf</code>所产生的栈，因此我们真正的执行部分应该是在<code>add esp, 10h</code>之后，我们观察一下输入，可以看到<code>v2</code>最先被输入，然后便是<code>v1</code>，因此<code>v2</code>所在的栈空间是位于<code>v1</code>下方的 ( 栈向上增长 )。我们每次初始化栈时并不会有数据，而<code>v1</code>处于栈空间的中间，因此我们需要一个<code>padding</code>来帮我们覆写到对应<code>v1</code>所在的空间内。示意图如下：</p>
<img src="https://s2.loli.net/2022/03/16/HZsvVBq3kFjI2PL.png" style="zoom: 67%;" />

<p><code>v1</code>距离栈顶还有<code>0x8</code>的空间，我们初始化栈时的<code>padding</code>将上面的<code>0x8</code>字节空间进行填充，之后的栈空间地址便是我们输入的<code>v1</code>地址。那么怎么进行初始化栈呢？栈开始时我们是将<code>EBP</code>和<code>ESP</code>两个栈指针的地址相等，然后入栈时栈顶指针<code>ESP</code>增加，我们在这个过程中是对栈进行了模拟操作，那么在<code>angr</code>中也有相应的模拟方式来实现模拟栈的初始化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">initial_state.regs.ebp = initial_state.regs.esp <span class="comment"># 初始化栈，令ebp等于esp</span></span><br><span class="line"></span><br><span class="line">password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">32</span>) <span class="comment"># 初始化两个位向量</span></span><br><span class="line">password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">padding_length_in_bytes = <span class="number">0x8</span> <span class="comment"># 填充栈数据 0x8 之后栈空间会在 v1 处</span></span><br><span class="line">initial_state.regs.esp -= padding_length_in_bytes </span><br><span class="line"></span><br><span class="line">initial_state.stack_push(password0) <span class="comment"># 将位向量压入栈中</span></span><br><span class="line">initial_state.stack_push(password1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么我们便可以把这一连串代码加入到之前的第二题的代码之中，编写出如下脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mimetypes <span class="keyword">import</span> init</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;./04_angr_symbolic_stack&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line">	<span class="comment"># 设置开始地址</span></span><br><span class="line">    start_addr = <span class="number">0x08048697</span></span><br><span class="line">    initial_state = project.factory.blank_state(addr=start_addr)</span><br><span class="line"></span><br><span class="line">    initial_state.regs.ebp = initial_state.regs.esp <span class="comment"># 初始化栈，令ebp等于esp</span></span><br><span class="line"></span><br><span class="line">    password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">32</span>) <span class="comment"># 初始化两个位向量</span></span><br><span class="line">    password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">    padding_length_in_bytes = <span class="number">0x8</span> <span class="comment"># 填充栈</span></span><br><span class="line">    initial_state.regs.esp -= padding_length_in_bytes <span class="comment"># 从栈顶减去对应的 padding 使栈空间到 v1 处</span></span><br><span class="line">	<span class="comment"># 将位向量压入栈中</span></span><br><span class="line">    initial_state.stack_push(password0) <span class="comment"># v1</span></span><br><span class="line">    initial_state.stack_push(password1) <span class="comment"># v2</span></span><br><span class="line"></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        solution0 = solution_state.se.<span class="built_in">eval</span>(password0)</span><br><span class="line">        solution1 = solution_state.se.<span class="built_in">eval</span>(password1)</span><br><span class="line"></span><br><span class="line">        solution = <span class="string">&#x27;%u %u&#x27;</span> % (solution0, solution1)</span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>在这个题目中我们学会了如何符号化栈空间，我们通过填充部分<code>padding</code>使我们的输入数据处于栈顶 ( 绕过了输入 )，同时与符号化寄存器相结合，让<code>angr</code>进行模拟，来代替输入的输入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">initial_state.regs.ebp = initial_state.regs.esp <span class="comment"># 初始化栈，令ebp等于esp</span></span><br><span class="line"></span><br><span class="line">password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">32</span>) <span class="comment"># 初始化向量</span></span><br><span class="line">password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">padding_length_in_bytes = XXX <span class="comment"># 填充栈数据 0x8 之后栈空间会在 v1 处</span></span><br><span class="line">initial_state.regs.esp -= padding_length_in_bytes <span class="comment"># 从栈顶减去 padding 的数据大小</span></span><br><span class="line"></span><br><span class="line">initial_state.stack_push(password0) <span class="comment"># 将位向量压入栈中</span></span><br><span class="line">initial_state.stack_push(password1)</span><br></pre></td></tr></table></figure>

<h2 id="05-angr-symbolic-memory"><a href="#05-angr-symbolic-memory" class="headerlink" title="05_angr_symbolic_memory"></a>05_angr_symbolic_memory</h2><p>看到题目便是我们要学习的符号化内存空间，观察一下输入的数据所在的位置，可以看到其处于在<code>bss</code>段上，属于一个内存区域内，我们所需要做的便是符号化内存空间。</p>
<img src="https://s2.loli.net/2022/03/17/g2biEX8QadlMcAj.png" style="zoom:80%;" />

<p>与符号化栈空间有一点类似，我们需要设置 4 个符号向量来进行模拟输入，然后想办法将其放在内存空间里，<code>angr</code>提供有对应把符号项量放在内存中的函数，我们可以直接通过调用来对内存空间进行符号化。但在这之前我们需要找到<code>bss</code>段每个输入数据所在的地址值，将对应的地址传入到栈空间里。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对应参数值为符号化的地址，和符号化的参数名</span></span><br><span class="line">initial_state.memory.store(password_addr, password)</span><br></pre></td></tr></table></figure>

<p>其余部分和前面一个题的符号化栈空间是十分相像的，需要我们对输入进行符号化处理，然后将其地址和参数名传入到内存段即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;../program/05_angr_symbolic_memory&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line"></span><br><span class="line">    start_addr = <span class="number">0x08048601</span></span><br><span class="line">    initial_state = project.factory.blank_state(addr=start_addr)</span><br><span class="line"></span><br><span class="line">    password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">64</span>) <span class="comment"># 64 = 8(8个字符) * 1(每个字符一字节) * 8(每个字节8比特)</span></span><br><span class="line">    password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">    password2 = claripy.BVS(<span class="string">&#x27;password2&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">    password3 = claripy.BVS(<span class="string">&#x27;password3&#x27;</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">    password0_addr = <span class="number">0x09FD92A0</span></span><br><span class="line">    password1_addr = <span class="number">0x09FD92A8</span></span><br><span class="line">    password2_addr = <span class="number">0x09FD92B0</span></span><br><span class="line">    password3_addr = <span class="number">0x09FD92B8</span></span><br><span class="line"></span><br><span class="line">    initial_state.memory.store(password0_addr, password0) <span class="comment"># 将位向量存入内存</span></span><br><span class="line">    initial_state.memory.store(password1_addr, password1)</span><br><span class="line">    initial_state.memory.store(password2_addr, password2)</span><br><span class="line">    initial_state.memory.store(password3_addr, password3)</span><br><span class="line"></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        solution0 = solution_state.se.<span class="built_in">eval</span>(password0)</span><br><span class="line">        solution1 = solution_state.se.<span class="built_in">eval</span>(password1)</span><br><span class="line">        solution2 = solution_state.se.<span class="built_in">eval</span>(password2)</span><br><span class="line">        solution3 = solution_state.se.<span class="built_in">eval</span>(password3)</span><br><span class="line">        solution = long_to_bytes(solution0)+<span class="string">b&#x27; &#x27;</span>+long_to_bytes(solution1)+<span class="string">b&#x27; &#x27;</span>+long_to_bytes(solution2)+<span class="string">b&#x27; &#x27;</span>+long_to_bytes(solution3)</span><br><span class="line">        <span class="built_in">print</span>(solution.decode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>不过需要注意的是符号化向量对应的大小应该是对应的<code>bit</code>数据大小，而不是看其字节长度。在这个过程中我们将内存进行了符号化处理，然后将我们的符号化向量传入到<code>bss</code>段中去。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">password = claripy.BVS(<span class="string">&#x27;password&#x27;</span>, &lt;bit数据大小&gt;) </span><br><span class="line">password_addr = XXX</span><br><span class="line">initial_state.memory.store(password_addr, password) <span class="comment"># 将位向量存入内存</span></span><br></pre></td></tr></table></figure>

<h2 id="06-angr-symbolic-dynamic-memory"><a href="#06-angr-symbolic-dynamic-memory" class="headerlink" title="06_angr_symbolic_dynamic_memory"></a>06_angr_symbolic_dynamic_memory</h2><p>在这个题目中与上一个题目不同的是题目动态分配了两个指针变量，将我们的输入保存在堆空间上，使得我们需要将堆上的空间进行符号化处理，也就是<code>malloc</code>分配的空间是动态的但是其返回的变量<code>buufer</code>位于<code>bss</code>段，是静态的，那么我们可以伪造指针，使其指向的是一片可写内存，进而符号化处理。</p>
<img src="https://s2.loli.net/2022/03/17/Lctai5ujnD6fyeq.png" alt="6.png" style="zoom:80%;" />

<p>我们可以看到空间内的定义数据都是处于<code>bss</code>段上的，我们便对其想办法来符号化。</p>
<img src="https://s2.loli.net/2022/03/17/Hju1aqReUd5sgcG.png" style="zoom:80%;" />

<p>相当于我们模拟<code>malloc</code>分配地址空间，在<code>bss</code>段里找到一块空的空间来保存我们的输入数据。与此同时我们观察程序入口点可以看到程序在输入后有<code>add esp, 16</code>对<code>scanf</code>的栈空间进行整理，所以我们程序开始的地址为下面一行的<code>0x08048699</code></p>
<img src="https://s2.loli.net/2022/03/17/tCmpxcrPXI5dBo1.png" alt="8.png" style="zoom:80%;" />

<p>接下来我们开始模拟<code>malloc</code>分配地址，并将其保存的输入符号化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 符号化输入</span></span><br><span class="line">password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">64</span>) <span class="comment"># 64 = 8(8个字符) * 1(每个字符一字节) * 8(每个字节8比特)</span></span><br><span class="line">password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对应空白 bss 段内空间</span></span><br><span class="line">fake0_addr = <span class="number">0x09FD9160</span> <span class="comment"># 伪造malloc得来的内存</span></span><br><span class="line">fake1_addr = <span class="number">0x09FD9180</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指向伪造内存的指针</span></span><br><span class="line">buffer0_addr = <span class="number">0x09FD92AC</span> <span class="comment"># 输入的存放地址 buffer0</span></span><br><span class="line">buffer1_addr = <span class="number">0x09FD92B4</span> <span class="comment"># buffer1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指针指向伪造的内存</span></span><br><span class="line"><span class="comment"># 参数为输入数据存放地址,bss 段伪造的空间</span></span><br><span class="line">initial_state.memory.store(buffer0_addr, fake0_addr, endness=project.arch.memory_endness) </span><br><span class="line">initial_state.memory.store(buffer1_addr, fake1_addr, endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将伪造的内存符号化</span></span><br><span class="line">initial_state.memory.store(fake0_addr, password0) <span class="comment"># bss 段伪造的地址,符号化的输入</span></span><br><span class="line">initial_state.memory.store(fake1_addr, password1)</span><br></pre></td></tr></table></figure>

<p>我们整理一下脚本将符号化动态的内存空间加入到我们的第二题的代码组合便是我们的脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> is_</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;../program/06_angr_symbolic_dynamic_memory&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line"></span><br><span class="line">    start_addr = <span class="number">0x08048699</span></span><br><span class="line">    initial_state = project.factory.blank_state(addr=start_addr)</span><br><span class="line"></span><br><span class="line">    password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">    password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">    fake0_addr = <span class="number">0x09FD9160</span> <span class="comment"># 伪造malloc得来的内存</span></span><br><span class="line">    fake1_addr = <span class="number">0x09FD9180</span></span><br><span class="line"></span><br><span class="line">    buffer0_addr = <span class="number">0x09FD92AC</span> <span class="comment"># 指向伪造内存的指针</span></span><br><span class="line">    buffer1_addr = <span class="number">0x09FD92B4</span></span><br><span class="line">    initial_state.memory.store(buffer0_addr, fake0_addr, endness=project.arch.memory_endness) <span class="comment"># 将指针指向伪造的内存</span></span><br><span class="line">    initial_state.memory.store(buffer1_addr, fake1_addr, endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">    initial_state.memory.store(fake0_addr, password0) <span class="comment"># 将伪造的内存符号化</span></span><br><span class="line">    initial_state.memory.store(fake1_addr, password1)</span><br><span class="line"></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        solution0 = solution_state.se.<span class="built_in">eval</span>(password0)</span><br><span class="line">        solution1 = solution_state.se.<span class="built_in">eval</span>(password1)</span><br><span class="line"></span><br><span class="line">        solution = long_to_bytes(solution0) + <span class="string">b&#x27; &#x27;</span> + long_to_bytes(solution1)</span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line">        <span class="built_in">print</span>(solution.decode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>通过这个题目，我们了解到如何将动态的内存分配的地址进行转换为符号化，我们需要在<code>bss</code>段上找到对应大小的空间来保存我们的输入，然后将符号化后的输入导入到伪装的<code>bss</code>段地址处，之后便可以利用之前符号化内存的方式实现解题，我们学到的关键函数为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对应空白 bss 段内空间</span></span><br><span class="line">fake_addr = XXX <span class="comment"># 伪造malloc得来的内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指向伪造内存的指针</span></span><br><span class="line">buffer_addr = XXX <span class="comment"># 输入的存放地址 buffer</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指针指向伪造的内存</span></span><br><span class="line"><span class="comment"># 参数为输入数据存放地址,bss 段伪造的空间</span></span><br><span class="line">initial_state.memory.store(buffer_addr, fake_addr, endness=project.arch.memory_endness) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将伪造的内存符号化</span></span><br><span class="line">initial_state.memory.store(fake_addr, password) <span class="comment"># bss 段伪造的地址,符号化的输入</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数：<code>endness=project.arch.memory_endness</code><br>在默认情况下，<code>angr</code>使用大端格式往内存中写入整数，这个参数告诉<code>angr</code>使用小端格式写入，这是x86的格式</p>
</blockquote>
<h2 id="07-angr-symbolic-file"><a href="#07-angr-symbolic-file" class="headerlink" title="07_angr_symbolic_file"></a>07_angr_symbolic_file</h2><p>看到题目发现里面是一个文件操作，从文件里进行读取数据，而我们需要将文件进行符号化处理，而<code>angr</code>也提供了对应的封装模块来供我们进行调用处理。下面列出其符号化文件的方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始执行地址</span></span><br><span class="line">start_addr = XXX</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;XXX&#x27;</span> <span class="comment"># 文件名称</span></span><br><span class="line">symbolic_file_size_bytes = <span class="number">64</span> <span class="comment"># 文件大小(此处写的是字节),也可以直接写入 bit 之后main初始化向量时不需要 * 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化位向量</span></span><br><span class="line">password = claripy.BVS(<span class="string">&#x27;password&#x27;</span>, symbolic_file_size_bytes * <span class="number">8</span>) <span class="comment"># * 8 将byte进行转换到bits</span></span><br><span class="line">password_file = angr.SimFile(filename, content=password, size=symbolic_file_size_bytes) <span class="comment"># 符号化文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再初始状态中添加一个虚拟的文件系统</span></span><br><span class="line">initial_state = project.factory.blank_state(addr=start_addr, fs=&#123;filename: password_file&#125;) </span><br></pre></td></tr></table></figure>

<p>那么我们就可以直接在第二题的条件约束上扩展，加入这一串对文件进行格式化的操作指令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;../program/07_angr_symbolic_file&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line"></span><br><span class="line">    start_addr = <span class="number">0x080488EA</span></span><br><span class="line"></span><br><span class="line">    filename = <span class="string">&#x27;MRXJKZYR.txt&#x27;</span> <span class="comment"># 文件名称</span></span><br><span class="line">    symbolic_file_size_bytes = <span class="number">64</span> <span class="comment"># 文件大小(字节)</span></span><br><span class="line"></span><br><span class="line">    password = claripy.BVS(<span class="string">&#x27;password&#x27;</span>, symbolic_file_size_bytes * <span class="number">8</span>) <span class="comment"># 初始化位向量</span></span><br><span class="line">    password_file = angr.SimFile(filename, content=password, size=symbolic_file_size_bytes) <span class="comment"># 符号化文件</span></span><br><span class="line"></span><br><span class="line">    initial_state = project.factory.blank_state(addr=start_addr, fs=&#123;filename: password_file&#125;) <span class="comment"># 再初始状态中添加一个虚拟的文件系统</span></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        solution = long_to_bytes(solution_state.solver.<span class="built_in">eval</span>(password))</span><br><span class="line">        <span class="built_in">print</span>(solution.decode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find solution&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>在这节里面我们学会了如何对文件进行符号化，来创建我们的约束求解器，其关键的函数如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 符号化文件</span></span><br><span class="line">password_file = angr.SimFile(filename, content=password, size=symbolic_file_size_bytes)</span><br><span class="line"><span class="comment"># 在初始状态添加一个虚拟的文件系统</span></span><br><span class="line">initial_state = project.factory.blank_state(addr=start_addr, fs=&#123;filename: password_file&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="08-angr-constraints"><a href="#08-angr-constraints" class="headerlink" title="08_angr_constraints"></a>08_angr_constraints</h2><p>把程序拖入进<code>IDA</code>进行分析可以得到如下伪代码，可以看出程序将我们对输入在经过加密后与字符串<code>MRXJKZYRKMKENFZB</code>进行比较值，我们可以轻松的看出目的的比较，但是<code>angr</code>是遍历各个分支来进行模拟的，因此时间开销十分大，我们需要将其进行减小模拟的过程分支来缩短模拟的时间。</p>
<p><img src="https://s2.loli.net/2022/03/17/TfV1sUr6uHZ4Kwv.png"></p>
<p>那么需要怎么操作？我们可以将<code>buffer</code>进行符号化处理，然后让程序来替代我们加密，之后我们切换到<code>angr</code>中，由我们来对加密后的数据进行检验，看是否与目的字符串相等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前半段与之前的方式一样，对输入的数据符号化，载入内存</span></span><br><span class="line"><span class="comment"># 之后进行模拟到检查函数之前</span></span><br><span class="line">addr_to_check_constraint = <span class="number">0x08048669</span></span><br><span class="line">simulation.explore(find=addr_to_check_constraint)</span><br></pre></td></tr></table></figure>

<p>此时我们需要转移到判断加密后的数据上：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">	<span class="comment"># 加密后的password的地址</span></span><br><span class="line">    constrained_parameter_addr = <span class="number">0x0804A050</span> <span class="comment"># 即输入字符串保存的地址</span></span><br><span class="line">    constrained_parameter_size_bytes = <span class="number">16</span>   <span class="comment"># password的长度(字节)</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment"># 从内存中加载password  ( 输入 )</span></span><br><span class="line">    constrained_parameter_bitvector = solution_state.memory.load(constrained_parameter_addr,constrained_parameter_size_bytes)</span><br><span class="line">    </span><br><span class="line">	<span class="comment"># 对比的字符串</span></span><br><span class="line">    constrained_parameter_desired_value = <span class="string">&#x27;MRXJKZYRKMKENFZB&#x27;</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment"># 约束表达式</span></span><br><span class="line">    constrained_expression = constrained_parameter_bitvector == constrained_parameter_desired_value                 </span><br><span class="line"> 	</span><br><span class="line">    <span class="comment"># 添加约束</span></span><br><span class="line">    solution_state.add_constraints(constrained_expression)</span><br><span class="line"></span><br><span class="line">    solution = long_to_bytes(solution_state.se.<span class="built_in">eval</span>(password))</span><br><span class="line">    <span class="built_in">print</span>(solution.decode())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the sokution&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;../program/08_angr_constraints&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line"></span><br><span class="line">    start_addr = <span class="number">0x08048625</span> <span class="comment"># 在输入函数之后</span></span><br><span class="line">    initial_state = project.factory.blank_state(addr=start_addr)</span><br><span class="line"></span><br><span class="line">    password = claripy.BVS(<span class="string">&#x27;password&#x27;</span>, <span class="number">16</span>*<span class="number">8</span>)</span><br><span class="line">    password_addr = <span class="number">0x0804A050</span></span><br><span class="line">    initial_state.memory.store(password_addr, password)</span><br><span class="line"></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">    addr_to_check_constraint = <span class="number">0x08048669</span> <span class="comment"># 在检查函数之前</span></span><br><span class="line">    simulation.explore(find=addr_to_check_constraint)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        constrained_parameter_addr = <span class="number">0x0804A050</span> <span class="comment"># 加密后的password的地址</span></span><br><span class="line">        constrained_parameter_size_bytes = <span class="number">16</span>   <span class="comment"># password的长度(字节)</span></span><br><span class="line">        constrained_parameter_bitvector = solution_state.memory.load(constrained_parameter_addr, constrained_parameter_size_bytes)  <span class="comment"># 从内存中加载password</span></span><br><span class="line"></span><br><span class="line">        constrained_parameter_desired_value = <span class="string">&#x27;MRXJKZYRKMKENFZB&#x27;</span>  <span class="comment"># reference string</span></span><br><span class="line"></span><br><span class="line">        constrained_expression = constrained_parameter_bitvector == constrained_parameter_desired_value                               <span class="comment"># 约束表达式</span></span><br><span class="line"></span><br><span class="line">        solution_state.add_constraints(constrained_expression)    <span class="comment"># 添加约束</span></span><br><span class="line"></span><br><span class="line">        solution = long_to_bytes(solution_state.se.<span class="built_in">eval</span>(password))</span><br><span class="line">        <span class="built_in">print</span>(solution.decode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the sokution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>在这一个题目中我们学会了将<code>angr</code>的遍历范围进行约束，来提升求解速度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从内存中加载password</span></span><br><span class="line">constrained_parameter_bitvector = solution_state.memory.load(constrained_parameter_addr, constrained_parameter_size_bytes) <span class="comment"># 参数为目标值的加载的地址，字节数大小</span></span><br><span class="line"><span class="comment"># 添加约束</span></span><br><span class="line">constrained_expression = XXX <span class="comment"># 条件表达式</span></span><br><span class="line">solution_state.add_constraints(constrained_expression)   </span><br></pre></td></tr></table></figure>

<h2 id="09-angr-hooks"><a href="#09-angr-hooks" class="headerlink" title="09_angr_hooks"></a>09_angr_hooks</h2><p>拖入<code>IDA</code>分析，可以看到程序是由两个输入组成，当第一个输入错误时便会退出，其中第一次的输入经过加密后需要等于<code>password</code>，第二次的输入需要等于加密后的<code>password</code></p>
<p><img src="https://s2.loli.net/2022/03/18/PATtI6wEYSkDRmX.png"></p>
<p>我们观察一下程序中需要<code>hook</code>的函数，可以看到程序执行的是进行比较字符串的操作，返回的是一个<code>bool</code>类型的数据，对此我们可以直接自己创建一个函数来进行直接比较并返回对应<code>bool</code>值，而不需要通过程序一个个的遍历判断，下面展示如何实现一个<code>hook</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绕过函数的地址</span></span><br><span class="line">check_equals_caller_addr = <span class="number">0x080486A9</span></span><br><span class="line"><span class="comment"># 通过 hook 跳过目标函数的长度</span></span><br><span class="line">instruction_to_skip_length = <span class="number">0x080486BB</span> - <span class="number">0x080486A9</span></span><br><span class="line"><span class="comment"># 创建一个 hook 函数</span></span><br><span class="line"><span class="meta">@project.hook(<span class="params">check_equals_caller_addr, instruction_to_skip_length</span>) </span><span class="comment"># 参数为绕过函数的地址,绕过函数长度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">skip_check_equals</span>(<span class="params">state</span>):</span></span><br><span class="line">    user_input_buffer_addr = <span class="number">0x0804A054</span>	<span class="comment"># 保存输入变量地址</span></span><br><span class="line">    user_input_buffer_length = <span class="number">16</span>	<span class="comment"># 第一个 scanf 的输入长度，此处为字节大小</span></span><br><span class="line">    <span class="comment"># 将输入载入内存</span></span><br><span class="line">    user_input_string = state.memory.load(</span><br><span class="line">        user_input_buffer_addr,</span><br><span class="line">        user_input_buffer_length</span><br><span class="line">    )</span><br><span class="line">	<span class="comment"># 目的字符串</span></span><br><span class="line">    check_against_string = <span class="string">&#x27;MRXJKZYRKMKENFZB&#x27;</span></span><br><span class="line">	<span class="comment"># 创建判断条件 -&gt; 字符串的比较</span></span><br><span class="line">    state.regs.eax = claripy.If(</span><br><span class="line">        user_input_string == check_against_string,</span><br><span class="line">        claripy.BVV(<span class="number">1</span>, <span class="number">32</span>), <span class="comment"># 程序的返回值是给寄存器 eax 保存</span></span><br><span class="line">        claripy.BVV(<span class="number">0</span>, <span class="number">32</span>) <span class="comment"># eax 为 32 bit 的寄存器，所以大小设置为 32</span></span><br><span class="line">    )  <span class="comment"># claripy.BVV(返回数据,返回 bit 大小)      </span></span><br><span class="line"><span class="comment"># 开始模拟</span></span><br><span class="line">simulation = project.factory.simgr(initial_state)</span><br></pre></td></tr></table></figure>

<p>那么程序的关键部分也便实现了，我们可以编写如下脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;./09_angr_hooks&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line"></span><br><span class="line">    initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绕过函数的地址</span></span><br><span class="line">    check_equals_caller_addr = <span class="number">0x080486A9</span></span><br><span class="line">    <span class="comment"># 通过 hook 跳过目标函数的长度</span></span><br><span class="line">    instruction_to_skip_length = <span class="number">0x080486BB</span> - <span class="number">0x080486A9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个 hook 函数</span></span><br><span class="line">    <span class="comment"># 参数为绕过函数的地址,绕过函数长度</span></span><br><span class="line"><span class="meta">    @project.hook(<span class="params">check_equals_caller_addr, length = instruction_to_skip_length</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_check_equals</span>(<span class="params">state</span>):</span></span><br><span class="line">        user_input_buffer_addr = <span class="number">0x0804A054</span>  <span class="comment"># 保存输入变量地址</span></span><br><span class="line">        user_input_buffer_length = <span class="number">16</span>  <span class="comment"># 第一个 scanf 的输入长度，此处为字节大小</span></span><br><span class="line">        <span class="comment"># 将输入载入内存</span></span><br><span class="line">        user_input_string = state.memory.load(</span><br><span class="line">            user_input_buffer_addr,</span><br><span class="line">            user_input_buffer_length</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 目的字符串</span></span><br><span class="line">        check_against_string = <span class="string">&#x27;MRXJKZYRKMKENFZB&#x27;</span></span><br><span class="line">        <span class="comment"># 创建判断条件 -&gt; 字符串的比较</span></span><br><span class="line">        <span class="comment"># 同时设定返回值</span></span><br><span class="line">        state.regs.eax = claripy.If(</span><br><span class="line">            user_input_string == check_against_string,</span><br><span class="line">            claripy.BVV(<span class="number">1</span>, <span class="number">32</span>),  <span class="comment"># 程序的返回值是给寄存器 eax 保存</span></span><br><span class="line">            claripy.BVV(<span class="number">0</span>, <span class="number">32</span>)  <span class="comment"># eax 为 32 bit 的寄存器，所以大小设置为 32</span></span><br><span class="line">        )  <span class="comment"># claripy.BVV(返回数据,返回 bit 大小)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line">    <span class="comment"># 开始模拟</span></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        solution = solution_state.posix.dumps(sys.stdin.fileno())</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(solution.decode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>通过这个例子我们学会了使用<code>hook</code>来代替程序中的函数，并执行我们自己构造的函数。其关键函数如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 hook 函数</span></span><br><span class="line"><span class="comment"># 参数为绕过函数的地址,绕过函数长度</span></span><br><span class="line"><span class="meta">@project.hook(<span class="params">check_equals_caller_addr, length = instruction_to_skip_length</span>)</span></span><br><span class="line"><span class="comment"># 创建判断条件 -&gt; 字符串的比较</span></span><br><span class="line"><span class="comment"># 同时设定返回值</span></span><br><span class="line">state.regs.eax = claripy.If(</span><br><span class="line">    user_input_string == check_against_string, <span class="comment"># 创建判断语句</span></span><br><span class="line">    claripy.BVV(<span class="number">1</span>, <span class="number">32</span>),  <span class="comment"># 程序的返回值是给寄存器 eax 保存</span></span><br><span class="line">    claripy.BVV(<span class="number">0</span>, <span class="number">32</span>)  <span class="comment"># eax 为 32 bit 的寄存器，所以大小设置为 32</span></span><br><span class="line">)  <span class="comment"># claripy.BVV(返回数据,返回 bit 大小)</span></span><br></pre></td></tr></table></figure>

<h2 id="10-angr-simprocedures"><a href="#10-angr-simprocedures" class="headerlink" title="10_angr_simprocedures"></a>10_angr_simprocedures</h2><p>上一道题目我们是只利用一个<code>hook</code>进行模拟了一个函数，但是在这个题目里面我们可以找到许许多多的函数，如果一个个写会累死的 ( bushi )</p>
<p><img src="https://s2.loli.net/2022/03/18/FtN9GgJP5QwnUuA.png"></p>
<p>所以在这个题目中我们需要想办法<code>hook</code>一片的函数，那么我们为什么不想一下我们把名字<code>hook</code>了，意味着每次调用这个相同名字的函数时执行的便是我们自己编写的过程。实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个类</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">mySimPro</span>(<span class="params">angr.SimProcedure</span>):</span></span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, user_input_addr, user_input_length</span>):</span></span><br><span class="line">           <span class="comment"># angr 输入的符号向量</span></span><br><span class="line">           angr_bvs = self.state.memory.load(</span><br><span class="line">               user_input_addr,</span><br><span class="line">               user_input_length</span><br><span class="line">           )</span><br><span class="line">           <span class="comment"># 目标字符串</span></span><br><span class="line">           desired = <span class="string">&#x27;MRXJKZYRKMKENFZB&#x27;</span></span><br><span class="line">           <span class="keyword">return</span> claripy.If(</span><br><span class="line">               desired == angr_bvs, <span class="comment"># 条件判断</span></span><br><span class="line">               claripy.BVV(<span class="number">1</span>,<span class="number">32</span>), <span class="comment"># 返回值设置</span></span><br><span class="line">               claripy.BVV(<span class="number">0</span>,<span class="number">32</span>)</span><br><span class="line">           )</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># hook 的函数名</span></span><br><span class="line">   check_symbol = <span class="string">&#x27;check_equals_MRXJKZYRKMKENFZB&#x27;</span></span><br><span class="line">   <span class="comment"># 创建 hook</span></span><br><span class="line">   project.hook_symbol(check_symbol,mySimPro())    <span class="comment"># 创建一个类来继承 angr.SimProcedure</span></span><br><span class="line">   simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么脚本编写如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pydoc <span class="keyword">import</span> describe</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;./09_angr_hooks&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line">    initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">mySimPro</span>(<span class="params">angr.SimProcedure</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, user_input_addr, user_input_length</span>):</span></span><br><span class="line">            <span class="comment"># angr 输入的符号向量</span></span><br><span class="line">            angr_bvs = self.state.memory.load(</span><br><span class="line">                user_input_addr,</span><br><span class="line">                user_input_length</span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># 目标字符串</span></span><br><span class="line">            desired = <span class="string">&#x27;MRXJKZYRKMKENFZB&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> claripy.If(</span><br><span class="line">                desired == angr_bvs, <span class="comment"># 条件判断</span></span><br><span class="line">                claripy.BVV(<span class="number">1</span>,<span class="number">32</span>), <span class="comment"># 返回值设置</span></span><br><span class="line">                claripy.BVV(<span class="number">0</span>,<span class="number">32</span>)</span><br><span class="line">            )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># hook 的函数名</span></span><br><span class="line">    check_symbol = <span class="string">&#x27;check_equals_MRXJKZYRKMKENFZB&#x27;</span></span><br><span class="line">    <span class="comment"># 创建 hook</span></span><br><span class="line">    project.hook_symbol(check_symbol,mySimPro())    <span class="comment"># 创建一个类来继承 angr.SimProcedure</span></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        solution = solution_state.posix.dumps(sys.stdin.fileno())</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(solution.decode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这道题目中我们学习了如何<code>hook</code>一个函数名，从而使程序在每次运行到这个函数名时执行的都是我们<code>hook</code>后的函数，对此我们利用继承的方式对其进行<code>hook</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplacementCheckEquals</span>(<span class="params">angr.SimProcedure</span>):</span> <span class="comment"># 继承angr的SimProcedure类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, to_check, length</span>):</span>             <span class="comment"># 模拟 angr 的输入</span></span><br><span class="line">        user_input_buffer_addr = to_check</span><br><span class="line">        user_input_buffer_length = length</span><br><span class="line"></span><br><span class="line">        user_input_string = self.state.memory.load(</span><br><span class="line">            user_input_buffer_addr,</span><br><span class="line">            user_input_buffer_length</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        check_against_string = XXX <span class="comment"># 检查函数，来判断输入的正确与否 </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> claripy.If(</span><br><span class="line">            user_input_string == check_against_string,</span><br><span class="line">            claripy.BVV(<span class="number">1</span>, <span class="number">32</span>), <span class="comment"># 返回值 返回值的 bit 位大小</span></span><br><span class="line">            claripy.BVV(<span class="number">0</span>, <span class="number">32</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 没去符号名时</span></span><br><span class="line">check_equals_symbol = <span class="string">&#x27;check_equals_MRXJKZYRKMKENFZB&#x27;</span> <span class="comment"># 函数名</span></span><br><span class="line">project.hook_symbol(check_equals_symbol, ReplacementCheckEquals())</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># hook原来的check函数，也可以使用上面的代码，但是如果程序去符号的话，就只能这种方法</span></span><br><span class="line">check_equals_addr = XXX</span><br><span class="line">project.hook(check_equals_addr, ReplacementCheckEquals())  <span class="comment"># 目标函数的地址,继承了angr.SimProcedure的类名</span></span><br></pre></td></tr></table></figure>

<h2 id="11-angr-sim-scanf"><a href="#11-angr-sim-scanf" class="headerlink" title="11_angr_sim_scanf"></a>11_angr_sim_scanf</h2><p>随着<code>angr</code>的更新迭代，似乎逐渐支持了<code>scanf</code>这一类的函数，可以不需要手动模拟<code>scanf</code>，<code>angr</code>可以直接自动化模拟，问了一下草莓师傅，似乎<code>angr</code>现在还能自动<code>hook</code>，关于这个我也没有去测试过，也不是太了解这些。</p>
<p>根据题目要求，需要我们模拟<code>scanf</code>来进行模拟输入，实现方式似乎类似于<code>hook</code>函数名，同样需要我们进行继承<code>angr</code>下的<code>SimpProcedure</code>，只是里面的一些函数发生了变化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplacementScanf</span>(<span class="params">angr.SimProcedure</span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, fmt, scanf0_addr, scanf1_addr</span>):</span></span><br><span class="line">        scanf0 = claripy.BVS(<span class="string">&#x27;scanf0&#x27;</span>, <span class="number">4</span>*<span class="number">8</span>) <span class="comment"># 符号化输入</span></span><br><span class="line">        scanf1 = claripy.BVS(<span class="string">&#x27;scanf1&#x27;</span>, <span class="number">4</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">        self.state.memory.store(scanf0_addr, scanf0, endness=project.arch.memory_endness) <span class="comment"># 将输入保存到内存空间</span></span><br><span class="line">        self.state.memory.store(scanf1_addr, scanf1, endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">        self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>] = scanf0 <span class="comment"># 将scanf0和scanf1保存到当前状态</span></span><br><span class="line">        self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>] = scanf1</span><br><span class="line">    </span><br><span class="line">    scanf_symbol = <span class="string">&#x27;__isoc99_scanf&#x27;</span>  <span class="comment"># 类似于 hook 函数名的方式</span></span><br><span class="line">    project.hook_symbol(scanf_symbol, ReplacementScanf())</span><br><span class="line"></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过上述模拟可以将输入的字符串保存到内存空间，那么我们便可以写出如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;../program/11_angr_sim_scanf&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line"></span><br><span class="line">    initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ReplacementScanf</span>(<span class="params">angr.SimProcedure</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, fmt, scanf0_addr, scanf1_addr</span>):</span></span><br><span class="line">            scanf0 = claripy.BVS(<span class="string">&#x27;scanf0&#x27;</span>, <span class="number">4</span>*<span class="number">8</span>)</span><br><span class="line">            scanf1 = claripy.BVS(<span class="string">&#x27;scanf1&#x27;</span>, <span class="number">4</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">            self.state.memory.store(scanf0_addr, scanf0, endness=project.arch.memory_endness)</span><br><span class="line">            self.state.memory.store(scanf1_addr, scanf1, endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">            self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>] = scanf0 <span class="comment"># 将scanf0和scanf1保存到当前状态</span></span><br><span class="line">            self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>] = scanf1</span><br><span class="line"></span><br><span class="line">    scanf_symbol = <span class="string">&#x27;__isoc99_scanf&#x27;</span> </span><br><span class="line">    project.hook_symbol(scanf_symbol, ReplacementScanf())</span><br><span class="line"></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        solution0 = solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>] <span class="comment">#从当前状态取出scanf0和scanf1</span></span><br><span class="line">        solution1 = solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        solution = <span class="string">&#x27;%u %u&#x27;</span> % (solution_state.se.<span class="built_in">eval</span>(solution0), solution_state.se.<span class="built_in">eval</span>(solution1))</span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>我们在这个题中同样利用到了符号化函数名的方式来对一堆的<code>scanf</code>进行模拟，并将其保存在内存段里，具体函数如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>] = scanf0 <span class="comment"># 将 scanf0 进行保存</span></span><br><span class="line">solution0 = solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>] <span class="comment"># 从当前状态取出 scanf0 </span></span><br></pre></td></tr></table></figure>

<h2 id="12-angr-veritesting"><a href="#12-angr-veritesting" class="headerlink" title="12_angr_veritesting"></a>12_angr_veritesting</h2><p>在这个题目中与<code>01</code>的<code>avoid</code>来约束目标输出字符串，但是这个题目中循环的次数较大，如果直接套用<code>01</code>的脚本可能会出现路径爆炸 ( <code>angr</code>模拟执行时遍历的路径是成指数级上涨，如果都需要需要执行那么便会引发错误 )，我们之前所做的<code>hook</code>函数，添加约束条件都是有效的防止路径爆炸的操作，我们接下来采用一个新的方式来解决路径爆炸的问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sm=p.factory.simulation_manager(istate,veritesting=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>这个函数让我们直接忽视循环结构，直接进行求解，一般耗时会比较长。</p>
<p>加入这个防止路径爆炸的脚本为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;../program/12_angr_veritesting&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line"></span><br><span class="line">    initial_state = project.factory.entry_state()</span><br><span class="line">    simulation = project.factory.simgr(initial_state, veritesting=<span class="literal">True</span>) <span class="comment"># 设置自动合并路径</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        solution = solution_state.posix.dumps(sys.stdin.fileno())</span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="13-angr-static-binary"><a href="#13-angr-static-binary" class="headerlink" title="13_angr_static_binary"></a>13_angr_static_binary</h2><p>这个示例的逻辑和<code>01</code>题是一样的,主要不同的地方是在于这个程序是静态链接编译的,所以程序中包含了一些<code>libc</code>的函数实现,但是这里可能会存在两个问题:</p>
<ol>
<li><p>这些函数里面隐藏一些出题人的坑;</p>
</li>
<li><p>这些函数里面的实现可能会依赖其他的系统函数或者实现方式不相同.所以<code>12</code> 题主要是让我们通过<code>Hook</code> 的方式重定向函数中被调用的<code>libc</code> 的函数</p>
</li>
</ol>
<p>首先,Linux 下启动main() 函数需要通过<code>__libc_start_main</code> 对程序进行初始化,然后再跳转到<code>main</code>() 函数;其次,在<code>main</code>() 函数里面调用了<code>printf</code> ,<code>scanf</code> ,<code>puts</code> ,所以我们需要通过Hook 来重定向它们.</p>
<p>幸运的是,我们不需要重新实现这些函数的实现,<code>Angr</code> 代码库里面已经帮我们实现了一部分<code>libc</code> 的函数库,所以我们只需要倒入它们即可.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">project = angr.Project(sys.argv[<span class="number">1</span>])</span><br><span class="line">initial_state = project.factory.entry_state()</span><br><span class="line">simulation = project.factory.simgr(initial_state,veritesting = <span class="literal">True</span>) <span class="comment"># 开启自动合并路径</span></span><br><span class="line"></span><br><span class="line">project.hook(<span class="number">0x804ed40</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;printf&#x27;</span>]()) <span class="comment"># hook库函数</span></span><br><span class="line">project.hook(<span class="number">0x804ed80</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;scanf&#x27;</span>]())</span><br><span class="line">project.hook(<span class="number">0x804f350</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;puts&#x27;</span>]())</span><br><span class="line">project.hook(<span class="number">0x8048d10</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;glibc&#x27;</span>][<span class="string">&#x27;__libc_start_main&#x27;</span>]())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">  stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)  <span class="comment"># :boolean</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">  stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Try again.&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)  <span class="comment"># :boolean</span></span><br><span class="line"></span><br><span class="line">simulation.explore(find = is_successful,avoid = should_abort)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found :</span><br><span class="line">  solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">  <span class="built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过上述题目，我们了解到了如何将静态链接中的库函数进行<code>hook</code>，从而来获取<code>libc</code> 的函数库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">project.hook(&lt;调用地址&gt;, angr.SIM_PROCEDURES[&#x27;&lt;系统库名&gt;&#x27;][&#x27;&lt;系统函数名&gt;&#x27;]()) # hook库函数</span><br><span class="line">angr.SIM_PROCEDURES[ 系统库名 ] [ 系统函数名 ] ()  =&gt;  获取Angr 内部实现的系统函数</span><br></pre></td></tr></table></figure>

<h2 id="14-angr-shared-library"><a href="#14-angr-shared-library" class="headerlink" title="14_angr_shared_library"></a>14_angr_shared_library</h2><p>在编译好的程序中我们可以看到有一个<code>validate</code>函数对我们的输入进行了比较，但是进入这个函数却发现没有相关的实现方式</p>
<p><img src="https://s2.loli.net/2022/03/19/yf7C86Ta5RK3dVM.png"></p>
<p>这是因为<code>validate</code>在共享库里，即程序提供的<code>so</code>中，事实上<code>so</code>也算是一种可执行文件，但是没有经过符号链接，我们需要的便是通过<code>angr</code>加载共享库，然后伪造参数来对<code>validate</code>函数进行调用。</p>
<img src="https://s2.loli.net/2022/03/19/ehHok7qsmRiV3O8.png" style="zoom:100%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  path_to_binary = sys.argv[<span class="number">1</span>]  <span class="comment">#  注意我们是要load so 库而不是执行程序</span></span><br><span class="line"></span><br><span class="line">  base = <span class="number">0x400000</span>  <span class="comment">#  base 基址是随意定的,可以随意修改</span></span><br><span class="line">  project = angr.Project(path_to_binary, load_options=&#123;</span><br><span class="line">    <span class="string">&#x27;main_opts&#x27;</span> : &#123;</span><br><span class="line">      <span class="string">&#x27;custom_base_addr&#x27;</span> : base</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  buffer_pointer = claripy.BVV(<span class="number">0x3000000</span>, <span class="number">32</span>)  <span class="comment">#  创建一个buffer 指针值</span></span><br><span class="line">  validate_function_address = base + <span class="number">0x6D7</span></span><br><span class="line">  initial_state = project.factory.call_state(validate_function_address, buffer_pointer,claripy.BVV(<span class="number">8</span>, <span class="number">32</span>))  <span class="comment">#  调用validate_function,因为函数声明validata_function(buffer_point,buffer_length) ,所以我们构造出调用validata_function(0x3000000,0x8) .</span></span><br><span class="line"></span><br><span class="line">  password = claripy.BVS(<span class="string">&#x27;password&#x27;</span>, <span class="number">8</span> * <span class="number">8</span>)  <span class="comment">#  创建一个求解对象,大小为8 字节</span></span><br><span class="line">  initial_state.memory.store(buffer_pointer, password)  <span class="comment">#  保存到0x30000000</span></span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">  simulation.explore(find = base + <span class="number">0x783</span>)  <span class="comment">#  执行到validate 函数的RETN 指令</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    solution_state.add_constraints(solution_state.regs.eax != <span class="number">0</span>)  <span class="comment">#  记得,我们要求validate 函数的返回值为1 的时候就是有解的,那么我们就需要在求解的时候添加上这么一个求解约束条件EAX 不能为False .</span></span><br><span class="line">    solution = solution_state.se.<span class="built_in">eval</span>(password)</span><br><span class="line">    <span class="built_in">print</span>(solution)</span><br></pre></td></tr></table></figure>

<h2 id="15-angr-arbitrary-read"><a href="#15-angr-arbitrary-read" class="headerlink" title="15_angr_arbitrary_read"></a>15_angr_arbitrary_read</h2><p>单纯的从程序上看的话似乎程序一直是输入错误，但是我们到栈上看输入的变量，可以发现读入了<code>20</code>个字符，但是栈空间中到<code>s</code>的距离仅有<code>16</code>，所以意味着多出来的<code>4</code>字节会覆盖<code>s</code>保存的地址，因此我们可以直接用这4字节进行替换到输出正确的地址处。</p>
<img src="https://s2.loli.net/2022/03/19/vPL7lbSEMUpq8zF.png" style="zoom:80%;" />

<p>所以脚本可以如下进行编写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line"></span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ReplacementScanf</span>(<span class="params">angr.SimProcedure</span>):</span>  <span class="comment">#  实现Scanf Hook 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, format_string, check_key_address,input_buffer_address</span>):</span></span><br><span class="line">      scanf0 = claripy.BVS(<span class="string">&#x27;scanf0&#x27;</span>, <span class="number">4</span> * <span class="number">8</span>)   <span class="comment"># check_key</span></span><br><span class="line">      scanf1 = claripy.BVS(<span class="string">&#x27;scanf1&#x27;</span>, <span class="number">20</span> * <span class="number">8</span>)  <span class="comment"># input_buffer</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> char <span class="keyword">in</span> scanf1.chop(bits=<span class="number">8</span>):</span><br><span class="line">        self.state.add_constraints(char &gt;= <span class="string">&#x27;0&#x27;</span>, char &lt;= <span class="string">&#x27;z&#x27;</span>)  <span class="comment">#  对input_buffer 的输入约束</span></span><br><span class="line"></span><br><span class="line">      self.state.memory.store(check_key_address, scanf0, endness=project.arch.memory_endness)</span><br><span class="line">      self.state.memory.store(input_buffer_address, scanf1,endness=project.arch.memory_endness)  <span class="comment">#  保存求解变量到指定的内存中</span></span><br><span class="line"></span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>] = scanf0  <span class="comment">#  保存这两个变量到state 中,后续求解需要用到</span></span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>] = scanf1</span><br><span class="line"></span><br><span class="line">  scanf_symbol = <span class="string">&#x27;__isoc99_scanf&#x27;</span></span><br><span class="line">  project.hook_symbol(scanf_symbol, ReplacementScanf())  <span class="comment">#  Hook scanf 函数</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check_puts</span>(<span class="params">state</span>):</span></span><br><span class="line">    puts_parameter = state.memory.load(state.regs.esp + <span class="number">4</span>, <span class="number">4</span>, endness=project.arch.memory_endness)  <span class="comment">#  获取puts() 函数的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> state.se.symbolic(puts_parameter):  <span class="comment">#  检查这个参数是否为符号化对象</span></span><br><span class="line">      good_job_string_address = <span class="number">0x4D525854B</span></span><br><span class="line"></span><br><span class="line">      copied_state = state.copy()  <span class="comment">#  复制执行状态上下文进行约束求解,不影响原理的执行上下文</span></span><br><span class="line"></span><br><span class="line">      copied_state.add_constraints(puts_parameter == good_job_string_address)  <span class="comment">#  puts 的参数地址是否可以被指定为0x4D525854B ,如果可以的话,那就证明这个值是可控的</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> copied_state.satisfiable():  <span class="comment">#  判断添加了上面这个约束是否有解</span></span><br><span class="line">        state.add_constraints(puts_parameter == good_job_string_address)  <span class="comment">#  如果有解的话就保存到我们执行的那个状态对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">    puts_address = <span class="number">0x8048370</span>  <span class="comment">#  当程序执行到puts() 函数时,我们就认为路径探索到了这里,然后再去通过check_puts() 判断这里是否存在漏洞,告诉Angr这是不是我们需要找的那条执行路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> state.addr == puts_address:</span><br><span class="line">      <span class="keyword">return</span> check_puts(state)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  simulation.explore(find=is_successful)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    solution0 = solution_state.se.<span class="built_in">eval</span>(solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>])</span><br><span class="line">    solution1 = solution_state.se.<span class="built_in">eval</span>(solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>],cast_to=<span class="built_in">bytes</span>)  <span class="comment">#  输出字符串序列化的内容</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(solution0,solution1)</span><br></pre></td></tr></table></figure>

<p>通过这个题目我们可以学习到添加对输入的约束，和复制状态的上下文，以及序列化内容转化为字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">state.copy()  <span class="comment"># 复制状态上下文</span></span><br><span class="line"></span><br><span class="line">state.satisfiable()  <span class="comment"># 判断当前的所有约束是否有解</span></span><br><span class="line"></span><br><span class="line">solution_state.se.<span class="built_in">eval</span>(求解变量,cast_to=<span class="built_in">bytes</span>)  <span class="comment"># 序列化变量内容为字符串</span></span><br></pre></td></tr></table></figure>

<h2 id="16-angr-arbitrary-write"><a href="#16-angr-arbitrary-write" class="headerlink" title="16_angr_arbitrary_write"></a>16_angr_arbitrary_write</h2><p>从程序看，其最终目的是将<code>password_buffer</code>里面的字符替换成<code>KZYRKMKE</code>，但是程序中彬没有指向<code>password_buffer</code>的变量，同时我们也发现与上一个题目一样函数存在溢出的漏洞，所以我们利用这个<code>4字节</code>溢出将目的<code>password_buffer</code>的值修改，达到输出正确的目的。</p>
<img src="https://s2.loli.net/2022/03/19/TwiaAsCQtbV6moY.png" style="zoom:80%;" />

<p>脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ReplacementScanf</span>(<span class="params">angr.SimProcedure</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, format_string, check_key ,input_buffer</span>):</span></span><br><span class="line">      scanf0 = claripy.BVS(<span class="string">&#x27;scanf0&#x27;</span>, <span class="number">4</span> * <span class="number">8</span>)</span><br><span class="line">      scanf1 = claripy.BVS(<span class="string">&#x27;scanf1&#x27;</span>, <span class="number">20</span> * <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> char <span class="keyword">in</span> scanf1.chop(bits=<span class="number">8</span>):</span><br><span class="line">        self.state.add_constraints(char &gt;= <span class="string">&#x27;0&#x27;</span>, char &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"></span><br><span class="line">      self.state.memory.store(check_key, scanf0, endness=project.arch.memory_endness)</span><br><span class="line">      self.state.memory.store(input_buffer, scanf1, endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>] = scanf0</span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>] = scanf1</span><br><span class="line"></span><br><span class="line">  scanf_symbol = <span class="string">&#x27;__isoc99_scanf&#x27;</span></span><br><span class="line">  project.hook_symbol(scanf_symbol, ReplacementScanf())</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check_strncpy</span>(<span class="params">state</span>):</span></span><br><span class="line">    strncpy_dest = state.memory.load(state.regs.esp + <span class="number">4</span>, <span class="number">4</span>, endness=project.arch.memory_endness)  <span class="comment">#  获取strncpy() 的参数,strncpy_dest ..</span></span><br><span class="line">    strncpy_src  = state.memory.load(state.regs.esp + <span class="number">8</span>, <span class="number">4</span>, endness=project.arch.memory_endness)</span><br><span class="line">    strncpy_len  = state.memory.load(state.regs.esp + <span class="number">12</span>, <span class="number">4</span>, endness=project.arch.memory_endness)</span><br><span class="line">    src_contents = state.memory.load(strncpy_src, strncpy_len)  <span class="comment">#  因为参数中只保存了地址,我们需要根据这个地址去获取内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> state.se.symbolic(strncpy_dest) <span class="keyword">and</span> state.se.symbolic(src_contents) :  <span class="comment">#  判断dest 和src 的内容是不是符号化对象</span></span><br><span class="line">      <span class="keyword">if</span> state.satisfiable(extra_constraints=(src_contents[ -<span class="number">1</span> : -<span class="number">64</span> ] == <span class="string">&#x27;KZYRKMKE&#x27;</span> ,strncpy_dest == <span class="number">0x4D52584C</span>)):  <span class="comment">#  尝试求解,其中strncpy_dest == 0x4D52584C 的意思是判断dest 是否可控为password 的地址;src_contents[ -1 : -64 ] == &#x27;KZYRKMKE&#x27; 是判断input_buffer 的内容是否可控为&#x27;KZYRKMKE&#x27; ,因为这块内存是倒序,所以需要通过[ -1 : -64 ] 倒转(contentes 的内容是比特,获取8 字节的大小为:8*8 = 64),然后判断该值是否为字符串&#x27;KZYRKMKE&#x27;</span></span><br><span class="line">        state.add_constraints(src_contents[ -<span class="number">1</span> : -<span class="number">64</span> ] == <span class="string">&#x27;KZYRKMKE&#x27;</span>,strncpy_dest == <span class="number">0x4D52584C</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">    strncpy_address = <span class="number">0x8048410</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> state.addr == strncpy_address:</span><br><span class="line">      <span class="keyword">return</span> check_strncpy(state)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  simulation.explore(find=is_successful)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    solution0 = solution_state.se.<span class="built_in">eval</span>(solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>])</span><br><span class="line">    solution1 = solution_state.se.<span class="built_in">eval</span>(solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>],cast_to=<span class="built_in">bytes</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(solution0,solution1)</span><br></pre></td></tr></table></figure>

<h2 id="17-angr-arbitrary-iump"><a href="#17-angr-arbitrary-iump" class="headerlink" title="17_angr_arbitrary_iump"></a>17_angr_arbitrary_iump</h2><p>一打开程序一看就只有一个输入，和一个输入错误，我们查看其函数，发现在某个地址处可以发现有输出<code>Good</code>，我们可以判断出这个是将<code>ret</code>的返回地址进行覆盖然后跳转到对应的输入正确函数地址处。</p>
<p>脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(</span><br><span class="line">    initial_state,</span><br><span class="line">    save_unconstrained=<span class="literal">True</span>,</span><br><span class="line">    stashes=&#123;</span><br><span class="line">      <span class="string">&#x27;active&#x27;</span> : [initial_state],</span><br><span class="line">      <span class="string">&#x27;unconstrained&#x27;</span> : [],</span><br><span class="line">      <span class="string">&#x27;found&#x27;</span> : [],</span><br><span class="line">      <span class="string">&#x27;not_needed&#x27;</span> : []</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ReplacementScanf</span>(<span class="params">angr.SimProcedure</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, format_string, input_buffer_address</span>):</span></span><br><span class="line">      input_buffer = claripy.BVS(<span class="string">&#x27;input_buffer&#x27;</span>, <span class="number">64</span> * <span class="number">8</span>)  <span class="comment">#  设置一个较大的input_buffer</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> char <span class="keyword">in</span> input_buffer.chop(bits=<span class="number">8</span>):</span><br><span class="line">        self.state.add_constraints(char &gt;= <span class="string">&#x27;0&#x27;</span>, char &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"></span><br><span class="line">      self.state.memory.store(input_buffer_address, input_buffer, endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution&#x27;</span>] = input_buffer</span><br><span class="line"></span><br><span class="line">  scanf_symbol = <span class="string">&#x27;__isoc99_scanf&#x27;</span></span><br><span class="line">  project.hook_symbol(scanf_symbol, ReplacementScanf())  <span class="comment">#  对scanf() 做Hook</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (simulation.active <span class="keyword">or</span> simulation.unconstrained) <span class="keyword">and</span> (<span class="keyword">not</span> simulation.found):  <span class="comment">#  </span></span><br><span class="line">    <span class="keyword">for</span> unconstrained_state <span class="keyword">in</span> simulation.unconstrained:</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">should_move</span>(<span class="params">s</span>):</span></span><br><span class="line">        <span class="keyword">return</span> s <span class="keyword">is</span> unconstrained_state</span><br><span class="line">      </span><br><span class="line">      simulation.move(<span class="string">&#x27;unconstrained&#x27;</span>, <span class="string">&#x27;found&#x27;</span>, filter_func=should_move)  <span class="comment">#  保存</span></span><br><span class="line"></span><br><span class="line">    simulation.step()  <span class="comment">#  步进执行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    solution_state.add_constraints(solution_state.regs.eip == <span class="number">0x4D525849</span>)  <span class="comment">#  判断EIP 地址是否可控</span></span><br><span class="line"></span><br><span class="line">    solution = solution_state.se.<span class="built_in">eval</span>(solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution&#x27;</span>],cast_to = <span class="built_in">bytes</span>)  <span class="comment">#  生成Payload</span></span><br><span class="line">    <span class="built_in">print</span>(solution)</span><br></pre></td></tr></table></figure>


            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        

    <div id='gitalk-container' class="comment link"
		data-enable='true'
        data-ae='true'
        data-ci='01ed89abee289d37f2f8'
        data-cs='51741e819059e2ea7ab6c6f3d0fa0ac631d1d975'
        data-r='equinox-shame.github.io'
        data-o='Equinox-shame'
        data-a='Equinox-shame'
        data-d='false'
    >查看评论</div>


        
    </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
