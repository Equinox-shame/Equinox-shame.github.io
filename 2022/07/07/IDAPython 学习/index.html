
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>IDAPython 学习 - Autumnal</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="IDAPython 背景IDAPython 创建于 2004 年。这是Gergely Erdelyi和Ero Carrera的共同努力。他们的目标 是结合强大的python与自动化分析的IDA的类C,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="Autumnal" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Autumnal</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">IDAPython 学习</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">IDAPython 学习</h1>
        <div class="stuff">
            <span>七月 07, 2022</span>
            

        </div>
        <div class="content markdown">
            <h2 id="IDAPython-背景"><a href="#IDAPython-背景" class="headerlink" title="IDAPython 背景"></a>IDAPython 背景</h2><p><code>IDAPython</code> 创建于 2004 年。这是<code>Gergely Erdelyi</code>和<code>Ero Carrera</code>的共同努力。他们的目标 是结合强大的<code>python</code>与自动化分析的<code>IDA</code>的类<code>C</code>脚本语言<code>IDC</code>。<code>IDAPython</code> 由三个独立模块 组成。第一个是<code>idc</code>，它是封装<code>IDA</code>的<code>IDC</code>函数的兼容性模块。第二个模块是<code>idautils</code>，这是<code>IDA</code>里的一个高级实用函数。第三个模块是<code>idaapi</code>，它允许访问更多低级数据，这些数据能 够被类使用通过<code>IDA</code>。</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:00012529 mov esi, [esp+4+arg_0]</span><br></pre></td></tr></table></figure>

<p><code>text</code>是节的名称，地址是<code>00012529</code>。显示的地址是 16 进制格式。<code>mov</code>这个指令被称作助记符。助记符后面的第一个操作是<code>esi</code>和第二个操作是<code>[esp+4+arg_0]</code>，</p>
<h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p><code>IDAPython</code>文档中地址作为<code>ea</code>被引用，地址可以通过几个不同的函数进行访问：</p>
<p>获取当前的地址</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ea = idc.ScreenEA()</span><br><span class="line">--- 或者 ---</span><br><span class="line">ea = here()</span><br></pre></td></tr></table></figure>

<p>获取最大地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MaxEA()</span><br></pre></td></tr></table></figure>

<p>获取最小地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MinEA()</span><br></pre></td></tr></table></figure>

<p>检测地址是否存在</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; idaapi.BADADDR</span><br><span class="line"><span class="number">4294967295</span></span><br><span class="line">Python&gt; <span class="built_in">hex</span>(idaapi.BADADDR)</span><br><span class="line"><span class="number">0xffffffffL</span></span><br><span class="line">Python&gt; <span class="keyword">if</span> BADADDR != here(): <span class="built_in">print</span>(<span class="string">&quot;valid address&quot;</span>)</span><br><span class="line">valid address</span><br></pre></td></tr></table></figure>

<h2 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h2><p>获取段名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idc.SegName(ea) <span class="comment"># ea是地址</span></span><br></pre></td></tr></table></figure>

<p>获取反汇编字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idc.GetDisasm(ea)</span><br></pre></td></tr></table></figure>

<p>获取操作数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idc.GetOpnd(ea,<span class="number">0</span>) <span class="comment"># 获取第一个操作数</span></span><br><span class="line">idc.GetOpnd(ea,<span class="number">1</span>) <span class="comment"># 获取第二个操作数</span></span><br></pre></td></tr></table></figure>

<h2 id="段"><a href="#段" class="headerlink" title="段"></a>段</h2><p>打印一行作用不大。<code>IDAPython</code>的强大来自于遍历所有的指令，交叉引用地址和搜索代 码或数据。后面两部分将在后面更详细地描述。遍历所有段将是一个不错的开始的位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取所有段名与其开始和结束的地址</span></span><br><span class="line">Python&gt; <span class="keyword">for</span> seg <span class="keyword">in</span> idautils.Segments():</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(idc.SegName(seg), idc.SegStart(seg), idc.SegEnd(seg))</span><br><span class="line">HEADER <span class="number">65536</span> <span class="number">66208</span></span><br><span class="line">.idata <span class="number">66208</span> <span class="number">66636</span></span><br><span class="line">.text <span class="number">66636</span> <span class="number">212000</span></span><br><span class="line">.data <span class="number">212000</span> <span class="number">217088</span></span><br><span class="line">.edata <span class="number">217088</span> <span class="number">217184</span></span><br><span class="line">INIT <span class="number">217184</span> <span class="number">219872</span></span><br><span class="line">.reloc <span class="number">219872</span> <span class="number">225696</span></span><br><span class="line">GAP <span class="number">225696</span> <span class="number">229376</span></span><br></pre></td></tr></table></figure>

<p><code>idautils.Segments()</code>返回一个遍历类型对象，我们可以循环这个对象通过使用一个<code>for</code>循 环。列表中的每个项都是段的起始地址。如果我们把它作为作为一个参数去调用<code>idc.SegName(ea)</code>，地址可以被用来获取名称。开始和结束的段可以通过调用<code>idc.SegStart(ea)</code>或<code>idc.SegEnd(ea)</code>获得。地址或<code>ea</code>需要位于段的开始或结束的范围内。如果我们不想遍历所有段，但想找到下一段我们可以使用<code>idc.NextSeg(ea)</code>。地址可以是段范围内的任何我们希望找到的下一段的地址。如果有机会我们想要通过名称获取一个段的开始地址，我们可以使用<code>idc.SegByName(segname)</code>。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>既然我们知道如何遍历所有段，我们就应该研究如何遍历所有已知函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 遍历所有函数的地址和函数名</span></span><br><span class="line">Python&gt; <span class="keyword">for</span> func <span class="keyword">in</span> idautils.Functions():</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="built_in">hex</span>(func), idc.GetFunctionName(func))</span><br><span class="line">Python&gt;</span><br><span class="line"><span class="number">0x401000</span> ?DefWindowProcA@CWnd@@MAEJIIJ@Z</span><br><span class="line"><span class="number">0x401006</span> ?LoadFrame@CFrameWnd@@UAEHIKPAVCWnd@@PAUCCreateContext@@@Z</span><br><span class="line"><span class="number">0x40100c</span> ??<span class="number">2</span>@YAPAXI@Z</span><br><span class="line"><span class="number">0x401020</span> save_xored</span><br><span class="line"><span class="number">0x401030</span> sub_401030</span><br><span class="line">....</span><br><span class="line"><span class="number">0x45c7b9</span> sub_45C7B9</span><br><span class="line"><span class="number">0x45c7c3</span> sub_45C7C3</span><br><span class="line"><span class="number">0x45c7cd</span> SEH_44A590</span><br><span class="line"><span class="number">0x45c7e0</span> unknown_libname_14</span><br><span class="line"><span class="number">0x45c7ea</span> SEH_43EE30</span><br></pre></td></tr></table></figure>

<p><code>idautils.Functions()</code>将返回一个已知函数列表。这个列表将包含起始地址的每一个函数。 <code>idautils.Functions()</code>可传递的参数范围内搜索。如果我们想要搜索可以通过开始地址和结束地址<code>idautils.Funtions(start_addr, end_addr)</code>。 获得一个函数的名称我们使用<code>idc.GetFunctionName(ea)</code>。<code>ea</code>可以是函数边界的任何地址。<code>IDAPython</code>含有大量的<code>API</code>集合提供使用的函数。让我们从一个简单的功能开始。这个函数的语义不重要，但我们应该在心里创建一个地址的记录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:0045C7C3 sub_45C7C3 proc near</span><br><span class="line">.text:0045C7C3 mov eax, [ebp-60h]</span><br><span class="line">.text:0045C7C6 push eax ; void *</span><br><span class="line">.text:0045C7C7 call w_delete</span><br><span class="line">.text:0045C7CC retn</span><br><span class="line">.text:0045C7CC sub_45C7C3 endp</span><br></pre></td></tr></table></figure>

<p>获得边界我们可以使用<code>idaapi.get_func(ea)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取当前 ea 地址处函数的地址范围</span></span><br><span class="line">Python&gt; func = idaapi.get_func(ea)</span><br><span class="line">Python&gt; <span class="built_in">type</span>(func)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">idaapi</span>.<span class="title">func_t</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">Python</span>&gt; <span class="title">print</span>(<span class="params"><span class="string">&quot;Start: 0x%x, End: 0x%x&quot;</span> % (<span class="params">func.startEA,</span></span></span></span><br><span class="line"><span class="params"><span class="params"><span class="class">func.endEA</span>)</span>)</span></span><br><span class="line"><span class="class"><span class="title">Start</span>:</span> <span class="number">0x45c7c3</span>, End: <span class="number">0x45c7cd</span></span><br></pre></td></tr></table></figure>

<p><code>idaapi.get_func(ea)</code>返回一个类的<code>idaapi.func_t</code>。有时它并不总是显而易见的如何使用一 个类的返回通过一个函数调用。一个有用的命令去查询在<code>Python</code>中的类是<code>dir(class)</code>函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; <span class="built_in">dir</span>(func)</span><br><span class="line">[<span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__del__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;__swig_destroy__&#x27;</span>, <span class="string">&#x27;__weakref__&#x27;</span>, <span class="string">&#x27;_print&#x27;</span>, <span class="string">&#x27;analyzed_sp&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;argsize&#x27;</span>, <span class="string">&#x27;clear&#x27;</span>, <span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;compare&#x27;</span>, <span class="string">&#x27;contains&#x27;</span>, <span class="string">&#x27;does_return&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;empty&#x27;</span>, <span class="string">&#x27;endEA&#x27;</span>, <span class="string">&#x27;extend&#x27;</span>, <span class="string">&#x27;flags&#x27;</span>, <span class="string">&#x27;fpd&#x27;</span>, <span class="string">&#x27;frame&#x27;</span>, <span class="string">&#x27;frregs&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;frsize&#x27;</span>, <span class="string">&#x27;intersect&#x27;</span>, <span class="string">&#x27;is_far&#x27;</span>, <span class="string">&#x27;llabelqty&#x27;</span>, <span class="string">&#x27;llabels&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;overlaps&#x27;</span>, <span class="string">&#x27;owner&#x27;</span>, <span class="string">&#x27;pntqty&#x27;</span>, <span class="string">&#x27;points&#x27;</span>, <span class="string">&#x27;referers&#x27;</span>, <span class="string">&#x27;refqty&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;regargqty&#x27;</span>, <span class="string">&#x27;regargs&#x27;</span>, <span class="string">&#x27;regvarqty&#x27;</span>, <span class="string">&#x27;regvars&#x27;</span>, <span class="string">&#x27;size&#x27;</span>, <span class="string">&#x27;startEA&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;tailqty&#x27;</span>, <span class="string">&#x27;tails&#x27;</span>, <span class="string">&#x27;this&#x27;</span>, <span class="string">&#x27;thisown&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>从这个输出我们能明白<code>startEA</code>和<code>endEA</code>用来访问函数的开始和结束。这些属性只适用于当前函 数。如果我们想要访问其他函数我们可以使用<code>idc.NextFunction(ea)</code>(下一个函数)和<code>idc.PrevFunction(ea)</code>(上一个函数)。<code>ea</code>的值仅需要在分析的函数的边界的地址里。枚举函数的一个警告是，只有当<code>IDA</code>将代码块标识为函数时，它才起作用。在代码块被标记为一个函数之前，它将在函数枚举过程中跳过。未标记为函数的代码将在图例中标记为红色(顶部的颜色栏)。这些可以手动固定或自动。<code>IDAPython</code>有很多不同的方法来访问相同的数据。访问边界内的一种常见的方法是使用 一个函数<code>idc.GetFunctionAttr(ea, FUNCATTR_START)</code>和<code>idc.GetFunctionAttr(ea, FUNCATTR_END)</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; ea = here()</span><br><span class="line">Python&gt; start = idc.GetFunctionAttr(ea, FUNCATTR_START)</span><br><span class="line">Python&gt; end = idc.GetFunctionAttr(ea, FUNCATTR_END)</span><br><span class="line">Python&gt; cur_addr = start</span><br><span class="line">Python&gt; <span class="keyword">while</span> cur_addr &lt;= end:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="built_in">hex</span>(cur_addr), idc.GetDisasm(cur_addr))</span><br><span class="line"><span class="meta">... </span>cur_addr = idc.NextHead(cur_addr, end)</span><br><span class="line">Python&gt;</span><br><span class="line"><span class="number">0x45c7c3</span> mov eax, [ebp-60h]</span><br><span class="line"><span class="number">0x45c7c6</span> push eax ; void *</span><br><span class="line"><span class="number">0x45c7c7</span> call w_delete</span><br><span class="line"><span class="number">0x45c7cc</span> retn</span><br></pre></td></tr></table></figure>

<p><code>idc.GetFunctionAttr(ea, attr)</code>是用来获取开始和结束的函数，然后我们打印当前地址和反 汇编通常使用<code>idc.GetDisasm(ea)</code>。我们使用<code>idc.NextHead(eax)</code>来获取下个指令的开始和继续直到我们到达这个函数的末尾。这种方式的一个缺陷是包含在开始和结束的功能边界。如果 有一个跳转地址高于函数的末尾循环也将过早的退出。这些类型的跳转在混淆技术(如代码转换)中非常常见。由于边界是不可靠的最好的实践是调用 <code>idautils.FuncItems(ea)</code>去循环函 数的每个地址。我们将进入更详细的关于这个方法在下面的部分。类似于<code>idc.GetFunctionAttr(ea, attr)</code>另一个有用的函数收集有关于函数的信息是<code>GetFunctionFlags(ea)</code>。它可以用来检索有关函数的信息，如库代码或函数不返回值。一个函数可能有 9 个标志。如果我们想列举所有的功能，我们可以使用以下代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; <span class="keyword">import</span> idautils</span><br><span class="line">Python&gt; <span class="keyword">for</span> func <span class="keyword">in</span> idautils.Functions():</span><br><span class="line"><span class="meta">... </span>flags = idc.GetFunctionFlags(func)</span><br><span class="line"><span class="meta">... </span><span class="keyword">if</span> flags &amp; FUNC_NORET:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="built_in">hex</span>(func), <span class="string">&quot;FUNC_NORET&quot;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">if</span> flags &amp; FUNC_FAR:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="built_in">hex</span>(func), <span class="string">&quot;FUNC_FAR&quot;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">if</span> flags &amp; FUNC_LIB:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="built_in">hex</span>(func), <span class="string">&quot;FUNC_LIB&quot;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">if</span> flags &amp; FUNC_STATIC:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="built_in">hex</span>(func), <span class="string">&quot;FUNC_STATIC&quot;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">if</span> flags &amp; FUNC_FRAME:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="built_in">hex</span>(func), <span class="string">&quot;FUNC_FRAME&quot;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">if</span> flags &amp; FUNC_USERFAR:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="built_in">hex</span>(func), <span class="string">&quot;FUNC_USERFAR&quot;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">if</span> flags &amp; FUNC_HIDDEN:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="built_in">hex</span>(func), <span class="string">&quot;FUNC_HIDDEN&quot;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">if</span> flags &amp; FUNC_THUNK:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="built_in">hex</span>(func), <span class="string">&quot;FUNC_THUNK&quot;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">if</span> flags &amp; FUNC_LIB:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="built_in">hex</span>(func), <span class="string">&quot;FUNC_BOTTOMBP&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>我们使用<code>idautils.Functions()</code>来获取所有已知函数列表的地址同时我们使用<code>idc.GetFunctionFlags(ea)</code>来获取标志。我们检测值通过使用逻辑<code>&amp;</code>在返回值的时候。例如 检测是否函数没有返回值我们将使用接下来的比较<code>if flags &amp; FUNC_NORET</code>。接下来我们重温所有的标志。这些标志是常见的，其他的是罕见的。</p>
<h3 id="FUNC-NORET"><a href="#FUNC-NORET" class="headerlink" title="FUNC_NORET"></a>FUNC_NORET</h3><p>这个标志用来标识一个函数没有执行一个返回指令。它的内部表示等于 1。一个不返回值的函数的例子，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CODE:004028F8 sub_4028F8 proc near</span><br><span class="line">CODE:004028F8</span><br><span class="line">CODE:004028F8 and eax, 7Fh</span><br><span class="line">CODE:004028FB mov edx, [esp+0]</span><br><span class="line">CODE:004028FE jmp sub_4028AC</span><br><span class="line">CODE:004028FE sub_4028F8 endp</span><br></pre></td></tr></table></figure>

<h3 id="FUNC-FAR"><a href="#FUNC-FAR" class="headerlink" title="FUNC_FAR"></a>FUNC_FAR</h3><p>这个标志很少出现，除非逆向软件使用分段内存。它的内部表示为一个整数 2</p>
<h3 id="FUNC-USERFAR"><a href="#FUNC-USERFAR" class="headerlink" title="FUNC_USERFAR"></a>FUNC_USERFAR</h3><p>这个标志比较罕见，具有非常小的文件。<code>hexrays</code>描述标志为“用户已指定远性功能”。它的内部值为 32</p>
<h3 id="FUNC-LIB"><a href="#FUNC-LIB" class="headerlink" title="FUNC_LIB"></a>FUNC_LIB</h3><p>此标志用于查找库代码。识别库代码非常有用，因为它是在执行分析时通常可以忽略的代码。它的内部表示为整数 4 。下面是一个例子，它的使用具有识别功能</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; <span class="keyword">for</span> func <span class="keyword">in</span> idautils.Functions():</span><br><span class="line"><span class="meta">... </span>flags = idc.GetFunctionFlags(func)</span><br><span class="line"><span class="meta">... </span><span class="keyword">if</span> flags &amp; FUNC_LIB:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="built_in">hex</span>(func), <span class="string">&quot;FUNC_LIB&quot;</span>, GetFunctionName(func))</span><br><span class="line">Python&gt;</span><br><span class="line"><span class="number">0x1a711160</span> FUNC_LIB _strcpy</span><br><span class="line"><span class="number">0x1a711170</span> FUNC_LIB _strcat</span><br><span class="line"><span class="number">0x1a711260</span> FUNC_LIB _memcmp</span><br><span class="line"><span class="number">0x1a711320</span> FUNC_LIB _memcpy</span><br><span class="line"><span class="number">0x1a711662</span> FUNC_LIB __onexit</span><br><span class="line">...</span><br><span class="line"><span class="number">0x1a711915</span> FUNC_LIB _exit</span><br><span class="line"><span class="number">0x1a711926</span> FUNC_LIB __exit</span><br><span class="line"><span class="number">0x1a711937</span> FUNC_LIB __cexit</span><br><span class="line"><span class="number">0x1a711946</span> FUNC_LIB __c_exit</span><br><span class="line"><span class="number">0x1a711955</span> FUNC_LIB _puts</span><br><span class="line"><span class="number">0x1a7119c0</span> FUNC_LIB _strcmp</span><br></pre></td></tr></table></figure>

<h3 id="FUNC-STATIC"><a href="#FUNC-STATIC" class="headerlink" title="FUNC_STATIC"></a>FUNC_STATIC</h3><p>此标志用于标识作为静态函数编译的函数。在<code>C</code>函数中默认是全局的。如果作者定义了 一个函数为静态只能访问内部文件等功能。在有限的方式下，这可以用来帮助理解源代码是如何构造的</p>
<h3 id="FUNC-FRAME"><a href="#FUNC-FRAME" class="headerlink" title="FUNC_FRAME"></a>FUNC_FRAME</h3><p>这个标志表明该函数使用帧指针<code>EBP</code>。使用帧指针的函数通常以设置堆栈框架的标准函数序言开始</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:1A716697 push ebp</span><br><span class="line">.text:1A716698 mov ebp, esp</span><br><span class="line">.text:1A71669A sub esp, 5Ch</span><br></pre></td></tr></table></figure>

<h3 id="FUNC-BOTTOMBP"><a href="#FUNC-BOTTOMBP" class="headerlink" title="FUNC_BOTTOMBP"></a>FUNC_BOTTOMBP</h3><p>类似<code>FUNC_FRAME</code>此标记用于跟踪帧指针。它将确定帧指针等于堆栈指针函数</p>
<h3 id="FUNC-HIDDEN"><a href="#FUNC-HIDDEN" class="headerlink" title="FUNC_HIDDEN"></a>FUNC_HIDDEN</h3><p>函数带<code>FUNC_HIDDEN</code>标志意味着他们是隐藏的将需要扩展到视图。如果我们转到一个被标记为隐藏的函数的地址，它会自动扩展</p>
<h3 id="FUNC-THUNK"><a href="#FUNC-THUNK" class="headerlink" title="FUNC_THUNK"></a>FUNC_THUNK</h3><p>这标志标识函数是<code>thunk</code>函数。一个简单的功能是跳到另一个函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:1A710606 Process32Next proc near</span><br><span class="line">.text:1A710606 jmp ds:__imp_Process32Next</span><br><span class="line">.text:1A710606 Process32Next endp</span><br></pre></td></tr></table></figure>

<p>应该指出的是，一个函数可以有多个标志</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x1a716697 FUNC_LIB</span><br><span class="line">0x1a716697 FUNC_FRAME</span><br><span class="line">0x1a716697 FUNC_HIDDEN</span><br><span class="line">0x1a716697 FUNC_BOTTOMBP</span><br></pre></td></tr></table></figure>

<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>既然我们知道函数如何访问它们的指令，如果我们有一个函数的地址，我们能使用<code>idautils.FuncItems(ea)</code>获取列表中所有地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印该函数段内的所有反汇编</span></span><br><span class="line">Python&gt; dism_addr = <span class="built_in">list</span>(idautils.FuncItems(here()))</span><br><span class="line">Python&gt; <span class="built_in">type</span>(dism_addr)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line">Python&gt; <span class="built_in">print</span>(dism_addr)</span><br><span class="line">[<span class="number">4573123</span>, <span class="number">4573126</span>, <span class="number">4573127</span>, <span class="number">4573132</span>]</span><br><span class="line">Python&gt; <span class="keyword">for</span> line <span class="keyword">in</span> dism_addr: </span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="built_in">hex</span>(line),idc.GetDisasm(line))</span><br><span class="line"><span class="number">0x45c7c3</span> mov eax, [ebp-60h]</span><br><span class="line"><span class="number">0x45c7c6</span> push eax ; void *</span><br><span class="line"><span class="number">0x45c7c7</span> call w_delete</span><br><span class="line"><span class="number">0x45c7cc</span> retn</span><br></pre></td></tr></table></figure>

<p><code>idautils.FuncItems(ea)</code>实际返回一个迭代器类型但是被强转成一个<code>list</code>。该列表将包含顺序连续的每个指令的起始地址。现在我们已经有了一个很好的知识库来遍历段、函数和指令，让我们展示一个有用的例子。有时当逆向包代码是唯一知道在哪里发生动态调用的。一个动态的调用将调用或跳转到一个操作数是一个寄存器，例如调用<code>eax</code>或<code>jmp edi</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;</span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> idautils.Functions(): <span class="comment"># 获取每一个函数的地址</span></span><br><span class="line"><span class="meta">... </span>flags = idc.GetFunctionFlags(func) <span class="comment"># 获取函数的标志</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">if</span> flags &amp; FUNC_LIB <span class="keyword">or</span> flags &amp; FUNC_THUNK: <span class="comment"># 判断是否为库函数或者是thunk函数</span></span><br><span class="line">    ... <span class="keyword">continue</span></span><br><span class="line"><span class="meta">... </span>dism_addr = <span class="built_in">list</span>(idautils.FuncItems(func)) <span class="comment"># 获取函数的每一个反汇编语句地址</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">for</span> line <span class="keyword">in</span> dism_addr:</span><br><span class="line">    ... m = idc.GetMnem(line) <span class="comment"># 获取反汇编助记符</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">if</span> m == <span class="string">&#x27;call&#x27;</span> <span class="keyword">or</span> m == <span class="string">&#x27;jmp&#x27;</span>:</span><br><span class="line">    ... op = idc.GetOpType(line, <span class="number">0</span>) <span class="comment"># 获取第一个操作数</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">if</span> op == o_reg: <span class="comment"># 如果第一个操作数是寄存器</span></span><br><span class="line">    ... <span class="built_in">print</span>(<span class="string">&quot;0x%x %s&quot;</span> % (line, idc.GetDisasm(line)))</span><br><span class="line">Python&gt;</span><br><span class="line"><span class="number">0x43ebde</span> call eax ; VirtualProtect</span><br></pre></td></tr></table></figure>

<p>我们调用<code>idautils.Functions()</code>去获取所有已知函数列表。每个函数我们检索函数的标志通过调用<code>idc.GetFunctionFlags(ea)</code>。如果这个函数是库代码或者<code>thunk</code>函数，则这个函数会被跳过。 接下来我们调用<code>idautils.FuncItems(ea)</code>来获取所有的地址在函数里。我们使用<code>for</code>循环循环遍历列表。由于我们只对<code>call</code>和<code>jmp</code>指令感兴趣我们需要通过调用<code>idc.GetMnem(ea)</code>。然后我 们用一个简单的字符串比较检查法。如果是一个<code>jump</code>或<code>call</code>我们通过操作的类型调用 <code>idc.GetOpType(ea, n)</code>。这个函数将返回一个整数是内部调用<code>op_t.type</code>。这个值可以用来确定 如果操作数是一个寄存器、内存引用等。然后我们检查<code>op_t.type</code>是一个寄存器。如果是这 样，我们打印行强制返回的<code>idautils.FuncItems(ea)</code>到一个列表是有用的，因为迭代器没有对 象如<code>len()</code>。通过把它作为一个列表，我们可以很容易地获得函数中的行数或指令数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; ea = here() <span class="comment"># 获取当前地址</span></span><br><span class="line">Python&gt; <span class="built_in">len</span>(idautils.FuncItems(ea)) <span class="comment"># 返回的是迭代器类型，所以没有 len()</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;&lt;string&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="built_in">object</span> of <span class="built_in">type</span> <span class="string">&#x27;generator&#x27;</span> has no <span class="built_in">len</span>()</span><br><span class="line">Python&gt; <span class="built_in">len</span>(<span class="built_in">list</span>(idautils.FuncItems(ea)))</span><br><span class="line"><span class="number">39</span></span><br></pre></td></tr></table></figure>

<p>在前一个示例中，我们使用了一个包含函数中所有地址的列表。我们循环每条指令并访问下条指令。如果我们只有一个地址，想获得下一个指示？移动到下一条指令的地址可以使用<code>idc.NextHead(ea)</code>和获得前一条指令地址我们使用<code>idc.PrevHead(ea)</code>。这些功能将得到下一 个指令的开始而不是下一个地址，得到下一个地址我们使用<code>idc.NextAddr(ea)</code>，得到前一个地址我们使用<code>idc.PrevAddr(ea)</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; ea = here()</span><br><span class="line">Python&gt; <span class="built_in">print</span>(<span class="built_in">hex</span>(ea), idc.GetDisasm(ea))</span><br><span class="line"><span class="number">0x10004f24</span> call sub_10004F32</span><br><span class="line">Python&gt; next_instr = idc.NextHead(ea) <span class="comment"># 获取下一条指令的地址，而不是当前的地址 + 1</span></span><br><span class="line">Python&gt; <span class="built_in">print</span>(<span class="built_in">hex</span>(next_instr), idc.GetDisasm(next_instr)) </span><br><span class="line"><span class="number">0x10004f29</span> mov [esi], eax</span><br><span class="line">Python&gt; prev_instr = idc.PrevHead(ea) <span class="comment"># 获取上一条指令的地址，而不是当前的地址 - 1</span></span><br><span class="line">Python&gt; <span class="built_in">print</span>(<span class="built_in">hex</span>(prev_instr), idc.GetDisasm(prev_instr))</span><br><span class="line"><span class="number">0x10004f1e</span> mov [esi+98h], eax</span><br><span class="line">Python&gt; <span class="built_in">print</span>(<span class="built_in">hex</span>(idc.NextAddr(ea)))</span><br><span class="line"><span class="number">0x10004f25</span></span><br><span class="line">Python&gt; <span class="built_in">print</span>(<span class="built_in">hex</span>(idc.PrevAddr(ea)))</span><br><span class="line"><span class="number">0x10004f23</span></span><br></pre></td></tr></table></figure>

<h2 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h2><p>操作数的类型是常用的，它将有助于复习所有的类型。正如前面所述，我们可以使用<code>idc.GetOpType(ea,n)</code>得到的操作数的类型。<code>ea</code>是地址，<code>n</code>是索引。这里有 8 种不同类型的操 作数类型</p>
<h3 id="o-void"><a href="#o-void" class="headerlink" title="o_void"></a>o_void</h3><p>如果一个指令没有任何操作数它将返回 0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; <span class="built_in">print</span>(<span class="built_in">hex</span>(ea), idc.GetDisasm(ea))</span><br><span class="line"><span class="number">0xa09166</span> retn</span><br><span class="line">Python&gt; <span class="built_in">print</span> idc.GetOpType(ea,<span class="number">0</span>)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="o-reg"><a href="#o-reg" class="headerlink" title="o_reg"></a>o_reg</h3><p>如果一个操作数是一个普遍的寄存器将返回此类型。这个值在内部表示为 1</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; <span class="built_in">print</span>(<span class="built_in">hex</span>(ea), idc.GetDisasm(ea))</span><br><span class="line"><span class="number">0xa09163</span> pop edi</span><br><span class="line">Python&gt; <span class="built_in">print</span>(idc.GetOpType(ea,<span class="number">0</span>))</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="o-mem"><a href="#o-mem" class="headerlink" title="o_mem"></a>o_mem</h3><p>如果一个操作数是直接内存引用它将返回这个类型。这个值在内部表示为 2。这种类型是有用的在<code>DATA</code>段查找引用</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; <span class="built_in">print</span>(<span class="built_in">hex</span>(ea), idc.GetDisasm(ea))</span><br><span class="line"><span class="number">0xa05d86</span> cmp ds:dword_A152B8, <span class="number">0</span></span><br><span class="line">Python&gt; <span class="built_in">print</span>(idc.GetOpType(ea,<span class="number">0</span>))</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="o-phrase"><a href="#o-phrase" class="headerlink" title="o_phrase"></a>o_phrase</h3><p>这个操作数被返回则这个操作数包含一个基本的寄存器或一个索引寄存器。这个值在内部表示为 3</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; <span class="built_in">print</span>(<span class="built_in">hex</span>(ea), idc.GetDisasm(ea))</span><br><span class="line"><span class="number">0x1000b8c2</span> mov [edi+ecx], eax</span><br><span class="line">Python&gt; <span class="built_in">print</span>(idc.GetOpType(ea,<span class="number">0</span>))</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="o-displ"><a href="#o-displ" class="headerlink" title="o_displ"></a>o_displ</h3><p>这个操作数被返回则操作数包含寄存器和一个位移值，这个为位移值是一个整数，例如<code>0x18</code>。这是常见的当一条指令访问值在一个结构中。在内部，它表示为 4 的值</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;<span class="built_in">print</span>(<span class="built_in">hex</span>(ea), idc.GetDisasm(ea))</span><br><span class="line"><span class="number">0xa05dc1</span> mov eax, [edi+18h]</span><br><span class="line">Python&gt;<span class="built_in">print</span>(idc.GetOpType(ea,<span class="number">1</span>))</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="o-imm"><a href="#o-imm" class="headerlink" title="o_imm"></a>o_imm</h3><p>操作数是这样一个为整数的<code>0xc</code>的值的类型(立即数)。它在内部表示为 5</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;<span class="built_in">print</span>(<span class="built_in">hex</span>(ea), idc.GetDisasm(ea))</span><br><span class="line"><span class="number">0xa05da1</span> add esp, 0Ch</span><br><span class="line">Python&gt;<span class="built_in">print</span>(idc.GetOpType(ea,<span class="number">1</span>))</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="o-far"><a href="#o-far" class="headerlink" title="o_far"></a>o_far</h3><p>这个操作数不是很常见当逆向<code>x86</code>或<code>x86_64</code>时。它是用来寻找操作数的访问立即数远地址的。它在内部表示为 6</p>
<h3 id="o-near"><a href="#o-near" class="headerlink" title="o_near"></a>o_near</h3><p>这个操作数不是很常见当逆向<code>x86</code>或<code>x86_64</code>时。它是用来寻找操作数的访问立即数近地址的。它在内部表示为 7</p>
<h2 id="交叉引用"><a href="#交叉引用" class="headerlink" title="交叉引用"></a>交叉引用</h2><p>能够找到交叉引用又名外部参考数据或代码是非常重要的。交叉引用是十分重要的，因为它提供在某些数据被使用或一个函数被调用的位置。例如，如果我们想找到<code>WriteFile</code>被调用的地址。使用交叉引用我们需要做的是确定<code>WriteFile</code>的地址在导入表中然后可以找到所有的交叉引用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; wf_addr = idc.LocByName(<span class="string">&quot;WriteFile&quot;</span>) <span class="comment"># 通过函数名定位对应API地址</span></span><br><span class="line">Python&gt; <span class="built_in">print</span>(<span class="built_in">hex</span>(wf_addr), idc.GetDisasm(wf_addr))</span><br><span class="line"><span class="number">0x1000e1b8</span> extrn WriteFile:dword</span><br><span class="line">Python&gt; <span class="keyword">for</span> addr <span class="keyword">in</span> idautils.CodeRefsTo(wf_addr, <span class="number">0</span>): <span class="comment"># API交叉引用</span></span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="built_in">hex</span>(addr), idc.GetDisasm(addr))</span><br><span class="line"><span class="number">0x10004932</span> call ds:WriteFile</span><br><span class="line"><span class="number">0x10005c38</span> call ds:WriteFile</span><br><span class="line"><span class="number">0x10007458</span> call ds:WriteFile</span><br></pre></td></tr></table></figure>

<p>第一行我们得到了API <code>WriteFile</code>的地址通过使用<code>idc.LocByName(str)</code>。这个函数将返回一个<code>API</code>的地址。我们输出<code>WriteFile</code>的地址是一个字符串表示的。然后遍历所有的交叉引用通过调用<code>idautils.CodeRefsTo(ea, flow)</code>。它能通过遍历将返回一个迭代器。<code>ea</code>是我们想要得到的交叉引用的地址。参数流是一个<code>bool</code>类型。它被用来指定是否要遵照正常的代码流。然后显示每一个交叉引用的地址。一个快速的注释关于使用<code>idc.LocByName(str)</code>。所有的重命名函数和<code>APIs</code>在一个<code>IDB</code>中能被访问通过调用<code>idautils.Names()</code>。这个函数返回一个迭代器对 象能够循环遍历输出或者访问名称。每个名称的项是一个<code>(ea, str_name)</code>的元组</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; [x <span class="keyword">for</span> x <span class="keyword">in</span> Names()]</span><br><span class="line">[(<span class="number">268439552</span>, <span class="string">&#x27;SetEventCreateThread&#x27;</span>), (<span class="number">268439615</span>, <span class="string">&#x27;StartAddress&#x27;</span>),</span><br><span class="line">(<span class="number">268441102</span>, <span class="string">&#x27;SetSleepClose&#x27;</span>),....</span><br></pre></td></tr></table></figure>

<p>如果我们想要获得代码在哪里被引用，我们需要使用<code>idautisl.CodeRefsFrom(ea,flow)</code>。例如让我们获取在<code>0x10004932</code>被引用的地址</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; ea = <span class="number">0x10004932</span></span><br><span class="line">Python&gt; <span class="built_in">print</span>(<span class="built_in">hex</span>(ea), idc.GetDisasm(ea))</span><br><span class="line"><span class="number">0x10004932</span> call ds:WriteFile</span><br><span class="line">Python&gt; <span class="keyword">for</span> addr <span class="keyword">in</span> idautils.CodeRefsFrom(ea, <span class="number">0</span>): <span class="comment"># API交叉引用</span></span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="built_in">hex</span>(addr), idc.GetDisasm(addr))</span><br><span class="line">Python&gt;</span><br><span class="line"><span class="number">0x1000e1b8</span> extrn WriteFile:dword</span><br></pre></td></tr></table></figure>

<p>如果我们看<code>idautils.CodeRefsTo(ea, flow)</code>这个例子，我们将看见地址<code>0x10004932</code>是一个到<code>WriteFile</code>的地址。<code>idautils.CodeRefsTo(ea, flow)</code>和<code>idautils.CodeRefsFrom(ea, flow)</code>是用来搜索交叉引用和代码。使用<code>idautils.CodeRefsTo(ea, flow)</code>的限制是它是 API，是动态导入的，然后手动重命名将不会显示为代码交叉引用。我们手动重命名一个<code>dword &quot;RtlCompareMemory&quot;</code>地址使用<code>idc.MakeName(ea, name)</code>。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; <span class="built_in">hex</span>(ea)</span><br><span class="line"><span class="number">0xa26c78</span></span><br><span class="line">Python&gt; idc.MakeName(ea, <span class="string">&quot;RtlCompareMemory&quot;</span>) <span class="comment"># 重命名</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line">Python&gt; <span class="keyword">for</span> addr <span class="keyword">in</span> idautils.CodeRefsTo(ea, <span class="number">0</span>):</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="built_in">hex</span>(addr), idc.GetDisasm(addr)) <span class="comment"># 没有输出</span></span><br></pre></td></tr></table></figure>

<p><code>IDA</code>将不标记这些<code>APIs</code>作为交叉引用。接下来我们将描述一个一般方式获得所有交叉引用。如果我们想要搜索交叉引用从数据中我们能使用<code>idautils.DataRefsTo(ea)</code>或者<code>idautils.DataRefsFrom(ea)</code></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; <span class="built_in">print</span>(<span class="built_in">hex</span>(ea), idc.GetDisasm(ea))</span><br><span class="line"><span class="number">0x1000e3ec</span> db <span class="string">&#x27;vnc32&#x27;</span>,<span class="number">0</span></span><br><span class="line">Python&gt;<span class="keyword">for</span> addr <span class="keyword">in</span> idautils.DataRefsTo(ea): </span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="built_in">hex</span>(addr),idc.GetDisasm(addr))</span><br><span class="line"><span class="number">0x100038ac</span> push offset aVnc32 ; <span class="string">&quot;vnc32&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>idautils.DataRefsTo(ea)</code>获取参数的地址，并返回所有交叉引用数据的地址的迭代器</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;<span class="built_in">print</span>(<span class="built_in">hex</span>(ea), idc.GetDisasm(ea))</span><br><span class="line"><span class="number">0x100038ac</span> push offset aVnc32 ; <span class="string">&quot;vnc32&quot;</span></span><br><span class="line">Python&gt;<span class="keyword">for</span> addr <span class="keyword">in</span> idautils.DataRefsFrom(ea):  <span class="comment"># 数据交叉引用</span></span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span> <span class="built_in">hex</span>(addr),idc.GetDisasm(addr)</span><br><span class="line"><span class="number">0x1000e3ec</span> db <span class="string">&#x27;vnc32&#x27;</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>对于逆向和显示地址我们调用<code>idautils.DataRefsFrom(ea)</code>，通过地址作为参数。他返回一 个一个所有地址交叉引用返回给数据的迭代器。使用不同的代码和数据可能有点混乱。如前所述，让我们描述一个更通用的技术。这种方法可以通过调用单个函数获得所有对地址的交叉引用。我们获得到一个地址的所有交叉引用使用<code>idautils.XrefsTo(ea, flags=0)</code>，获得从一个地址到所有交叉引用调用<code>idautils.XrefsFrom(ea, flags=0)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; <span class="built_in">print</span>(<span class="built_in">hex</span>(ea), idc.GetDisasm(ea))</span><br><span class="line"><span class="number">0x1000eee0</span> unicode <span class="number">0</span>, &lt;Path&gt;,<span class="number">0</span></span><br><span class="line">Python&gt;<span class="keyword">for</span> xref <span class="keyword">in</span> idautils.XrefsTo(ea, <span class="number">1</span>): <span class="comment"># 根据后面的参数决定交叉引用对象</span></span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(xref.<span class="built_in">type</span>, idautils.XrefTypeName(xref.<span class="built_in">type</span>), <span class="built_in">hex</span>(xref.frm), <span class="built_in">hex</span>(xref.to), xref.iscode)</span><br><span class="line">Python&gt;</span><br><span class="line"><span class="number">1</span> Data_Offset <span class="number">0x1000ac0d</span> <span class="number">0x1000eee0</span> <span class="number">0</span></span><br><span class="line">Python&gt;<span class="built_in">print</span>(<span class="built_in">hex</span>(xref.frm), idc.GetDisasm(xref.frm))</span><br><span class="line"><span class="number">0x1000ac0d</span> push offset KeyName ; <span class="string">&quot;Path&quot;</span></span><br></pre></td></tr></table></figure>

<p>第一行显示我的们的地址和一个字符串命名的。我们使用<code>idautils.XrefsTo(ea, 1)</code>获得的所有交叉引用的字符串。我们然后使用<code>xref.type</code>来打印交叉引用类型值。<code>idautils.XrefTypeName(xref.type)</code>被用来打印这个类型的字符串表示。有十二个不同的文件引用类型的值。该值可以在左边看到，它的对应名字可以被看到，如下所示</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> = <span class="string">&#x27;Data_Unknown&#x27;</span></span><br><span class="line"><span class="number">1</span> = <span class="string">&#x27;Data_Offset&#x27;</span></span><br><span class="line"><span class="number">2</span> = <span class="string">&#x27;Data_Write&#x27;</span></span><br><span class="line"><span class="number">3</span> = <span class="string">&#x27;Data_Read&#x27;</span></span><br><span class="line"><span class="number">4</span> = <span class="string">&#x27;Data_Text&#x27;</span></span><br><span class="line"><span class="number">5</span> = <span class="string">&#x27;Data_Informational&#x27;</span></span><br><span class="line"><span class="number">16</span> = <span class="string">&#x27;Code_Far_Call&#x27;</span></span><br><span class="line"><span class="number">17</span> = <span class="string">&#x27;Code_Near_Call&#x27;</span></span><br><span class="line"><span class="number">18</span> = <span class="string">&#x27;Code_Far_Jump&#x27;</span></span><br><span class="line"><span class="number">19</span> = <span class="string">&#x27;Code_Near_Jump&#x27;</span></span><br><span class="line"><span class="number">20</span> = <span class="string">&#x27;Code_User&#x27;</span></span><br><span class="line"><span class="number">21</span> = <span class="string">&#x27;Ordinary_Flow&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>xref.frm</code>打印在哪里引用的地址，<code>xref.to</code>打印被引用的地址。<code>xref.iscode</code>打印是否交叉引用是在一个代码段中。在前面的例子中，我们使用<code>idautils.XrefsTo(ea, 1)</code>的标志设置值为 1。如果这个标志为 0 任何交叉引用将不被显示。我们有如下反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:1000AAF6 jnb short loc_1000AB02 ; XREF</span><br><span class="line">.text:1000AAF8 mov eax, [ebx+0Ch]</span><br><span class="line">.text:1000AAFB mov ecx, [esi]</span><br><span class="line">.text:1000AAFD sub eax, edi</span><br><span class="line">.text:1000AAFF mov [edi+ecx], eax</span><br><span class="line">.text:1000AB02</span><br><span class="line">.text:1000AB02 loc_1000AB02: ; ea is here()</span><br><span class="line">.text:1000AB02 mov byte ptr [ebx], 1</span><br></pre></td></tr></table></figure>

<p>我们在<code>1000AB02</code>处进行标记。这个地址从<code>1000AAF6</code>有一个交叉引用，但是它也有第二个交叉引用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;<span class="built_in">print</span>(<span class="built_in">hex</span>(ea), idc.GetDisasm(ea))</span><br><span class="line"><span class="number">0x1000ab02</span> mov byte ptr [ebx], <span class="number">1</span></span><br><span class="line">Python&gt;<span class="keyword">for</span> xref <span class="keyword">in</span> idautils.XrefsTo(ea, <span class="number">1</span>): </span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(xref.<span class="built_in">type</span>, idautils.XrefTypeName(xref.<span class="built_in">type</span>),<span class="built_in">hex</span>(xref.frm), <span class="built_in">hex</span>(xref.to), xref.iscode)</span><br><span class="line">Python&gt;</span><br><span class="line"><span class="number">19</span> Code_Near_Jump <span class="number">0x1000aaf6</span> <span class="number">0x1000ab02</span> <span class="number">1</span></span><br><span class="line">Python&gt;<span class="keyword">for</span> xref <span class="keyword">in</span> idautils.XrefsTo(ea, <span class="number">0</span>): </span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(xref.<span class="built_in">type</span>, idautils.XrefTypeName(xref.<span class="built_in">type</span>),</span><br><span class="line"><span class="built_in">hex</span>(xref.frm), <span class="built_in">hex</span>(xref.to), xref.iscode)</span><br><span class="line">Python&gt;</span><br><span class="line"><span class="number">21</span> Ordinary_Flow <span class="number">0x1000aaff</span> <span class="number">0x1000ab02</span> <span class="number">1</span></span><br><span class="line"><span class="number">19</span> Code_Near_Jump <span class="number">0x1000aaf6</span> <span class="number">0x1000ab02</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>第二个交叉引用是从<code>1000AAFF</code>到<code>1000AB02</code>。交叉引用不会造成分支指令。他们也可以被普通的代码流影响。如果我们设置标志为<code>1 Ordinary_Flow</code>引用类型将不被增加。回到之前的<code>RtlCompareMemory</code>例子。我们能使用<code>idautils.XrefsTo(ea,flow)</code>来获取交叉引用</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; <span class="built_in">hex</span>(ea)</span><br><span class="line"><span class="number">0xa26c78</span></span><br><span class="line">Python&gt; idc.MakeName(ea, <span class="string">&quot;RtlCompareMemory&quot;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">Python&gt; <span class="keyword">for</span> xref <span class="keyword">in</span> idautils.XrefsTo(ea, <span class="number">1</span>):</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(xref.<span class="built_in">type</span>, idautils.XrefTypeName(xref.<span class="built_in">type</span>), <span class="built_in">hex</span>(xref.frm), <span class="built_in">hex</span>(xref.to), xref.iscode)</span><br><span class="line">Python&gt;</span><br><span class="line"><span class="number">3</span> Data_Read <span class="number">0xa142a3</span> <span class="number">0xa26c78</span> <span class="number">0</span></span><br><span class="line"><span class="number">3</span> Data_Read <span class="number">0xa143e8</span> <span class="number">0xa26c78</span> <span class="number">0</span></span><br><span class="line"><span class="number">3</span> Data_Read <span class="number">0xa162da</span> <span class="number">0xa26c78</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>有时获得所有交叉引用有点多余</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; <span class="built_in">print</span> <span class="built_in">hex</span>(ea), idc.GetDisasm(ea)</span><br><span class="line"><span class="number">0xa21138</span> extrn GetProcessHeap:dword</span><br><span class="line">Python&gt; <span class="keyword">for</span> xref <span class="keyword">in</span> idautils.XrefsTo(ea, <span class="number">1</span>):</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(xref.<span class="built_in">type</span>, idautils.XrefTypeName(xref.<span class="built_in">type</span>), <span class="built_in">hex</span>(xref.frm), <span class="built_in">hex</span>(xref.to), xref.iscode)</span><br><span class="line">Python&gt;</span><br><span class="line"><span class="number">17</span> Code_Near_Call <span class="number">0xa143b0</span> <span class="number">0xa21138</span> <span class="number">1</span></span><br><span class="line"><span class="number">17</span> Code_Near_Call <span class="number">0xa1bb1b</span> <span class="number">0xa21138</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> Data_Read <span class="number">0xa143b0</span> <span class="number">0xa21138</span> <span class="number">0</span></span><br><span class="line"><span class="number">3</span> Data_Read <span class="number">0xa1bb1b</span> <span class="number">0xa21138</span> <span class="number">0</span></span><br><span class="line">Python&gt; <span class="built_in">print</span>(idc.GetDisasm(<span class="number">0xa143b0</span>))</span><br><span class="line">call ds:GetProcessHea</span><br></pre></td></tr></table></figure>

<p>冗长的来自<code>Data_read</code>和<code>Code_near</code>都添加到交叉引用。让所有的地址并将它们添加到一个集合可以使所有有用的地址被留下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_to_xrefs</span>(<span class="params">ea</span>):</span></span><br><span class="line">	xref_set = <span class="built_in">set</span>([])</span><br><span class="line">	<span class="keyword">for</span> xref <span class="keyword">in</span> idautils.XrefsTo(ea, <span class="number">1</span>):</span><br><span class="line">		xref_set.add(xref.frm)</span><br><span class="line">	<span class="keyword">return</span> xref_set</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_frm_xrefs</span>(<span class="params">ea</span>):</span></span><br><span class="line">	xref_set = <span class="built_in">set</span>([])</span><br><span class="line">	<span class="keyword">for</span> xref <span class="keyword">in</span> idautils.XrefsFrom(ea, <span class="number">1</span>):</span><br><span class="line">		xref_set.add(xref.to)</span><br><span class="line">	<span class="keyword">return</span> xref_set</span><br></pre></td></tr></table></figure>

<p>例如剩下的函数<code>GetProcessHeap</code>的例子</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; <span class="built_in">print</span>(<span class="built_in">hex</span>(ea), idc.GetDisasm(ea))</span><br><span class="line"><span class="number">0xa21138</span> extrn GetProcessHeap:dword</span><br><span class="line">Python&gt; get_to_xrefs(ea)</span><br><span class="line"><span class="built_in">set</span>([<span class="number">10568624</span>, <span class="number">10599195</span>])</span><br><span class="line">Python&gt; [<span class="built_in">hex</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> get_to_xrefs(ea)]</span><br><span class="line">[<span class="string">&#x27;0xa143b0&#x27;</span>, <span class="string">&#x27;0xa1bb1b&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>我们已经遍历了一些基本的我们所知道的函数或指令。这是有用的，但是有时我们需要 搜索特殊的字节例如<code>0x55 0x8B 0xEC</code>。这些字节搭配是经典的功能语句<code>push ebp</code>，<code>mov ebp</code>， <code>esp</code>。为了搜索这些字节或者二进制搭配我们可以使用<code>idc.FindBinary(ea, flag, searchstr, radix=16)</code>。<code>ea</code>是我们想要搜索的地址从标志是字典或条件中。这里有一些不同类型的标志。 名称和值如下所示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SEARCH_UP = 0</span><br><span class="line">SEARCH_DOWN = 1</span><br><span class="line">SEARCH_NEXT = 2</span><br><span class="line">SEARCH_CASE = 4</span><br><span class="line">SEARCH_REGEX = 8</span><br><span class="line">SEARCH_NOBRK = 16</span><br><span class="line">SEARCH_NOSHOW = 32</span><br><span class="line">SEARCH_UNICODE = 64 **</span><br><span class="line">SEARCH_IDENT = 128 **</span><br><span class="line">SEARCH_BRK = 256 **</span><br><span class="line">** 较老的IDA版本可能不支持</span><br></pre></td></tr></table></figure>

<p>并不是所有这些标志都值得掌握，而是一些最常用的标志。</p>
<p><code>SEARCH_UP</code>和<code>SEARCH_DOWN</code>被用来选择字典我们希望我们搜索到接下来的。</p>
<p><code>SEARCH_NEXT</code>被用来获得下一个找到的对象。</p>
<p><code>SEARCH_CASE</code>被用于指定大小写敏感度。</p>
<p><code>SEARCH_NOSHOW</code>将不显示搜索过程。</p>
<p><code>SEARCH_UNICODE</code>被用来处理所有的<code>Unicode</code>字符串搜索。</p>
<p>我们正在寻找的模式是<code>searchstr</code>。<code>radix</code>被使用当正在写入进程模块时。本课题是此文章讨论的范围之外。我将推荐阅读《IDA Pro 权威指南》第 19 章。现在<code>radix</code>字段可以留空。快速浏览一下前面提到的函数语句字节模式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; pattern = <span class="string">&#x27;55 8B EC&#x27;</span></span><br><span class="line">addr = MinEA()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line"><span class="meta">... </span>addr = idc.FindBinary(addr, SEARCH_DOWN, pattern);</span><br><span class="line"><span class="meta">... </span><span class="keyword">if</span> addr != idc.BADADDR:</span><br><span class="line">    ... <span class="built_in">print</span>(<span class="built_in">hex</span>(addr), idc.GetDisasm(addr))</span><br><span class="line">Python&gt;</span><br><span class="line"><span class="number">0x401000</span> push ebp</span><br><span class="line"><span class="number">0x401000</span> push ebp</span><br><span class="line"><span class="number">0x401000</span> push ebp</span><br><span class="line"><span class="number">0x401000</span> push ebp</span><br><span class="line"><span class="number">0x401000</span> push ebp</span><br></pre></td></tr></table></figure>

<p>在第一行我们发现我们搜索的部分。被搜索的部分能以 16 进制的形式开始带 <code>0x</code> 作为在<code>0x55 0x8B 0xEC</code>或者作为字节 <code>55 8B EC</code>出现在<code>IDA</code>的 16 进制窗口。<code>\x55\x8B\xEC</code>不能被使用,除非我们使用<code>idc.FindText(ea, flag, y, x, searchstr)</code>。<code>MinEA()</code>被用来获得第一个地址在可执行的位置。然后我们将<code>idc.FindBinary(ea, flag, searchstr, radix=16)</code>返回的给一个叫做<code>addr</code>的变量。</p>
<p>在搜索时验证搜索有没有找到匹配部分是十分重要的。它通过对比<code>addr</code>的<code>idc.BADADDR</code>。然后打印地址和反汇编。</p>
<p>注意到地址没有增加吗？这是因为我们没有设定<code>SEARCH_NEXT 标志</code>。当设立该标志时，如果上一个地址包含我们的字节部分搜索将不在通过。如下所示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; pattern = <span class="string">&#x27;55 8B EC&#x27;</span></span><br><span class="line">addr = MinEA()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line"><span class="meta">... </span>addr = idc.FindBinary(addr, SEARCH_DOWN|SEARCH_NEXT,pattern);</span><br><span class="line"><span class="meta">... </span><span class="keyword">if</span> addr != idc.BADADDR:</span><br><span class="line">    ... <span class="built_in">print</span>(<span class="built_in">hex</span>(addr), idc.GetDisasm(addr))</span><br><span class="line">Python&gt;</span><br><span class="line"><span class="number">0x401040</span> push ebp</span><br><span class="line"><span class="number">0x401070</span> push ebp</span><br><span class="line"><span class="number">0x4010e0</span> push ebp</span><br><span class="line"><span class="number">0x401150</span> push ebp</span><br><span class="line"><span class="number">0x4011b0</span> push ebp</span><br></pre></td></tr></table></figure>

<p>搜索字节是十分有帮助的，但是有时候我们也许想要搜索字符串例如“<code>chrome.dll</code>”。我们可以转换字符串到 16 进制字节，使用<code>[hex(y) for y in bytearray(&quot;chrome.dll&quot;)]</code>但是这有一点丑陋。另外，如果字符串是<code>Unicode</code>，我们必须解释这种格式。最简单的方式是使用<code>FindText(ea, flag, y, x, searchstr)</code>。大多数字节应该看起来相似，因为他们是相同的作为<code>idc.FindBinary</code>。<code>ea</code>是开始地址，<code>flag</code>是方向和类型用于搜索。<code>y</code>是要搜索的<code>ea</code>中的行数，<code>x</code>是行中的坐标。这些字段通常分配为 0。现在搜索出现的字符串“<code>Accept</code>”。对于这个例子任何字符串从字符串窗口按<code>shift+F12</code>能使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; cur_addr = MinEA()</span><br><span class="line">end = MaxEA()</span><br><span class="line"><span class="keyword">while</span> cur_addr &lt; end:</span><br><span class="line"><span class="meta">... </span>cur_addr = idc.FindText(cur_addr, SEARCH_DOWN, <span class="number">0</span>, <span class="number">0</span>,<span class="string">&quot;Accept&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> cur_addr == idc.BADADDR:</span><br><span class="line"><span class="meta">... </span><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="built_in">hex</span>(cur_addr), idc.GetDisasm(cur_addr))</span><br><span class="line"><span class="meta">... </span>cur_addr = idc.NextHead(cur_addr)</span><br><span class="line">Python&gt;</span><br><span class="line"><span class="number">0x40da72</span> push offset aAcceptEncoding; <span class="string">&quot;Accept-Encoding:\n&quot;</span></span><br><span class="line"><span class="number">0x40face</span> push offset aHttp1_1Accept; <span class="string">&quot; HTTP/1.1\r\nAccept: */*</span></span><br><span class="line"><span class="string">\r\n &quot;</span></span><br><span class="line"><span class="number">0x40fadf</span> push offset aAcceptLanguage; <span class="string">&quot;Accept-Language: ru</span></span><br><span class="line"><span class="string">\r\n&quot;</span></span><br><span class="line">...</span><br><span class="line"><span class="number">0x423c00</span> db <span class="string">&#x27;Accept&#x27;</span>,<span class="number">0</span></span><br><span class="line"><span class="number">0x423c14</span> db <span class="string">&#x27;Accept-Language&#x27;</span>,<span class="number">0</span></span><br><span class="line"><span class="number">0x423c24</span> db <span class="string">&#x27;Accept-Encoding&#x27;</span>,<span class="number">0</span></span><br><span class="line"><span class="number">0x423ca4</span> db <span class="string">&#x27;Accept-Ranges&#x27;</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>我们使用<code>MinEA()</code>获得最小地址和将其赋值给变量名<code>cur_addr</code>。同样的做法对于最大地址调用<code>MaxEA()</code>和赋值返回给变量名<code>end</code>。由于我们不知道字符串出现的次数，我们需要检查搜索是否继续下去，并且小于最大地址。我们然后赋值<code>idc.FindText</code>的返回值给当前地址。因为我们将手动增加地址通过调用<code>idc.NextHead(ea)</code>。我们不需要<code>SEARCH_NEXT</code>这个标志。理由是我们手动增加当前地址到接下来的行中是因为一个字符串能在一行中出现多次。这便使它很难获得下一个字符串的地址。</p>
<p>除了前面描述的模式搜索外，还有两个函数可用于查找其他类型。根据<code>API</code>的名称可以很容易的推断出函数的整体功能。在讨论寻找不同类型之前，我们首先通过地址来识别类型。有一个<code>API</code>的子集，首先是可以用来确定一个地址类型。这个<code>APIs</code>返回一个<code>True</code>或<code>False</code>的布尔值。</p>
<h3 id="idc-isCode-f"><a href="#idc-isCode-f" class="headerlink" title="idc.isCode(f)"></a>idc.isCode(f)</h3><p>如果<code>IDA</code>标记地址为代码，返回<code>True</code>。 </p>
<h3 id="idc-isData-f"><a href="#idc-isData-f" class="headerlink" title="idc.isData(f)"></a>idc.isData(f)</h3><p>如果<code>IDA</code>标记地址为数据，返回<code>True</code>。 </p>
<h3 id="idc-isTail-f"><a href="#idc-isTail-f" class="headerlink" title="idc.isTail(f)"></a>idc.isTail(f)</h3><p>如果<code>IDA</code>标记地址为尾部，返回<code>True</code>。 </p>
<h3 id="idc-isUnknown-f"><a href="#idc-isUnknown-f" class="headerlink" title="idc.isUnknown(f)"></a>idc.isUnknown(f)</h3><p>如果<code>IDA</code>标记地址为未知，返回<code>True</code>。这个类型被使用当<code>IDA</code>没有标识地址是代码还是数据。 </p>
<h3 id="idc-isHead-f"><a href="#idc-isHead-f" class="headerlink" title="idc.isHead(f)"></a>idc.isHead(f)</h3><p>如果<code>IDA</code>标记地址为头部，返回<code>True</code>。我们首先需要一个内部的标志来表示，然后通过<code>idc.is</code>设置函数。为获得这个内部标志我们使用<code>idc.GetFlags(ea)</code>。现在我们有了一个基本的功能，如何对不同类型的函数使用，让我们举一个简单的例子。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; <span class="built_in">print</span>(<span class="built_in">hex</span>(ea), idc.GetDisasm(ea))</span><br><span class="line"><span class="number">0x10001000</span> push ebp</span><br><span class="line">Python&gt; idc.isCode(idc.GetFlags(ea))</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="idc-FindCode-ea-flag"><a href="#idc-FindCode-ea-flag" class="headerlink" title="idc.FindCode(ea, flag)"></a>idc.FindCode(ea, flag)</h3><p>它被用来找到下一个被标记为代码的地址。如果我们想找到一个数据块的结束，这将十分有用。如果<code>ea</code>是一个已经作为代码被标记的地址它将返回下一个地址。这个<code>flag</code>将被用来提前描述<code>idc.FindText</code>。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; <span class="built_in">print</span>(<span class="built_in">hex</span>(ea), idc.GetDisasm(ea))</span><br><span class="line"><span class="number">0x4140e8</span> dd offset dword_4140EC</span><br><span class="line">Python&gt; addr = idc.FindCode(ea, SEARCH_DOWN|SEARCH_NEXT)</span><br><span class="line">Python&gt; <span class="built_in">print</span>(<span class="built_in">hex</span>(addr), idc.GetDisasm(addr))</span><br><span class="line"><span class="number">0x41410c</span> push ebx</span><br></pre></td></tr></table></figure>

<p>我们能了解<code>ea</code>是地址<code>0x4140e8</code>的一些数据。我们赋值<code>idc.FindCode(ea, SEARCH_DOWN|SEARCH_NEXT)</code>的返回值给<code>addr</code>。然后我们打印<code>addr</code>和它的汇编。通过调用一个函数，我们跳过开始标记为代码 36 字节数据的部分。</p>
<h3 id="idc-FindData-ea-flag"><a href="#idc-FindData-ea-flag" class="headerlink" title="idc.FindData(ea, flag)"></a>idc.FindData(ea, flag)</h3><p>这的使用方式和<code>idc.findcode</code>完全一样，除了它将返回下一个地址被标记为一个数据块的开始</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; <span class="built_in">print</span>(<span class="built_in">hex</span>(ea), idc.GetDisasm(ea))</span><br><span class="line"><span class="number">0x41410c</span> push ebx</span><br><span class="line">Python&gt; addr = idc.FindData(ea, SEARCH_UP|SEARCH_NEXT)</span><br><span class="line">Python&gt; <span class="built_in">print</span>(<span class="built_in">hex</span>(addr), idc.GetDisasm(addr))</span><br><span class="line"><span class="number">0x4140ec</span> dd 49540E0Eh, 746E6564h, 4570614Dh, 7972746Eh, <span class="number">8</span>, <span class="number">1</span>,</span><br><span class="line">4010BCh</span><br></pre></td></tr></table></figure>

<p>只有一点比前面的例子稍有不同的是<code>SEARCH_UP|SEARCH_NEXT</code>的方向和搜索的数据</p>
<h3 id="idc-FindUnexplored-ea-flag"><a href="#idc-FindUnexplored-ea-flag" class="headerlink" title="idc.FindUnexplored(ea, flag)"></a>idc.FindUnexplored(ea, flag)</h3><p>这个函数是用来寻找的字节地址，<code>IDA</code>没有识别码或数据。<code>unknown</code>类型将需要进一步的人工分析或通过脚本观察。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; <span class="built_in">print</span>(<span class="built_in">hex</span>(ea), idc.GetDisasm(ea))</span><br><span class="line"><span class="number">0x406a05</span> jge short loc_406A3A</span><br><span class="line">Python&gt; addr = idc.FindUnexplored(ea, SEARCH_DOWN)</span><br><span class="line">Python&gt; <span class="built_in">print</span>(<span class="built_in">hex</span>(addr), idc.GetDisasm(addr))</span><br><span class="line"><span class="number">0x41b004</span> db 0DFh ; ?</span><br></pre></td></tr></table></figure>

<h3 id="idc-FindExplored-ea-flag"><a href="#idc-FindExplored-ea-flag" class="headerlink" title="idc.FindExplored(ea, flag)"></a>idc.FindExplored(ea, flag)</h3><p>它是用来寻找一个地址，IDA 确定为代码和数据。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x41b900</span> db ? ;</span><br><span class="line">Python&gt; addr = idc.FindExplored(ea, SEARCH_UP)</span><br><span class="line">Python&gt; <span class="built_in">print</span>(<span class="built_in">hex</span>(addr), idc.GetDisasm(addr))</span><br><span class="line"><span class="number">0x41b5f4</span> dd ?</span><br></pre></td></tr></table></figure>

<p>这可能看上去不是真实的值，但如果我们要打印的<code>addr</code>的交叉引用，我们会看到它被使用</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; <span class="keyword">for</span> xref <span class="keyword">in</span> idautils.XrefsTo(addr, <span class="number">1</span>):</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="built_in">hex</span>(xref.frm), idc.GetDisasm(xref.frm))</span><br><span class="line">Python&gt;</span><br><span class="line"><span class="number">0x4069c3</span> mov eax, dword_41B5F4[ecx*<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h3 id="idc-FindImmediate-ea-flag-value"><a href="#idc-FindImmediate-ea-flag-value" class="headerlink" title="idc.FindImmediate(ea, flag, value)"></a>idc.FindImmediate(ea, flag, value)</h3><p>并不是寻找一种我们可能要搜索的一个特定的值。比方说，我们猜测代码调用<code>rand</code>来生成一个随机数，但是我们找不到代码。如果我们知道<code>rand</code>使用值<code>0x343fd</code>作为种子，则我们可以寻找一些数。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; addr = idc.FindImmediate(MinEA(), SEARCH_DOWN, <span class="number">0x343FD</span> )</span><br><span class="line">Python&gt; addr</span><br><span class="line">[<span class="number">268453092</span>, <span class="number">0</span>]</span><br><span class="line">Python&gt; <span class="built_in">print</span>(<span class="string">&quot;0x%x %s %x&quot;</span> % (addr[<span class="number">0</span>], idc.GetDisasm(addr[<span class="number">0</span>]), addr[<span class="number">1</span>]))</span><br><span class="line"><span class="number">0x100044e4</span> imul eax, 343FDh <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>在第一行我们获取最小地址通过<code>MinEA()</code>，接下来，然后搜索值<code>0x343fd</code>。而不是返回一个地址来显示找到的APIs <code>idc.FindImmediate</code>返回一个<code>tupple</code>。<code>tupple</code>的第一项将成为地址第二项将成为操作数。类似于<code>idc.GetOpnd</code>第一个操作数开始返回零。当我们打印的地址和反汇编，我们可以看到的值是第二个操作数。如果我们想搜索所有使用立即数我们可以做如下内容。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;addr = MinEA()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>addr, operand = idc.FindImmediate(addr, SEARCH_DOWN|SEARCH_NEXT, <span class="number">0x7a</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">if</span> addr != BADADDR:</span><br><span class="line">    ... <span class="built_in">print</span>(<span class="built_in">hex</span>(addr), idc.GetDisasm(addr), <span class="string">&quot;Operand &quot;</span>, operand)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span><span class="keyword">break</span></span><br><span class="line">Python&gt;</span><br><span class="line"><span class="number">0x402434</span> dd <span class="number">9</span>, 0FF0Bh, 0Ch, 0FF0Dh, 0Dh, 0FF13h, 13h, 0FF1Bh, 1Bh Operand <span class="number">0</span></span><br><span class="line"><span class="number">0x40acee</span> cmp eax, 7Ah Operand <span class="number">1</span></span><br><span class="line"><span class="number">0x40b943</span> push 7Ah Operand <span class="number">0</span></span><br><span class="line"><span class="number">0x424a91</span> cmp eax, 7Ah Operand <span class="number">1</span></span><br><span class="line"><span class="number">0x424b3d</span> cmp eax, 7Ah Operand <span class="number">1</span></span><br><span class="line"><span class="number">0x425507</span> cmp eax, 7Ah Operand <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>大部分的代码应该看起来很熟悉，但因为我们是搜索多个值我们将使用一个<code>while</code>循环和<code>SEARCH_DOWN|SEARCH_NEXT</code>标志。</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='true'
        data-ae='true'
        data-ci='01ed89abee289d37f2f8'
        data-cs='51741e819059e2ea7ab6c6f3d0fa0ac631d1d975'
        data-r='MyBlogComments'
        data-o='Equinox-shame'
        data-a='Equinox-shame'
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
