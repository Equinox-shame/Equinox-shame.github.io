

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="梓曰">
  <meta name="keywords" content="">
  
    <meta name="description" content="基础知识 变量 变量使用 let 关键字来声明。 在赋值时，Rust 能够在 99% 的情况下自动推断其类型。如果不能，也可以手动将类型添加到变量声明中。 1234567891011121314fn main() &amp;#123;    &#x2F;&#x2F; rust 推断出x的类型    let x &#x3D; 13;    println!(&quot;&amp;#123;&amp;#125;&quot;, x);    &#x2F;&#x2F; rust">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust 语言之旅">
<meta property="og:url" content="https://equinox-shame.github.io/2023/09/06/Rust%20%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%85/index.html">
<meta property="og:site_name" content="Autumnal">
<meta property="og:description" content="基础知识 变量 变量使用 let 关键字来声明。 在赋值时，Rust 能够在 99% 的情况下自动推断其类型。如果不能，也可以手动将类型添加到变量声明中。 1234567891011121314fn main() &amp;#123;    &#x2F;&#x2F; rust 推断出x的类型    let x &#x3D; 13;    println!(&quot;&amp;#123;&amp;#125;&quot;, x);    &#x2F;&#x2F; rust">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-09-06T15:50:19.189Z">
<meta property="article:modified_time" content="2023-09-06T15:48:51.399Z">
<meta property="article:author" content="梓曰">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Rust 语言之旅 - Autumnal</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"equinox-shame.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"2aM6IUUWOeDGCZaDdRhrvLam-gzGzoHsz","app_key":"GQdXw2PjI9DScgw5QHVCZeYm","server_url":"https://2am6iuuw.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Autumnal Equinox</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Rust 语言之旅"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-09-06 23:50" pubdate>
          2023年9月6日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          21k 字
        
      </span>
    

    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Rust 语言之旅</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="基础知识">基础知识</h2>
<h3 id="变量">变量</h3>
<p>变量使用 <strong>let</strong> 关键字来声明。</p>
<p>在赋值时，Rust 能够在 99% 的情况下自动推断其类型。如果不能，也可以手动将类型添加到变量声明中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// rust 推断出x的类型</span><br>    <span class="hljs-keyword">let</span> x = <span class="hljs-number">13</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x);<br><br>    <span class="hljs-comment">// rust也可以显式声明类型</span><br>    <span class="hljs-keyword">let</span> x: <span class="hljs-built_in">f64</span> = <span class="hljs-number">3.14159</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x);<br><br>    <span class="hljs-comment">// rust 也支持先声明后初始化，但很少这样做</span><br>    <span class="hljs-keyword">let</span> x;<br>    x = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Rust 非常关心哪些变量是可修改的。值分为两种类型：</p>
<ul>
<li><strong>可变的</strong> - 编译器允许对变量进行读取和写入。</li>
<li><strong>不可变的</strong> - 编译器只允许对变量进行读取。</li>
</ul>
<p>可变值用 <strong>mut</strong> 关键字表示。</p>
<h3 id="基本类型">基本类型</h3>
<p>Rust 有多种常见的类型：</p>
<ul>
<li>布尔型 - <code>bool</code> 表示 true 或 false</li>
<li>无符号整型- <code>u8</code> <code>u32</code> <code>u64</code> <code>u128</code> 表示正整数</li>
<li>有符号整型 - <code>i8</code> <code>i32</code> <code>i64</code> <code>i128</code> 表示正负整数</li>
<li>指针大小的整数 - <code>usize</code> <code>isize</code> 表示内存中内容的索引和大小</li>
<li>浮点数 - <code>f32</code> <code>f64</code></li>
<li>元组（tuple） - <code>(value, value, ...)</code> 用于在栈上传递固定序列的值</li>
<li>数组 - 在编译时已知的具有固定长度的相同元素的集合</li>
<li>切片（slice） - 在运行时已知长度的相同元素的集合</li>
<li><code>str</code>(string slice) - 在运行时已知长度的文本</li>
</ul>
<blockquote>
<p>可以通过将类型附加到数字的末尾来明确指定数字类型（如 <code>13u32</code> 和 <code>2u8</code>）</p>
</blockquote>
<h3 id="类型转换">类型转换</h3>
<p>使用 <strong>as</strong> 关键字</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-number">13u8</span>;<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-number">7u32</span>;<br>    <span class="hljs-keyword">let</span> c = a <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span> + b;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, c);<br><br>    <span class="hljs-keyword">let</span> t = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, t <span class="hljs-keyword">as</span> <span class="hljs-built_in">u8</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="常量">常量</h3>
<p>使用 <strong>const</strong> 关键字，常量必须始终具有显式的类型。</p>
<h3 id="数组">数组</h3>
<p>数组是所有相同类型数据元素的固定长度集合。</p>
<p>一个数组的数据类型是 <code>[T;N]</code>，其中 T 是元素的类型，N 是编译时已知的固定长度。</p>
<p>可以使用 <code>[x]</code> 运算符提取单个元素，其中 <em>x</em> 是所需元素的 <em>usize</em> 索引（从 0 开始）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> nums: [<span class="hljs-built_in">i32</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, nums);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, nums[<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="函数">函数</h3>
<p>fn + 函数名 + 参数 + 返回类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(x: <span class="hljs-built_in">i32</span>, y: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> &#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="多个返回值">多个返回值</h3>
<p>函数可以通过<strong>元组</strong>来返回多个值。</p>
<p>元组元素可以通过他们的索引来获取。</p>
<p>Rust 允许我们将后续会看到的各种形式的解构，也允许我们以符合逻辑的方式提取数据结构的子片段。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">swap</span></span>(x: <span class="hljs-built_in">i32</span>, y: <span class="hljs-built_in">i32</span>) -&gt; (<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>) &#123;<br>    <span class="hljs-keyword">return</span> (y, x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// 返回一个元组</span><br>    <span class="hljs-keyword">let</span> result = swap(<span class="hljs-number">123</span>, <span class="hljs-number">321</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, result.<span class="hljs-number">0</span>, result.<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 将元组解构为两个变量</span><br>    <span class="hljs-keyword">let</span> (a, b) = swap(result.<span class="hljs-number">0</span>, result.<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, a, b);<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>没有返回值将会返回一个空元组，使用 <code>()</code> 进行表示</p>
</blockquote>
<h2 id="基本控制流">基本控制流</h2>
<h3 id="if-else-if-else">if/else if/else</h3>
<p>Rust 的条件判断没有括号！所有常见的逻辑运算符仍然适用：<code>==</code>，<code>!=</code>， <code>&lt;</code>， <code>&gt;</code>， <code>&lt;=</code>， <code>&gt;=</code>， <code>!</code>， <code>||</code>， <code>&amp;&amp;</code></p>
<h3 id="循环">循环</h3>
<p><code>break</code> 会退出当前循环</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">loop</span> &#123;<br>        x += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> x == <span class="hljs-number">42</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x);<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>loop</code> 可以被中断以返回一个值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> v = <span class="hljs-keyword">loop</span> &#123;<br>        x += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> x == <span class="hljs-number">13</span> &#123;<br>            <span class="hljs-keyword">break</span> <span class="hljs-string">&quot;found the 13&quot;</span>;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;from loop: &#123;&#125;&quot;</span>, v);<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="while">while</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> x != <span class="hljs-number">42</span> &#123;<br>        x += <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="for">for</h3>
<p>Rust 的 <code>for</code> 循环是一个强大的升级。它遍历来自计算结果为迭代器的任意表达式的值。</p>
<p><code>..</code> 运算符创建一个可以生成包含起始数字、但不包含末尾数字的数字序列的迭代器。</p>
<p><code>..=</code> 运算符创建一个可以生成包含起始数字、且包含末尾数字的数字序列的迭代器。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..=<span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="match">match</h3>
<p>Rust 有一个非常有用的关键字，用于匹配值的所有可能条件， 并在匹配为真时执行相应代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-number">42</span>;<br><br>    <span class="hljs-keyword">match</span> x &#123;<br>        <span class="hljs-number">0</span> =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;found zero&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 我们可以匹配多个值</span><br>        <span class="hljs-number">1</span> | <span class="hljs-number">2</span> =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;found 1 or 2!&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 我们可以匹配迭代器</span><br>        <span class="hljs-number">3</span>..=<span class="hljs-number">9</span> =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;found a number 3 to 9 inclusively&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 我们可以将匹配数值绑定到变量</span><br>        matched_num @ <span class="hljs-number">10</span>..=<span class="hljs-number">100</span> =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;found &#123;&#125; number between 10 to 100!&quot;</span>, matched_num);<br>        &#125;<br>        <span class="hljs-comment">// 这是默认匹配，如果没有处理所有情况，则必须存在该匹配</span><br>        _ =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;found something else!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Standard Output: found 42 number between 10 to 100!</span><br></code></pre></td></tr></table></figure>
<h2 id="基本数据结构类型">基本数据结构类型</h2>
<h3 id="结构体">结构体</h3>
<p>一个 <code>struct</code> 就是一些字段的集合。</p>
<p><em>字段</em>是一个与数据结构相关联的数据值。它的值可以是基本类型或结构体类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SeaCreature</span></span> &#123;<br>    <span class="hljs-comment">// String 是个结构体</span><br>    animal_type: <span class="hljs-built_in">String</span>,<br>    name: <span class="hljs-built_in">String</span>,<br>    arms: <span class="hljs-built_in">i32</span>,<br>    legs: <span class="hljs-built_in">i32</span>,<br>    weapon: <span class="hljs-built_in">String</span>,<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法调用">方法调用</h3>
<p>与函数（function）不同，方法（method）是与特定数据类型关联的函数。</p>
<p><strong>静态方法</strong> — 属于某个类型，调用时使用 <code>::</code> 运算符。</p>
<p><strong>实例方法</strong> — 属于某个类型的实例，调用时使用 <code>.</code> 运算符。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// 使用静态方法来创建一个String实例</span><br>    <span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Hello world!&quot;</span>);<br>    <span class="hljs-comment">// 使用实例来调用方法</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; is &#123;&#125; characters long.&quot;</span>, s, s.len());<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="类元组结构体">类元组结构体</h3>
<p>简洁起见，你可以创建像元组一样被使用的结构体。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Location</span></span>(<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// 这仍然是一个在栈上的结构体</span><br>    <span class="hljs-keyword">let</span> loc = Location(<span class="hljs-number">42</span>, <span class="hljs-number">32</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, loc.<span class="hljs-number">0</span>, loc.<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="泛型">泛型</h2>
<p>泛型允许我们不完全定义一个 <code>struct</code> 或 <code>enum</code>，使编译器能够根据我们的代码使用情况，在编译时创建一个完全定义的版本。</p>
<p>Rust 通常可以通过查看我们的实例化来推断出最终的类型，但是如果需要帮助，你可以使用 <code>::&lt;T&gt;</code> 操作符来显式地进行操作， 该操作符也被称为 <code>turbofish</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 一个部分定义的结构体类型</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BagOfHolding</span></span>&lt;T&gt; &#123;<br>    item: T,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// 注意：通过使用泛型，我们创建了编译时创建的类型，使代码更大</span><br>    <span class="hljs-comment">// Turbofish 使之显式化</span><br>    <span class="hljs-keyword">let</span> i32_bag = BagOfHolding::&lt;<span class="hljs-built_in">i32</span>&gt; &#123; item: <span class="hljs-number">42</span> &#125;;<br>    <span class="hljs-keyword">let</span> bool_bag = BagOfHolding::&lt;<span class="hljs-built_in">bool</span>&gt; &#123; item: <span class="hljs-literal">true</span> &#125;;<br>    <br>    <span class="hljs-comment">// Rust 也可以推断出泛型的类型！</span><br>    <span class="hljs-keyword">let</span> float_bag = BagOfHolding &#123; item: <span class="hljs-number">3.14</span> &#125;;<br><br>    <span class="hljs-comment">// 注意：在现实生活中，不要把一袋东西放在另一袋东西里:)</span><br>    <span class="hljs-keyword">let</span> bag_in_bag = BagOfHolding &#123;<br>        item: BagOfHolding &#123; item: <span class="hljs-string">&quot;嘭！&quot;</span> &#125;,<br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<br>        <span class="hljs-string">&quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>,<br>        i32_bag.item, bool_bag.item, float_bag.item, bag_in_bag.item.item<br>    );<br>&#125;<br><span class="hljs-comment">// Standard Output: 42 true 3.14 嘭！</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>有点像是 C++ 中的模板类</p>
</blockquote>
<h3 id="表示空">表示空</h3>
<p>Rust 没有 <code>null</code>，使用泛型来替代值，并采用 <code>None</code> 进行替代</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Item</span></span> &#123;<br>    Inventory(<span class="hljs-built_in">String</span>),<br>    <span class="hljs-comment">// None represents the absence of an item</span><br>    <span class="hljs-literal">None</span>,<br>    <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BagOfHolding</span></span> &#123;<br>    item: Item,<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Option">Option</h3>
<p>Rust 有一个内置的泛型枚举叫做 <code>Option</code>，它可以让我们不使用 <code>null</code> 就可以表示可以为空的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Option</span></span>&lt;T&gt; &#123;<br>    <span class="hljs-literal">None</span>,<br>    <span class="hljs-literal">Some</span>(T),<br>&#125;<br></code></pre></td></tr></table></figure>
<p>有以下例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 一个部分定义的结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BagOfHolding</span></span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">// 我们的参数类型T可以传递给其他</span><br>    item: <span class="hljs-built_in">Option</span>&lt;T&gt;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// 注意：一个放 i32 的 bag，里面什么都没有！</span><br>    <span class="hljs-comment">// 我们必须注明类型，否则 Rust 不知道 bag 的类型</span><br>    <span class="hljs-keyword">let</span> i32_bag = BagOfHolding::&lt;<span class="hljs-built_in">i32</span>&gt; &#123; item: <span class="hljs-literal">None</span> &#125;;<br><br>    <span class="hljs-keyword">if</span> i32_bag.item.is_none() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;there&#x27;s nothing in the bag!&quot;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;there&#x27;s something in the bag!&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> i32_bag = BagOfHolding::&lt;<span class="hljs-built_in">i32</span>&gt; &#123; item: <span class="hljs-literal">Some</span>(<span class="hljs-number">42</span>) &#125;;<br><br>    <span class="hljs-keyword">if</span> i32_bag.item.is_some() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;there&#x27;s something in the bag!&quot;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;there&#x27;s nothing in the bag!&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// match 可以让我们优雅地解构 Option，并且确保我们处理了所有的可能情况！</span><br>    <span class="hljs-keyword">match</span> i32_bag.item &#123;<br>        <span class="hljs-literal">Some</span>(v) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;found &#123;&#125; in bag!&quot;</span>, v),<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;found nothing&quot;</span>),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Result">Result</h3>
<p>Rust 有一个内置的泛型枚举叫做 <code>Result</code>，它可以让我们返回一个可能包含错误的值。 这是编程语言进行错误处理的惯用方法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Result</span></span>&lt;T, E&gt; &#123;<br>    <span class="hljs-literal">Ok</span>(T),<br>    <span class="hljs-literal">Err</span>(E),<br>&#125;<br></code></pre></td></tr></table></figure>
<p>有以下例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">do_something_that_might_fail</span></span>(i:<span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">f32</span>,<span class="hljs-built_in">String</span>&gt; &#123;<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">42</span> &#123;<br>        <span class="hljs-literal">Ok</span>(<span class="hljs-number">13.0</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-literal">Err</span>(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;this is not the right number&quot;</span>))   <br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> result = do_something_that_might_fail(<span class="hljs-number">12</span>);<br><br>    <span class="hljs-comment">// match 让我优雅地解构 Rust，并且确保我们处理了所有情况！</span><br>    <span class="hljs-keyword">match</span> result &#123;<br>        <span class="hljs-literal">Ok</span>(v) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;found &#123;&#125;&quot;</span>, v),<br>        <span class="hljs-literal">Err</span>(e) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Error: &#123;&#125;&quot;</span>,e),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>main</code> 函数有可以返回 <code>Result</code> 的能力！</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">do_something_that_might_fail</span></span>(i: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">f32</span>, <span class="hljs-built_in">String</span>&gt; &#123;<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">42</span> &#123;<br>        <span class="hljs-literal">Ok</span>(<span class="hljs-number">13.0</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-literal">Err</span>(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;this is not the right number&quot;</span>))<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 主函数不返回值，但可能返回一个错误！</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; <span class="hljs-built_in">Result</span>&lt;(), <span class="hljs-built_in">String</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> result = do_something_that_might_fail(<span class="hljs-number">12</span>);<br><br>    <span class="hljs-keyword">match</span> result &#123;<br>        <span class="hljs-literal">Ok</span>(v) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;found &#123;&#125;&quot;</span>, v),<br>        <span class="hljs-literal">Err</span>(_e) =&gt; &#123;<br>            <span class="hljs-comment">// 优雅地处理错误</span><br>            <br>            <span class="hljs-comment">// 返回一个说明发生了什么的新错误！</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;something went wrong in main!&quot;</span>));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Notice we use a unit value inside a Result Ok</span><br>    <span class="hljs-comment">// to represent everything is fine</span><br>    <span class="hljs-literal">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="错误处理">错误处理</h3>
<p><code>Result</code> 如此常见以至于 Rust 有个强大的操作符 <code>?</code> 来与之配合。 以下两个表达式是等价的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">do_something_that_might_fail()?<br><span class="hljs-keyword">match</span> do_something_that_might_fail() &#123;<br>    <span class="hljs-literal">Ok</span>(v) =&gt; v,<br>    <span class="hljs-literal">Err</span>(e) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(e),<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Option-Result-处理">Option/Result 处理</h3>
<p>当只是试图快速地写一些代码时，<code>Option</code>/<code>Result</code> 对付起来可能比较无聊。 <code>Option</code> 和 <code>Result</code> 都有一个名为 <code>unwrap</code> 的函数：这个函数可以简单粗暴地获取其中的值。 <code>unwrap</code> 会：</p>
<ol>
<li>获取 Option/Result 内部的值</li>
<li>如果枚举的类型是 None/Err， 则会 <code>panic!</code></li>
</ol>
<p>这两段代码是等价的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">my_option.unwrap()<br><span class="hljs-keyword">match</span> my_option &#123;<br>    <span class="hljs-literal">Some</span>(v) =&gt; v,<br>    <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;some error message generated by Rust!&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure>
<p>类似的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">my_result.unwrap()<br><span class="hljs-keyword">match</span> my_result &#123;<br>    <span class="hljs-literal">Ok</span>(v) =&gt; v,<br>    <span class="hljs-literal">Err</span>(e) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;some error message generated by Rust!&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Vectors">Vectors</h3>
<p>一些经常使用的泛型是集合类型。一个 vector 是可变长度的元素集合，以 <code>Vec</code> 结构表示。</p>
<p>比起手动构建，宏 <code>vec!</code> 让我们可以轻松地创建 vector。</p>
<p><code>Vec</code> 有一个形如 <code>iter()</code> 的方法可以为一个 vector 创建迭代器，这允许我们可以轻松地将 vector 用到 <code>for</code> 循环中去。</p>
<p>内存细节：</p>
<ul>
<li><code>Vec</code> 是一个结构体，但是内部其实保存了在堆上固定长度数据的引用。</li>
<li>一个 vector 开始有默认大小容量，当更多的元素被添加进来后，它会重新在堆上分配一个新的并具有更大容量的定长列表。（类似 C++ 的 vector）</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// 我们可以显式确定类型</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> i32_vec = <span class="hljs-built_in">Vec</span>::&lt;<span class="hljs-built_in">i32</span>&gt;::new(); <span class="hljs-comment">// turbofish &lt;3</span><br>    i32_vec.push(<span class="hljs-number">1</span>);<br>    i32_vec.push(<span class="hljs-number">2</span>);<br>    i32_vec.push(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-comment">// 但是看看 Rust 是多么聪明的自动检测类型啊</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> float_vec = <span class="hljs-built_in">Vec</span>::new();<br>    float_vec.push(<span class="hljs-number">1.3</span>);<br>    float_vec.push(<span class="hljs-number">2.3</span>);<br>    float_vec.push(<span class="hljs-number">3.4</span>);<br><br>    <span class="hljs-comment">// 这是个漂亮的宏！</span><br>    <span class="hljs-keyword">let</span> string_vec = <span class="hljs-built_in">vec!</span>[<span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Hello&quot;</span>), <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;World&quot;</span>)];<br><br>    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> string_vec.iter() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, word);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="所有权和数据借用">所有权和数据借用</h2>
<p>Rust 没有垃圾回收机制。</p>
<p>Rust 将使用资源最后被使用的位置或者一个函数域的结束来作为资源被析构和释放的地方。 此处析构和释放的概念被称之为 <strong>drop</strong>（丢弃）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span> &#123;<br>    x: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> foo_a = Foo &#123; x: <span class="hljs-number">42</span> &#125;;<br>    <span class="hljs-keyword">let</span> foo_b = Foo &#123; x: <span class="hljs-number">13</span> &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, foo_a.x);<br>    <span class="hljs-comment">// foo_a 将在这里被 dropped 因为其在这之后再也没有被使用</span><br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, foo_b.x);<br>    <span class="hljs-comment">// foo_b 将在这里被 dropped 因为这是函数域的结尾</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="移交所有权">移交所有权</h3>
<p>将所有者作为参数传递给函数时，其所有权将移交至该函数的参数。 在一次<strong>移动</strong>后，原函数中的变量将无法再被使用。</p>
<p>内存细节:</p>
<ul>
<li>在<strong>移动</strong>期间，所有者的堆栈值将会被复制到函数调用的参数堆栈中。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span> &#123;<br>    x: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">do_something</span></span>(f: Foo) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, f.x);<br>    <span class="hljs-comment">// f 在这里被 dropped 释放</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> foo = Foo &#123; x: <span class="hljs-number">42</span> &#125;;<br>    <span class="hljs-comment">// foo 被移交至 do_something</span><br>    do_something(foo);<br>    <span class="hljs-comment">// 此后 foo 便无法再被使用</span><br>    <span class="hljs-comment">// println!(&quot;&#123;&#125;&quot;, foo);  产生相应报错</span><br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="归还所有权">归还所有权</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span> &#123;<br>    x: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">do_something</span></span>() -&gt; Foo &#123;<br>    Foo &#123; x: <span class="hljs-number">42</span> &#125;<br>    <span class="hljs-comment">// 所有权被移出</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> foo = do_something();<br>    <span class="hljs-comment">// foo 成为了所有者</span><br>    <span class="hljs-comment">// foo 在函数域结尾被 dropped 释放</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="使用引用借用所有权">使用引用借用所有权</h3>
<p>引用允许我们通过 <code>&amp;</code> 操作符来借用对一个资源的访问权限。 引用也会如同其他资源一样被释放。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span> &#123;<br>    x: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> foo = Foo &#123; x: <span class="hljs-number">42</span> &#125;;<br>    <span class="hljs-keyword">let</span> f = &amp;foo;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, f.x);<br>    <span class="hljs-comment">// f 在这里被 dropped 释放</span><br>    <span class="hljs-comment">// foo 在这里被 dropped 释放</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="通过引用借用可变所有权">通过引用借用可变所有权</h3>
<p>我们也可以使用 <code>&amp;mut</code> 操作符来借用对一个资源的可变访问权限。 在发生了可变借用后，一个资源的所有者便不可以再次被借用或者修改。</p>
<p>内存细节：</p>
<ul>
<li>Rust 之所以要避免同时存在两种可以改变所拥有变量值的方式，是因为此举可能会导致潜在的数据争用（data race）。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span> &#123;<br>    x: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">do_something</span></span>(f: Foo) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, f.x);<br>    <span class="hljs-comment">// f 在这里被 dropped 释放</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> foo = Foo &#123; x: <span class="hljs-number">42</span> &#125;;<br>    <span class="hljs-keyword">let</span> f = &amp;<span class="hljs-keyword">mut</span> foo;<br><br>    <span class="hljs-comment">// 会报错: do_something(foo);</span><br>    <span class="hljs-comment">// 因为 foo 已经被可变借用而无法取得其所有权</span><br><br>    <span class="hljs-comment">// 会报错: foo.x = 13;</span><br>    <span class="hljs-comment">// 因为 foo 已经被可变借用而无法被修改</span><br><br>    f.x = <span class="hljs-number">13</span>;<br>    <span class="hljs-comment">// f 会因为此后不再被使用而被 dropped 释放</span><br>    <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, foo.x);<br>    <br>    <span class="hljs-comment">// 现在修改可以正常进行因为其所有可变引用已经被 dropped 释放</span><br>    foo.x = <span class="hljs-number">7</span>;<br>    <br>    <span class="hljs-comment">// 移动 foo 的所有权到一个函数中</span><br>    do_something(foo);<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>所有权意味着我们需要注意我们的引用变量在原变量后是会产生数据争用，进而会产生报错。这意味着我们如果在 foo.x = 7 后面将 f.x 进行输出会引发报错</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">foo.x = <span class="hljs-number">7</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, f.x);<br></code></pre></td></tr></table></figure>
<p>上述代码会产生报错信息</p>
</blockquote>
<h3 id="显示生命周期">显示生命周期</h3>
<p>尽管 Rust 不总是在代码中将它展示出来，但编译器会理解每一个变量的生命周期并进行验证以确保一个引用不会有长于其所有者的存在时间。 同时，函数可以通过使用一些符号来参数化函数签名，以帮助界定哪些参数和返回值共享同一生命周期。 生命周期注解总是以 <code>'</code> 开头，例如 <code>'a</code>，<code>'b</code> 以及 <code>'c</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span> &#123;<br>    x: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-comment">// 参数 foo 和返回值共享同一生命周期</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">do_something</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(foo: &amp;<span class="hljs-symbol">&#x27;a</span> Foo) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">i32</span> &#123;<br>    <span class="hljs-keyword">return</span> &amp;foo.x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> foo = Foo &#123; x: <span class="hljs-number">42</span> &#125;;<br>    <span class="hljs-keyword">let</span> x = &amp;<span class="hljs-keyword">mut</span> foo.x;<br>    *x = <span class="hljs-number">13</span>;<br>    <span class="hljs-comment">// x 在这里被 dropped 释放从而允许我们再创建一个不可变引用</span><br>    <span class="hljs-keyword">let</span> y = do_something(&amp;foo);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, y);<br>    <span class="hljs-comment">// y 在这里被 dropped 释放</span><br>    <span class="hljs-comment">// foo 在这里被 dropped 释放</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="文本">文本</h2>
<h3 id="字符串常量（String-Literals）">字符串常量（String Literals）</h3>
<p>字符串常量（String Literals）采用 Unicode 编码（注：下文提及的 <strong>utf-8</strong> 为 Unicode 的一部分）。</p>
<p>字符串常量的类型为 <code>&amp;'static str</code>：</p>
<ul>
<li><code>&amp;</code> 意味着该变量为对内存中数据的引用，没有使用 <code>&amp;mut</code> 代表编译器将不会允许对该变量的修改</li>
<li><code>'static</code> 意味着字符串数据将会一直保存到程序结束（它不会在程序运行期间被<strong>释放（drop）</strong>）</li>
<li><code>str</code> 意味着该变量总是指向一串合法的 <strong>utf-8</strong> 字节序列。</li>
</ul>
<p>内存细节：</p>
<ul>
<li>Rust 编译器可能会将字符串储存在程序内存的数据段中。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>	<span class="hljs-keyword">let</span> a: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;你好 🦀&quot;</span>;<br>	<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, a, a.len());<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="转义字符">转义字符</h3>
<p>Rust 支持类 C 语言中的常见转义字符；</p>
<ul>
<li><code>\n</code> - 换行符</li>
<li><code>\r</code> - 回车符（回到本行起始位置）</li>
<li><code>\t</code> - 水平制表符（即键盘 Tab 键）</li>
<li><code>\\</code> - 代表单个反斜杠 \</li>
<li><code>\0</code> - 空字符（null）</li>
<li><code>\'</code> - 代表单引号 ’</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> a: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;Ferris 说：\t\&quot;你好\&quot;&quot;</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,a);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="原始字符串常量">原始字符串常量</h4>
<p>原始字符串支持写入原始的文本而无需为特殊字符转义，因而不会导致可读性下降（如双引号与反斜杠无需写为 <code>\&quot;</code> 和 <code>\\</code>），只需以 <code>r#&quot;</code> 开头，以 <code>&quot;#</code> 结尾。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> a: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">r#&quot;</span><br><span class="hljs-string">        &lt;div class=&quot;advice&quot;&gt;</span><br><span class="hljs-string">            原始字符串在一些情景下非常有用。</span><br><span class="hljs-string">        &lt;/div&gt;</span><br><span class="hljs-string">        &quot;#</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, a);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="文件中的字符串常量">文件中的字符串常量</h3>
<p>如果你需要使用大量文本，可以尝试用宏 <code>include_str!</code> 来从本地文件中导入文本到程序中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> hello_html = <span class="hljs-built_in">include_str!</span>(<span class="hljs-string">&quot;hello.html&quot;</span>);<br></code></pre></td></tr></table></figure>
<h3 id="字符串片段（String-Slice）">字符串片段（String Slice）</h3>
<p>字符串片段是对内存中字节序列的引用，而且这段字节序列必须是合法的 utf-8 字节序列。</p>
<p><code>str</code> 片段的字符串片段（子片段），也必须是合法的 utf-8 字节序列。</p>
<p><code>&amp;str</code> 的常用方法：</p>
<ul>
<li><code>len</code> 获取字符串常量的字节长度（不是字符长度）。</li>
<li><code>starts_with</code>/<code>ends_with</code> 用于基础测试。</li>
<li><code>is_empty</code> 长度为 0 时返回 true。</li>
<li><code>find</code> 返回 <code>Option&lt;usize&gt;</code>，其中的 <code>usize</code> 为匹配到的第一个对应文本的索引值。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-string">&quot;你好 🦀&quot;</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, a.len());<br>    <span class="hljs-keyword">let</span> first_word = &amp;a[<span class="hljs-number">0</span>..<span class="hljs-number">6</span>];<br>    <span class="hljs-keyword">let</span> second_word = &amp;a[<span class="hljs-number">7</span>..<span class="hljs-number">11</span>];<br>    <span class="hljs-comment">// let half_crab = &amp;a[7..9]; 报错</span><br>    <span class="hljs-comment">// Rust 不接受无效 unicode 字符构成的片段</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, first_word, second_word);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Char">Char</h3>
<p>为了解决使用 Unicode 带来的麻烦，Rust 提供了将 utf-8 字节序列转化为类型 <code>char</code> 的 vector 的方法。</p>
<p>每个 <code>char</code> 长度都为 4 字节（可提高字符查找的效率）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// 收集字符并转换为类型为 char 的 vector</span><br>    <span class="hljs-keyword">let</span> chars = <span class="hljs-string">&quot;你好 🦀&quot;</span>.chars().collect::&lt;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">char</span>&gt;&gt;();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, chars.len()); <span class="hljs-comment">// 结果应为 4</span><br>    <span class="hljs-comment">// 由于 char 为 4 字节长，我们可以将其转化为 u32</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, chars[<span class="hljs-number">3</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="字符串（String）">字符串（String）</h3>
<p><strong>字符串<code>String</code></strong> 是一个结构体，其持有以堆（heap）的形式在内存中存储的 utf-8 字节序列。</p>
<p>由于它以堆的形式来存储，字符串可以延长、修改等等。这些都是字符串常量（string literals）无法执行的操作。</p>
<p>常用方法：</p>
<ul>
<li><code>push_str</code> 用于在字符串的结尾添加字符串常量（&amp;str）。</li>
<li><code>replace</code> 用于将一段字符串替换为其它的。</li>
<li><code>to_lowercase</code>/<code>to_uppercase</code> 用于大小写转换。</li>
<li><code>trim</code> 用于去除字符串前后的空格。</li>
</ul>
<p>如果字符串<code>String</code> 被释放（drop）了，其对应的堆内存片段也将被释放。</p>
<p>字符串<code>String</code> 可以使用 <code>+</code> 运算符来在其结尾处连接一个 <code>&amp;str</code> 并将其自身返回。但这个方法可能并不像你想象中的那么人性化。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> helloworld = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;你好&quot;</span>);<br>    helloworld.push_str(<span class="hljs-string">&quot; 世界&quot;</span>);<br>    helloworld = helloworld + <span class="hljs-string">&quot;!&quot;</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, helloworld);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="字符串构建">字符串构建</h3>
<p><code>concat</code> 和 <code>join</code> 可以以简洁而有效的方式构建字符串</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> helloworld = [<span class="hljs-string">&quot;你好&quot;</span>, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;世界&quot;</span>, <span class="hljs-string">&quot;！&quot;</span>].concat();<br>    <span class="hljs-keyword">let</span> abc = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>].join(<span class="hljs-string">&quot;,&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, helloworld);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,abc);<br>&#125;<br><br><span class="hljs-comment">// Standard Output:</span><br><span class="hljs-comment">// 你好 世界！</span><br><span class="hljs-comment">//  a,b,c</span><br></code></pre></td></tr></table></figure>
<h3 id="字符串格式化">字符串格式化</h3>
<p>宏 <code>format!</code> 可用于创建一个使用占位符的参数化字符串。（例：<code>&#123;&#125;</code>）</p>
<p><code>format!</code> 和 <code>println!</code> 生成的参数化字符串相同，只是 <code>format!</code> 将其返回而 <code>println!</code> 将其打印出来</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-number">42</span>;<br>    <span class="hljs-keyword">let</span> f = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;生活诀窍: &#123;&#125;&quot;</span>,a);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,f);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="字符串转换">字符串转换</h3>
<p>许多类型都可以通过 <code>to_string</code> 转换为字符串。</p>
<p>而泛型函数 <code>parse</code> 则可将字符串或是字符串常量转换为其它类型，该函数会返回 <code>Result</code> 因为转换有可能失败。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; <span class="hljs-built_in">Result</span>&lt;(), std::num::ParseIntError&gt; &#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-number">42</span>;<br>    <span class="hljs-keyword">let</span> a_string = a.to_string();<br>    <span class="hljs-keyword">let</span> b = a_string.parse::&lt;<span class="hljs-built_in">i32</span>&gt;()?;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, a, b);<br>    <span class="hljs-literal">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="面向对象">面向对象</h2>
<h3 id="使用方法进行封装">使用方法进行封装</h3>
<p>Rust 支持<em>对象</em>的概念。“对象”是一个与一些函数（也称为<em>方法</em>）相关联的结构体。</p>
<p>任何方法的第一个参数必须是与方法调用相关联的实例的引用。(例如 <code>instanceOfObj.foo()</code>)。Rust 使用：</p>
<ul>
<li><code>&amp;self</code> —— 对实例的不可变引用。</li>
<li><code>&amp;mut self</code> —— 对实例的可变引用。</li>
</ul>
<p>方法是在一个有 <code>impl</code> 关键字的实现块中定义的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> MyStruct &#123; <br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>有如下例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SeaCreature</span></span> &#123;<br>    noise: <span class="hljs-built_in">String</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> SeaCreature &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_sound</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-built_in">str</span> &#123;<br>        &amp;<span class="hljs-keyword">self</span>.noise<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> creature = SeaCreature &#123;<br>        noise: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;blub&quot;</span>),<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, creature.get_sound());<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="抽象与选择性暴露">抽象与选择性暴露</h3>
<p>Rust 可以隐藏对象的内部实现细节。</p>
<p>默认情况下，字段和方法只有它们所属的模块才可访问。</p>
<p><code>pub</code> 关键字可以将字段和方法暴露给模块外的访问者。</p>
<p><code>priv </code> 关键字可以将字段和方法隐藏。</p>
<h3 id="使用-Trait-实现多态">使用 Trait 实现多态</h3>
<p>Rust 支持多态的特性。Trait 允许我们将一组方法与结构类型关联起来。</p>
<p>我们首先在 Trait 里面定义函数签名：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">MyTrait</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(&amp;<span class="hljs-keyword">self</span>);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当一个结构体实现一个 trait 时，它便建立了一个契约，允许我们通过 trait 类型与结构体进行间接交互（例如 <code>&amp;dyn MyTrait</code>），而不必知道其真实的类型。</p>
<p>结构体实现 Trait 方法是在实现块中定义要实现的方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> MyTrait <span class="hljs-keyword">for</span> MyStruct &#123; <br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        ...<br>    &#125;<br>    ... <br>&#125;<br></code></pre></td></tr></table></figure>
<p>有如下例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SeaCreature</span></span> &#123;<br>    <span class="hljs-keyword">pub</span> name: <span class="hljs-built_in">String</span>,<br>    noise: <span class="hljs-built_in">String</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> SeaCreature &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_sound</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-built_in">str</span> &#123;<br>        &amp;<span class="hljs-keyword">self</span>.noise<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">NoiseMaker</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">make_noise</span></span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-keyword">impl</span> NoiseMaker <span class="hljs-keyword">for</span> SeaCreature &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">make_noise</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, &amp;<span class="hljs-keyword">self</span>.get_sound());<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> creature = SeaCreature &#123;<br>        name: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Ferris&quot;</span>),<br>        noise: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;blub&quot;</span>),<br>    &#125;;<br>    creature.make_noise();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="动态调度和静态调度">动态调度和静态调度</h3>
<p>方法的执行有两种方式：</p>
<ul>
<li>静态调度——当实例类型已知时，我们直接知道要调用什么函数。</li>
<li>动态调度——当实例类型未知时，我们必须想方法来调用正确的函数。</li>
</ul>
<p>Trait 类型 <code>&amp;dyn MyTrait</code> 给我们提供了使用动态调度间接处理对象实例的能力。</p>
<p>当使用动态调度时，Rust 会鼓励你在你的 trait 类型前加上<code>dyn</code>，以便其他人知道你在做什么。</p>
<p>内存细节：</p>
<ul>
<li>动态调度的速度稍慢，因为要追寻指针以找到真正的函数调用。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SeaCreature</span></span> &#123;<br>    <span class="hljs-keyword">pub</span> name: <span class="hljs-built_in">String</span>,<br>    noise: <span class="hljs-built_in">String</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> SeaCreature &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_sound</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-built_in">str</span> &#123;<br>        &amp;<span class="hljs-keyword">self</span>.noise<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">NoiseMaker</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">make_noise</span></span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-keyword">impl</span> NoiseMaker <span class="hljs-keyword">for</span> SeaCreature &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">make_noise</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, &amp;<span class="hljs-keyword">self</span>.get_sound());<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">static_make_noise</span></span>(creature: &amp;SeaCreature) &#123;<br>    <span class="hljs-comment">// 我们知道真实类型</span><br>    creature.make_noise();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">dynamic_make_noise</span></span>(noise_maker: &amp;<span class="hljs-keyword">dyn</span> NoiseMaker) &#123;<br>    <span class="hljs-comment">// 我们不知道真实类型</span><br>    noise_maker.make_noise();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> creature = SeaCreature &#123;<br>        name: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Ferris&quot;</span>),<br>        noise: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;咕噜&quot;</span>),<br>    &#125;;<br>    static_make_noise(&amp;creature);<br>    dynamic_make_noise(&amp;creature);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="泛型函数">泛型函数</h3>
<p>Rust中的泛型与 Trait 是相辅相成的。 当我们描述一个参数化类型 <code>T</code> 时，我们可以通过列出参数必须实现的 Trait 来限制哪些类型可以作为参数使用。</p>
<p>在以下例子中，类型 <code>T</code> 必须实现 <code>Foo</code> 这个 Trait：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">my_function</span></span>&lt;T&gt;(foo: T)<br><span class="hljs-keyword">where</span><br>    T:Foo<br>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过使用泛型，我们在编译时创建静态类型的函数，这些函数有已知的类型和大小，允许我们对其执行静态调度，并存储为有已知大小的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SeaCreature</span></span> &#123;<br>    <span class="hljs-keyword">pub</span> name: <span class="hljs-built_in">String</span>,<br>    noise: <span class="hljs-built_in">String</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> SeaCreature &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_sound</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-built_in">str</span> &#123;<br>        &amp;<span class="hljs-keyword">self</span>.noise<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">NoiseMaker</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">make_noise</span></span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-keyword">impl</span> NoiseMaker <span class="hljs-keyword">for</span> SeaCreature &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">make_noise</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, &amp;<span class="hljs-keyword">self</span>.get_sound());<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">generic_make_noise</span></span>&lt;T&gt;(creature: &amp;T)<br><span class="hljs-keyword">where</span><br>    T: NoiseMaker,<br>&#123;<br>    <span class="hljs-comment">// 我们在编译期就已经知道其真实类型</span><br>    creature.make_noise();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> creature = SeaCreature &#123;<br>        name: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Ferris&quot;</span>),<br>        noise: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;咕噜&quot;</span>),<br>    &#125;;<br>    generic_make_noise(&amp;creature);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="泛型函数简写">泛型函数简写</h3>
<p>Rust 为由 Trait 限制的泛型函数提供了简写形式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">my_function</span></span>(foo: <span class="hljs-keyword">impl</span> Foo) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这段代码等价于：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">my_function</span></span>&lt;T&gt;(foo: T)<br><span class="hljs-keyword">where</span><br>    T:Foo<br>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>有以下例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SeaCreature</span></span> &#123;<br>    <span class="hljs-keyword">pub</span> name: <span class="hljs-built_in">String</span>,<br>    noise: <span class="hljs-built_in">String</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> SeaCreature &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_sound</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-built_in">str</span> &#123;<br>        &amp;<span class="hljs-keyword">self</span>.noise<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">NoiseMaker</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">make_noise</span></span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-keyword">impl</span> NoiseMaker <span class="hljs-keyword">for</span> SeaCreature &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">make_noise</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, &amp;<span class="hljs-keyword">self</span>.get_sound());<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">generic_make_noise</span></span>(creature: &amp;<span class="hljs-keyword">impl</span> NoiseMaker)<br>&#123;<br>    <span class="hljs-comment">// 我们在编译期就已经知道其真实类型</span><br>    creature.make_noise();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> creature = SeaCreature &#123;<br>        name: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Ferris&quot;</span>),<br>        noise: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;咕噜&quot;</span>),<br>    &#125;;<br>    generic_make_noise(&amp;creature);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Box">Box</h3>
<p><code>Box</code> 是一个允许我们将数据从栈上移到堆上的数据结构。</p>
<p><code>Box</code> 是一个被称为<em>智能指针</em>的结构，它持有指向我们在堆上的数据的指针。</p>
<p>由于 <code>Box</code> 是一个已知大小的结构体（因为它只是持有一个指针）， 因此它经常被用在一个必须知道其字段大小的结构体中存储对某个目标的引用。</p>
<p><code>Box</code> 非常常见，它几乎可以被用在任何地方：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">Box</span>::new(Foo &#123; ... &#125;)<br></code></pre></td></tr></table></figure>
<p>有以下例子</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SeaCreature</span></span> &#123;<br>    <span class="hljs-keyword">pub</span> name: <span class="hljs-built_in">String</span>,<br>    noise: <span class="hljs-built_in">String</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> SeaCreature &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_sound</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-built_in">str</span> &#123;<br>        &amp;<span class="hljs-keyword">self</span>.noise<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">NoiseMaker</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">make_noise</span></span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-keyword">impl</span> NoiseMaker <span class="hljs-keyword">for</span> SeaCreature &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">make_noise</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, &amp;<span class="hljs-keyword">self</span>.get_sound());<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Ocean</span></span> &#123;<br>    animals: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> NoiseMaker&gt;&gt;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> ferris = SeaCreature &#123;<br>        name: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Ferris&quot;</span>),<br>        noise: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;咕噜&quot;</span>),<br>    &#125;;<br>    <span class="hljs-keyword">let</span> sarah = SeaCreature &#123;<br>        name: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Sarah&quot;</span>),<br>        noise: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;哧溜&quot;</span>),<br>    &#125;;<br>    <span class="hljs-keyword">let</span> ocean = Ocean &#123;<br>        animals: <span class="hljs-built_in">vec!</span>[<span class="hljs-built_in">Box</span>::new(ferris), <span class="hljs-built_in">Box</span>::new(sarah)],<br>    &#125;;<br>    <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> ocean.animals.iter() &#123;<br>        a.make_noise();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="智能指针">智能指针</h2>
<h3 id="指针">指针</h3>
<p>引用可以转换成一个更原始的类型，指针(raw pointer)。 像数字一样，它可以不受限制地复制和传递，但是Rust 不保证它指向的内存位置的有效性。 有两种指针类型：</p>
<ul>
<li><code>*const T</code> - 指向永远不会改变的 T 类型数据的指针。</li>
<li><code>*mut T</code> - 指向可以更改的 T 类型数据的指针。</li>
</ul>
<p>指针可以与数字相互转换（例如<code>usize</code>）。<br>
指针可以使用 <em>unsafe</em> 代码访问数据（稍后会详细介绍）。</p>
<p>内存细节：</p>
<ul>
<li>Rust中的引用在用法上与 C 中的指针非常相似，但在如何存储和传递给其他函数上有更多的编译时间限制。</li>
<li>Rust中的指针类似于 C 中的指针，它表示一个可以复制或传递的数字，甚至可以转换为数字类型，可以将其修改为数字以进行指针数学运算。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-number">42</span>;<br>    <span class="hljs-keyword">let</span> memory_location = &amp;a <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-built_in">i32</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Data is here &#123;:x&#125;&quot;</span>, memory_location);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="运算符">运算符 *</h3>
<p><code>*</code> 运算符是一种很明确的解引用的方法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> a: <span class="hljs-built_in">i32</span> = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">let</span> ref_ref_ref_a: &amp;&amp;&amp;<span class="hljs-built_in">i32</span> = &amp;&amp;&amp;a;<br><span class="hljs-keyword">let</span> ref_a: &amp;<span class="hljs-built_in">i32</span> = **ref_ref_ref_a;<br><span class="hljs-keyword">let</span> b: <span class="hljs-built_in">i32</span> = *ref_a;<br></code></pre></td></tr></table></figure>
<p>内存细节:</p>
<ul>
<li>因为 i32 是实现了 <code>Copy</code> 特性的原始类型，堆栈上变量 <code>a</code> 的字节被复制到变量 <code>b</code> 的字节中。</li>
</ul>
<h3 id="运算符-2">运算符 .</h3>
<p><code>.</code>运算符用于访问引用的字段和方法，它的工作原理更加巧妙。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> f = Foo &#123; value: <span class="hljs-number">42</span> &#125;;<br><span class="hljs-keyword">let</span> ref_ref_ref_f = &amp;&amp;&amp;f;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, ref_ref_ref_f.value);<br></code></pre></td></tr></table></figure>
<p><code>.</code> 运算符会做一些列自动解引用操作。 最后一行由编译器自动转换为以下内容。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, (***ref_ref_ref_f).value);<br></code></pre></td></tr></table></figure>
<h3 id="智能指针-2">智能指针</h3>
<p>除了能够使用<code>&amp;</code>运算符创建对现有类型数据的引用之外, Rust 给我们提供了能够创建称为智能指针的<em>类引用</em>结构。<br>
我们可以在高层次上将引用视为一种类型，它使我们能够访问另一种类型. 智能指针的行为与普通引用不同，因为它们基于程序员编写的内部逻辑进行操作. 作为程序员的你就是<em>智能</em>的一部分。<br>
通常，智能指针实现了 <code>Deref</code>、<code>DerefMut</code> 和 <code>Drop</code> 特征，以指定当使用 <code>*</code> 和 <code>.</code> 运算符时解引用应该触发的逻辑。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Deref;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TattleTell</span></span>&lt;T&gt; &#123;<br>    value: T,<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;T&gt; Deref <span class="hljs-keyword">for</span> TattleTell&lt;T&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Target</span></span> = T;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deref</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;T &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; was used!&quot;</span>, std::any::type_name::&lt;T&gt;());<br>        &amp;<span class="hljs-keyword">self</span>.value<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> foo = TattleTell &#123;<br>        value: <span class="hljs-string">&quot;secret message&quot;</span>,<br>    &#125;;<br>    <span class="hljs-comment">// dereference occurs here immediately </span><br>    <span class="hljs-comment">// after foo is auto-referenced for the</span><br>    <span class="hljs-comment">// function `len`</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, foo.len());<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="测试">测试</h2>
<h3 id="测试编写">测试编写</h3>
<p>我们可以通过添加<code>#[cfg(test)]</code>标签来表明我们来进行测试，对我们需要进行测试的函数打上对应标签<code>#[test]</code>，有以下例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">it_works</span></span>() &#123;<br>        <span class="hljs-keyword">let</span> result = <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">assert_eq!</span>(result, <span class="hljs-number">4</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们使用<code>assert_eq!()</code>来根据运算结果来判断是否产生一个<code>panic</code>信息，当我们发生错误时会在测试时用<code>FAILED</code>进行显示出来，方便我们定位到发生错误的对应函数中去</p>
<p>当我们要进行测试时，我们使用以下代码来进行运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cargo test<br></code></pre></td></tr></table></figure>
<p>当我们测试一个应该发生<code>panic</code>的错误处理时我们可以添加<code> #[should_panic]</code>标签来表明对应代码应该产生<code>panic</code>错误信息，当其未按预期产生错误信息时便会产生<code>FAILED</code></p>
<h3 id="并行或连续的运行测试">并行或连续的运行测试</h3>
<p>当运行多个测试时，Rust 默认使用线程来并行运行。这意味着测试会更快地运行完毕，所以你可以更快的得到代码能否工作的反馈。因为测试是在同时运行的，你应该确保测试不能相互依赖，或依赖任何共享的状态，包括依赖共享的环境，比如当前工作目录或者环境变量。</p>
<p>举个例子，每一个测试都运行一些代码，假设这些代码都在硬盘上创建一个 <code>test-output.txt</code> 文件并写入一些数据。接着每一个测试都读取文件中的数据并断言这个文件包含特定的值，而这个值在每个测试中都是不同的。因为所有测试都是同时运行的，一个测试可能会在另一个测试读写文件过程中修改了文件。那么第二个测试就会失败，并不是因为代码不正确，而是因为测试并行运行时相互干扰。一个解决方案是使每一个测试读写不同的文件；另一个解决方案是一次运行一个测试。</p>
<p>如果你不希望测试并行运行，或者想要更加精确的控制线程的数量，可以传递 <code>--test-threads</code> 参数和希望使用线程的数量给测试二进制文件。例如：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> cargo <span class="hljs-built_in">test</span> -- --test-threads=1</span><br></code></pre></td></tr></table></figure>
<p>这里将测试线程设置为 <code>1</code>，告诉程序不要使用任何并行机制。这也会比并行运行花费更多时间，不过在有共享的状态时，测试就不会潜在的相互干扰了。</p>
<h3 id="显示函数输出">显示函数输出</h3>
<p>默认情况下，当测试通过时，Rust 的测试库会截获打印到标准输出的所有内容。比如在测试中调用了 <code>println!</code> 而测试通过了，我们将不会在终端看到 <code>println!</code> 的输出：只会看到说明测试通过的提示行。如果测试失败了，则会看到所有标准输出和其他错误信息。</p>
<p>如果你希望也能看到通过的测试中打印的值，也可以在结尾加上 <code>--show-output</code> 告诉 Rust 显示成功测试的输出。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> cargo <span class="hljs-built_in">test</span> -- --show-output</span><br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Programming/" class="category-chain-item">Programming</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Rust 语言之旅</div>
      <div>https://equinox-shame.github.io/2023/09/06/Rust 语言之旅/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>梓曰</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年9月6日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/08/31/Python%20%E6%89%93%E5%8C%85%E5%90%8E%E7%9A%84Dump/" title="Python 打包后 DUMP 的那些事">
                        <span class="hidden-mobile">Python 打包后 DUMP 的那些事</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"2aM6IUUWOeDGCZaDdRhrvLam-gzGzoHsz","appKey":"GQdXw2PjI9DScgw5QHVCZeYm","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":true,"serverURLs":"","emojiCDN":"//i0.hdslb.com/bfs/emote/","emojiMaps":{"脱单doge":"bf7e00ecab02171f8461ee8cf439c73db9797748.png","热":"4e58a2a6f5f1580ac33df2d2cf7ecad7d9ab3635.png","微笑":"685612eadc33f6bc233776c6241813385844f182.png","口罩":"3ad2f66b151496d2a5fb0a8ea75f32265d778dd3.png","doge":"3087d273a78ccaff4bb1e9972e2ba2a7583c9f11.png","妙啊":"b4cb77159d58614a9b787b91b1cd22a81f383535.png","OK":"4683fd9ffc925fa6423110979d7dcac5eda297f4.png","星星眼":"63c9d1a31c0da745b61cdb35e0ecb28635675db2.png","辣眼睛":"35d62c496d1e4ea9e091243fa812866f5fecc101.png","吃瓜":"4191ce3c44c2b3df8fd97c33f85d3ab15f4f3c84.png","滑稽":"d15121545a99ac46774f1f4465b895fe2d1411c3.png","呲牙":"b5a5898491944a4268360f2e7a84623149672eb6.png","打call":"431432c43da3ee5aab5b0e4f8931953e649e9975.png","歪嘴":"4384050fbab0586259acdd170b510fe262f08a17.png","调皮":"8290b7308325e3179d2154327c85640af1528617.png","翻白眼":"eba54707c7168925b18f6f8b1f48d532fe08c2b1.png","灵魂出窍":"43d3db7d97343c01b47e22cfabeca84b4251f35a.png","再见":"fc510306bae26c9aec7e287cdf201ded27b065b9.png","嗑瓜子":"28a91da1685d90124cfeead74622e1ebb417c0eb.png","笑哭":"c3043ba94babf824dea03ce500d0e73763bf4f40.png","藏狐":"ba0937ef6f3ccca85e2e0047e6263f3b4da37201.png","脸红":"0922c375da40e6b69002bd89b858572f424dcfca.png","给心心":"1597302b98827463f5b75c7cac1f29ea6ce572c4.png","嘟嘟":"abd7404537d8162720ccbba9e0a8cdf75547e07a.png","哦呼":"362bded07ea5434886271d23fa25f5d85d8af06c.png","喜欢":"8a10a4d73a89f665feff3d46ca56e83dc68f9eb8.png","酸了":"92b1c8cbceea3ae0e8e32253ea414783e8ba7806.png","嫌弃":"de4c0783aaa60ec03de0a2b90858927bfad7154b.png","大哭":"2caafee2e5db4db72104650d87810cc2c123fc86.png","害羞":"9d2ec4e1fbd6cb1b4d12d2bbbdd124ccb83ddfda.png","疑惑":"b7840db4b1f9f4726b7cb23c0972720c1698d661.png","喜极而泣":"485a7e0c01c2d70707daae53bee4a9e2e31ef1ed.png","奸笑":"bb84906573472f0a84cebad1e9000eb6164a6f5a.png","阴险":"ba8d5f8e7d136d59aab52c40fd3b8a43419eb03c.png","囧":"12e41d357a9807cc80ef1e1ed258127fcc791424.png","呆":"33ad6000d9f9f168a0976bc60937786f239e5d8c.png","大笑":"ca94ad1c7e6dac895eb5b33b7836b634c614d1c0.png","惊喜":"0afecaf3a3499479af946f29749e1a6c285b6f65.png"},"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://equinox-shame.github.io" target="_blank" rel="nofollow noopener"><span>梓曰</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
